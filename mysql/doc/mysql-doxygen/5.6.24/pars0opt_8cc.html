<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/pars/pars0opt.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_c02798894e5aa4a484f6bb200b76ebea.html">pars</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pars0opt.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="pars0opt_8h_source.html">pars0opt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0sel_8h_source.html">row0sel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0ins_8h_source.html">row0ins.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;pars0grm.h&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0pars_8h_source.html">pars0pars.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3996c9076ef1cc1a758b270fc6b1fa6e"><td class="memItemLeft" align="right" valign="top"><a id="a3996c9076ef1cc1a758b270fc6b1fa6e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OPT_EQUAL</b>&#160;&#160;&#160;1	/* comparison by = */</td></tr>
<tr class="separator:a3996c9076ef1cc1a758b270fc6b1fa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7b75523ddfc7cd1562d495112d1c06"><td class="memItemLeft" align="right" valign="top"><a id="a4a7b75523ddfc7cd1562d495112d1c06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OPT_COMPARISON</b>&#160;&#160;&#160;2	/* comparison by &lt;, &gt;, &lt;=, or &gt;= */</td></tr>
<tr class="separator:a4a7b75523ddfc7cd1562d495112d1c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae734fe45c8b382762d0af349afca92"><td class="memItemLeft" align="right" valign="top"><a id="a2ae734fe45c8b382762d0af349afca92"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OPT_NOT_COND</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a2ae734fe45c8b382762d0af349afca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f520ada6b588363491e7964b8ed39c"><td class="memItemLeft" align="right" valign="top"><a id="af6f520ada6b588363491e7964b8ed39c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OPT_END_COND</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:af6f520ada6b588363491e7964b8ed39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab387578bdbbecdd51d26701d034d9de5"><td class="memItemLeft" align="right" valign="top"><a id="ab387578bdbbecdd51d26701d034d9de5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OPT_TEST_COND</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ab387578bdbbecdd51d26701d034d9de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e7347cca39f2045da0855775996dbe"><td class="memItemLeft" align="right" valign="top"><a id="a02e7347cca39f2045da0855775996dbe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OPT_SCROLL_COND</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a02e7347cca39f2045da0855775996dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a90eeeef9a3e98b97bd3848d0117b692c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a90eeeef9a3e98b97bd3848d0117b692c">opt_invert_cmp_op</a> (int <a class="el" href="ibuf0ibuf_8cc.html#a02d89caeb1f64de105ee1c3988799855">op</a>)</td></tr>
<tr class="separator:a90eeeef9a3e98b97bd3848d0117b692c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7986eaed080538e6571246f3611796de"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a7986eaed080538e6571246f3611796de">opt_check_exp_determined_before</a> (que_node_t *exp, <a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint nth_table)</td></tr>
<tr class="separator:a7986eaed080538e6571246f3611796de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b134bcceb6011be56d7caa1415dec91"><td class="memItemLeft" align="right" valign="top">static que_node_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a2b134bcceb6011be56d7caa1415dec91">opt_look_for_col_in_comparison_before</a> (ulint cmp_type, ulint col_no, <a class="el" href="structfunc__node__t.html">func_node_t</a> *search_cond, <a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint nth_table, ulint *<a class="el" href="ibuf0ibuf_8cc.html#a02d89caeb1f64de105ee1c3988799855">op</a>)</td></tr>
<tr class="separator:a2b134bcceb6011be56d7caa1415dec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dd8ef4f9af9b180047ad2de7f186fe"><td class="memItemLeft" align="right" valign="top">static que_node_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a16dd8ef4f9af9b180047ad2de7f186fe">opt_look_for_col_in_cond_before</a> (ulint cmp_type, ulint col_no, <a class="el" href="structfunc__node__t.html">func_node_t</a> *search_cond, <a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint nth_table, ulint *<a class="el" href="ibuf0ibuf_8cc.html#a02d89caeb1f64de105ee1c3988799855">op</a>)</td></tr>
<tr class="separator:a16dd8ef4f9af9b180047ad2de7f186fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259317add71381a06987497081d1ae9a"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a259317add71381a06987497081d1ae9a">opt_calc_index_goodness</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint nth_table, que_node_t **index_plan, ulint *last_op)</td></tr>
<tr class="separator:a259317add71381a06987497081d1ae9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ae41fef8cb1fb6034957aa67c81150"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a51ae41fef8cb1fb6034957aa67c81150">opt_calc_n_fields_from_goodness</a> (ulint goodness)</td></tr>
<tr class="separator:a51ae41fef8cb1fb6034957aa67c81150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52969e83a6c103e4cecdaf486428d6c6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a52969e83a6c103e4cecdaf486428d6c6">opt_op_to_search_mode</a> (ibool asc, ulint <a class="el" href="ibuf0ibuf_8cc.html#a02d89caeb1f64de105ee1c3988799855">op</a>)</td></tr>
<tr class="separator:a52969e83a6c103e4cecdaf486428d6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fd9da7ecfd4a4ae7c6a8ade7650ee1"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#af2fd9da7ecfd4a4ae7c6a8ade7650ee1">opt_is_arg</a> (que_node_t *arg_node, <a class="el" href="structfunc__node__t.html">func_node_t</a> *func_node)</td></tr>
<tr class="separator:af2fd9da7ecfd4a4ae7c6a8ade7650ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ce6ec0e604144cc3d37c9edf43369f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a80ce6ec0e604144cc3d37c9edf43369f">opt_check_order_by</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node)</td></tr>
<tr class="separator:a80ce6ec0e604144cc3d37c9edf43369f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bafe20a3c1f7c8ba9711a67acabd72d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a8bafe20a3c1f7c8ba9711a67acabd72d">opt_search_plan_for_table</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a8bafe20a3c1f7c8ba9711a67acabd72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d9b7b0bdbfddbd9cfb434475bf1158"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a50d9b7b0bdbfddbd9cfb434475bf1158">opt_classify_comparison</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>, <a class="el" href="structfunc__node__t.html">func_node_t</a> *cond)</td></tr>
<tr class="separator:a50d9b7b0bdbfddbd9cfb434475bf1158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac80c0a4e8ea8f2c8837aa377e4688f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#abac80c0a4e8ea8f2c8837aa377e4688f">opt_find_test_conds</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>, <a class="el" href="structfunc__node__t.html">func_node_t</a> *cond)</td></tr>
<tr class="separator:abac80c0a4e8ea8f2c8837aa377e4688f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6274c0b2eab85177963c29571f57b20"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#ac6274c0b2eab85177963c29571f57b20">opt_normalize_cmp_conds</a> (<a class="el" href="structfunc__node__t.html">func_node_t</a> *cond, <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ac6274c0b2eab85177963c29571f57b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7047e8a4c71f03274003822a4cd9d38c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a7047e8a4c71f03274003822a4cd9d38c">opt_determine_and_normalize_test_conds</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>)</td></tr>
<tr class="separator:a7047e8a4c71f03274003822a4cd9d38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1272d7f168cdbeb9cb8974e11f9467c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#aa1272d7f168cdbeb9cb8974e11f9467c">opt_find_all_cols</a> (ibool copy_val, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, sym_node_list_t *col_list, <a class="el" href="structplan__t.html">plan_t</a> *<a class="el" href="row0sel_8cc.html#ae07da4fbb23295fa0b9f353e50440368">plan</a>, que_node_t *exp)</td></tr>
<tr class="separator:aa1272d7f168cdbeb9cb8974e11f9467c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406b5d8880d94af0f4b0ec23ca259c18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a406b5d8880d94af0f4b0ec23ca259c18">opt_find_copy_cols</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>, <a class="el" href="structfunc__node__t.html">func_node_t</a> *search_cond)</td></tr>
<tr class="separator:a406b5d8880d94af0f4b0ec23ca259c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9a90267471776b0428fd5beb4ed34c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#aae9a90267471776b0428fd5beb4ed34c">opt_classify_cols</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>)</td></tr>
<tr class="separator:aae9a90267471776b0428fd5beb4ed34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafdb3602b2751d230d1cb9993aa3a0b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#acafdb3602b2751d230d1cb9993aa3a0b">opt_clust_access</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:acafdb3602b2751d230d1cb9993aa3a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58737fc6cc1ab20470869afad637c86d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a58737fc6cc1ab20470869afad637c86d">opt_search_plan</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node)</td></tr>
<tr class="separator:a58737fc6cc1ab20470869afad637c86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e820b7e5f5ef57f6b863ceed2ffee57"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0opt_8cc.html#a3e820b7e5f5ef57f6b863ceed2ffee57">opt_print_query_plan</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node)</td></tr>
<tr class="separator:a3e820b7e5f5ef57f6b863ceed2ffee57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simple SQL optimizer</p>
<p>Created 12/21/1997 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a259317add71381a06987497081d1ae9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259317add71381a06987497081d1ae9a">&#9670;&nbsp;</a></span>opt_calc_index_goodness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint opt_calc_index_goodness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>nth_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t **&#160;</td>
          <td class="paramname"><em>index_plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>last_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the goodness for an index according to a select node. The goodness is 4 times the number of first fields in index whose values we already know exactly in the query. If we have a comparison condition for an additional field, 2 point are added. If the index is unique, and we know all the unique fields for the index we add 1024 points. For a clustered index we add 1 point. </p><dl class="section return"><dt>Returns</dt><dd>goodness </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">sel_node</td><td>in: parsed select node </td></tr>
    <tr><td class="paramname">nth_table</td><td>in: nth table in a join </td></tr>
    <tr><td class="paramname">index_plan</td><td>in/out: comparison expressions for this index </td></tr>
    <tr><td class="paramname">last_op</td><td>out: last comparison operator, if goodness &gt; 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51ae41fef8cb1fb6034957aa67c81150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ae41fef8cb1fb6034957aa67c81150">&#9670;&nbsp;</a></span>opt_calc_n_fields_from_goodness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint opt_calc_n_fields_from_goodness </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>goodness</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of matched fields based on an index goodness. </p><dl class="section return"><dt>Returns</dt><dd>number of excatly or partially matched fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">goodness</td><td>in: goodness </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7986eaed080538e6571246f3611796de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7986eaed080538e6571246f3611796de">&#9670;&nbsp;</a></span>opt_check_exp_determined_before()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool opt_check_exp_determined_before </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>exp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>nth_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the value of an expression can be calculated BEFORE the nth table in a join is accessed. If this is the case, it can possibly be used in an index search for the nth table. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if already determined </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp</td><td>in: expression </td></tr>
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
    <tr><td class="paramname">nth_table</td><td>in: nth table will be accessed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80ce6ec0e604144cc3d37c9edf43369f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ce6ec0e604144cc3d37c9edf43369f">&#9670;&nbsp;</a></span>opt_check_order_by()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void opt_check_order_by </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decides if the fetching of rows should be made in a descending order, and also checks that the chosen query plan produces a result which satisfies the order-by. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: select node; asserts an error if the plan does not agree with the order-by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae9a90267471776b0428fd5beb4ed34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9a90267471776b0428fd5beb4ed34c">&#9670;&nbsp;</a></span>opt_classify_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void opt_classify_cols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Classifies the table columns according to whether we use the column only while holding the latch on the page, or whether we have to copy the column value to dynamic memory. Puts the first occurrence of a column to either list in the plan node, and puts indirections to later occurrences of the column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
    <tr><td class="paramname">i</td><td>in: ith table in the join </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50d9b7b0bdbfddbd9cfb434475bf1158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d9b7b0bdbfddbd9cfb434475bf1158">&#9670;&nbsp;</a></span>opt_classify_comparison()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint opt_classify_comparison </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks at a comparison condition and decides if it can, and need, be tested for a table AFTER the table has been accessed. </p><dl class="section return"><dt>Returns</dt><dd>OPT_NOT_COND if not for this table, else OPT_END_COND, OPT_TEST_COND, or OPT_SCROLL_COND, where the last means that the condition need not be tested, except when scroll cursors are used </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
    <tr><td class="paramname">i</td><td>in: ith table in the join </td></tr>
    <tr><td class="paramname">cond</td><td>in: comparison condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acafdb3602b2751d230d1cb9993aa3a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafdb3602b2751d230d1cb9993aa3a0b">&#9670;&nbsp;</a></span>opt_clust_access()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void opt_clust_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills in the info in plan which is used in accessing a clustered index record. The columns must already be classified for the plan node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
    <tr><td class="paramname">n</td><td>in: nth table in select </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7047e8a4c71f03274003822a4cd9d38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7047e8a4c71f03274003822a4cd9d38c">&#9670;&nbsp;</a></span>opt_determine_and_normalize_test_conds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void opt_determine_and_normalize_test_conds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds out the search condition conjuncts we can, and need, to test as the ith table in a join is accessed. The search tuple can eliminate the need to test some conjuncts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
    <tr><td class="paramname">i</td><td>in: ith table in the join </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1272d7f168cdbeb9cb8974e11f9467c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1272d7f168cdbeb9cb8974e11f9467c">&#9670;&nbsp;</a></span>opt_find_all_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void opt_find_all_cols </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>copy_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sym_node_list_t *&#160;</td>
          <td class="paramname"><em>col_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for occurrences of the columns of the table in the query subgraph and adds them to the list of columns if an occurrence of the same column does not already exist in the list. If the column is already in the list, puts a value indirection to point to the occurrence in the column list, except if the column occurrence we are looking at is in the column list, in which case nothing is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy_val</td><td>in: if TRUE, new found columns are added as columns to copy </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the table to use </td></tr>
    <tr><td class="paramname">col_list</td><td>in: base node of a list where to add new found columns </td></tr>
    <tr><td class="paramname">plan</td><td>in: plan or NULL </td></tr>
    <tr><td class="paramname">exp</td><td>in: expression or condition or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a406b5d8880d94af0f4b0ec23ca259c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406b5d8880d94af0f4b0ec23ca259c18">&#9670;&nbsp;</a></span>opt_find_copy_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void opt_find_copy_cols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td>
          <td class="paramname"><em>search_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for occurrences of the columns of the table in conditions which are not yet determined AFTER the join operation has fetched a row in the ith table. The values for these column must be copied to dynamic memory for later use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
    <tr><td class="paramname">i</td><td>in: ith table in the join </td></tr>
    <tr><td class="paramname">search_cond</td><td>in: search condition or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abac80c0a4e8ea8f2c8837aa377e4688f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac80c0a4e8ea8f2c8837aa377e4688f">&#9670;&nbsp;</a></span>opt_find_test_conds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void opt_find_test_conds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively looks for test conditions for a table in a join. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
    <tr><td class="paramname">i</td><td>in: ith table in the join </td></tr>
    <tr><td class="paramname">cond</td><td>in: conjunction of search conditions or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90eeeef9a3e98b97bd3848d0117b692c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90eeeef9a3e98b97bd3848d0117b692c">&#9670;&nbsp;</a></span>opt_invert_cmp_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int opt_invert_cmp_op </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts a comparison operator. </p><dl class="section return"><dt>Returns</dt><dd>the equivalent operator when the order of the arguments is switched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>in: operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2fd9da7ecfd4a4ae7c6a8ade7650ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fd9da7ecfd4a4ae7c6a8ade7650ee1">&#9670;&nbsp;</a></span>opt_is_arg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool opt_is_arg </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>arg_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td>
          <td class="paramname"><em>func_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if a node is an argument node of a function node. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if is an argument </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg_node</td><td>in: possible argument node </td></tr>
    <tr><td class="paramname">func_node</td><td>in: function node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b134bcceb6011be56d7caa1415dec91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b134bcceb6011be56d7caa1415dec91">&#9670;&nbsp;</a></span>opt_look_for_col_in_comparison_before()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static que_node_t* opt_look_for_col_in_comparison_before </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td>
          <td class="paramname"><em>search_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>nth_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks in a comparison condition if a column value is already restricted by it BEFORE the nth table is accessed. </p><dl class="section return"><dt>Returns</dt><dd>expression restricting the value of the column, or NULL if not known </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp_type</td><td>in: OPT_EQUAL, OPT_COMPARISON </td></tr>
    <tr><td class="paramname">col_no</td><td>in: column number </td></tr>
    <tr><td class="paramname">search_cond</td><td>in: comparison condition </td></tr>
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
    <tr><td class="paramname">nth_table</td><td>in: nth table in a join (a query from a single table is considered a join of 1 table) </td></tr>
    <tr><td class="paramname">op</td><td>out: comparison operator ('=', PARS_GE_TOKEN, ... ); this is inverted if the column appears on the right side </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16dd8ef4f9af9b180047ad2de7f186fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dd8ef4f9af9b180047ad2de7f186fe">&#9670;&nbsp;</a></span>opt_look_for_col_in_cond_before()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static que_node_t* opt_look_for_col_in_cond_before </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td>
          <td class="paramname"><em>search_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>nth_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks in a search condition if a column value is already restricted by the search condition BEFORE the nth table is accessed. Takes into account that if we will fetch in an ascending order, we cannot utilize an upper limit for a column value; in a descending order, respectively, a lower limit. </p><dl class="section return"><dt>Returns</dt><dd>expression restricting the value of the column, or NULL if not known </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp_type</td><td>in: OPT_EQUAL, OPT_COMPARISON </td></tr>
    <tr><td class="paramname">col_no</td><td>in: column number </td></tr>
    <tr><td class="paramname">search_cond</td><td>in: search condition or NULL </td></tr>
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
    <tr><td class="paramname">nth_table</td><td>in: nth table in a join (a query from a single table is considered a join of 1 table) </td></tr>
    <tr><td class="paramname">op</td><td>out: comparison operator ('=', PARS_GE_TOKEN, ... ) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6274c0b2eab85177963c29571f57b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6274c0b2eab85177963c29571f57b20">&#9670;&nbsp;</a></span>opt_normalize_cmp_conds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void opt_normalize_cmp_conds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes a list of comparison conditions so that a column of the table appears on the left side of the comparison if possible. This is accomplished by switching the arguments of the operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>in: first in a list of comparison conditions, or NULL </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52969e83a6c103e4cecdaf486428d6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52969e83a6c103e4cecdaf486428d6c6">&#9670;&nbsp;</a></span>opt_op_to_search_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint opt_op_to_search_mode </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>asc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a comparison operator to the corresponding search mode PAGE_CUR_GE, ... </p><dl class="section return"><dt>Returns</dt><dd>search mode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asc</td><td>in: TRUE if the rows should be fetched in an ascending order </td></tr>
    <tr><td class="paramname">op</td><td>in: operator '=', PARS_GE_TOKEN, ... </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e820b7e5f5ef57f6b863ceed2ffee57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e820b7e5f5ef57f6b863ceed2ffee57">&#9670;&nbsp;</a></span>opt_print_query_plan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void opt_print_query_plan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of a query plan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: select node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58737fc6cc1ab20470869afad637c86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58737fc6cc1ab20470869afad637c86d">&#9670;&nbsp;</a></span>opt_search_plan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void opt_search_plan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimizes a select. Decides which indexes to tables to use. The tables are accessed in the order that they were written to the FROM part in the select statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: parsed select node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bafe20a3c1f7c8ba9711a67acabd72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bafe20a3c1f7c8ba9711a67acabd72d">&#9670;&nbsp;</a></span>opt_search_plan_for_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void opt_search_plan_for_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimizes a select. Decides which indexes to tables to use. The tables are accessed in the order that they were written to the FROM part in the select statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sel_node</td><td>in: parsed select node </td></tr>
    <tr><td class="paramname">i</td><td>in: this is the ith table </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: trx_lock_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structtrx__lock__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">trx_lock_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8b7f840c1deb4b3322a24bff1a9d11b8"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a8b7f840c1deb4b3322a24bff1a9d11b8">n_active_thrs</a></td></tr>
<tr class="separator:a8b7f840c1deb4b3322a24bff1a9d11b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5a11c3bcbef8f9f71497710587ba90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a34bba6fbd37f499f7874fc416547759f">trx_que_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a5b5a11c3bcbef8f9f71497710587ba90">que_state</a></td></tr>
<tr class="separator:a5b5a11c3bcbef8f9f71497710587ba90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e14b7f69b10d6046cfddc88f9b0d5df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a3e14b7f69b10d6046cfddc88f9b0d5df">wait_lock</a></td></tr>
<tr class="separator:a3e14b7f69b10d6046cfddc88f9b0d5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09444e637794a39a2b97482d1256b73b"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a09444e637794a39a2b97482d1256b73b">deadlock_mark</a></td></tr>
<tr class="separator:a09444e637794a39a2b97482d1256b73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2f454ead49718d7f34152f605f2eec"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#afb2f454ead49718d7f34152f605f2eec">was_chosen_as_deadlock_victim</a></td></tr>
<tr class="separator:afb2f454ead49718d7f34152f605f2eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab2bc88e411af161ff3c1e447c30ae4"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a4ab2bc88e411af161ff3c1e447c30ae4">wait_started</a></td></tr>
<tr class="separator:a4ab2bc88e411af161ff3c1e447c30ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affae4ec9c18be6c1f774472fae0bfbc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#affae4ec9c18be6c1f774472fae0bfbc9">wait_thr</a></td></tr>
<tr class="separator:affae4ec9c18be6c1f774472fae0bfbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3a26f3c5dc889837e30b8bccd2f572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a2b3a26f3c5dc889837e30b8bccd2f572">lock_heap</a></td></tr>
<tr class="separator:a2b3a26f3c5dc889837e30b8bccd2f572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae18624cf2dbe2455b2ea84bf9f5217"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a4ae18624cf2dbe2455b2ea84bf9f5217">trx_locks</a></td></tr>
<tr class="separator:a4ae18624cf2dbe2455b2ea84bf9f5217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5616df6a5e28c150a2c9fe90b8351fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structib__vector__t.html">ib_vector_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a5616df6a5e28c150a2c9fe90b8351fac">table_locks</a></td></tr>
<tr class="separator:a5616df6a5e28c150a2c9fe90b8351fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d5c7bfeea5d55b9b71a6ed2e016486"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#ad1d5c7bfeea5d55b9b71a6ed2e016486">cancel</a></td></tr>
<tr class="separator:ad1d5c7bfeea5d55b9b71a6ed2e016486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Latching protocol for <a class="el" href="structtrx__lock__t.html#a5b5a11c3bcbef8f9f71497710587ba90">trx_lock_t::que_state</a>. <a class="el" href="structtrx__lock__t.html#a5b5a11c3bcbef8f9f71497710587ba90">trx_lock_t::que_state</a> captures the state of the query thread during the execution of a query. This is different from a transaction state. The query state of a transaction can be updated asynchronously by other threads. The other threads can be system threads, like the timeout monitor thread or user threads executing other queries. Another thing to be mindful of is that there is a delay between when a query thread is put into LOCK_WAIT state and before it actually starts waiting. Between these two events it is possible that the query thread is granted the lock it was waiting for, which implies that the state can be changed asynchronously.</p>
<p>All these operations take place within the context of locking. Therefore state changes within the locking code must acquire both the lock mutex and the trx-&gt;mutex when changing trx-&gt;lock.que_state to TRX_QUE_LOCK_WAIT or trx-&gt;lock.wait_lock to non-NULL but when the lock wait ends it is sufficient to only acquire the trx-&gt;mutex. To query the state either of the mutexes is sufficient within the locking code and no mutex is required when the query thread is no longer waiting. The locks and state of an active transaction. Protected by lock_sys-&gt;mutex, trx-&gt;mutex or both. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="ad1d5c7bfeea5d55b9b71a6ed2e016486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d5c7bfeea5d55b9b71a6ed2e016486">&#9670;&nbsp;</a></span>cancel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool trx_lock_t::cancel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if the transaction is being rolled back either via deadlock detection or due to lock timeout. The caller has to acquire the <a class="el" href="structtrx__t.html#aea04c751aa48ef4eaddade1d4627ec32">trx_t::mutex</a> in order to cancel the locks. In <a class="el" href="lock0lock_8cc.html#a7abfdceec128a59cd3c1ad2569bb3eaf">lock_trx_table_locks_remove()</a> we check for this cancel of a transaction's locks and avoid reacquiring the trx mutex to prevent recursive deadlocks. Protected by both the lock sys mutex and the <a class="el" href="structtrx__t.html#aea04c751aa48ef4eaddade1d4627ec32">trx_t::mutex</a>. </p>

</div>
</div>
<a id="a09444e637794a39a2b97482d1256b73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09444e637794a39a2b97482d1256b73b">&#9670;&nbsp;</a></span>deadlock_mark</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t trx_lock_t::deadlock_mark</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A mark field that is initialized to and checked against lock_mark_counter by lock_deadlock_recursive(). </p>

</div>
</div>
<a id="a2b3a26f3c5dc889837e30b8bccd2f572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3a26f3c5dc889837e30b8bccd2f572">&#9670;&nbsp;</a></span>lock_heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* trx_lock_t::lock_heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>memory heap for trx_locks; protected by lock_sys-&gt;mutex </p>

</div>
</div>
<a id="a8b7f840c1deb4b3322a24bff1a9d11b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7f840c1deb4b3322a24bff1a9d11b8">&#9670;&nbsp;</a></span>n_active_thrs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint trx_lock_t::n_active_thrs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of active query threads </p>

</div>
</div>
<a id="a5b5a11c3bcbef8f9f71497710587ba90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5a11c3bcbef8f9f71497710587ba90">&#9670;&nbsp;</a></span>que_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a34bba6fbd37f499f7874fc416547759f">trx_que_t</a> trx_lock_t::que_state</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>valid when trx-&gt;state == TRX_STATE_ACTIVE: TRX_QUE_RUNNING, TRX_QUE_LOCK_WAIT, ... </p>

</div>
</div>
<a id="a5616df6a5e28c150a2c9fe90b8351fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5616df6a5e28c150a2c9fe90b8351fac">&#9670;&nbsp;</a></span>table_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structib__vector__t.html">ib_vector_t</a>* trx_lock_t::table_locks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All table locks requested by this transaction, including AUTOINC locks </p>

</div>
</div>
<a id="a4ae18624cf2dbe2455b2ea84bf9f5217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae18624cf2dbe2455b2ea84bf9f5217">&#9670;&nbsp;</a></span>trx_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">trx_lock_t::trx_locks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>locks requested by the transaction; insertions are protected by trx-&gt;mutex and lock_sys-&gt;mutex; removals are protected by lock_sys-&gt;mutex </p>

</div>
</div>
<a id="a3e14b7f69b10d6046cfddc88f9b0d5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e14b7f69b10d6046cfddc88f9b0d5df">&#9670;&nbsp;</a></span>wait_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlock__t.html">lock_t</a>* trx_lock_t::wait_lock</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if trx execution state is TRX_QUE_LOCK_WAIT, this points to the lock request, otherwise this is NULL; set to non-NULL when holding both trx-&gt;mutex and lock_sys-&gt;mutex; set to NULL when holding lock_sys-&gt;mutex; readers should hold lock_sys-&gt;mutex, except when they are holding trx-&gt;mutex and wait_lock==NULL </p>

</div>
</div>
<a id="a4ab2bc88e411af161ff3c1e447c30ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab2bc88e411af161ff3c1e447c30ae4">&#9670;&nbsp;</a></span>wait_started</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t trx_lock_t::wait_started</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lock wait started at this time, protected only by lock_sys-&gt;mutex </p>

</div>
</div>
<a id="affae4ec9c18be6c1f774472fae0bfbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affae4ec9c18be6c1f774472fae0bfbc9">&#9670;&nbsp;</a></span>wait_thr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__thr__t.html">que_thr_t</a>* trx_lock_t::wait_thr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>query thread belonging to this trx that is in QUE_THR_LOCK_WAIT state. For threads suspended in a lock wait, this is protected by lock_sys-&gt;mutex. Otherwise, this may only be modified by the thread that is serving the running transaction. </p>

</div>
</div>
<a id="afb2f454ead49718d7f34152f605f2eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2f454ead49718d7f34152f605f2eec">&#9670;&nbsp;</a></span>was_chosen_as_deadlock_victim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool trx_lock_t::was_chosen_as_deadlock_victim</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when the transaction decides to wait for a lock, it sets this to FALSE; if another transaction chooses this transaction as a victim in deadlock resolution, it sets this to TRUE. Protected by trx-&gt;mutex. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>storage/innobase/include/<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

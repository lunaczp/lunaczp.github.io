<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: mysys/waiting_threads.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7507adac5764e4f818c81969b3802964.html">mysys</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">waiting_threads.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;waiting_threads.h&gt;</code><br />
<code>#include &lt;m_string.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__wt__resource.html">st_wt_resource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdeadlock__arg.html">deadlock_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a95736f7e176e5cc5c121f5824bb2cd0f"><td class="memItemLeft" align="right" valign="top"><a id="a95736f7e176e5cc5c121f5824bb2cd0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>incr</b>(<a class="el" href="struct_v_a_r.html">VAR</a>,  LOCK)&#160;&#160;&#160;do { (<a class="el" href="struct_v_a_r.html">VAR</a>)++; } while(0)</td></tr>
<tr class="separator:a95736f7e176e5cc5c121f5824bb2cd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab0c859b8de86b54b31943e011522dd8d"><td class="memItemLeft" align="right" valign="top"><a id="ab0c859b8de86b54b31943e011522dd8d"></a>
static <a class="el" href="structmy__atomic__rwlock__t.html">my_atomic_rwlock_t</a> cycle_stats_lock&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((unused))</td></tr>
<tr class="separator:ab0c859b8de86b54b31943e011522dd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b50142142993cb50fc71f99e5a8b1"><td class="memItemLeft" align="right" valign="top"><a id="afb4b50142142993cb50fc71f99e5a8b1"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>increment_success_stats</b> ()</td></tr>
<tr class="separator:afb4b50142142993cb50fc71f99e5a8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93f340c9163678f6799c977356671a5"><td class="memItemLeft" align="right" valign="top"><a id="ad93f340c9163678f6799c977356671a5"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>increment_cycle_stats</b> (uint depth, uint slot)</td></tr>
<tr class="separator:ad93f340c9163678f6799c977356671a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2ece7e281acbe9b44e533e673cc9d8"><td class="memItemLeft" align="right" valign="top"><a id="a2b2ece7e281acbe9b44e533e673cc9d8"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>increment_wait_stats</b> (ulonglong waited, int ret)</td></tr>
<tr class="separator:a2b2ece7e281acbe9b44e533e673cc9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ef36a1649e42b36fc147318b663c38"><td class="memItemLeft" align="right" valign="top"><a id="a40ef36a1649e42b36fc147318b663c38"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rc_rwlock_init</b> (<a class="el" href="structst__wt__resource.html">WT_RESOURCE</a> *rc)</td></tr>
<tr class="separator:a40ef36a1649e42b36fc147318b663c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ad2ebe2f15af64c5692157740c17aa"><td class="memItemLeft" align="right" valign="top"><a id="ae3ad2ebe2f15af64c5692157740c17aa"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rc_rwlock_destroy</b> (<a class="el" href="structst__wt__resource.html">WT_RESOURCE</a> *rc)</td></tr>
<tr class="separator:ae3ad2ebe2f15af64c5692157740c17aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15452b961999039f0fc9230794caf92d"><td class="memItemLeft" align="right" valign="top"><a id="a15452b961999039f0fc9230794caf92d"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rc_rdlock</b> (<a class="el" href="structst__wt__resource.html">WT_RESOURCE</a> *rc)</td></tr>
<tr class="separator:a15452b961999039f0fc9230794caf92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22db0689edf17bfd541debc78fde25a7"><td class="memItemLeft" align="right" valign="top"><a id="a22db0689edf17bfd541debc78fde25a7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rc_wrlock</b> (<a class="el" href="structst__wt__resource.html">WT_RESOURCE</a> *rc)</td></tr>
<tr class="separator:a22db0689edf17bfd541debc78fde25a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3af43b5dd075dd821e3fef147fab06c"><td class="memItemLeft" align="right" valign="top"><a id="aa3af43b5dd075dd821e3fef147fab06c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>rc_unlock</b> (<a class="el" href="structst__wt__resource.html">WT_RESOURCE</a> *rc)</td></tr>
<tr class="separator:aa3af43b5dd075dd821e3fef147fab06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a95230d55c8556c168f2115cabdb195"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#a5a95230d55c8556c168f2115cabdb195">wt_resource_init</a> (uchar *arg)</td></tr>
<tr class="separator:a5a95230d55c8556c168f2115cabdb195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0501b730a52856fff19a4a4accf7f215"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#a0501b730a52856fff19a4a4accf7f215">wt_resource_destroy</a> (uchar *arg)</td></tr>
<tr class="separator:a0501b730a52856fff19a4a4accf7f215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154ab051a49e2a286e00984f136133bb"><td class="memItemLeft" align="right" valign="top"><a id="a154ab051a49e2a286e00984f136133bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wt_init</b> ()</td></tr>
<tr class="separator:a154ab051a49e2a286e00984f136133bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33280a89a085306a797d01ed9a8b10ec"><td class="memItemLeft" align="right" valign="top"><a id="a33280a89a085306a797d01ed9a8b10ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wt_end</b> ()</td></tr>
<tr class="separator:a33280a89a085306a797d01ed9a8b10ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9944cb8d5b6d581657e3de4d7bfb720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#ab9944cb8d5b6d581657e3de4d7bfb720">wt_thd_lazy_init</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const ulong *ds, const ulong *ts, const ulong *dl, const ulong *tl)</td></tr>
<tr class="separator:ab9944cb8d5b6d581657e3de4d7bfb720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ceee36654677aa356d0cebb32d4386"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#aa3ceee36654677aa356d0cebb32d4386">fix_thd_pins</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:aa3ceee36654677aa356d0cebb32d4386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3f7de4935fb2cf65aa31ddaab4a68d"><td class="memItemLeft" align="right" valign="top"><a id="a4a3f7de4935fb2cf65aa31ddaab4a68d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wt_thd_destroy</b> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:a4a3f7de4935fb2cf65aa31ddaab4a68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232169c5d953ec33f32164cf67f5ea3e"><td class="memItemLeft" align="right" valign="top">my_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#a232169c5d953ec33f32164cf67f5ea3e">wt_resource_id_memcmp</a> (const void *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, const void *<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>)</td></tr>
<tr class="separator:a232169c5d953ec33f32164cf67f5ea3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d71c89418d386fd1a6cc4a8d4e51d4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#a73d71c89418d386fd1a6cc4a8d4e51d4">change_victim</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="fts0que_8cc.html#a278a42b0432f35e1568f2697202fdc49">found</a>, struct <a class="el" href="structdeadlock__arg.html">deadlock_arg</a> *arg)</td></tr>
<tr class="separator:a73d71c89418d386fd1a6cc4a8d4e51d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8353d04c961ec504513a604985e3e3b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#ac8353d04c961ec504513a604985e3e3b">deadlock_search</a> (struct <a class="el" href="structdeadlock__arg.html">deadlock_arg</a> *arg, <a class="el" href="structst__wt__thd.html">WT_THD</a> *blocker, uint depth)</td></tr>
<tr class="separator:ac8353d04c961ec504513a604985e3e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95920c3b979a68dec9a07151f7359d1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#ac95920c3b979a68dec9a07151f7359d1">deadlock</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__wt__thd.html">WT_THD</a> *blocker, uint depth, uint max_depth)</td></tr>
<tr class="separator:ac95920c3b979a68dec9a07151f7359d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae629c1b4c4bffec4871e98568d3a9880"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#ae629c1b4c4bffec4871e98568d3a9880">unlock_lock_and_free_resource</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__wt__resource.html">WT_RESOURCE</a> *rc)</td></tr>
<tr class="separator:ae629c1b4c4bffec4871e98568d3a9880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b46e1bd5eb16f990f2e1c61cce676af"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#a5b46e1bd5eb16f990f2e1c61cce676af">stop_waiting_locked</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:a5b46e1bd5eb16f990f2e1c61cce676af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5de7b130e0507146922e5db3dfd9f2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#abf5de7b130e0507146922e5db3dfd9f2">stop_waiting</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:abf5de7b130e0507146922e5db3dfd9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7a68ea0d1af72667aa94a74ac37eee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#a2d7a68ea0d1af72667aa94a74ac37eee">wt_thd_will_wait_for</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__wt__thd.html">WT_THD</a> *blocker, const WT_RESOURCE_ID *resid)</td></tr>
<tr class="separator:a2d7a68ea0d1af72667aa94a74ac37eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b22cc893f0c4ea13584050385e578a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> *mutex)</td></tr>
<tr class="separator:af7b22cc893f0c4ea13584050385e578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f0e0a15fd682fa11614970d8213a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#ad0f0e0a15fd682fa11614970d8213a4a">wt_thd_release</a> (<a class="el" href="structst__wt__thd.html">WT_THD</a> *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const WT_RESOURCE_ID *resid)</td></tr>
<tr class="separator:ad0f0e0a15fd682fa11614970d8213a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af89deb29632a87d9244e90b79ba374df"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#af89deb29632a87d9244e90b79ba374df">wt_wait_table</a> [WT_WAIT_STATS]</td></tr>
<tr class="separator:af89deb29632a87d9244e90b79ba374df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398ad9f07c4ce156f4e0906d7868bce8"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#a398ad9f07c4ce156f4e0906d7868bce8">wt_wait_stats</a> [WT_WAIT_STATS+1]</td></tr>
<tr class="separator:a398ad9f07c4ce156f4e0906d7868bce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0286ac2b16cd82e9f20e2b62b645ad"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="waiting__threads_8c.html#a8f0286ac2b16cd82e9f20e2b62b645ad">wt_cycle_stats</a> [2][WT_CYCLE_STATS+1]</td></tr>
<tr class="separator:a8f0286ac2b16cd82e9f20e2b62b645ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8383e7687df1487c95b6f5b55315e5"><td class="memItemLeft" align="right" valign="top"><a id="a4a8383e7687df1487c95b6f5b55315e5"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>wt_success_stats</b></td></tr>
<tr class="separator:a4a8383e7687df1487c95b6f5b55315e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3fdfe97bfb70cf26a164fea210cd30"><td class="memItemLeft" align="right" valign="top"><a id="a6c3fdfe97bfb70cf26a164fea210cd30"></a>
static <a class="el" href="struct_l_f___h_a_s_h.html">LF_HASH</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reshash</b></td></tr>
<tr class="separator:a6c3fdfe97bfb70cf26a164fea210cd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>"waiting threads" subsystem - a unified interface for threads to wait on each other, with built-in deadlock detection.</p>
<p>Main concepts ^^^^^^^^^^^^^ a thread - is represented by a WT_THD structure. One physical thread can have only one WT_THD descriptor at any given moment.</p>
<p>a resource - a thread does not wait for other threads directly, instead it waits for a "resource", which is "owned" by other threads. It waits, exactly, for all "owners" to "release" a resource. It does not have to correspond to a physical resource. For example, it may be convenient in certain cases to force resource == thread. A resource is represented by a WT_RESOURCE structure.</p>
<p>a resource identifier - a pair of {resource type, value}. A value is an ulonglong number. Represented by a WT_RESOURCE_ID structure.</p>
<p>a resource type - a pointer to a statically defined instance of WT_RESOURCE_TYPE structure. This structure contains a pointer to a function that knows how to compare values of this resource type. In the simple case it could be <a class="el" href="waiting__threads_8c.html#a232169c5d953ec33f32164cf67f5ea3e">wt_resource_id_memcmp()</a>.</p>
<p>a wait-for graph - a graph, that represenst "wait-for" relationships. It has two types of nodes - threads and resources. There are directed edges from a thread to a resource it is waiting for (WT_THD::waiting_for), from a thread to resources that it "owns" (WT_THD::my_resources), and from a resource to threads that "own" it (WT_RESOURCE::owners)</p>
<p>Graph completeness ^^^^^^^^^^^^^^^^^^</p>
<p>For flawless deadlock detection wait-for graph must be complete. It means that when a thread starts waiting it needs to know <em>all</em> its blockers, and call <a class="el" href="waiting__threads_8c.html#a2d7a68ea0d1af72667aa94a74ac37eee">wt_thd_will_wait_for()</a> for every one of them. Otherwise two phenomena should be expected:</p>
<ol type="1">
<li><p class="startli">Fuzzy timeouts:</p>
<p class="startli">thread A needs to get a lock, and is blocked by a thread B. it waits. Just before the timeout thread B releases the lock. thread A is ready to grab the lock but discovers that it is also blocked by a thread C. It waits and times out.</p>
<p class="startli">As a result thread A has waited two timeout intervals, instead of one.</p>
</li>
<li><p class="startli">Unreliable cycle detection:</p>
<p class="startli">Thread A waits for threads B and C Thread C waits for D Thread D wants to start waiting for A</p>
<p class="startli">one can see immediately that thread D creates a cycle, and thus a deadlock is detected.</p>
<p class="startli">But if thread A would only wait for B, and start waiting for C when B would unlock, thread D would be allowed to wait, a deadlock would be only detected when B unlocks or somebody times out.</p>
</li>
</ol>
<p>These two phenomena don't affect a correctness, and strictly speaking, the caller is not required to call <a class="el" href="waiting__threads_8c.html#a2d7a68ea0d1af72667aa94a74ac37eee">wt_thd_will_wait_for()</a> for <em>all</em> blockers - it may optimize <a class="el" href="waiting__threads_8c.html#a2d7a68ea0d1af72667aa94a74ac37eee">wt_thd_will_wait_for()</a> calls. But they may be perceived as bugs by users, it must be understood that such an optimization comes with its price.</p>
<p>Usage ^^^^^</p>
<p>First, the wt* subsystem must be initialized by calling wt_init(). In the server you don't need to do it, it's done in mysqld.cc.</p>
<p>Similarly, wt_end() frees wt* structures, should be called at the end, but in the server mysqld.cc takes care of that.</p>
<p>Every WT_THD should be initialized with <a class="el" href="waiting__threads_8c.html#ab9944cb8d5b6d581657e3de4d7bfb720">wt_thd_lazy_init()</a>. After that they can be used in other wt_thd_* calls. Before discarding, WT_THD should be free'd with wt_thd_destroy(). In the server both are handled in sql_class.cc, it's an error to try to do it manually.</p>
<p>To use the deadlock detection one needs to use this thread's WT_THD, call <a class="el" href="waiting__threads_8c.html#a2d7a68ea0d1af72667aa94a74ac37eee">wt_thd_will_wait_for()</a> for every thread it needs to wait on, then call <a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait()</a>. When thread releases a resource it should call <a class="el" href="waiting__threads_8c.html#ad0f0e0a15fd682fa11614970d8213a4a">wt_thd_release()</a> (or wt_thd_release_all()) - it will notify (send a signal) threads waiting in <a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait()</a>, if appropriate.</p>
<p>Just like with pthread's cond_wait, there could be spurious wake-ups from <a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait()</a>. A caller is expected to handle that (that is, to re-check the blocking criteria).</p>
<p><a class="el" href="waiting__threads_8c.html#a2d7a68ea0d1af72667aa94a74ac37eee">wt_thd_will_wait_for()</a> and <a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait()</a> return either WT_OK or WT_DEADLOCK. Additionally <a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait()</a> can return WT_TIMEOUT. Out of memory and other fatal errors are reported as WT_DEADLOCK - and a transaction must be aborted just the same.</p>
<p>Configuration ^^^^^^^^^^^^^ There are four config variables. Two deadlock search depths - short and long - and two timeouts. Deadlock search is performed with the short depth on every <a class="el" href="waiting__threads_8c.html#a2d7a68ea0d1af72667aa94a74ac37eee">wt_thd_will_wait_for()</a> call. <a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait()</a> waits with a short timeout, performs a deadlock search with the long depth, and waits with a long timeout. As most deadlock cycles are supposed to be short, most deadlocks will be detected at once, and waits will rarely be necessary.</p>
<p>These config variables are thread-local. Different threads may have different search depth and timeout values.</p>
<p>Also, deadlock detector supports different killing strategies, the victim in a deadlock cycle is selected based on the "weight". See "weight" description in <a class="el" href="waiting__threads_8h_source.html">waiting_threads.h</a> for details. It's up to the caller to set weights accordingly.</p>
<p>Status ^^^^^^ We calculate the number of successfull waits (WT_OK returned from <a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait()</a>), a number of timeouts, a deadlock cycle length distribution - number of deadlocks with every length from 1 to WT_CYCLE_STATS, and a wait time distribution - number of waits with a time from 1 us to 1 min in WT_WAIT_STATS intervals on a log e scale.</p>
<p>Sample usage as was done in the Maria engine ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p><ul>
<li>in class THD, THD::transaction had a WT_THD object; there were session variables to set the short/long depth/timeout.</li>
<li>when mysqld started, wt_init() was called; when it ended, wt_end() was called.</li>
<li>in THD's constructor, wt_thd_lazy_init(&amp;transaction.wt, &amp;variables.wt_deadlock_search_depth_short, &amp;variables.wt_timeout_short, &amp;variables.wt_deadlock_search_depth_long, &amp;variables.wt_timeout_long);</li>
<li>in THD::cleanup(): wt_thd_destroy(&amp;transaction.wt);</li>
<li>this was sufficient to make the deadlock-detector available to the Maria engine (which can grab THD); the engine used it this way:</li>
<li>when it wrote a row, and hit a duplicate key, it would find who wrote this key, the "blocker" transaction. If "blocker" had committed, duplicate key error would be sent. Otherwise, we would wait for it, in the following code snippet (originally from storage/maria/ma_write.c). After the blocker is gone, we would retry the write: <pre class="fragment">  while (keyinfo-&gt;ck_insert(info,
           (*keyinfo-&gt;make_key)(info, &amp;int_key, i, buff, record,
                                filepos, info-&gt;trn-&gt;trid)))
  {
    / * we got a write error * /
    if error is not "duplicate key" then return error;
    info-&gt;dup_key_trid has the culprit:
    if the culprit is ourselves then return error;
    otherwise:
    blocker= trnman_trid_to_trn(info-&gt;trn, info-&gt;dup_key_trid);
    / *
      if blocker TRN was not found, it means that the conflicting
      transaction was committed long time ago. It could not be
      aborted, as it would have to wait on the key tree lock
      to remove the conflicting key it has inserted.
      /
    if (!blocker || blocker-&gt;commit_trid != ~(TrID)0)
    { / * committed * /
      if (blocker)
        pthread_mutex_unlock(&amp; blocker-&gt;state_lock);
      rw_unlock(&amp;keyinfo-&gt;root_lock);
      goto err;
    }
    / * release root_lock to let blocker finish its work * /
    rw_unlock(&amp;keyinfo-&gt;root_lock);
    {
      / * running. now we wait * /
      WT_RESOURCE_ID rc;
      int res;
      const char *old_proc_info;

      rc.type= &amp;ma_rc_dup_unique;
      rc.value= (intptr)blocker;
      res= wt_thd_will_wait_for(info-&gt;trn-&gt;wt, blocker-&gt;wt, &amp; rc);
      if (res != WT_OK)
      {
        pthread_mutex_unlock(&amp; blocker-&gt;state_lock);
        my_errno= HA_ERR_LOCK_DEADLOCK;
        goto err;
      }
      old_proc_info= proc_info_hook(0,
                                    "waiting for a resource",
                                    __func__, __FILE__, __LINE__);
      res= wt_thd_cond_timedwait(info-&gt;trn-&gt;wt, &amp; blocker-&gt;state_lock);
      proc_info_hook(0, old_proc_info, __func__, __FILE__, __LINE__);

      pthread_mutex_unlock(&amp; blocker-&gt;state_lock);
      if (res != WT_OK)
      {
        my_errno= res == WT_TIMEOUT ? HA_ERR_LOCK_WAIT_TIMEOUT
                                    : HA_ERR_LOCK_DEADLOCK;
        goto err;
      }
      / * if we come here, blocker has rolled back or committed,
      so is gone, we can retry the ck_insert() * /
    }
    rw_wrlock(&amp;keyinfo-&gt;root_lock);
</pre> #ifndef MARIA_CANNOT_ROLLBACK keyinfo-&gt;version++; #endif }</li>
<li>ma_rc_dup_unique was: / * a WT_RESOURCE_TYPE for transactions waiting on a unique key conflict * / WT_RESOURCE_TYPE ma_rc_dup_unique={ wt_resource_id_memcmp, 0};</li>
<li>When a Maria transaction would commit or rollback it would call: / * Wake up threads waiting for this transaction * / static void wt_thd_release_self(TRN *trn) { if (trn-&gt;wt) { WT_RESOURCE_ID rc; rc.type=  rc.value= (intptr)trn; wt_thd_release(trn-&gt;wt, &amp; rc); trn-&gt;wt= 0; } }</li>
</ul>
<p>Tests ^^^^^ unittest/mysys/waiting_threads-t.c, currently disabled. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a73d71c89418d386fd1a6cc4a8d4e51d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d71c89418d386fd1a6cc4a8d4e51d4">&#9670;&nbsp;</a></span>change_victim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void change_victim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>found</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdeadlock__arg.html">deadlock_arg</a> *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>helper function to change the victim, according to the weight </p>

</div>
</div>
<a id="ac95920c3b979a68dec9a07151f7359d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95920c3b979a68dec9a07151f7359d1">&#9670;&nbsp;</a></span>deadlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int deadlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>blocker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deadlock detection in a wait-for graph</p>
<p>A wrapper for recursive <a class="el" href="waiting__threads_8c.html#ac8353d04c961ec504513a604985e3e3b">deadlock_search()</a> - prepares <a class="el" href="structdeadlock__arg.html">deadlock_arg</a> structure, invokes <a class="el" href="waiting__threads_8c.html#ac8353d04c961ec504513a604985e3e3b">deadlock_search()</a>, increments statistics, notifies the victim.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread that is going to wait. Deadlock is detected if, while walking the graph, we reach a thread that is waiting on thd </td></tr>
    <tr><td class="paramname">blocker</td><td>starting point of a search. In <a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait()</a> it's thd, in <a class="el" href="waiting__threads_8c.html#a2d7a68ea0d1af72667aa94a74ac37eee">wt_thd_will_wait_for()</a> it's a thread that thd is going to wait for </td></tr>
    <tr><td class="paramname">depth</td><td>starting search depth. In general it's the number of edges in the wait-for graph between thd and the blocker. Practically only two values are used (and supported) - when thd == blocker it's 0, when thd waits directly for blocker, it's 1 </td></tr>
    <tr><td class="paramname">max_depth</td><td>search depth limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8353d04c961ec504513a604985e3e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8353d04c961ec504513a604985e3e3b">&#9670;&nbsp;</a></span>deadlock_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int deadlock_search </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdeadlock__arg.html">deadlock_arg</a> *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>blocker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>recursive loop detection in a wait-for graph with a limited search depth </p>

</div>
</div>
<a id="aa3ceee36654677aa356d0cebb32d4386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ceee36654677aa356d0cebb32d4386">&#9670;&nbsp;</a></span>fix_thd_pins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int fix_thd_pins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finalize WT_THD initialization</p>
<p>After lazy WT_THD initialization, parts of the structure are still uninitialized. This function completes the initialization, allocating memory, if necessary. It's called automatically on demand, when WT_THD is about to be used. </p>

</div>
</div>
<a id="abf5de7b130e0507146922e5db3dfd9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5de7b130e0507146922e5db3dfd9f2">&#9670;&nbsp;</a></span>stop_waiting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int stop_waiting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>register the fact that thd is not waiting anymore</p>
<p>locks thd-&gt;waiting_for and calls <a class="el" href="waiting__threads_8c.html#a5b46e1bd5eb16f990f2e1c61cce676af">stop_waiting_locked()</a>. </p>

</div>
</div>
<a id="a5b46e1bd5eb16f990f2e1c61cce676af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b46e1bd5eb16f990f2e1c61cce676af">&#9670;&nbsp;</a></span>stop_waiting_locked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int stop_waiting_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>register the fact that thd is not waiting anymore</p>
<p>decrease waiter_count, clear waiting_for, free the resource if appropriate. thd-&gt;waiting_for must be locked! </p>

</div>
</div>
<a id="ae629c1b4c4bffec4871e98568d3a9880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae629c1b4c4bffec4871e98568d3a9880">&#9670;&nbsp;</a></span>unlock_lock_and_free_resource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int unlock_lock_and_free_resource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__wt__resource.html">WT_RESOURCE</a> *&#160;</td>
          <td class="paramname"><em>rc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete an element from reshash if it has no waiters or owners</p>
<p>rc-&gt;lock must be locked by the caller and it's unlocked on return. </p>

</div>
</div>
<a id="a0501b730a52856fff19a4a4accf7f215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0501b730a52856fff19a4a4accf7f215">&#9670;&nbsp;</a></span>wt_resource_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void wt_resource_destroy </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>WT_RESOURCE destructor</p>
<p>It's called from lf_hash and takes a pointer to an <a class="el" href="struct_l_f___s_l_i_s_t.html">LF_SLIST</a> instance. WT_RESOURCE is located at arg+sizeof(<a class="el" href="struct_l_f___s_l_i_s_t.html">LF_SLIST</a>) </p>

</div>
</div>
<a id="a232169c5d953ec33f32164cf67f5ea3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232169c5d953ec33f32164cf67f5ea3e">&#9670;&nbsp;</a></span>wt_resource_id_memcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">my_bool wt_resource_id_memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trivial resource id comparison function - bytewise memcmp.</p>
<p>It can be used in WT_RESOURCE_TYPE structures where bytewise comparison of values is sufficient. </p>

</div>
</div>
<a id="a5a95230d55c8556c168f2115cabdb195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a95230d55c8556c168f2115cabdb195">&#9670;&nbsp;</a></span>wt_resource_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void wt_resource_init </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>WT_RESOURCE constructor</p>
<p>It's called from lf_hash and takes a pointer to an <a class="el" href="struct_l_f___s_l_i_s_t.html">LF_SLIST</a> instance. WT_RESOURCE is located at arg+sizeof(<a class="el" href="struct_l_f___s_l_i_s_t.html">LF_SLIST</a>) </p>

</div>
</div>
<a id="af7b22cc893f0c4ea13584050385e578a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b22cc893f0c4ea13584050385e578a">&#9670;&nbsp;</a></span>wt_thd_cond_timedwait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wt_thd_cond_timedwait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>called by a <em>waiter</em> (thd) to start waiting</p>
<p>It's supposed to be a drop-in replacement for pthread_cond_timedwait(), and it takes mutex as an argument.</p>
<dl class="section return"><dt>Returns</dt><dd>one of WT_TIMEOUT, WT_DEADLOCK, WT_OK </dd></dl>

</div>
</div>
<a id="ab9944cb8d5b6d581657e3de4d7bfb720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9944cb8d5b6d581657e3de4d7bfb720">&#9670;&nbsp;</a></span>wt_thd_lazy_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wt_thd_lazy_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulong *&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulong *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulong *&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulong *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_lazy.html">Lazy</a> WT_THD initialization</p>
<p>Cheap initialization of WT_THD. Only initialize fields that don't require memory allocations - basically, it only does assignments. The rest of the WT_THD structure will be initialized on demand, on the first use. This allows one to initialize lazily all WT_THD structures, even if some (or even most) of them will never be used for deadlock detection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ds</td><td>a pointer to deadlock search depth short value </td></tr>
    <tr><td class="paramname">ts</td><td>a pointer to deadlock timeout short value </td></tr>
    <tr><td class="paramname">dl</td><td>a pointer to deadlock search depth long value </td></tr>
    <tr><td class="paramname">tl</td><td>a pointer to deadlock timeout long value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>these are pointers to values, and WT_THD stores them as pointers. It allows one later to change search depths and timeouts for existing threads. It also means that the pointers must stay valid for the lifetime of WT_THD. </dd></dl>

</div>
</div>
<a id="ad0f0e0a15fd682fa11614970d8213a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f0e0a15fd682fa11614970d8213a4a">&#9670;&nbsp;</a></span>wt_thd_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wt_thd_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WT_RESOURCE_ID *&#160;</td>
          <td class="paramname"><em>resid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>called by a <em>blocker</em> when it releases a resource</p>
<p>it's conceptually similar to pthread_cond_broadcast, and must be done under the same mutex as <a class="el" href="waiting__threads_8c.html#af7b22cc893f0c4ea13584050385e578a">wt_thd_cond_timedwait()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resid</td><td>a resource to release. 0 to release all resources </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d7a68ea0d1af72667aa94a74ac37eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7a68ea0d1af72667aa94a74ac37eee">&#9670;&nbsp;</a></span>wt_thd_will_wait_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wt_thd_will_wait_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__wt__thd.html">WT_THD</a> *&#160;</td>
          <td class="paramname"><em>blocker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WT_RESOURCE_ID *&#160;</td>
          <td class="paramname"><em>resid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>notify the system that a thread needs to wait for another thread</p>
<p>called by a <em>waiter</em> to declare that it (thd) will wait for another thread (blocker) on a specific resource (resid). can be called many times, if many blockers own a blocking resource. but must always be called with the same resource id - a thread cannot wait for more than one resource at a time.</p>
<dl class="section return"><dt>Returns</dt><dd>WT_OK or WT_DEADLOCK</dd></dl>
<p>As a new edge is added to the wait-for graph, a deadlock detection is performed for this new edge. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8f0286ac2b16cd82e9f20e2b62b645ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0286ac2b16cd82e9f20e2b62b645ad">&#9670;&nbsp;</a></span>wt_cycle_stats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 wt_cycle_stats[2][WT_CYCLE_STATS+1]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>distribution of cycle lengths first column tells whether this was during short or long detection </p>

</div>
</div>
<a id="a398ad9f07c4ce156f4e0906d7868bce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398ad9f07c4ce156f4e0906d7868bce8">&#9670;&nbsp;</a></span>wt_wait_stats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 wt_wait_stats[WT_WAIT_STATS+1]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>wait time distribution (log e scale) </p>

</div>
</div>
<a id="af89deb29632a87d9244e90b79ba374df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89deb29632a87d9244e90b79ba374df">&#9670;&nbsp;</a></span>wt_wait_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong wt_wait_table[WT_WAIT_STATS]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>preset table of wait intervals </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

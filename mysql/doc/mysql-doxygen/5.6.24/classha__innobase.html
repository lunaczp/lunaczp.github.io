<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: ha_innobase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classha__innobase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ha_innobase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ha__innodb_8h_source.html">ha_innodb.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ha_innobase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classha__innobase.png" usemap="#ha_5Finnobase_map" alt=""/>
  <map id="ha_5Finnobase_map" name="ha_5Finnobase_map">
<area href="classhandler.html" alt="handler" shape="rect" coords="0,56,84,80"/>
<area href="class_sql__alloc.html" alt="Sql_alloc" shape="rect" coords="0,0,84,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a64cbd796fd4bf42cab7d28c2c0e09564"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a64cbd796fd4bf42cab7d28c2c0e09564">ha_innobase</a> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *table_arg)</td></tr>
<tr class="separator:a64cbd796fd4bf42cab7d28c2c0e09564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd31ce1c2179ed2677ff036de0633913"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#afd31ce1c2179ed2677ff036de0633913">~ha_innobase</a> ()</td></tr>
<tr class="separator:afd31ce1c2179ed2677ff036de0633913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a3a299ed63452b5b99c27126cfb07e"><td class="memItemLeft" align="right" valign="top">enum row_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a40a3a299ed63452b5b99c27126cfb07e">get_row_type</a> () const</td></tr>
<tr class="separator:a40a3a299ed63452b5b99c27126cfb07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c66a5e6163f68403c8fd0adb796607"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a37c66a5e6163f68403c8fd0adb796607">table_type</a> () const</td></tr>
<tr class="separator:a37c66a5e6163f68403c8fd0adb796607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381d429e7e607873a361166ac1ce965c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a381d429e7e607873a361166ac1ce965c">index_type</a> (uint key_number)</td></tr>
<tr class="separator:a381d429e7e607873a361166ac1ce965c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678fe7a653db9708db5a37e49af65e75"><td class="memItemLeft" align="right" valign="top">const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a678fe7a653db9708db5a37e49af65e75">bas_ext</a> () const</td></tr>
<tr class="separator:a678fe7a653db9708db5a37e49af65e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d695a97ee1acee5dfd857d777e49fc"><td class="memItemLeft" align="right" valign="top">Table_flags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af6d695a97ee1acee5dfd857d777e49fc">table_flags</a> () const</td></tr>
<tr class="separator:af6d695a97ee1acee5dfd857d777e49fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d94a2fa52bcdb95fa43d671076e5b0"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af9d94a2fa52bcdb95fa43d671076e5b0">index_flags</a> (uint idx, uint part, bool all_parts) const</td></tr>
<tr class="separator:af9d94a2fa52bcdb95fa43d671076e5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f734e94ccb05d3d69c681f7d72eeab"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a11f734e94ccb05d3d69c681f7d72eeab">max_supported_keys</a> () const</td></tr>
<tr class="separator:a11f734e94ccb05d3d69c681f7d72eeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cfa4634931c1e60095b24fc3252cd9"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a51cfa4634931c1e60095b24fc3252cd9">max_supported_key_length</a> () const</td></tr>
<tr class="separator:a51cfa4634931c1e60095b24fc3252cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa875d4c79f9b15154528325488fc90fc"><td class="memItemLeft" align="right" valign="top"><a id="aa875d4c79f9b15154528325488fc90fc"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_part_length</b> () const</td></tr>
<tr class="separator:aa875d4c79f9b15154528325488fc90fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b442f6b0804f0bb034583298661d8e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a3b442f6b0804f0bb034583298661d8e4">keys_to_use_for_scanning</a> ()</td></tr>
<tr class="separator:a3b442f6b0804f0bb034583298661d8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705d0c97e01255009d0c97ba80ba3f85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a705d0c97e01255009d0c97ba80ba3f85">open</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, int <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, uint test_if_locked)</td></tr>
<tr class="separator:a705d0c97e01255009d0c97ba80ba3f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401cda4e42cc0b9fcba2bc30668a7a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a401cda4e42cc0b9fcba2bc30668a7a03">clone</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:a401cda4e42cc0b9fcba2bc30668a7a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5377253148c95f8c9d8c21ab4bd2fc9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a5377253148c95f8c9d8c21ab4bd2fc9b">close</a> (void)</td></tr>
<tr class="separator:a5377253148c95f8c9d8c21ab4bd2fc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144d4357ed15c4af18092a88e5ab55db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a144d4357ed15c4af18092a88e5ab55db">scan_time</a> ()</td></tr>
<tr class="separator:a144d4357ed15c4af18092a88e5ab55db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe974cf972531fadb046018db76614e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a4fe974cf972531fadb046018db76614e">read_time</a> (uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, uint ranges, ha_rows rows)</td></tr>
<tr class="separator:a4fe974cf972531fadb046018db76614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf78c3052b9adeec8eb41b8f23ad71"><td class="memItemLeft" align="right" valign="top">longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8faf78c3052b9adeec8eb41b8f23ad71">get_memory_buffer_size</a> () const</td></tr>
<tr class="separator:a8faf78c3052b9adeec8eb41b8f23ad71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974ef9811d788fbab703a6d3cd292476"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a974ef9811d788fbab703a6d3cd292476">write_row</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a974ef9811d788fbab703a6d3cd292476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39587716831a568109760921542718b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af39587716831a568109760921542718b">update_row</a> (const uchar *old_data, uchar *new_data)</td></tr>
<tr class="separator:af39587716831a568109760921542718b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249d241a7445cb297f253f297730f8ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a249d241a7445cb297f253f297730f8ee">delete_row</a> (const uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a249d241a7445cb297f253f297730f8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1584696559d62c9f1b263189a73cbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ada1584696559d62c9f1b263189a73cbd">was_semi_consistent_read</a> ()</td></tr>
<tr class="separator:ada1584696559d62c9f1b263189a73cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b12ebc2bb2a73404771514a047f0ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ac3b12ebc2bb2a73404771514a047f0ab">try_semi_consistent_read</a> (bool yes)</td></tr>
<tr class="separator:ac3b12ebc2bb2a73404771514a047f0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af201c2ed028097a876935c9695421db6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af201c2ed028097a876935c9695421db6">unlock_row</a> ()</td></tr>
<tr class="separator:af201c2ed028097a876935c9695421db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ede2b59a30025b97e35614b8008631"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae7ede2b59a30025b97e35614b8008631">index_init</a> (uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, bool sorted)</td></tr>
<tr class="separator:ae7ede2b59a30025b97e35614b8008631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191905c0a48f411f3a250f665a54d48e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a191905c0a48f411f3a250f665a54d48e">index_end</a> ()</td></tr>
<tr class="separator:a191905c0a48f411f3a250f665a54d48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136fcf0b707eb71d6c58b9d299cf347f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a136fcf0b707eb71d6c58b9d299cf347f">index_read</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a136fcf0b707eb71d6c58b9d299cf347f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136fb4fe1294684ecd00afff33064d06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a136fb4fe1294684ecd00afff33064d06">index_read_idx</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a136fb4fe1294684ecd00afff33064d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0729db8f95a01df92d6a4ac0a9986af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa0729db8f95a01df92d6a4ac0a9986af">index_read_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len)</td></tr>
<tr class="separator:aa0729db8f95a01df92d6a4ac0a9986af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60518f2b2bfdba02649ebcf5f3ca2545"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a60518f2b2bfdba02649ebcf5f3ca2545">index_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a60518f2b2bfdba02649ebcf5f3ca2545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed9c3e4225dd57c685db7916da272b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a6ed9c3e4225dd57c685db7916da272b6">index_next_same</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a6ed9c3e4225dd57c685db7916da272b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b40809d4ce6883294fceb9f9c7a8fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a11b40809d4ce6883294fceb9f9c7a8fc">index_prev</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a11b40809d4ce6883294fceb9f9c7a8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d74e0604e1891a2e69cb014a96f1d76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a3d74e0604e1891a2e69cb014a96f1d76">index_first</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a3d74e0604e1891a2e69cb014a96f1d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0585621f565a14ca13e3655a89a1914c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a0585621f565a14ca13e3655a89a1914c">index_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a0585621f565a14ca13e3655a89a1914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad399dbc2e6b9cfcf788993d1bc6fb666"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ad399dbc2e6b9cfcf788993d1bc6fb666">rnd_init</a> (bool scan)</td></tr>
<tr class="separator:ad399dbc2e6b9cfcf788993d1bc6fb666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c8f18dc5a8d094d818099107a0fcd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a98c8f18dc5a8d094d818099107a0fcd2">rnd_end</a> ()</td></tr>
<tr class="separator:a98c8f18dc5a8d094d818099107a0fcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dec515b9c0632116153a9990f980cf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a5dec515b9c0632116153a9990f980cf9">rnd_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a5dec515b9c0632116153a9990f980cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ac165a69160c94dd25349674fff74c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a77ac165a69160c94dd25349674fff74c">rnd_pos</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uchar *pos)</td></tr>
<tr class="separator:a77ac165a69160c94dd25349674fff74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfd4d887e03cb00e09254a4bb17debc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a3bfd4d887e03cb00e09254a4bb17debc">ft_init</a> ()</td></tr>
<tr class="separator:a3bfd4d887e03cb00e09254a4bb17debc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90782f6c7b37725ff0845f761460dedf"><td class="memItemLeft" align="right" valign="top"><a id="a90782f6c7b37725ff0845f761460dedf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ft_end</b> ()</td></tr>
<tr class="separator:a90782f6c7b37725ff0845f761460dedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f63c971df342b417d2f52256ff9c55d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__ft__info.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a3f63c971df342b417d2f52256ff9c55d">ft_init_ext</a> (uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, uint inx, <a class="el" href="class_string.html">String</a> *key)</td></tr>
<tr class="separator:a3f63c971df342b417d2f52256ff9c55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82de5f1b81a59879d5f3f3c27710e366"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a82de5f1b81a59879d5f3f3c27710e366">ft_read</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a82de5f1b81a59879d5f3f3c27710e366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a2c6b04ebbd71da3c9406bfc461e3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae2a2c6b04ebbd71da3c9406bfc461e3d">position</a> (const uchar *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="separator:ae2a2c6b04ebbd71da3c9406bfc461e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943220a0de85c62db4ad846ec0ba88ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a943220a0de85c62db4ad846ec0ba88ab">info</a> (uint)</td></tr>
<tr class="separator:a943220a0de85c62db4ad846ec0ba88ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac86762c99c97898e7d184a2dcaa385"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a2ac86762c99c97898e7d184a2dcaa385">analyze</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a2ac86762c99c97898e7d184a2dcaa385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9692c4de7d2593fdb398aefe9ff668e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a9692c4de7d2593fdb398aefe9ff668e5">optimize</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a9692c4de7d2593fdb398aefe9ff668e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c84c4a207ad95ed5d715661c604ae26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8c84c4a207ad95ed5d715661c604ae26">discard_or_import_tablespace</a> (my_bool discard)</td></tr>
<tr class="separator:a8c84c4a207ad95ed5d715661c604ae26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a8e8c82b63bb51e96caac9e65e7ba3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a48a8e8c82b63bb51e96caac9e65e7ba3">extra</a> (enum ha_extra_function operation)</td></tr>
<tr class="separator:a48a8e8c82b63bb51e96caac9e65e7ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52efc99d1f7cf9d97312ff95ad6c96fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a52efc99d1f7cf9d97312ff95ad6c96fb">reset</a> ()</td></tr>
<tr class="separator:a52efc99d1f7cf9d97312ff95ad6c96fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97491497626f54845bba1539e0c1ec7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ac97491497626f54845bba1539e0c1ec7">external_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, int lock_type)</td></tr>
<tr class="separator:ac97491497626f54845bba1539e0c1ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0cc1d1c6fe6adca293d598924adcff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a5f0cc1d1c6fe6adca293d598924adcff">transactional_table_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, int lock_type)</td></tr>
<tr class="separator:a5f0cc1d1c6fe6adca293d598924adcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2653367f5003185e9df77992f4a80e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a6e2653367f5003185e9df77992f4a80e">start_stmt</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, thr_lock_type lock_type)</td></tr>
<tr class="separator:a6e2653367f5003185e9df77992f4a80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810a90e2d5ec1ea15c83b4f79dfdb028"><td class="memItemLeft" align="right" valign="top"><a id="a810a90e2d5ec1ea15c83b4f79dfdb028"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (uchar *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="separator:a810a90e2d5ec1ea15c83b4f79dfdb028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e47491716ea977e4d74714983801c3"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a10e47491716ea977e4d74714983801c3">records_in_range</a> (uint inx, <a class="el" href="structst__key__range.html">key_range</a> *min_key, <a class="el" href="structst__key__range.html">key_range</a> *max_key)</td></tr>
<tr class="separator:a10e47491716ea977e4d74714983801c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747831324f241471b06cb9db6cc4908d"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a747831324f241471b06cb9db6cc4908d">estimate_rows_upper_bound</a> ()</td></tr>
<tr class="separator:a747831324f241471b06cb9db6cc4908d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ea4b44716bf246fa249c371f08421f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae8ea4b44716bf246fa249c371f08421f">update_create_info</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:ae8ea4b44716bf246fa249c371f08421f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe6b85680a474f4cc10b7ebd1a9ce47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a0fe6b85680a474f4cc10b7ebd1a9ce47">parse_table_name</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, ulint <a class="el" href="ha__innodb_8cc.html#a3ca41e26d8b04a12445282fdce51338a">flags2</a>, char *norm_name, char *<a class="el" href="ha__innodb_8cc.html#aef4bf7b7c86841d2fe26e93116dccb28">temp_path</a>, char *<a class="el" href="ha__innodb_8cc.html#a81d88b913d3c839f4a517e383707b68b">remote_path</a>)</td></tr>
<tr class="separator:a0fe6b85680a474f4cc10b7ebd1a9ce47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ecdd68f467ec7a3785cb782c9e128d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a31ecdd68f467ec7a3785cb782c9e128d">create</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, register <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="ha__innodb_8cc.html#ae64f1475e9ca79d24be2a8091b9cbdd7">form</a>, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:a31ecdd68f467ec7a3785cb782c9e128d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819d891b648b8846e7d58ee795799473"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a819d891b648b8846e7d58ee795799473">truncate</a> ()</td></tr>
<tr class="separator:a819d891b648b8846e7d58ee795799473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ec3c69d0250c2ef1b1c5c5bd61153d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa9ec3c69d0250c2ef1b1c5c5bd61153d">delete_table</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:aa9ec3c69d0250c2ef1b1c5c5bd61153d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4cb28dc4dac919ba8182b7cb176781"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#abf4cb28dc4dac919ba8182b7cb176781">rename_table</a> (const char *<a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a>, const char *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>)</td></tr>
<tr class="separator:abf4cb28dc4dac919ba8182b7cb176781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5eefd497c817f7e3a0d8c52458efe6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a5c5eefd497c817f7e3a0d8c52458efe6">check</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a5c5eefd497c817f7e3a0d8c52458efe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe9674d4d001b7bbb13a1be8922325"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a7cfe9674d4d001b7bbb13a1be8922325">update_table_comment</a> (const char *comment)</td></tr>
<tr class="separator:a7cfe9674d4d001b7bbb13a1be8922325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4bef829362895e69f4b018cb411f2e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aee4bef829362895e69f4b018cb411f2e">get_foreign_key_create_info</a> ()</td></tr>
<tr class="separator:aee4bef829362895e69f4b018cb411f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115f5e0b70a59aaec2fbefced8b7faa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a115f5e0b70a59aaec2fbefced8b7faa4">get_foreign_key_list</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a115f5e0b70a59aaec2fbefced8b7faa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fbf47cb6215228269a97efd5f50592"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a58fbf47cb6215228269a97efd5f50592">get_parent_foreign_key_list</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a58fbf47cb6215228269a97efd5f50592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3165bcb0f9f9d6902fb11e6bac1da8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#afd3165bcb0f9f9d6902fb11e6bac1da8">can_switch_engines</a> ()</td></tr>
<tr class="separator:afd3165bcb0f9f9d6902fb11e6bac1da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcc2977ea644e085e6b9e503913d783"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a9fcc2977ea644e085e6b9e503913d783">referenced_by_foreign_key</a> ()</td></tr>
<tr class="separator:a9fcc2977ea644e085e6b9e503913d783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7775bc549ac945b58b9151dd24f77b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa7775bc549ac945b58b9151dd24f77b8">free_foreign_key_create_info</a> (char *str)</td></tr>
<tr class="separator:aa7775bc549ac945b58b9151dd24f77b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a9779dfd5b55feb0888a7381661f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ab5a9779dfd5b55feb0888a7381661f74">store_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> **<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>, enum thr_lock_type lock_type)</td></tr>
<tr class="separator:ab5a9779dfd5b55feb0888a7381661f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8653e736d0ddaf3fc11a4d2bcbf93f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a4e8653e736d0ddaf3fc11a4d2bcbf93f">init_table_handle_for_HANDLER</a> ()</td></tr>
<tr class="separator:a4e8653e736d0ddaf3fc11a4d2bcbf93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1226df999937e02ca1c1b0653e1a3e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a0d1226df999937e02ca1c1b0653e1a3e">get_auto_increment</a> (ulonglong <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulonglong increment, ulonglong nb_desired_values, ulonglong *first_value, ulonglong *nb_reserved_values)</td></tr>
<tr class="separator:a0d1226df999937e02ca1c1b0653e1a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8418ce7f1d1353c685fc93b88f16c1d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8418ce7f1d1353c685fc93b88f16c1d2">reset_auto_increment</a> (ulonglong value)</td></tr>
<tr class="separator:a8418ce7f1d1353c685fc93b88f16c1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4392eb1ca708975a460d244fdb9e77"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#afc4392eb1ca708975a460d244fdb9e77">get_error_message</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, <a class="el" href="class_string.html">String</a> *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:afc4392eb1ca708975a460d244fdb9e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53715acaa5441a53f0758ed900648760"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a53715acaa5441a53f0758ed900648760">get_foreign_dup_key</a> (char *, uint, char *, uint)</td></tr>
<tr class="separator:a53715acaa5441a53f0758ed900648760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0634d10e89122642d9278dd195bc7ea"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae0634d10e89122642d9278dd195bc7ea">table_cache_type</a> ()</td></tr>
<tr class="separator:ae0634d10e89122642d9278dd195bc7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8935c26cd1541f91e30786806a347f0a"><td class="memItemLeft" align="right" valign="top">my_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8935c26cd1541f91e30786806a347f0a">register_query_cache_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, char *table_key, uint key_length, qc_engine_callback *call_back, ulonglong *engine_data)</td></tr>
<tr class="separator:a8935c26cd1541f91e30786806a347f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cffddf7092f925a3d4af2268cafd8a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a7cffddf7092f925a3d4af2268cafd8a6">primary_key_is_clustered</a> ()</td></tr>
<tr class="separator:a7cffddf7092f925a3d4af2268cafd8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada20e8c05d828321f457df68be4bc7bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ada20e8c05d828321f457df68be4bc7bd">cmp_ref</a> (const uchar *ref1, const uchar *ref2)</td></tr>
<tr class="separator:ada20e8c05d828321f457df68be4bc7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb2efbc261d05d135f2c3761eacdbe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aaeb2efbc261d05d135f2c3761eacdbe9">check_if_incompatible_data</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *<a class="el" href="classha__innobase.html#a943220a0de85c62db4ad846ec0ba88ab">info</a>, uint table_changes)</td></tr>
<tr class="separator:aaeb2efbc261d05d135f2c3761eacdbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2e45aaeee263279fdfdc1b57c82ce020"><td class="memItemLeft" align="right" valign="top">enum_alter_inplace_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a2e45aaeee263279fdfdc1b57c82ce020">check_if_supported_inplace_alter</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a2e45aaeee263279fdfdc1b57c82ce020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143df4f5250198dcc51fc256d5f6e33b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a143df4f5250198dcc51fc256d5f6e33b">prepare_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a143df4f5250198dcc51fc256d5f6e33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6500b207c94934efcad46386b2425a66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a6500b207c94934efcad46386b2425a66">inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a6500b207c94934efcad46386b2425a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181db6334fe348fd1571ee862cee747"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ab181db6334fe348fd1571ee862cee747">commit_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:ab181db6334fe348fd1571ee862cee747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a72cfeaceefd05a2f700c138c194770fc inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a72cfeaceefd05a2f700c138c194770fc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unbind_psi</b> ()</td></tr>
<tr class="separator:a72cfeaceefd05a2f700c138c194770fc inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e335a403d8203854bc5b94111992b79 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1e335a403d8203854bc5b94111992b79"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rebind_psi</b> ()</td></tr>
<tr class="separator:a1e335a403d8203854bc5b94111992b79 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae8f7f7b4f67773b73906143238dc9f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9ae8f7f7b4f67773b73906143238dc9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b> (<a class="el" href="structhandlerton.html">handlerton</a> *ht_arg, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share_arg)</td></tr>
<tr class="separator:a9ae8f7f7b4f67773b73906143238dc9f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad6edb66592b200a7c7ac0f947dc66 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init</a> ()</td></tr>
<tr class="separator:ab1ad6edb66592b200a7c7ac0f947dc66 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e02829386929734724b143391e0a11 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5e02829386929734724b143391e0a11">ha_open</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, int <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, int test_if_locked)</td></tr>
<tr class="memdesc:ab5e02829386929734724b143391e0a11 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open database-handler.  <a href="classhandler.html#ab5e02829386929734724b143391e0a11">More...</a><br /></td></tr>
<tr class="separator:ab5e02829386929734724b143391e0a11 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28824cdff2c1812e282463c908e84c2 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">ha_close</a> (void)</td></tr>
<tr class="separator:ae28824cdff2c1812e282463c908e84c2 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af23462b249041a0db03c1c7139d76b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init</a> (uint idx, bool sorted)</td></tr>
<tr class="separator:a0af23462b249041a0db03c1c7139d76b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6bd01057c6cdd86d2ea2ee4ea65ca3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a> ()</td></tr>
<tr class="separator:afa6bd01057c6cdd86d2ea2ee4ea65ca3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c99736cb400350e007578889b8375 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init</a> (bool scan)</td></tr>
<tr class="separator:afb5c99736cb400350e007578889b8375 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9bf34ac0a004d8c5c32267f20842f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a> ()</td></tr>
<tr class="separator:ad4d9bf34ac0a004d8c5c32267f20842f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3743f3a48e7be751dbb2691be4c992a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">ha_rnd_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ad3743f3a48e7be751dbb2691be4c992a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8615219b3e692e7d484d2ba6cfa86 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uchar *pos)</td></tr>
<tr class="separator:abcd8615219b3e692e7d484d2ba6cfa86 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729d9c9c011527b81287574294887bf3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">ha_index_read_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a729d9c9c011527b81287574294887bf3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9be09b8d0b1c03c96eb95f79dd7c9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3fa9be09b8d0b1c03c96eb95f79dd7c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_read_last_map</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a3fa9be09b8d0b1c03c96eb95f79dd7c9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831321e8d33958db4fd4968de932acf inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">ha_index_read_idx_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:ac831321e8d33958db4fd4968de932acf inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c99e96a8350ff577a94529be9387a30 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">ha_index_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a4c99e96a8350ff577a94529be9387a30 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb977dac0435158be227e45e04c8b798 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb977dac0435158be227e45e04c8b798">ha_index_prev</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:abb977dac0435158be227e45e04c8b798 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd574a3025588e9b0cd49e0d6908e3b8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">ha_index_first</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:abd574a3025588e9b0cd49e0d6908e3b8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7415f1744039a51ef15e923ef7da1b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">ha_index_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a2a7415f1744039a51ef15e923ef7da1b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f79360a45d50c6b558feb1c308c4157 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">ha_index_next_same</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a3f79360a45d50c6b558feb1c308c4157 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f8c07d2ede3fb1f46fc0afb4052d2c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a37f8c07d2ede3fb1f46fc0afb4052d2c">ha_index_read</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a37f8c07d2ede3fb1f46fc0afb4052d2c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1790fe12f8d773f27d5b4b1cb30bd7ab inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1790fe12f8d773f27d5b4b1cb30bd7ab">ha_index_read_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len)</td></tr>
<tr class="separator:a1790fe12f8d773f27d5b4b1cb30bd7ab inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">ha_reset</a> ()</td></tr>
<tr class="memdesc:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_check.html">Check</a> handler usage and reset state of file to after 'open'.  <a href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">More...</a><br /></td></tr>
<tr class="separator:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1ef9b6ab27156116f91bf50b1ac19f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6e1ef9b6ab27156116f91bf50b1ac19f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_or_rnd_end</b> ()</td></tr>
<tr class="separator:a6e1ef9b6ab27156116f91bf50b1ac19f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3015577f49008561db1d34ae750e70 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">Table_flags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b3015577f49008561db1d34ae750e70">ha_table_flags</a> () const</td></tr>
<tr class="separator:a6b3015577f49008561db1d34ae750e70 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99b5f8ae28bc5c374919396f8dcf08 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">ha_external_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, int lock_type)</td></tr>
<tr class="separator:a9a99b5f8ae28bc5c374919396f8dcf08 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e651543ba0dbb2257a50dc1cdb5ea9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ad8e651543ba0dbb2257a50dc1cdb5ea9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_write_row</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ad8e651543ba0dbb2257a50dc1cdb5ea9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6bb19636dda0f1537fe780b6aca17a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1f6bb19636dda0f1537fe780b6aca17a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr class="separator:a1f6bb19636dda0f1537fe780b6aca17a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e3b24f5bb5b2a8fa0c45732db8cdd inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3f0e3b24f5bb5b2a8fa0c45732db8cdd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_delete_row</b> (const uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a3f0e3b24f5bb5b2a8fa0c45732db8cdd inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbcbef5b9b8ed0f76d700a29091ad3f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="abfbcbef5b9b8ed0f76d700a29091ad3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_release_auto_increment</b> ()</td></tr>
<tr class="separator:abfbcbef5b9b8ed0f76d700a29091ad3f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234580f9765751ce185182dd1edc3bdb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a234580f9765751ce185182dd1edc3bdb">check_collation_compatibility</a> ()</td></tr>
<tr class="separator:a234580f9765751ce185182dd1edc3bdb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a8030a4a3928d216599e1c03e9b28c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a79a8030a4a3928d216599e1c03e9b28c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_check_for_upgrade</b> (<a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a79a8030a4a3928d216599e1c03e9b28c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56545ec9967544c80d5612f8ac9b8e6e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">ha_check</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a56545ec9967544c80d5612f8ac9b8e6e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d70543d9566894b5a81d25eca2e8e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">ha_repair</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ad28d70543d9566894b5a81d25eca2e8e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f09a15d46c019a621b0a65bb1ec89d3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">ha_start_bulk_insert</a> (ha_rows rows)</td></tr>
<tr class="separator:a3f09a15d46c019a621b0a65bb1ec89d3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f3cbf4a769155c994ed39f76433106 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">ha_end_bulk_insert</a> ()</td></tr>
<tr class="separator:a30f3cbf4a769155c994ed39f76433106 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c8ce82a564b0cbf6340dc9b74a9c23 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">ha_bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:a49c8ce82a564b0cbf6340dc9b74a9c23 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef228137a11565f7d52a60ad802004 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">ha_delete_all_rows</a> ()</td></tr>
<tr class="separator:a1fef228137a11565f7d52a60ad802004 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25394328a49d42bb45b3b263009f02c7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a25394328a49d42bb45b3b263009f02c7">ha_truncate</a> ()</td></tr>
<tr class="separator:a25394328a49d42bb45b3b263009f02c7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68b71d64ca04789d1c6130320eaf22c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af68b71d64ca04789d1c6130320eaf22c">ha_reset_auto_increment</a> (ulonglong value)</td></tr>
<tr class="separator:af68b71d64ca04789d1c6130320eaf22c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a8a7650a41fd9a05a32521826ccd5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">ha_optimize</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a980a8a7650a41fd9a05a32521826ccd5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc9e4971b8e768c102398da0656a7f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">ha_analyze</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a66cc9e4971b8e768c102398da0656a7f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d5287bdf480f8cd20f758bb2d9bd1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">ha_check_and_repair</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:a169d5287bdf480f8cd20f758bb2d9bd1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb079b3dc59160ba828ef89b4463921 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">ha_disable_indexes</a> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:aeeb079b3dc59160ba828ef89b4463921 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9c53758728e07eb37cbb65ea3ab50 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">ha_enable_indexes</a> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a36e9c53758728e07eb37cbb65ea3ab50 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f75cf982985d21907140a17521cd6c5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1f75cf982985d21907140a17521cd6c5">ha_discard_or_import_tablespace</a> (my_bool discard)</td></tr>
<tr class="separator:a1f75cf982985d21907140a17521cd6c5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee228a60527e81efd9a49ddfdd4850d inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ee228a60527e81efd9a49ddfdd4850d">ha_rename_table</a> (const char *<a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a>, const char *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>)</td></tr>
<tr class="separator:a6ee228a60527e81efd9a49ddfdd4850d inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28700a3bf1af24f9a31ebae51bf877db inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a28700a3bf1af24f9a31ebae51bf877db">ha_delete_table</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a28700a3bf1af24f9a31ebae51bf877db inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcc37ec84386f5d6cc86448781666cb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">ha_drop_table</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a6bcc37ec84386f5d6cc86448781666cb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14af5825a427ba6baac74b13223637f8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a14af5825a427ba6baac74b13223637f8">ha_create</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="ha__innodb_8cc.html#ae64f1475e9ca79d24be2a8091b9cbdd7">form</a>, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a14af5825a427ba6baac74b13223637f8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722462d7e71059a8ed1f43d0fb28366b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a722462d7e71059a8ed1f43d0fb28366b">ha_create_handler_files</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a722462d7e71059a8ed1f43d0fb28366b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fb90782fea926f7a4450889d2d4a93 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5fb90782fea926f7a4450889d2d4a93">ha_change_partitions</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)</td></tr>
<tr class="separator:ab5fb90782fea926f7a4450889d2d4a93 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af575e947965117a3a200aec827b1a7c3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af575e947965117a3a200aec827b1a7c3">ha_drop_partitions</a> (const char *path)</td></tr>
<tr class="separator:af575e947965117a3a200aec827b1a7c3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624a8892433666df834a9b6ed6b8c2dd inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a624a8892433666df834a9b6ed6b8c2dd">ha_rename_partitions</a> (const char *path)</td></tr>
<tr class="separator:a624a8892433666df834a9b6ed6b8c2dd inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c090210fefb7e95d885688f5717028 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ad4c090210fefb7e95d885688f5717028"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_next_insert_id_after_explicit_value</b> (ulonglong nr)</td></tr>
<tr class="separator:ad4c090210fefb7e95d885688f5717028 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d2f9da11425e388640206b4d22241 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a8a7d2f9da11425e388640206b4d22241"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>update_auto_increment</b> ()</td></tr>
<tr class="separator:a8a7d2f9da11425e388640206b4d22241 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda4f1390385a4dc0bfd2981fee23e6c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">print_error</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, myf errflag)</td></tr>
<tr class="separator:afda4f1390385a4dc0bfd2981fee23e6c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eede0999f8273864faa40c5e181793 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">get_dup_key</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>)</td></tr>
<tr class="separator:ad5eede0999f8273864faa40c5e181793 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b117a976fc9423d2337da59f35d128c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a2b117a976fc9423d2337da59f35d128c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>change_table_ptr</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table_arg, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:a2b117a976fc9423d2337da59f35d128c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ac6b2908a899c0ce230818bb7a993 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time</a> (uint keynr, double <a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a>)</td></tr>
<tr class="separator:a4a2ac6b2908a899c0ce230818bb7a993 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d4ecfa5cfe85d8179aa52488016d0 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae73d4ecfa5cfe85d8179aa52488016d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_transactions</b> ()</td></tr>
<tr class="separator:ae73d4ecfa5cfe85d8179aa52488016d0 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fd434bc44b88f4e47f44f02c877c91 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a27fd434bc44b88f4e47f44f02c877c91"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>extra_rec_buf_length</b> () const</td></tr>
<tr class="separator:a27fd434bc44b88f4e47f44f02c877c91 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc56a8f3a2c01c127ad553fdf2a8c18 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1bc56a8f3a2c01c127ad553fdf2a8c18">is_fatal_error</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:a1bc56a8f3a2c01c127ad553fdf2a8c18 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c1bde4ae61f0aee31d241b0821369c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a> ()</td></tr>
<tr class="separator:a85c1bde4ae61f0aee31d241b0821369c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07">column_bitmaps_signal</a> ()</td></tr>
<tr class="memdesc:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL signal that it changed the column bitmap.  <a href="classhandler.html#a4de97045e5381007565fd2b0da235c07">More...</a><br /></td></tr>
<tr class="separator:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf0aed6539181d465676ebc661f2b5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aacdf0aed6539181d465676ebc661f2b5"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>get_index</b> (void) const</td></tr>
<tr class="separator:aacdf0aed6539181d465676ebc661f2b5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488245f51aa4676c872bb0564dbe71f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">start_bulk_update</a> ()</td></tr>
<tr class="separator:a7488245f51aa4676c872bb0564dbe71f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf7319a6498f655f8f07b1b34b12fc inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">start_bulk_delete</a> ()</td></tr>
<tr class="separator:acdaf7319a6498f655f8f07b1b34b12fc inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886bf2fbf16de7e200e3ebc0765fb6e4 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">exec_bulk_update</a> (uint *dup_key_found)</td></tr>
<tr class="separator:a886bf2fbf16de7e200e3ebc0765fb6e4 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6c46d66ca282a4cbd6118e4c99e03 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">end_bulk_update</a> ()</td></tr>
<tr class="separator:a2bf6c46d66ca282a4cbd6118e4c99e03 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f9f1ca2b5efc0b41e96c6b793d9bb1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">end_bulk_delete</a> ()</td></tr>
<tr class="separator:af5f9f1ca2b5efc0b41e96c6b793d9bb1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0d596ff3ddc77b4f0ad990c4c4cb4b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">read_range_first</a> (const <a class="el" href="structst__key__range.html">key_range</a> *start_key, const <a class="el" href="structst__key__range.html">key_range</a> *end_key, bool eq_range, bool sorted)</td></tr>
<tr class="memdesc:a3a0d596ff3ddc77b4f0ad990c4c4cb4b inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges. Store ranges for future calls to read_range_next.  <a href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">More...</a><br /></td></tr>
<tr class="separator:a3a0d596ff3ddc77b4f0ad990c4c4cb4b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4632aa56c9c66a57558f849f8e01271 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">read_range_next</a> ()</td></tr>
<tr class="memdesc:ae4632aa56c9c66a57558f849f8e01271 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">More...</a><br /></td></tr>
<tr class="separator:ae4632aa56c9c66a57558f849f8e01271 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7dfb95a0da2e828ac018aa2b4abe3a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">set_end_range</a> (const <a class="el" href="structst__key__range.html">key_range</a> *range, enum_range_scan_direction <a class="el" href="btr0btr_8cc.html#a942da44c6711d230377078633665e89b">direction</a>)</td></tr>
<tr class="separator:a4b7dfb95a0da2e828ac018aa2b4abe3a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef38e7407e87ba5d1ccde59c3e94bb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">compare_key</a> (<a class="el" href="structst__key__range.html">key_range</a> *range)</td></tr>
<tr class="separator:af0ef38e7407e87ba5d1ccde59c3e94bb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767345668267e3c8881fab6e351e6c8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab767345668267e3c8881fab6e351e6c8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compare_key_icp</b> (const <a class="el" href="structst__key__range.html">key_range</a> *range) const</td></tr>
<tr class="separator:ab767345668267e3c8881fab6e351e6c8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72693b6e25765a4290f531f578bcf2eb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a72693b6e25765a4290f531f578bcf2eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ft_end</b> ()</td></tr>
<tr class="separator:a72693b6e25765a4290f531f578bcf2eb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be2fa5d347252f8a28dce931654b76 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">rnd_pos_by_record</a> (uchar *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="separator:ac2be2fa5d347252f8a28dce931654b76 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50b704d53d715d6b0fd3534c6107d8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aff50b704d53d715d6b0fd3534c6107d8">read_first_row</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint primary_key)</td></tr>
<tr class="separator:aff50b704d53d715d6b0fd3534c6107d8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730672727f9ad989e80f3732eb838a10 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a730672727f9ad989e80f3732eb838a10">restart_rnd_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uchar *pos)</td></tr>
<tr class="separator:a730672727f9ad989e80f3732eb838a10 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590afc40dd01fb9fc387ef1d97370f41 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a590afc40dd01fb9fc387ef1d97370f41"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rnd_same</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint inx)</td></tr>
<tr class="separator:a590afc40dd01fb9fc387ef1d97370f41 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c3487f93880d33b4ef37b41c5c5fbb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a47c3487f93880d33b4ef37b41c5c5fbb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_dynamic_partition_info</b> (<a class="el" href="struct_p_a_r_t_i_t_i_o_n___s_t_a_t_s.html">PARTITION_STATS</a> *stat_info, uint part_id)</td></tr>
<tr class="separator:a47c3487f93880d33b4ef37b41c5c5fbb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e746c224b70d3b03b2886ecf4563394 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a7e746c224b70d3b03b2886ecf4563394"></a>
virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_key_hash_value</b> (<a class="el" href="class_field.html">Field</a> **field_array)</td></tr>
<tr class="separator:a7e746c224b70d3b03b2886ecf4563394 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e72da94a7f5577f00ab5c89204ec1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6b7e72da94a7f5577f00ab5c89204ec1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra_opt</b> (enum ha_extra_function operation, ulong cache_size)</td></tr>
<tr class="separator:a6b7e72da94a7f5577f00ab5c89204ec1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2428788c2437e4e33c4b390cc697f7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">start_read_removal</a> (void)</td></tr>
<tr class="separator:a3e2428788c2437e4e33c4b390cc697f7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517d99c283e85e8d97460f07a781dabf inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">end_read_removal</a> (void)</td></tr>
<tr class="separator:a517d99c283e85e8d97460f07a781dabf inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f9bf8ee63f3b8312fdc31be3819ede inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab6f9bf8ee63f3b8312fdc31be3819ede"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_next_insert_id</b> (ulonglong <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:ab6f9bf8ee63f3b8312fdc31be3819ede inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b51670b2497f01f19f587a4a969386 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a15b51670b2497f01f19f587a4a969386"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>restore_auto_increment</b> (ulonglong <a class="el" href="handler_8cc.html#ae9f796d8fbc7dc812557a17547b8e69e">prev_insert_id</a>)</td></tr>
<tr class="separator:a15b51670b2497f01f19f587a4a969386 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc92ca74cd6aca9a6070a186ced4cb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1abc92ca74cd6aca9a6070a186ced4cb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_old_types</b> ()</td></tr>
<tr class="separator:a1abc92ca74cd6aca9a6070a186ced4cb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b5fa7360fc536082f495ee7e09bcba inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab1b5fa7360fc536082f495ee7e09bcba"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>assign_to_keycache</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ab1b5fa7360fc536082f495ee7e09bcba inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061ab331631179647ccdbd71960ba37 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a0061ab331631179647ccdbd71960ba37"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>preload_keys</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a0061ab331631179647ccdbd71960ba37 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc45e93a1b669fa750f73a617c46bac inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a8bc45e93a1b669fa750f73a617c46bac"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>indexes_are_disabled</b> (void)</td></tr>
<tr class="separator:a8bc45e93a1b669fa750f73a617c46bac inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441afeebcb5b56e598fb7f860c9247d1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a441afeebcb5b56e598fb7f860c9247d1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>append_create_info</b> (<a class="el" href="class_string.html">String</a> *packet)</td></tr>
<tr class="separator:a441afeebcb5b56e598fb7f860c9247d1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda33331aacc500b1b974033cb64a869 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adda33331aacc500b1b974033cb64a869">is_fk_defined_on_table_or_index</a> (uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:adda33331aacc500b1b974033cb64a869 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a347e66418fe35a07f24900bcbdce82 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a8a347e66418fe35a07f24900bcbdce82"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>get_default_no_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a8a347e66418fe35a07f24900bcbdce82 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4512d49169a2766f5c5b4896a9691c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="abc4512d49169a2766f5c5b4896a9691c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_auto_partitions</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info)</td></tr>
<tr class="separator:abc4512d49169a2766f5c5b4896a9691c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cad9d951b59dd0b705e6861dc489e7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab3cad9d951b59dd0b705e6861dc489e7">get_no_parts</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, uint *no_parts)</td></tr>
<tr class="separator:ab3cad9d951b59dd0b705e6861dc489e7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46ea4bb55add228a28b24d748426aa2 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aa46ea4bb55add228a28b24d748426aa2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_part_info</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info, bool early)</td></tr>
<tr class="separator:aa46ea4bb55add228a28b24d748426aa2 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9c5a03956913d75de1fca3af7833a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a7ee9c5a03956913d75de1fca3af7833a"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_record_length</b> () const</td></tr>
<tr class="separator:a7ee9c5a03956913d75de1fca3af7833a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493c1ac62569e6cc89cbfde66fea47f3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a493c1ac62569e6cc89cbfde66fea47f3"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_keys</b> () const</td></tr>
<tr class="separator:a493c1ac62569e6cc89cbfde66fea47f3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adabba96b635533f31d5e38e6d2a74c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1adabba96b635533f31d5e38e6d2a74c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_parts</b> () const</td></tr>
<tr class="separator:a1adabba96b635533f31d5e38e6d2a74c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b1d6fe7e717fe234c18915cb26e87 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9e1b1d6fe7e717fe234c18915cb26e87"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_length</b> () const</td></tr>
<tr class="separator:a9e1b1d6fe7e717fe234c18915cb26e87 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa0c2a89e52a27667973c1d5074dca7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a4fa0c2a89e52a27667973c1d5074dca7"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_part_length</b> () const</td></tr>
<tr class="separator:a4fa0c2a89e52a27667973c1d5074dca7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a498859c2d47448100e5e703622bb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a672a498859c2d47448100e5e703622bb"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_record_length</b> () const</td></tr>
<tr class="separator:a672a498859c2d47448100e5e703622bb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d5b6de2843435371dc9045403e3d07 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a25d5b6de2843435371dc9045403e3d07"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_parts</b> () const</td></tr>
<tr class="separator:a25d5b6de2843435371dc9045403e3d07 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082d2a49764e8548b8104dc514877b3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab082d2a49764e8548b8104dc514877b3"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>min_record_length</b> (uint options) const</td></tr>
<tr class="separator:ab082d2a49764e8548b8104dc514877b3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a20da13aaa177f1a256e5fb63e7c78 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a64a20da13aaa177f1a256e5fb63e7c78"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>low_byte_first</b> () const</td></tr>
<tr class="separator:a64a20da13aaa177f1a256e5fb63e7c78 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf438c8ef657577f61612ebe2e1c95a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6cf438c8ef657577f61612ebe2e1c95a"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>checksum</b> () const</td></tr>
<tr class="separator:a6cf438c8ef657577f61612ebe2e1c95a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea4b726707284210cc365ad454add03 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6ea4b726707284210cc365ad454add03"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_crashed</b> () const</td></tr>
<tr class="separator:a6ea4b726707284210cc365ad454add03 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca08387779d587f8d3ea84b965ddc391 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aca08387779d587f8d3ea84b965ddc391"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>auto_repair</b> () const</td></tr>
<tr class="separator:aca08387779d587f8d3ea84b965ddc391 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2447668275a831bcf73b5c00818254a6 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count</a> (void) const</td></tr>
<tr class="separator:a2447668275a831bcf73b5c00818254a6 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e765264bd31e0519e03e1bd53d8c6d2 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">cond_push</a> (const <a class="el" href="class_item.html">Item</a> *cond)</td></tr>
<tr class="separator:a5e765264bd31e0519e03e1bd53d8c6d2 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eb8d2966b848ec4beea5a25cba9dea inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">cond_pop</a> ()</td></tr>
<tr class="separator:ac3eb8d2966b848ec4beea5a25cba9dea inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc6ba204aa4d1bacc35d9d1d75ab15 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">cancel_pushed_idx_cond</a> ()</td></tr>
<tr class="separator:a41cc6ba204aa4d1bacc35d9d1d75ab15 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86930bf10b20ad19b3df07e07d28116e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a86930bf10b20ad19b3df07e07d28116e">number_of_pushed_joins</a> () const</td></tr>
<tr class="separator:a86930bf10b20ad19b3df07e07d28116e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f6946109f48559e92a9e7c1b86517 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a624f6946109f48559e92a9e7c1b86517">root_of_pushed_join</a> () const</td></tr>
<tr class="separator:a624f6946109f48559e92a9e7c1b86517 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef865015edc575d0a50d1a6f5b13e4a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaef865015edc575d0a50d1a6f5b13e4a">parent_of_pushed_join</a> () const</td></tr>
<tr class="separator:aaef865015edc575d0a50d1a6f5b13e4a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38213f889f5312cd3e452fc34d11a201 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a38213f889f5312cd3e452fc34d11a201"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_pushed</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a38213f889f5312cd3e452fc34d11a201 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f56e97f4fb1faebbc23145492bf541d inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a5f56e97f4fb1faebbc23145492bf541d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_next_pushed</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a5f56e97f4fb1faebbc23145492bf541d inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecf7f9bf265e6801b625768f0f2bbe inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad0ecf7f9bf265e6801b625768f0f2bbe">ha_prepare_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:ad0ecf7f9bf265e6801b625768f0f2bbe inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b182710a133be9561afc149cb6aa8f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a96b182710a133be9561afc149cb6aa8f">ha_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a96b182710a133be9561afc149cb6aa8f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec170a4aa71186f9dc17358b55587c7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ec170a4aa71186f9dc17358b55587c7">ha_commit_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:a6ec170a4aa71186f9dc17358b55587c7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b81b74b0b7b87de4f99ebe20c49dc44 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5b81b74b0b7b87de4f99ebe20c49dc44">ha_notify_table_changed</a> ()</td></tr>
<tr class="separator:a5b81b74b0b7b87de4f99ebe20c49dc44 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key</a> ()</td></tr>
<tr class="memdesc:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f" title="use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY...">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key  <a href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">More...</a><br /></td></tr>
<tr class="separator:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923f2b845012582b5a343b5ede6129c1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a923f2b845012582b5a343b5ede6129c1"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>alter_table_flags</b> (uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:a923f2b845012582b5a343b5ede6129c1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd7e44bc71120ace1e467ccb02ad06 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:ac8dd7e44bc71120ace1e467ccb02ad06 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24fcaab09a75e81702c2e2c34fa0b62 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">delete_all_rows</a> ()</td></tr>
<tr class="separator:ac24fcaab09a75e81702c2e2c34fa0b62 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c1378edb4813d141f666ce2b9382a4 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ac9c1378edb4813d141f666ce2b9382a4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_and_repair</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ac9c1378edb4813d141f666ce2b9382a4 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272e3a0622ad461a5a86c74ddb9289c6 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a272e3a0622ad461a5a86c74ddb9289c6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>disable_indexes</b> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a272e3a0622ad461a5a86c74ddb9289c6 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22328b49eac2417561360bd00bbe8299 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a22328b49eac2417561360bd00bbe8299"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>enable_indexes</b> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a22328b49eac2417561360bd00bbe8299 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d474cf912188a562e9f419872031e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ac61d474cf912188a562e9f419872031e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>drop_table</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ac61d474cf912188a562e9f419872031e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741fbc5479d9ee0ccca766f3eca3703f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a741fbc5479d9ee0ccca766f3eca3703f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="ha__innodb_8cc.html#ae64f1475e9ca79d24be2a8091b9cbdd7">form</a>, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)=0</td></tr>
<tr class="separator:a741fbc5479d9ee0ccca766f3eca3703f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fe1bf5cf87a258787ca67a2add8bd1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a75fe1bf5cf87a258787ca67a2add8bd1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create_handler_files</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a75fe1bf5cf87a258787ca67a2add8bd1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be47bbed1ce6bf15d11f786f1a7476c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a5be47bbed1ce6bf15d11f786f1a7476c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>change_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)</td></tr>
<tr class="separator:a5be47bbed1ce6bf15d11f786f1a7476c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed6471578e35fab41d3d623df55e686 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a4ed6471578e35fab41d3d623df55e686"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>drop_partitions</b> (const char *path)</td></tr>
<tr class="separator:a4ed6471578e35fab41d3d623df55e686 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579edf594ce51cd019654a790ff5ca64 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a579edf594ce51cd019654a790ff5ca64"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rename_partitions</b> (const char *path)</td></tr>
<tr class="separator:a579edf594ce51cd019654a790ff5ca64 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae370a0f787c1b936e475a5762b91350c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae370a0f787c1b936e475a5762b91350c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_ha_share_ref</b> (<a class="el" href="class_handler__share.html">Handler_share</a> **arg_ha_share)</td></tr>
<tr class="separator:ae370a0f787c1b936e475a5762b91350c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a271a4a135d110cf6f22ae8ce664664 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6a271a4a135d110cf6f22ae8ce664664"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_lock_type</b> () const</td></tr>
<tr class="separator:a6a271a4a135d110cf6f22ae8ce664664 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aebb522f7dbcfdc14f5c155c3444b1e8d"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aebb522f7dbcfdc14f5c155c3444b1e8d">get_mysql_bin_log_name</a> ()</td></tr>
<tr class="separator:aebb522f7dbcfdc14f5c155c3444b1e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6cc241a1fc1609eda33a6db4c96e2a"><td class="memItemLeft" align="right" valign="top">static ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a0c6cc241a1fc1609eda33a6db4c96e2a">get_mysql_bin_log_pos</a> ()</td></tr>
<tr class="separator:a0c6cc241a1fc1609eda33a6db4c96e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_sql__alloc"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_sql__alloc')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_sql__alloc.html">Sql_alloc</a></td></tr>
<tr class="memitem:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a193100cab44074df6f4f1507b333dcda"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)  throw ()</td></tr>
<tr class="separator:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a14b17bd7ec22fc7a7e5b56702e5630a6"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)  throw ()</td></tr>
<tr class="separator:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a13f2eacbb6adcee5c9ac94629e2863b3"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)  throw ()</td></tr>
<tr class="separator:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a06adbd3404f702994fd10619c41267f0"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)  throw ()</td></tr>
<tr class="separator:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a1e428ed5b826482a49b1d8a1d246a579"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a7c08622003a34134a56eccaf2d95c0b9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="ab0c7ed4b5a1eb798f3af463eb84b1e3b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a6dd86b56cecc3919504cf5e1452f2511"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0f862aa6099e9e60f999dc17085f0494"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a0f862aa6099e9e60f999dc17085f0494">store_key_val_for_row</a> (uint keynr, char *buff, uint buff_len, const uchar *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="separator:a0f862aa6099e9e60f999dc17085f0494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518cf241b927b988de6bc474c8b4643b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a518cf241b927b988de6bc474c8b4643b">update_thd</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:a518cf241b927b988de6bc474c8b4643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eccb7dd13ca5bf52a55fe853ce8886d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a9eccb7dd13ca5bf52a55fe853ce8886d">update_thd</a> ()</td></tr>
<tr class="separator:a9eccb7dd13ca5bf52a55fe853ce8886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee86ce04780977e2324e80f7e0778fc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aee86ce04780977e2324e80f7e0778fc6">change_active_index</a> (uint keynr)</td></tr>
<tr class="separator:aee86ce04780977e2324e80f7e0778fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd97c9e165033ff755f5fb27c4e6880"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a8cd97c9e165033ff755f5fb27c4e6880">general_fetch</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint <a class="el" href="btr0btr_8cc.html#a942da44c6711d230377078633665e89b">direction</a>, uint match_mode)</td></tr>
<tr class="separator:a8cd97c9e165033ff755f5fb27c4e6880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400fcd617ee4b48d7ebf5912327044bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a400fcd617ee4b48d7ebf5912327044bd">innobase_lock_autoinc</a> ()</td></tr>
<tr class="separator:a400fcd617ee4b48d7ebf5912327044bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd1728a40bbe81bb67bdb48f3f1ed48"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a3dd1728a40bbe81bb67bdb48f3f1ed48">innobase_peek_autoinc</a> ()</td></tr>
<tr class="separator:a3dd1728a40bbe81bb67bdb48f3f1ed48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d3c1079d9b43c53818325869511c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a73d3c1079d9b43c53818325869511c7e">innobase_set_max_autoinc</a> (ulonglong auto_inc)</td></tr>
<tr class="separator:a73d3c1079d9b43c53818325869511c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082fe8faf3f491d6074316a338a4a2f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a082fe8faf3f491d6074316a338a4a2f4">innobase_reset_autoinc</a> (ulonglong auto_inc)</td></tr>
<tr class="separator:a082fe8faf3f491d6074316a338a4a2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2735eb712eb5e8f266e8e2721276cbb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a2735eb712eb5e8f266e8e2721276cbb8">innobase_get_autoinc</a> (ulonglong *value)</td></tr>
<tr class="separator:a2735eb712eb5e8f266e8e2721276cbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e95c7cbdf023565b070e278217967d"><td class="memItemLeft" align="right" valign="top"><a id="a57e95c7cbdf023565b070e278217967d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>innobase_initialize_autoinc</b> ()</td></tr>
<tr class="separator:a57e95c7cbdf023565b070e278217967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489b87e8913357771cc9922932718b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a489b87e8913357771cc9922932718b9f">innobase_get_index</a> (uint keynr)</td></tr>
<tr class="separator:a489b87e8913357771cc9922932718b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c3afa2be783339e4998eaaf812e5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae2c3afa2be783339e4998eaaf812e5c2">build_template</a> (bool whole_row)</td></tr>
<tr class="separator:ae2c3afa2be783339e4998eaaf812e5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa288074a103562d391f66ddb87e9329b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#aa288074a103562d391f66ddb87e9329b">reset_template</a> ()</td></tr>
<tr class="separator:aa288074a103562d391f66ddb87e9329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386c923a87de679b81cc5c400e78681d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a386c923a87de679b81cc5c400e78681d">info_low</a> (uint, bool)</td></tr>
<tr class="separator:a386c923a87de679b81cc5c400e78681d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a05ded39281413b23e00758533069cbc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a05ded39281413b23e00758533069cbc5">prebuilt</a></td></tr>
<tr class="separator:a05ded39281413b23e00758533069cbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5951077a66c00be186c75834067c8a"><td class="memItemLeft" align="right" valign="top">THD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#acf5951077a66c00be186c75834067c8a">user_thd</a></td></tr>
<tr class="separator:acf5951077a66c00be186c75834067c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc67caa50a6b2b6f6f51b532a318125"><td class="memItemLeft" align="right" valign="top"><a id="a0cc67caa50a6b2b6f6f51b532a318125"></a>
<a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lock</b></td></tr>
<tr class="separator:a0cc67caa50a6b2b6f6f51b532a318125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498a8ac1f1ddd1aba325eea02a536297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__innobase__share.html">INNOBASE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a498a8ac1f1ddd1aba325eea02a536297">share</a></td></tr>
<tr class="separator:a498a8ac1f1ddd1aba325eea02a536297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f37946e8eb555e06ee03cb5b413f337"><td class="memItemLeft" align="right" valign="top">uchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a4f37946e8eb555e06ee03cb5b413f337">upd_buf</a></td></tr>
<tr class="separator:a4f37946e8eb555e06ee03cb5b413f337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3001f41ab9d5fce56a3476ed657e23f"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af3001f41ab9d5fce56a3476ed657e23f">upd_buf_size</a></td></tr>
<tr class="separator:af3001f41ab9d5fce56a3476ed657e23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682c1d23f2a41d05628d9028767c1153"><td class="memItemLeft" align="right" valign="top"><a id="a682c1d23f2a41d05628d9028767c1153"></a>
Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>int_table_flags</b></td></tr>
<tr class="separator:a682c1d23f2a41d05628d9028767c1153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0a9a1d637eb24ef7d125fe1d5c7eb4"><td class="memItemLeft" align="right" valign="top"><a id="a6a0a9a1d637eb24ef7d125fe1d5c7eb4"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>primary_key</b></td></tr>
<tr class="separator:a6a0a9a1d637eb24ef7d125fe1d5c7eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87cf8a6eac817fb2c579118cf179f09"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ac87cf8a6eac817fb2c579118cf179f09">start_of_scan</a></td></tr>
<tr class="separator:ac87cf8a6eac817fb2c579118cf179f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2002ecd962161d4a8ecaf54ee4fd038"><td class="memItemLeft" align="right" valign="top"><a id="ac2002ecd962161d4a8ecaf54ee4fd038"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>last_match_mode</b></td></tr>
<tr class="separator:ac2002ecd962161d4a8ecaf54ee4fd038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeade7014188c7e403cdcb45fafb2c4"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a6eeade7014188c7e403cdcb45fafb2c4">num_write_row</a></td></tr>
<tr class="separator:a6eeade7014188c7e403cdcb45fafb2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Multi Range Read interface @{</h2></td></tr>
<tr class="memitem:a9868d8254aeebf2283682fa5b8a3f1ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ds_mrr__impl.html">DsMrr_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a9868d8254aeebf2283682fa5b8a3f1ab">ds_mrr</a></td></tr>
<tr class="separator:a9868d8254aeebf2283682fa5b8a3f1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4517bdf2708a81551d540e9ab7efe6de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a4517bdf2708a81551d540e9ab7efe6de">multi_range_read_init</a> (<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, <a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a4517bdf2708a81551d540e9ab7efe6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b6c417a1a9dbb3d27a3edd278549b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#af6b6c417a1a9dbb3d27a3edd278549b6">multi_range_read_next</a> (char **range_info)</td></tr>
<tr class="separator:af6b6c417a1a9dbb3d27a3edd278549b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d81f0569084ce9b0de1c986e09046b3"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a7d81f0569084ce9b0de1c986e09046b3">multi_range_read_info_const</a> (uint keyno, <a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint *bufsz, uint *<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_cost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:a7d81f0569084ce9b0de1c986e09046b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086247f18e144c81c2719164c8775c58"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#a086247f18e144c81c2719164c8775c58">multi_range_read_info</a> (uint keyno, uint n_ranges, uint keys, uint *bufsz, uint *<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_cost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:a086247f18e144c81c2719164c8775c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b9900547917e786cccfc4af25bd689"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__innobase.html#ae7b9900547917e786cccfc4af25bd689">idx_cond_push</a> (uint keyno, class <a class="el" href="class_item.html">Item</a> *idx_cond)</td></tr>
<tr class="separator:ae7b9900547917e786cccfc4af25bd689"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:ab5b14b11876fb5ac53a4cc7aceea6a2d inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab5b14b11876fb5ac53a4cc7aceea6a2d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>enum_range_scan_direction</b> { <b>RANGE_SCAN_ASC</b>, 
<b>RANGE_SCAN_DESC</b>
 }</td></tr>
<tr class="separator:ab5b14b11876fb5ac53a4cc7aceea6a2d inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17118f023ca8fc0db852fc578206c4fe inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a17118f023ca8fc0db852fc578206c4fe"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NONE</b> =0, 
<b>INDEX</b>, 
<b>RND</b>
 }</td></tr>
<tr class="separator:a17118f023ca8fc0db852fc578206c4fe inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67af5473a36655c922682399d4c5b6ec inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a67af5473a36655c922682399d4c5b6ec"></a>
typedef ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>Table_flags</b></td></tr>
<tr class="separator:a67af5473a36655c922682399d4c5b6ec inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a395bae75af9e51a116097a788b2cf57f inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a395bae75af9e51a116097a788b2cf57f"></a>
<a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ht</b></td></tr>
<tr class="separator:a395bae75af9e51a116097a788b2cf57f inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c7037216007ba6140e6cff5162024d inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a53c7037216007ba6140e6cff5162024d"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>ref</b></td></tr>
<tr class="separator:a53c7037216007ba6140e6cff5162024d inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501dc41ecb010069e8bc9d035aae6aa inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a7501dc41ecb010069e8bc9d035aae6aa"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>dup_ref</b></td></tr>
<tr class="separator:a7501dc41ecb010069e8bc9d035aae6aa inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df561df4b2b6552a7b42189feb0400a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1df561df4b2b6552a7b42189feb0400a"></a>
<a class="el" href="classha__statistics.html">ha_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stats</b></td></tr>
<tr class="separator:a1df561df4b2b6552a7b42189feb0400a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec520eba79eb9f182c534e82c60ebc6 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9ec520eba79eb9f182c534e82c60ebc6"></a>
range_seq_t&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_iter</b></td></tr>
<tr class="separator:a9ec520eba79eb9f182c534e82c60ebc6 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51e423645829d3e540c109556931fa inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a2a51e423645829d3e540c109556931fa"></a>
<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_funcs</b></td></tr>
<tr class="separator:a2a51e423645829d3e540c109556931fa inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52372127bd238a7f622190316ba8124f inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a52372127bd238a7f622190316ba8124f"></a>
<a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>multi_range_buffer</b></td></tr>
<tr class="separator:a52372127bd238a7f622190316ba8124f inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a476dfe8526807dfc820c4b09f7a6d1 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1a476dfe8526807dfc820c4b09f7a6d1"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>ranges_in_seq</b></td></tr>
<tr class="separator:a1a476dfe8526807dfc820c4b09f7a6d1 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff4dfb21c4583b55afc4fe5aba50389 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="adff4dfb21c4583b55afc4fe5aba50389"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_is_output_sorted</b></td></tr>
<tr class="separator:adff4dfb21c4583b55afc4fe5aba50389 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2632d137c3a17fa583f08db5681e80a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="af2632d137c3a17fa583f08db5681e80a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_have_range</b></td></tr>
<tr class="separator:af2632d137c3a17fa583f08db5681e80a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2347edc229832e533d1fb73b236e32b inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="af2347edc229832e533d1fb73b236e32b"></a>
<a class="el" href="structst__key__multi__range.html">KEY_MULTI_RANGE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_cur_range</b></td></tr>
<tr class="separator:af2347edc229832e533d1fb73b236e32b inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d698fe9901f0f487c9618ddbb0f1be inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a28d698fe9901f0f487c9618ddbb0f1be"></a>
<a class="el" href="structst__key__range.html">key_range</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>end_range</b></td></tr>
<tr class="separator:a28d698fe9901f0f487c9618ddbb0f1be inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186b7c7a70634a8e9758ed51708359c inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3186b7c7a70634a8e9758ed51708359c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>errkey</b></td></tr>
<tr class="separator:a3186b7c7a70634a8e9758ed51708359c inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5efc62f32ef66b55667fd8370ef33 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a5ad5efc62f32ef66b55667fd8370ef33"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>key_used_on_scan</b></td></tr>
<tr class="separator:a5ad5efc62f32ef66b55667fd8370ef33 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f2838eebffef46663c19f85d2ad2cc inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a29f2838eebffef46663c19f85d2ad2cc"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>active_index</b></td></tr>
<tr class="separator:a29f2838eebffef46663c19f85d2ad2cc inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64def328ff0ca7e391b217c2d3a758ec inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a></td></tr>
<tr class="separator:a64def328ff0ca7e391b217c2d3a758ec inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943005f89e7a6d5cee246e1c5b46e9ab inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a943005f89e7a6d5cee246e1c5b46e9ab"></a>
<a class="el" href="structst__ft__info.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_handler</b></td></tr>
<tr class="separator:a943005f89e7a6d5cee246e1c5b46e9ab inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745f5757f7d7d690fb30ea7df8f08d43 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a745f5757f7d7d690fb30ea7df8f08d43"></a>
enum handler:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>inited</b></td></tr>
<tr class="separator:a745f5757f7d7d690fb30ea7df8f08d43 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd47d68a7b406d8777396a657095d5e8 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="afd47d68a7b406d8777396a657095d5e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>implicit_emptied</b></td></tr>
<tr class="separator:afd47d68a7b406d8777396a657095d5e8 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2f8d7155cb44162bb4181cb09f2f3 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a0ed2f8d7155cb44162bb4181cb09f2f3"></a>
const <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_cond</b></td></tr>
<tr class="separator:a0ed2f8d7155cb44162bb4181cb09f2f3 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3d956f73649657bad389acfad5f0b inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae9b3d956f73649657bad389acfad5f0b"></a>
<a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond</b></td></tr>
<tr class="separator:ae9b3d956f73649657bad389acfad5f0b inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc8d81143d1c9c10b976711fe44cf37 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a4dc8d81143d1c9c10b976711fe44cf37"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond_keyno</b></td></tr>
<tr class="separator:a4dc8d81143d1c9c10b976711fe44cf37 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ab295e407d8a5c50087fed0f4fcd18 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a></td></tr>
<tr class="separator:a62ab295e407d8a5c50087fed0f4fcd18 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd2cafd83ae60562649bf9688aebf1 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a></td></tr>
<tr class="separator:a05dd2cafd83ae60562649bf9688aebf1 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1540a47a05c03724f1102aaaa623131e inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_discrete__interval.html">Discrete_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">auto_inc_interval_for_cur_row</a></td></tr>
<tr class="separator:a1540a47a05c03724f1102aaaa623131e inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfcef0738a89138c8f41ded8da17c0a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a></td></tr>
<tr class="separator:acdfcef0738a89138c8f41ded8da17c0a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e7cba3fe3bf9731a91be82983cc35 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">PSI_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a></td></tr>
<tr class="separator:a881e7cba3fe3bf9731a91be82983cc35 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:af8c2b258691e5baac8dd22d19c084b37 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">index_read_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="memdesc:af8c2b258691e5baac8dd22d19c084b37 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">More...</a><br /></td></tr>
<tr class="separator:af8c2b258691e5baac8dd22d19c084b37 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0c549a00023dd44682cd9452cf830 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">index_read_idx_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="memdesc:acba0c549a00023dd44682cd9452cf830 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="classhandler.html#acba0c549a00023dd44682cd9452cf830">More...</a><br /></td></tr>
<tr class="separator:acba0c549a00023dd44682cd9452cf830 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae069d5991214e1fdf14cc44fd865a180 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">index_read_last_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="memdesc:ae069d5991214e1fdf14cc44fd865a180 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">More...</a><br /></td></tr>
<tr class="separator:ae069d5991214e1fdf14cc44fd865a180 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aaaf2105e60ca590b79fae82e48960 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed</a> ()</td></tr>
<tr class="separator:a26aaaf2105e60ca590b79fae82e48960 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25b44b50ac64192d6cfef591252ed7 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aad25b44b50ac64192d6cfef591252ed7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_statistic_increment</b> (ulonglong SSV::*<a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>) const</td></tr>
<tr class="separator:aad25b44b50ac64192d6cfef591252ed7 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57260c07a7ed5d6522a02d473e8ceb1d inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a57260c07a7ed5d6522a02d473e8ceb1d"></a>
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ha_data</b> (THD *) const</td></tr>
<tr class="separator:a57260c07a7ed5d6522a02d473e8ceb1d inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df65ee64bcedb5a4b34bf752b2fab08 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9df65ee64bcedb5a4b34bf752b2fab08"></a>
THD *&#160;</td><td class="memItemRight" valign="bottom"><b>ha_thd</b> (void) const</td></tr>
<tr class="separator:a9df65ee64bcedb5a4b34bf752b2fab08 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69803cd29d92bfecd97212354212c516 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">PSI_table_share *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a69803cd29d92bfecd97212354212c516">ha_table_share_psi</a> (const <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share) const</td></tr>
<tr class="separator:a69803cd29d92bfecd97212354212c516 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf21a8ad4be872bbfe94f5cb40abca inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_handler__share.html">Handler_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">get_ha_share_ptr</a> ()</td></tr>
<tr class="separator:a13bf21a8ad4be872bbfe94f5cb40abca inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24470ac1d4ac336cedbe7c245d321c9 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">set_ha_share_ptr</a> (<a class="el" href="class_handler__share.html">Handler_share</a> *arg_ha_share)</td></tr>
<tr class="separator:ab24470ac1d4ac336cedbe7c245d321c9 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a39db9dc1cca31f4a3ec0e0e1d7300 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">lock_shared_ha_data</a> ()</td></tr>
<tr class="separator:aa3a39db9dc1cca31f4a3ec0e0e1d7300 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059bbed3de416b3bea51c69dc064e79 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">unlock_shared_ha_data</a> ()</td></tr>
<tr class="separator:a8059bbed3de416b3bea51c69dc064e79 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classhandler')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a3b094cfe680aa06a7d8b70194415aa3b inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3b094cfe680aa06a7d8b70194415aa3b"></a>
<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table_share</b></td></tr>
<tr class="separator:a3b094cfe680aa06a7d8b70194415aa3b inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0d051d1ef534891b27612cc4ff56f7 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="abb0d051d1ef534891b27612cc4ff56f7"></a>
<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table</b></td></tr>
<tr class="separator:abb0d051d1ef534891b27612cc4ff56f7 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98743b18a24c8baef7e22a11df74d6c9 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a98743b18a24c8baef7e22a11df74d6c9"></a>
Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>cached_table_flags</b></td></tr>
<tr class="separator:a98743b18a24c8baef7e22a11df74d6c9 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44b6a4c101f982cd13a344dce5a870 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="adf44b6a4c101f982cd13a344dce5a870"></a>
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>estimation_rows_to_insert</b></td></tr>
<tr class="separator:adf44b6a4c101f982cd13a344dce5a870 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011df14ecc738037499572c304d8ee90 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a011df14ecc738037499572c304d8ee90"></a>
<a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>range_key_part</b></td></tr>
<tr class="separator:a011df14ecc738037499572c304d8ee90 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272c3d9b40a9e7c5de20ed390d23a636 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a272c3d9b40a9e7c5de20ed390d23a636"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>eq_range</b></td></tr>
<tr class="separator:a272c3d9b40a9e7c5de20ed390d23a636 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a159ca294d8dafe32405e6ad546e6a4 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1a159ca294d8dafe32405e6ad546e6a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>in_range_check_pushed_down</b></td></tr>
<tr class="separator:a1a159ca294d8dafe32405e6ad546e6a4 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class defining a handle to an Innodb table </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a64cbd796fd4bf42cab7d28c2c0e09564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cbd796fd4bf42cab7d28c2c0e09564">&#9670;&nbsp;</a></span>ha_innobase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ha_innobase::ha_innobase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>hton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct <a class="el" href="classha__innobase.html">ha_innobase</a> handler. </p>

</div>
</div>
<a id="afd31ce1c2179ed2677ff036de0633913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd31ce1c2179ed2677ff036de0633913">&#9670;&nbsp;</a></span>~ha_innobase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ha_innobase::~ha_innobase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destruct <a class="el" href="classha__innobase.html">ha_innobase</a> handler. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ac86762c99c97898e7d184a2dcaa385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac86762c99c97898e7d184a2dcaa385">&#9670;&nbsp;</a></span>analyze()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::analyze </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates index cardinalities of the table, based on random dives into each index tree. This does NOT calculate exact statistics on the table. </p><dl class="section return"><dt>Returns</dt><dd>HA_ADMIN_* error code or HA_ADMIN_OK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: connection thread handle </td></tr>
    <tr><td class="paramname">check_opt</td><td>in: currently ignored </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a678fe7a653db9708db5a37e49af65e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678fe7a653db9708db5a37e49af65e75">&#9670;&nbsp;</a></span>bas_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char ** ha_innobase::bas_ext </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the table file name extension. </p><dl class="section return"><dt>Returns</dt><dd>file extension string </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">handler</a>.</p>

</div>
</div>
<a id="ae2c3afa2be783339e4998eaaf812e5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c3afa2be783339e4998eaaf812e5c2">&#9670;&nbsp;</a></span>build_template()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::build_template </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>whole_row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds a 'template' to the prebuilt struct.</p>
<p>The template is used in fast retrieval of just those column values MySQL needs in its processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whole_row</td><td>true if access is needed to a whole row, false if accessing individual fields is enough</td></tr>
  </table>
  </dd>
</dl>
<p>Builds a 'template' to the prebuilt struct. The template is used in fast retrieval of just those column values MySQL needs in its processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whole_row</td><td>in: true=ROW_MYSQL_WHOLE_ROW, false=ROW_MYSQL_REC_FIELDS </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd3165bcb0f9f9d6902fb11e6bac1da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3165bcb0f9f9d6902fb11e6bac1da8">&#9670;&nbsp;</a></span>can_switch_engines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool ha_innobase::can_switch_engines </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> may change the storage engine of the table. Changing storage engines is not allowed for tables for which there are foreign key constraints (parent or child tables). </p><dl class="section return"><dt>Returns</dt><dd>TRUE if can switch engines </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">handler</a>.</p>

</div>
</div>
<a id="aee86ce04780977e2324e80f7e0778fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee86ce04780977e2324e80f7e0778fc6">&#9670;&nbsp;</a></span>change_active_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::change_active_index </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Changes the active index of a handle. </p><dl class="section return"><dt>Returns</dt><dd>0 or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>in: use this index; MAX_KEY means always clustered index, even if it was internally generated by InnoDB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c5eefd497c817f7e3a0d8c52458efe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5eefd497c817f7e3a0d8c52458efe6">&#9670;&nbsp;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::check </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to check that an InnoDB table is not corrupted. If corruption is noticed, prints to stderr information about it. In case of corruption may also assert a failure and crash the server. </p><dl class="section return"><dt>Returns</dt><dd>HA_ADMIN_CORRUPT or HA_ADMIN_OK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: user thread handle </td></tr>
    <tr><td class="paramname">check_opt</td><td>in: check options </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="aaeb2efbc261d05d135f2c3761eacdbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb2efbc261d05d135f2c3761eacdbe9">&#9670;&nbsp;</a></span>check_if_incompatible_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool ha_innobase::check_if_incompatible_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Part of old, deprecated in-place ALTER API. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">handler</a>.</p>

</div>
</div>
<a id="a2e45aaeee263279fdfdc1b57c82ce020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e45aaeee263279fdfdc1b57c82ce020">&#9670;&nbsp;</a></span>check_if_supported_inplace_alter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_alter_inplace_result ha_innobase::check_if_supported_inplace_alter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>On-line ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> interface </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="handler0alter_8cc.html">handler0alter.cc</a> <a class="el" href="struct_check.html">Check</a> if InnoDB supports <a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a> particular alter <a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a> in-place </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ALTER_INPLACE_NOT_SUPPORTED</td><td>Not supported </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK</td><td>Supported </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE</td><td>Supported, but requires lock during main phase and exclusive lock during prepare phase. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE</td><td>Supported, prepare phase requires exclusive lock. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">handler</a>.</p>

</div>
</div>
<a id="a401cda4e42cc0b9fcba2bc30668a7a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401cda4e42cc0b9fcba2bc30668a7a03">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="classhandler.html">handler</a> * ha_innobase::clone </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__mem__root.html">MEM_ROOT</a> *&#160;</td>
          <td class="paramname"><em>mem_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name </td></tr>
    <tr><td class="paramname">mem_root</td><td>in: memory context </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a5377253148c95f8c9d8c21ab4bd2fc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5377253148c95f8c9d8c21ab4bd2fc9b">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes a handle to an InnoDB table. </p><dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="ada20e8c05d828321f457df68be4bc7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada20e8c05d828321f457df68be4bc7bd">&#9670;&nbsp;</a></span>cmp_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::cmp_ref </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>ref1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>ref2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares two 'refs'. A 'ref' is the (internal) primary key value of the row. If there is no explicitly declared non-null unique key or a primary key, then InnoDB internally uses the row id as the primary key. </p><dl class="section return"><dt>Returns</dt><dd>&lt; 0 if ref1 &lt; ref2, 0 if equal, else &gt; 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref1</td><td>in: an (internal) primary key value in the MySQL key value format </td></tr>
    <tr><td class="paramname">ref2</td><td>in: an (internal) primary key value in the MySQL key value format </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="ab181db6334fe348fd1571ee862cee747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab181db6334fe348fd1571ee862cee747">&#9670;&nbsp;</a></span>commit_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_innobase::commit_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Commit or rollback the changes made during <a class="el" href="classha__innobase.html#a143df4f5250198dcc51fc256d5f6e33b">prepare_inplace_alter_table()</a> and <a class="el" href="classha__innobase.html#a6500b207c94934efcad46386b2425a66">inplace_alter_table()</a> inside the storage engine. Note that the allowed level of concurrency during this operation will be the same as for <a class="el" href="classha__innobase.html#a6500b207c94934efcad46386b2425a66">inplace_alter_table()</a> and thus might be higher than during <a class="el" href="classha__innobase.html#a143df4f5250198dcc51fc256d5f6e33b">prepare_inplace_alter_table()</a>. (E.g concurrent writes were blocked during prepare, but might not be during commit). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">commit</td><td>true =&gt; Commit, false =&gt; Rollback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Failure </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">handler</a>.</p>

</div>
</div>
<a id="a31ecdd68f467ec7a3785cb782c9e128d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ecdd68f467ec7a3785cb782c9e128d">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">register <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new table to an InnoDB database. </p><dl class="section return"><dt>Returns</dt><dd>error number </dd></dl>

</div>
</div>
<a id="a249d241a7445cb297f253f297730f8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249d241a7445cb297f253f297730f8ee">&#9670;&nbsp;</a></span>delete_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::delete_row </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a row given as the parameter. </p><dl class="section return"><dt>Returns</dt><dd>error number or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>in: a row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9ec3c69d0250c2ef1b1c5c5bd61153d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ec3c69d0250c2ef1b1c5c5bd61153d">&#9670;&nbsp;</a></span>delete_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Drops a table from an InnoDB database. Before calling this function, MySQL calls innobase_commit to commit the transaction of the current user. Then the current user cannot have locks set on the table. Drop table operation inside InnoDB will remove all locks any user has on the table inside InnoDB. </p><dl class="section return"><dt>Returns</dt><dd>error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">handler</a>.</p>

</div>
</div>
<a id="a8c84c4a207ad95ed5d715661c604ae26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c84c4a207ad95ed5d715661c604ae26">&#9670;&nbsp;</a></span>discard_or_import_tablespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::discard_or_import_tablespace </td>
          <td>(</td>
          <td class="paramtype">my_bool&#160;</td>
          <td class="paramname"><em>discard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Discards or imports an InnoDB tablespace. </p><dl class="section return"><dt>Returns</dt><dd>0 == success, -1 == error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discard</td><td>in: TRUE if discard, else import </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a747831324f241471b06cb9db6cc4908d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747831324f241471b06cb9db6cc4908d">&#9670;&nbsp;</a></span>estimate_rows_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ha_rows ha_innobase::estimate_rows_upper_bound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gives an UPPER BOUND to the number of rows in a table. This is used in <a class="el" href="filesort_8cc.html" title="Sorts a database. ">filesort.cc</a>. </p><dl class="section return"><dt>Returns</dt><dd>upper bound of rows </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">handler</a>.</p>

</div>
</div>
<a id="ac97491497626f54845bba1539e0c1ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97491497626f54845bba1539e0c1ec7">&#9670;&nbsp;</a></span>external_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::external_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As MySQL will execute an external lock for every new table it uses when it starts to process an SQL statement (an exception is when MySQL calls start_stmt for the handle) we can use this function to store the pointer to the THD in the handle. We will also use this function to communicate to InnoDB that a new SQL statement has started and that we must store a savepoint to our transaction handle, so that we are able to roll back the SQL statement in case of an error. </p><dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: handle to the user thread </td></tr>
    <tr><td class="paramname">lock_type</td><td>in: lock type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48a8e8c82b63bb51e96caac9e65e7ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a8e8c82b63bb51e96caac9e65e7ba3">&#9670;&nbsp;</a></span>extra()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::extra </td>
          <td>(</td>
          <td class="paramtype">enum ha_extra_function&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tells something additional to the handler about how to do things. </p><dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>in: HA_EXTRA_FLUSH or some other flag </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="aa7775bc549ac945b58b9151dd24f77b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7775bc549ac945b58b9151dd24f77b8">&#9670;&nbsp;</a></span>free_foreign_key_create_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::free_foreign_key_create_info </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees the foreign key create info for a table stored in InnoDB, if it is non-NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in, own: create info string to free </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a3bfd4d887e03cb00e09254a4bb17debc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfd4d887e03cb00e09254a4bb17debc">&#9670;&nbsp;</a></span>ft_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::ft_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize FT index scan </p><dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a3f63c971df342b417d2f52256ff9c55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f63c971df342b417d2f52256ff9c55d">&#9670;&nbsp;</a></span>ft_init_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structst__ft__info.html">FT_INFO</a> * ha_innobase::ft_init_ext </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize FT index scan </p><dl class="section return"><dt>Returns</dt><dd>FT_INFO structure if successful or NULL </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a82de5f1b81a59879d5f3f3c27710e366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82de5f1b81a59879d5f3f3c27710e366">&#9670;&nbsp;</a></span>ft_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::ft_read </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fetch next result from the FT result set </p><dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buf contain result row </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a8cd97c9e165033ff755f5fb27c4e6880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd97c9e165033ff755f5fb27c4e6880">&#9670;&nbsp;</a></span>general_fetch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::general_fetch </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>match_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the next or previous row from a cursor, which must have previously been positioned using index_read. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for next row in MySQL format </td></tr>
    <tr><td class="paramname">direction</td><td>in: ROW_SEL_NEXT or ROW_SEL_PREV </td></tr>
    <tr><td class="paramname">match_mode</td><td>in: 0, ROW_SEL_EXACT, or ROW_SEL_EXACT_PREFIX </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d1226df999937e02ca1c1b0653e1a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1226df999937e02ca1c1b0653e1a3e">&#9670;&nbsp;</a></span>get_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::get_auto_increment </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>nb_desired_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>first_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>nb_reserved_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the auto-inc counter in *first_value and ~0 on failure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>in: table autoinc offset </td></tr>
    <tr><td class="paramname">increment</td><td>in: table autoinc increment </td></tr>
    <tr><td class="paramname">nb_desired_values</td><td>in: number of values reqd </td></tr>
    <tr><td class="paramname">first_value</td><td>out: the autoinc value </td></tr>
    <tr><td class="paramname">nb_reserved_values</td><td>out: count of reserved values </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">handler</a>.</p>

</div>
</div>
<a id="afc4392eb1ca708975a460d244fdb9e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4392eb1ca708975a460d244fdb9e77">&#9670;&nbsp;</a></span>get_error_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool ha_innobase::get_error_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See comment in <a class="el" href="handler_8cc.html" title="Handler-calling-functions. ">handler.cc</a> </p>

<p>Reimplemented from <a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">handler</a>.</p>

</div>
</div>
<a id="a53715acaa5441a53f0758ed900648760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53715acaa5441a53f0758ed900648760">&#9670;&nbsp;</a></span>get_foreign_dup_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_innobase::get_foreign_dup_key </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>child_table_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_key_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>child_key_name_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the names of the table and the key for which there was a duplicate entry in the case of HA_ERR_FOREIGN_DUPLICATE_KEY.</p>
<p>If any of the names is not available, then this method will return false and will not change any of child_table_name or child_key_name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_table_name[out]</td><td>Table name </td></tr>
    <tr><td class="paramname">child_table_name_len[in]</td><td>Table name buffer size </td></tr>
    <tr><td class="paramname">child_key_name[out]</td><td><a class="el" href="class_key.html">Key</a> name </td></tr>
    <tr><td class="paramname">child_key_name_len[in]</td><td><a class="el" href="class_key.html">Key</a> name buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>table and key names were available and were written into the corresponding out parameters. </td></tr>
    <tr><td class="paramname">false</td><td>table and key names were not available, the out parameters were not touched. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a20878b1fb8d31b91dbf53ac963d90f78">handler</a>.</p>

</div>
</div>
<a id="aee4bef829362895e69f4b018cb411f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4bef829362895e69f4b018cb411f2e">&#9670;&nbsp;</a></span>get_foreign_key_create_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char * ha_innobase::get_foreign_key_create_info </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the foreign key create info for a table stored in InnoDB. </p><dl class="section return"><dt>Returns</dt><dd>own: character string in the form which can be inserted to the CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> statement, MUST be freed with <a class="el" href="classha__innobase.html#aa7775bc549ac945b58b9151dd24f77b8">ha_innobase::free_foreign_key_create_info</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a115f5e0b70a59aaec2fbefced8b7faa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115f5e0b70a59aaec2fbefced8b7faa4">&#9670;&nbsp;</a></span>get_foreign_key_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::get_foreign_key_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the list of foreign keys in this table. </p><dl class="section return"><dt>Returns</dt><dd>always 0, that is, always succeeds </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: user thread handle </td></tr>
    <tr><td class="paramname">f_key_list</td><td>out: foreign key list </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a81064e61d4c08261af409fb6ee34e3ca">handler</a>.</p>

</div>
</div>
<a id="a8faf78c3052b9adeec8eb41b8f23ad71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faf78c3052b9adeec8eb41b8f23ad71">&#9670;&nbsp;</a></span>get_memory_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN longlong ha_innobase::get_memory_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the size of the InnoDB memory buffer. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a475f7fbe39f6ff0e9da2ac6c3d6c629e">handler</a>.</p>

</div>
</div>
<a id="aebb522f7dbcfdc14f5c155c3444b1e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb522f7dbcfdc14f5c155c3444b1e8d">&#9670;&nbsp;</a></span>get_mysql_bin_log_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char * ha_innobase::get_mysql_bin_log_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the bin log name. </p>

</div>
</div>
<a id="a0c6cc241a1fc1609eda33a6db4c96e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6cc241a1fc1609eda33a6db4c96e2a">&#9670;&nbsp;</a></span>get_mysql_bin_log_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulonglong ha_innobase::get_mysql_bin_log_pos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the bin log offset (or file position). </p>

</div>
</div>
<a id="a58fbf47cb6215228269a97efd5f50592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fbf47cb6215228269a97efd5f50592">&#9670;&nbsp;</a></span>get_parent_foreign_key_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::get_parent_foreign_key_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the set of foreign keys where this table is the referenced table. </p><dl class="section return"><dt>Returns</dt><dd>always 0, that is, always succeeds </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: user thread handle </td></tr>
    <tr><td class="paramname">f_key_list</td><td>out: foreign key list </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a9187eea9999eba802ee4ae01f91dda3b">handler</a>.</p>

</div>
</div>
<a id="a40a3a299ed63452b5b99c27126cfb07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a3a299ed63452b5b99c27126cfb07e">&#9670;&nbsp;</a></span>get_row_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN enum row_type ha_innobase::get_row_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>InnoDB database tables Get the record format from the data dictionary. </p><dl class="section return"><dt>Returns</dt><dd>one of ROW_TYPE_REDUNDANT, ROW_TYPE_COMPACT, ROW_TYPE_COMPRESSED, ROW_TYPE_DYNAMIC </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a163a360c0cd4575ae207553b8d5c918d">handler</a>.</p>

</div>
</div>
<a id="ae7b9900547917e786cccfc4af25bd689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b9900547917e786cccfc4af25bd689">&#9670;&nbsp;</a></span>idx_cond_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN class <a class="el" href="class_item.html">Item</a> * ha_innobase::idx_cond_push </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>idx_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to push down an index condition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyno</td><td>MySQL key number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_cond</td><td>Index condition to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>idx_cond if pushed; NULL if not pushed</dd></dl>
<p>Attempt to push down an index condition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyno</td><td>MySQL key number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx_cond</td><td>Index condition to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Part of idx_cond which the handler will not evaluate </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">handler</a>.</p>

</div>
</div>
<a id="a191905c0a48f411f3a250f665a54d48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191905c0a48f411f3a250f665a54d48e">&#9670;&nbsp;</a></span>index_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Currently does nothing. </p><dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a3d74e0604e1891a2e69cb014a96f1d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d74e0604e1891a2e69cb014a96f1d76">&#9670;&nbsp;</a></span>index_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_first </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Positions a cursor on the first record in an index and reads the corresponding row to buf. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the row </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af37bd518c53c966459632584c34855d0">handler</a>.</p>

</div>
</div>
<a id="af9d94a2fa52bcdb95fa43d671076e5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d94a2fa52bcdb95fa43d671076e5b0">&#9670;&nbsp;</a></span>index_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulong ha_innobase::index_flags </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the operations supported for indexes. </p><dl class="section return"><dt>Returns</dt><dd>flags of supported operations </dd></dl>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="ae7ede2b59a30025b97e35614b8008631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ede2b59a30025b97e35614b8008631">&#9670;&nbsp;</a></span>index_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_init </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a handle to use an index. </p><dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>in: key (index) number </td></tr>
    <tr><td class="paramname">sorted</td><td>in: 1 if result MUST be sorted according to index </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a0585621f565a14ca13e3655a89a1914c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0585621f565a14ca13e3655a89a1914c">&#9670;&nbsp;</a></span>index_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_last </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Positions a cursor on the last record in an index and reads the corresponding row to buf. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the row </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">handler</a>.</p>

</div>
</div>
<a id="a60518f2b2bfdba02649ebcf5f3ca2545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60518f2b2bfdba02649ebcf5f3ca2545">&#9670;&nbsp;</a></span>index_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the next row from a cursor, which must have previously been positioned using index_read. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for next row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">handler</a>.</p>

</div>
</div>
<a id="a6ed9c3e4225dd57c685db7916da272b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed9c3e4225dd57c685db7916da272b6">&#9670;&nbsp;</a></span>index_next_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_next_same </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the next row matching to the key value given as the parameter. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the row </td></tr>
    <tr><td class="paramname">key</td><td>in: key value </td></tr>
    <tr><td class="paramname">keylen</td><td>in: key value length </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">handler</a>.</p>

</div>
</div>
<a id="a11b40809d4ce6883294fceb9f9c7a8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b40809d4ce6883294fceb9f9c7a8fc">&#9670;&nbsp;</a></span>index_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_prev </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the previous row from a cursor, which must have previously been positioned using index_read. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for previous row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">handler</a>.</p>

</div>
</div>
<a id="a136fcf0b707eb71d6c58b9d299cf347f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136fcf0b707eb71d6c58b9d299cf347f">&#9670;&nbsp;</a></span>index_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_read </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Positions an index cursor to the index specified in the handle. Fetches the row if any. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_KEY_NOT_FOUND, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the returned row </td></tr>
    <tr><td class="paramname">key_ptr</td><td>in: key value; if this is NULL we position the cursor at the start or end of index; this can also contain an InnoDB row id, in which case key_len is the InnoDB row id length; the key value can also be a prefix of a full key value, and the last column can be a prefix of a full column </td></tr>
    <tr><td class="paramname">key_len</td><td>in: key value length </td></tr>
    <tr><td class="paramname">find_flag</td><td>in: search flags from <a class="el" href="my__base_8h_source.html">my_base.h</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a136fb4fe1294684ecd00afff33064d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136fb4fe1294684ecd00afff33064d06">&#9670;&nbsp;</a></span>index_read_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_read_idx </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Positions an index cursor to the index specified in keynr. Fetches the row if any. ??? This is only used to read whole keys ??? </p><dl class="section return"><dt>Returns</dt><dd>error number or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the returned row </td></tr>
    <tr><td class="paramname">keynr</td><td>in: use this index </td></tr>
    <tr><td class="paramname">key</td><td>in: key value; if this is NULL we position the cursor at the start or end of index </td></tr>
    <tr><td class="paramname">key_len</td><td>in: key value length </td></tr>
    <tr><td class="paramname">find_flag</td><td>in: search flags from <a class="el" href="my__base_8h_source.html">my_base.h</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0729db8f95a01df92d6a4ac0a9986af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0729db8f95a01df92d6a4ac0a9986af">&#9670;&nbsp;</a></span>index_read_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::index_read_last </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following functions works like index_read, but it find the last row with the current key value or prefix. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_KEY_NOT_FOUND, or an error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: fetched row </td></tr>
    <tr><td class="paramname">key_ptr</td><td>in: key value, or a prefix of a full key value </td></tr>
    <tr><td class="paramname">key_len</td><td>in: length of the key val or prefix in bytes </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a381d429e7e607873a361166ac1ce965c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381d429e7e607873a361166ac1ce965c">&#9670;&nbsp;</a></span>index_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char * ha_innobase::index_type </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the index type. </p><dl class="section return"><dt>Returns</dt><dd>index type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>: index number </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a943220a0de85c62db4ad846ec0ba88ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943220a0de85c62db4ad846ec0ba88ab">&#9670;&nbsp;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::info </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns statistics information of the table to the MySQL interpreter, in various fields of the handle object. </p><dl class="section return"><dt>Returns</dt><dd>HA_ERR_* error code or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>in: what information is requested </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a386c923a87de679b81cc5c400e78681d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386c923a87de679b81cc5c400e78681d">&#9670;&nbsp;</a></span>info_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::info_low </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_analyze</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns statistics information of the table to the MySQL interpreter, in various fields of the handle object. </p><dl class="section return"><dt>Returns</dt><dd>HA_ERR_* error code or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>in: what information is requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e8653e736d0ddaf3fc11a4d2bcbf93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8653e736d0ddaf3fc11a4d2bcbf93f">&#9670;&nbsp;</a></span>init_table_handle_for_HANDLER()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::init_table_handle_for_HANDLER </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this when you have opened a new table handle in HANDLER, before you call <a class="el" href="classha__innobase.html#a136fb4fe1294684ecd00afff33064d06">index_read_idx()</a> etc. Actually, we can let the cursor stay open even over a transaction commit! Then you should call this before every operation, fetch next etc. This function inits the necessary things even after a transaction commit. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a2735eb712eb5e8f266e8e2721276cbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2735eb712eb5e8f266e8e2721276cbb8">&#9670;&nbsp;</a></span>innobase_get_autoinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ha_innobase::innobase_get_autoinc </td>
          <td>(</td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the next autoinc value. Acquire the relevant locks before reading the AUTOINC value. If SUCCESS then the table AUTOINC mutex will be locked on return and all relevant locks acquired. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>out: autoinc value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a489b87e8913357771cc9922932718b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489b87e8913357771cc9922932718b9f">&#9670;&nbsp;</a></span>innobase_get_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a> * ha_innobase::innobase_get_index </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the index for a handle. Does not change active index. </p><dl class="section return"><dt>Returns</dt><dd>NULL or index instance. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>in: use this index; MAX_KEY means always clustered index, even if it was internally generated by InnoDB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a400fcd617ee4b48d7ebf5912327044bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400fcd617ee4b48d7ebf5912327044bd">&#9670;&nbsp;</a></span>innobase_lock_autoinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ha_innobase::innobase_lock_autoinc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This special handling is really to overcome the limitations of MySQL's binlogging. We need to eliminate the non-determinism that will arise in INSERT ... SELECT type of statements, since MySQL binlog only stores the min value of the autoinc interval. Once that is fixed we can get rid of the special lock handling. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK else error code </dd></dl>

</div>
</div>
<a id="a3dd1728a40bbe81bb67bdb48f3f1ed48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd1728a40bbe81bb67bdb48f3f1ed48">&#9670;&nbsp;</a></span>innobase_peek_autoinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulonglong ha_innobase::innobase_peek_autoinc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function reads the global auto-inc counter. It doesn't use the AUTOINC lock even if the lock mode is set to TRADITIONAL. </p><dl class="section return"><dt>Returns</dt><dd>the autoinc value </dd></dl>

</div>
</div>
<a id="a082fe8faf3f491d6074316a338a4a2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082fe8faf3f491d6074316a338a4a2f4">&#9670;&nbsp;</a></span>innobase_reset_autoinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ha_innobase::innobase_reset_autoinc </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>autoinc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the autoinc value in the table. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all went well else error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoinc</td><td>in: value to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73d3c1079d9b43c53818325869511c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d3c1079d9b43c53818325869511c7e">&#9670;&nbsp;</a></span>innobase_set_max_autoinc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ha_innobase::innobase_set_max_autoinc </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>auto_inc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the autoinc value in the table. The autoinc value is only set if it's greater than the existing autoinc value in the table. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all went well else error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auto_inc</td><td>in: value to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6500b207c94934efcad46386b2425a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6500b207c94934efcad46386b2425a66">&#9670;&nbsp;</a></span>inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_innobase::inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and Alter_inplace_information. The level of concurrency allowed during this operation depends on the return value from <a class="el" href="classha__innobase.html#a2e45aaeee263279fdfdc1b57c82ce020">check_if_supported_inplace_alter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Failure </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">handler</a>.</p>

</div>
</div>
<a id="a3b442f6b0804f0bb034583298661d8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b442f6b0804f0bb034583298661d8e4">&#9670;&nbsp;</a></span>keys_to_use_for_scanning()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> * ha_innobase::keys_to_use_for_scanning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the key map of keys that are usable for scanning. </p><dl class="section return"><dt>Returns</dt><dd>key_map_full </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a51cfa4634931c1e60095b24fc3252cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cfa4634931c1e60095b24fc3252cd9">&#9670;&nbsp;</a></span>max_supported_key_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN uint ha_innobase::max_supported_key_length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum key length. </p><dl class="section return"><dt>Returns</dt><dd>maximum supported key length, in bytes </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a11f734e94ccb05d3d69c681f7d72eeab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f734e94ccb05d3d69c681f7d72eeab">&#9670;&nbsp;</a></span>max_supported_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN uint ha_innobase::max_supported_keys </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum number of keys. </p><dl class="section return"><dt>Returns</dt><dd>MAX_KEY </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a086247f18e144c81c2719164c8775c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086247f18e144c81c2719164c8775c58">&#9670;&nbsp;</a></span>multi_range_read_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows ha_innobase::multi_range_read_info </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize multi range read and get information. </p><dl class="section see"><dt>See also</dt><dd>DsMrr_impl::dsmrr_info </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td></td></tr>
    <tr><td class="paramname">seq</td><td></td></tr>
    <tr><td class="paramname">seq_init_param</td><td></td></tr>
    <tr><td class="paramname">n_ranges</td><td></td></tr>
    <tr><td class="paramname">bufsz</td><td></td></tr>
    <tr><td class="paramname">flags</td><td></td></tr>
    <tr><td class="paramname">cost</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">handler</a>.</p>

</div>
</div>
<a id="a7d81f0569084ce9b0de1c986e09046b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d81f0569084ce9b0de1c986e09046b3">&#9670;&nbsp;</a></span>multi_range_read_info_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows ha_innobase::multi_range_read_info_const </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize multi range read and get information. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__myisam.html#ae4f3c7421685089c3887e24b2cf7e32b">ha_myisam::multi_range_read_info_const</a> </dd>
<dd>
DsMrr_impl::dsmrr_info_const </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td></td></tr>
    <tr><td class="paramname">seq</td><td></td></tr>
    <tr><td class="paramname">seq_init_param</td><td></td></tr>
    <tr><td class="paramname">n_ranges</td><td></td></tr>
    <tr><td class="paramname">bufsz</td><td></td></tr>
    <tr><td class="paramname">flags</td><td></td></tr>
    <tr><td class="paramname">cost</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">handler</a>.</p>

</div>
</div>
<a id="a4517bdf2708a81551d540e9ab7efe6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4517bdf2708a81551d540e9ab7efe6de">&#9670;&nbsp;</a></span>multi_range_read_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::multi_range_read_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize multi range read </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ds_mrr__impl.html#ade7283d68a19de82fd19ad836ac10506">DsMrr_impl::dsmrr_init</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td></td></tr>
    <tr><td class="paramname">seq_init_param</td><td></td></tr>
    <tr><td class="paramname">n_ranges</td><td></td></tr>
    <tr><td class="paramname">mode</td><td></td></tr>
    <tr><td class="paramname">buf</td><td>Multi Range Read interface, DS-MRR calls </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">handler</a>.</p>

</div>
</div>
<a id="af6b6c417a1a9dbb3d27a3edd278549b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b6c417a1a9dbb3d27a3edd278549b6">&#9670;&nbsp;</a></span>multi_range_read_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_innobase::multi_range_read_next </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Process next multi range read </p><dl class="section see"><dt>See also</dt><dd>DsMrr_impl::dsmrr_next </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_info</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">handler</a>.</p>

</div>
</div>
<a id="a705d0c97e01255009d0c97ba80ba3f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705d0c97e01255009d0c97ba80ba3f85">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>test_if_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and opens a handle to a table which already exists in an InnoDB database. </p><dl class="section return"><dt>Returns</dt><dd>1 if error, 0 if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name </td></tr>
    <tr><td class="paramname">mode</td><td>in: not used </td></tr>
    <tr><td class="paramname">test_if_locked</td><td>in: not used </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a9692c4de7d2593fdb398aefe9ff668e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9692c4de7d2593fdb398aefe9ff668e5">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::optimize </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is mapped to "ALTER TABLE tablename ENGINE=InnoDB", which rebuilds the table in MySQL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: connection thread handle </td></tr>
    <tr><td class="paramname">check_opt</td><td>in: currently ignored </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a0fe6b85680a474f4cc10b7ebd1a9ce47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe6b85680a474f4cc10b7ebd1a9ce47">&#9670;&nbsp;</a></span>parse_table_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::parse_table_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>norm_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>temp_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>remote_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the table name into normal name and either temp path or remote path if needed. </p><dl class="section return"><dt>Returns</dt><dd>0 if successful, otherwise, error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in/out: table name provided </td></tr>
    <tr><td class="paramname">create_info</td><td>in: more information of the created table, contains also the create statement string </td></tr>
    <tr><td class="paramname">flags</td><td>in: flags </td></tr>
    <tr><td class="paramname">flags2</td><td>in: flags2 </td></tr>
    <tr><td class="paramname">norm_name</td><td>out: normalized table name </td></tr>
    <tr><td class="paramname">temp_path</td><td>out: absolute path of table </td></tr>
    <tr><td class="paramname">remote_path</td><td>out: remote path of table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2a2c6b04ebbd71da3c9406bfc461e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a2c6b04ebbd71da3c9406bfc461e3d">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::position </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a reference to the current row to 'ref' field of the handle. Note that in the case where we have generated the clustered index for the table, the function parameter is illogical: we MUST ASSUME that 'record' is the current 'position' of the handle, because if row ref is actually the row id internally generated in InnoDB, then 'record' does not contain it. We just guess that the row id must be for the record where the handle was positioned the last time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>in: row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a143df4f5250198dcc51fc256d5f6e33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143df4f5250198dcc51fc256d5f6e33b">&#9670;&nbsp;</a></span>prepare_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_innobase::prepare_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows InnoDB to update internal structures with concurrent writes blocked (provided that <a class="el" href="classha__innobase.html#a2e45aaeee263279fdfdc1b57c82ce020">check_if_supported_inplace_alter()</a> did not return HA_ALTER_INPLACE_NO_LOCK). This will be invoked before <a class="el" href="classha__innobase.html#a6500b207c94934efcad46386b2425a66">inplace_alter_table()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Failure </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">handler</a>.</p>

</div>
</div>
<a id="a7cffddf7092f925a3d4af2268cafd8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cffddf7092f925a3d4af2268cafd8a6">&#9670;&nbsp;</a></span>primary_key_is_clustered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool ha_innobase::primary_key_is_clustered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if the primary key is clustered index. </p><dl class="section return"><dt>Returns</dt><dd>true </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a4fe974cf972531fadb046018db76614e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe974cf972531fadb046018db76614e">&#9670;&nbsp;</a></span>read_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN double ha_innobase::read_time </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the time it takes to read a set of ranges through an index This enables us to optimise reads for clustered indexes. </p><dl class="section return"><dt>Returns</dt><dd>estimated time measured in disk seeks </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: key number </td></tr>
    <tr><td class="paramname">ranges</td><td>in: how many ranges </td></tr>
    <tr><td class="paramname">rows</td><td>in: estimated number of rows in the ranges </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">handler</a>.</p>

</div>
</div>
<a id="a10e47491716ea977e4d74714983801c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e47491716ea977e4d74714983801c3">&#9670;&nbsp;</a></span>records_in_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ha_rows ha_innobase::records_in_range </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__key__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>min_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__key__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>max_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimates the number of index records in a range. </p><dl class="section return"><dt>Returns</dt><dd>estimated number of rows </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>in: index number </td></tr>
    <tr><td class="paramname">min_key</td><td>in: start key value of the range, may also be 0 </td></tr>
    <tr><td class="paramname">max_key</td><td>in: range end key val, may also be 0 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a9fcc2977ea644e085e6b9e503913d783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcc2977ea644e085e6b9e503913d783">&#9670;&nbsp;</a></span>referenced_by_foreign_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN uint ha_innobase::referenced_by_foreign_key </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a table is referenced by a foreign key. The MySQL manual states that a REPLACE is either equivalent to an INSERT, or DELETE(s) + INSERT. Only a delete is then allowed internally to resolve a duplicate key conflict in REPLACE, not an update. </p><dl class="section return"><dt>Returns</dt><dd>&gt; 0 if referenced by a FOREIGN KEY </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a8935c26cd1541f91e30786806a347f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8935c26cd1541f91e30786806a347f0a">&#9670;&nbsp;</a></span>register_query_cache_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN my_bool ha_innobase::register_query_cache_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qc_engine_callback *&#160;</td>
          <td class="paramname"><em>call_back</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>engine_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ask InnoDB if a query to a table can be cached. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if query caching of the table is permitted </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: user thread handle </td></tr>
    <tr><td class="paramname">table_key</td><td>in: normalized path to the table </td></tr>
    <tr><td class="paramname">key_length</td><td>in: length of the normalized path to the table </td></tr>
    <tr><td class="paramname">call_back</td><td>out: pointer to function for checking if query caching is permitted </td></tr>
    <tr><td class="paramname">engine_data</td><td>in/out: data to call_back </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a2ec87bfd95b71d14fafbb3f88569094f">handler</a>.</p>

</div>
</div>
<a id="abf4cb28dc4dac919ba8182b7cb176781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4cb28dc4dac919ba8182b7cb176781">&#9670;&nbsp;</a></span>rename_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Renames an InnoDB table. </p><dl class="section return"><dt>Returns</dt><dd>0 or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>in: old name of the table </td></tr>
    <tr><td class="paramname">to</td><td>in: new name of the table </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">handler</a>.</p>

</div>
</div>
<a id="a52efc99d1f7cf9d97312ff95ad6c96fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52efc99d1f7cf9d97312ff95ad6c96fb">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset state of file to after 'open'. This function is called after every statement for all tables used by that statement. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a1161c615e45f4bd9c285a0e3c1e332af">handler</a>.</p>

</div>
</div>
<a id="a8418ce7f1d1353c685fc93b88f16c1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8418ce7f1d1353c685fc93b88f16c1d2">&#9670;&nbsp;</a></span>reset_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::reset_auto_increment </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the auto-increment counter to the given value, i.e. the next row inserted will get the given value. This is called e.g. after TRUNCATE is emulated by doing a 'DELETE FROM t'. HA_ERR_WRONG_COMMAND is returned by storage engines that don't support this operation. </p><dl class="section return"><dt>Returns</dt><dd>0 or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>in: new value for table autoinc </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a27e343a6e97ad5264e1fe5a70659899f">handler</a>.</p>

</div>
</div>
<a id="aa288074a103562d391f66ddb87e9329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa288074a103562d391f66ddb87e9329b">&#9670;&nbsp;</a></span>reset_template()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_innobase::reset_template </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets a query execution 'template'. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__innobase.html#ae2c3afa2be783339e4998eaaf812e5c2">build_template()</a></dd></dl>
<p>Resets some fields of a prebuilt struct. The template is used in fast retrieval of just those column values MySQL needs in its processing. </p>

</div>
</div>
<a id="a98c8f18dc5a8d094d818099107a0fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c8f18dc5a8d094d818099107a0fcd2">&#9670;&nbsp;</a></span>rnd_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::rnd_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ends a table scan. </p><dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="ad399dbc2e6b9cfcf788993d1bc6fb666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad399dbc2e6b9cfcf788993d1bc6fb666">&#9670;&nbsp;</a></span>rnd_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::rnd_init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize a table scan. </p><dl class="section return"><dt>Returns</dt><dd>0 or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>in: TRUE if table/index scan FALSE otherwise </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#a9ddfc5530e45a9340e2de99626085da6">handler</a>.</p>

</div>
</div>
<a id="a5dec515b9c0632116153a9990f980cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dec515b9c0632116153a9990f980cf9">&#9670;&nbsp;</a></span>rnd_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::rnd_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the next row in a table scan (also used to read the FIRST row in a table scan). </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_END_OF_FILE, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: returns the row in this buffer, in MySQL format </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">handler</a>.</p>

</div>
</div>
<a id="a77ac165a69160c94dd25349674fff74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ac165a69160c94dd25349674fff74c">&#9670;&nbsp;</a></span>rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::rnd_pos </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fetches a row from the table based on a row reference. </p><dl class="section return"><dt>Returns</dt><dd>0, HA_ERR_KEY_NOT_FOUND, or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer for the row </td></tr>
    <tr><td class="paramname">pos</td><td>in: primary key value of the row in the MySQL format, or the row id if the clustered index was internally generated by InnoDB; the length of data in pos has to be ref_length </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">handler</a>.</p>

</div>
</div>
<a id="a144d4357ed15c4af18092a88e5ab55db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144d4357ed15c4af18092a88e5ab55db">&#9670;&nbsp;</a></span>scan_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN double ha_innobase::scan_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>How many seeks it will take to read through the table. This is to be comparable to the number returned by records_in_range so that we can decide if we should scan the table or use keys. </p><dl class="section return"><dt>Returns</dt><dd>estimated time measured in disk seeks </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a6e2653367f5003185e9df77992f4a80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2653367f5003185e9df77992f4a80e">&#9670;&nbsp;</a></span>start_stmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::start_stmt </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>MySQL calls this function at the start of each SQL statement inside LOCK TABLES. Inside LOCK TABLES the ::external_lock method does not work to mark SQL statement borders. Note also a special case: if a temporary table is created inside LOCK TABLES, MySQL has not called <a class="el" href="classha__innobase.html#ac97491497626f54845bba1539e0c1ec7">external_lock()</a> at all on that table. MySQL-5.0 also calls this before each statement in an execution of a stored procedure. To make the execution more deterministic for binlogging, MySQL-5.0 locks all tables involved in a stored procedure with full explicit table locks (thd_in_lock_tables(thd) holds in <a class="el" href="classha__innobase.html#ab5a9779dfd5b55feb0888a7381661f74">store_lock()</a>) before executing the procedure. </p><dl class="section return"><dt>Returns</dt><dd>0 or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: handle to the user thread </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a0f862aa6099e9e60f999dc17085f0494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f862aa6099e9e60f999dc17085f0494">&#9670;&nbsp;</a></span>store_key_val_for_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN uint ha_innobase::store_key_val_for_row </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>buff_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a key value for a row to a buffer. </p><dl class="section return"><dt>Returns</dt><dd>key value length as stored in buff </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>in: key number </td></tr>
    <tr><td class="paramname">buff</td><td>in/out: buffer for the key value (in MySQL format) </td></tr>
    <tr><td class="paramname">buff_len</td><td>in: buffer length </td></tr>
    <tr><td class="paramname">record</td><td>in: row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5a9779dfd5b55feb0888a7381661f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a9779dfd5b55feb0888a7381661f74">&#9670;&nbsp;</a></span>store_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> ** ha_innobase::store_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a MySQL table lock stored in the 'lock' field of the handle to a proper type before storing pointer to the lock into an array of pointers. MySQL also calls this if it wants to reset some table locks to a not-locked state during the processing of an SQL query. An example is that during a SELECT the read lock is released early on the 'const' tables where we only fetch one row. MySQL does not call this when it releases all locks at the end of an SQL statement. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the next element in the 'to' array </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: user thread handle </td></tr>
    <tr><td class="paramname">to</td><td>in: pointer to an array of pointers to lock structs; pointer to the 'lock' field of current handle is stored next to this array </td></tr>
    <tr><td class="paramname">lock_type</td><td>in: lock type to store in 'lock'; this may also be TL_IGNORE </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">handler</a>.</p>

</div>
</div>
<a id="ae0634d10e89122642d9278dd195bc7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0634d10e89122642d9278dd195bc7ea">&#9670;&nbsp;</a></span>table_cache_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN uint8 ha_innobase::table_cache_type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if table caching is supported. </p><dl class="section return"><dt>Returns</dt><dd>HA_CACHE_TBL_ASKTRANSACT </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">handler</a>.</p>

</div>
</div>
<a id="af6d695a97ee1acee5dfd857d777e49fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d695a97ee1acee5dfd857d777e49fc">&#9670;&nbsp;</a></span>table_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN handler::Table_flags ha_innobase::table_flags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the table flags to use for the statement. </p><dl class="section return"><dt>Returns</dt><dd>table flags </dd></dl>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a37c66a5e6163f68403c8fd0adb796607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c66a5e6163f68403c8fd0adb796607">&#9670;&nbsp;</a></span>table_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char * ha_innobase::table_type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the table type (storage engine name). </p><dl class="section return"><dt>Returns</dt><dd>table type </dd></dl>

<p>Implements <a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">handler</a>.</p>

</div>
</div>
<a id="a5f0cc1d1c6fe6adca293d598924adcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0cc1d1c6fe6adca293d598924adcff">&#9670;&nbsp;</a></span>transactional_table_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::transactional_table_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>With this function MySQL request a transactional lock to a table when user issued query LOCK TABLES..WHERE ENGINE = InnoDB. </p><dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: handle to the user thread </td></tr>
    <tr><td class="paramname">lock_type</td><td>in: lock type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a819d891b648b8846e7d58ee795799473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819d891b648b8846e7d58ee795799473">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::truncate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all rows of an InnoDB table. </p><dl class="section return"><dt>Returns</dt><dd>error number </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">handler</a>.</p>

</div>
</div>
<a id="ac3b12ebc2bb2a73404771514a047f0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b12ebc2bb2a73404771514a047f0ab">&#9670;&nbsp;</a></span>try_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::try_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell the engine whether it should avoid unnecessary lock waits. If yes, in an UPDATE or DELETE, if the row under the cursor was locked by another transaction, the engine may try an optimistic read of the last committed row value under the cursor. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">handler</a>.</p>

</div>
</div>
<a id="af201c2ed028097a876935c9695421db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af201c2ed028097a876935c9695421db6">&#9670;&nbsp;</a></span>unlock_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::unlock_row </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a new lock set on a row, if it was not read optimistically. This can be called after a row has been read in the processing of an UPDATE or a DELETE query, if the option innodb_locks_unsafe_for_binlog is set. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="ae8ea4b44716bf246fa249c371f08421f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ea4b44716bf246fa249c371f08421f">&#9670;&nbsp;</a></span>update_create_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::update_create_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update create_info. Used in SHOW CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> et al. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_info</td><td>in/out: create info </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="af39587716831a568109760921542718b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39587716831a568109760921542718b">&#9670;&nbsp;</a></span>update_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::update_row </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>old_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>new_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates a row given as a parameter to a new value. Note that we are given whole rows, not just the fields which are updated: this incurs some overhead for CPU when we check which fields are actually updated. TODO: currently InnoDB does not prevent the 'Halloween problem': in a searched update a single row can get updated several times if its index columns are updated! </p><dl class="section return"><dt>Returns</dt><dd>error number or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_row</td><td>in: old row in MySQL format </td></tr>
    <tr><td class="paramname">new_row</td><td>in: new row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cfe9674d4d001b7bbb13a1be8922325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfe9674d4d001b7bbb13a1be8922325">&#9670;&nbsp;</a></span>update_table_comment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char * ha_innobase::update_table_comment </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>comment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds information about free space in the InnoDB tablespace to a table comment which is printed out when a user calls SHOW <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> STATUS. Adds also info on foreign keys. </p><dl class="section return"><dt>Returns</dt><dd>table comment + InnoDB free space + info on foreign keys </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comment</td><td>in: table comment defined by user </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a518cf241b927b988de6bc474c8b4643b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518cf241b927b988de6bc474c8b4643b">&#9670;&nbsp;</a></span>update_thd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::update_thd </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the user_thd field in a handle and also allocates a new InnoDB transaction handle if needed, and updates the transaction fields in the prebuilt struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: thd to use the handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eccb7dd13ca5bf52a55fe853ce8886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eccb7dd13ca5bf52a55fe853ce8886d">&#9670;&nbsp;</a></span>update_thd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ha_innobase::update_thd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the user_thd field in a handle and also allocates a new InnoDB transaction handle if needed, and updates the transaction fields in the prebuilt struct. </p>

</div>
</div>
<a id="ada1584696559d62c9f1b263189a73cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1584696559d62c9f1b263189a73cbd">&#9670;&nbsp;</a></span>was_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool ha_innobase::was_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In an UPDATE or DELETE, if the row under the cursor was locked by another transaction, and the engine used an optimistic read of the last committed row value under the cursor, then the engine returns 1 from this function. MySQL must NOT try to update this optimistic value. If the optimistic value does not match the WHERE condition, MySQL can decide to skip over this row. Currently only works for InnoDB. This can be used to avoid unnecessary lock waits.</p>
<p>If this method returns nonzero, it will also signal the storage engine that the next read will be a locking re-read of the row. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">handler</a>.</p>

</div>
</div>
<a id="a974ef9811d788fbab703a6d3cd292476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974ef9811d788fbab703a6d3cd292476">&#9670;&nbsp;</a></span>write_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int ha_innobase::write_row </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a row in an InnoDB database, to the table specified in this handle. </p><dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record</td><td>in: a row in MySQL format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9868d8254aeebf2283682fa5b8a3f1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9868d8254aeebf2283682fa5b8a3f1ab">&#9670;&nbsp;</a></span>ds_mrr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ds_mrr__impl.html">DsMrr_impl</a> ha_innobase::ds_mrr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The multi range read session object </p>

</div>
</div>
<a id="a6eeade7014188c7e403cdcb45fafb2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eeade7014188c7e403cdcb45fafb2c4">&#9670;&nbsp;</a></span>num_write_row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint ha_innobase::num_write_row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of <a class="el" href="classha__innobase.html#a974ef9811d788fbab703a6d3cd292476">write_row()</a> calls </p>

</div>
</div>
<a id="a05ded39281413b23e00758533069cbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ded39281413b23e00758533069cbc5">&#9670;&nbsp;</a></span>prebuilt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a>* ha_innobase::prebuilt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>prebuilt struct in InnoDB, used to save CPU time with prebuilt data structures </p>

</div>
</div>
<a id="a498a8ac1f1ddd1aba325eea02a536297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498a8ac1f1ddd1aba325eea02a536297">&#9670;&nbsp;</a></span>share</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__innobase__share.html">INNOBASE_SHARE</a>* ha_innobase::share</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>information for MySQL table locking </p>

</div>
</div>
<a id="ac87cf8a6eac817fb2c579118cf179f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87cf8a6eac817fb2c579118cf179f09">&#9670;&nbsp;</a></span>start_of_scan</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong ha_innobase::start_of_scan</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>this is set to 1 when we are starting a table scan but have not yet fetched any row, else 0 </p>

</div>
</div>
<a id="a4f37946e8eb555e06ee03cb5b413f337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f37946e8eb555e06ee03cb5b413f337">&#9670;&nbsp;</a></span>upd_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uchar* ha_innobase::upd_buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>buffer used in updates </p>

</div>
</div>
<a id="af3001f41ab9d5fce56a3476ed657e23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3001f41ab9d5fce56a3476ed657e23f">&#9670;&nbsp;</a></span>upd_buf_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint ha_innobase::upd_buf_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the size of upd_buf in bytes </p>

</div>
</div>
<a id="acf5951077a66c00be186c75834067c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5951077a66c00be186c75834067c8a">&#9670;&nbsp;</a></span>user_thd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">THD* ha_innobase::user_thd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the thread handle of the user currently using the handle; this is set in external_lock function </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>storage/innobase/handler/<a class="el" href="ha__innodb_8h_source.html">ha_innodb.h</a></li>
<li>storage/innobase/handler/<a class="el" href="ha__innodb_8cc.html">ha_innodb.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Sid_map Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_sid__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Sid_map Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="rpl__gtid_8h_source.html">rpl_gtid.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sid__map_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_sid__map_1_1_node.html" title="Node pointed to by both the hash and the array. ">Node</a> pointed to by both the hash and the array.  <a href="struct_sid__map_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcb420a3241258cc68ab42910133144d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#adcb420a3241258cc68ab42910133144d">Sid_map</a> (<a class="el" href="class_checkable__rwlock.html">Checkable_rwlock</a> *<a class="el" href="class_sid__map.html#a0dd02514995333a3887ba4a93492a885">sid_lock</a>)</td></tr>
<tr class="separator:adcb420a3241258cc68ab42910133144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ebe48caba52d2bccd668088c25a8e8"><td class="memItemLeft" align="right" valign="top"><a id="a02ebe48caba52d2bccd668088c25a8e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#a02ebe48caba52d2bccd668088c25a8e8">~Sid_map</a> ()</td></tr>
<tr class="memdesc:a02ebe48caba52d2bccd668088c25a8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this <a class="el" href="class_sid__map.html">Sid_map</a>. <br /></td></tr>
<tr class="separator:a02ebe48caba52d2bccd668088c25a8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aa9c0f385a44772e9e5c3955cca0cf"><td class="memItemLeft" align="right" valign="top">rpl_sidno&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#a23aa9c0f385a44772e9e5c3955cca0cf">add_sid</a> (const <a class="el" href="struct_uuid.html">rpl_sid</a> &amp;sid)</td></tr>
<tr class="separator:a23aa9c0f385a44772e9e5c3955cca0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1667fd040c720d4ab8c35871f63926f4"><td class="memItemLeft" align="right" valign="top">rpl_sidno&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#a1667fd040c720d4ab8c35871f63926f4">sid_to_sidno</a> (const <a class="el" href="struct_uuid.html">rpl_sid</a> &amp;sid) const</td></tr>
<tr class="separator:a1667fd040c720d4ab8c35871f63926f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ecf605e76bbc3862cda4588fe680b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_uuid.html">rpl_sid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#a93ecf605e76bbc3862cda4588fe680b6">sidno_to_sid</a> (rpl_sidno sidno) const</td></tr>
<tr class="separator:a93ecf605e76bbc3862cda4588fe680b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136025a5e9fb2ea21eb4da9d44060fce"><td class="memItemLeft" align="right" valign="top">rpl_sidno&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#a136025a5e9fb2ea21eb4da9d44060fce">get_sorted_sidno</a> (rpl_sidno <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>) const</td></tr>
<tr class="separator:a136025a5e9fb2ea21eb4da9d44060fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1dbe6bf6fbaf1d6c3199cd407a620c"><td class="memItemLeft" align="right" valign="top">rpl_sidno&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#a4e1dbe6bf6fbaf1d6c3199cd407a620c">get_max_sidno</a> () const</td></tr>
<tr class="separator:a4e1dbe6bf6fbaf1d6c3199cd407a620c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a36a4e53afd262e046a287bd1717b8035"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#a36a4e53afd262e046a287bd1717b8035">add_node</a> (rpl_sidno sidno, const <a class="el" href="struct_uuid.html">rpl_sid</a> &amp;sid)</td></tr>
<tr class="separator:a36a4e53afd262e046a287bd1717b8035"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0dd02514995333a3887ba4a93492a885"><td class="memItemLeft" align="right" valign="top"><a id="a0dd02514995333a3887ba4a93492a885"></a>
<a class="el" href="class_checkable__rwlock.html">Checkable_rwlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#a0dd02514995333a3887ba4a93492a885">sid_lock</a></td></tr>
<tr class="memdesc:a0dd02514995333a3887ba4a93492a885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write lock that protects updates to the number of SIDNOs. <br /></td></tr>
<tr class="separator:a0dd02514995333a3887ba4a93492a885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7948054471515ffdf35bd8b5727ecb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__dynamic__array.html">DYNAMIC_ARRAY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#aa7948054471515ffdf35bd8b5727ecb9">_sidno_to_sid</a></td></tr>
<tr class="separator:aa7948054471515ffdf35bd8b5727ecb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9a8b28cb71f03024ab88b40a0fa9fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__hash.html">HASH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#afe9a8b28cb71f03024ab88b40a0fa9fa">_sid_to_sidno</a></td></tr>
<tr class="separator:afe9a8b28cb71f03024ab88b40a0fa9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e630d058f90d59bb7ea3cad7ad9ffd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__dynamic__array.html">DYNAMIC_ARRAY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sid__map.html#a5e630d058f90d59bb7ea3cad7ad9ffd5">_sorted</a></td></tr>
<tr class="separator:a5e630d058f90d59bb7ea3cad7ad9ffd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a bidirectional map between SID and SIDNO.</p>
<p>SIDNOs are always numbers greater or equal to 1.</p>
<p>This data structure OPTIONALLY knows of a read-write lock that protects the number of SIDNOs. The lock is provided by the invoker of the constructor and it is generally the caller's responsibility to acquire the read lock. If the lock is not NULL, access methods assert that the caller already holds the read (or write) lock. If the lock is not NULL and a method of this class grows the number of SIDNOs, then the method temporarily upgrades this lock to a write lock and then degrades it to a read lock again; there will be a short period when the lock is not held at all. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adcb420a3241258cc68ab42910133144d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb420a3241258cc68ab42910133144d">&#9670;&nbsp;</a></span>Sid_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sid_map::Sid_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_checkable__rwlock.html">Checkable_rwlock</a> *&#160;</td>
          <td class="paramname"><em>sid_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create this <a class="el" href="class_sid__map.html">Sid_map</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid_lock</td><td>Read-write lock that protects updates to the number of SIDNOs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a36a4e53afd262e046a287bd1717b8035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a4e53afd262e046a287bd1717b8035">&#9670;&nbsp;</a></span>add_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Sid_map::add_node </td>
          <td>(</td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>sidno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_uuid.html">rpl_sid</a> &amp;&#160;</td>
          <td class="paramname"><em>sid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="struct_sid__map_1_1_node.html" title="Node pointed to by both the hash and the array. ">Node</a> from the given SIDNO and SID and add it to _sidno_to_sid, _sid_to_sidno, and _sorted.</p>
<p>The caller must hold the write lock on sid_lock before invoking this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>The SIDNO to add. </td></tr>
    <tr><td class="paramname">sid</td><td>The SID to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a23aa9c0f385a44772e9e5c3955cca0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23aa9c0f385a44772e9e5c3955cca0cf">&#9670;&nbsp;</a></span>add_sid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rpl_sidno Sid_map::add_sid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_uuid.html">rpl_sid</a> &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given SID to this map if it does not already exist.</p>
<p>The caller must hold the read lock or write lock on sid_lock before invoking this function. If the SID does not exist in this map, it will release the read lock, take a write lock, update the map, release the write lock, and take the read lock again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>The SID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SIDNO</td><td>The SIDNO for the SID (a new SIDNO if the SID did not exist, an existing if it did exist). </td></tr>
    <tr><td class="paramname">negative</td><td>Error. This function calls my_error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e1dbe6bf6fbaf1d6c3199cd407a620c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1dbe6bf6fbaf1d6c3199cd407a620c">&#9670;&nbsp;</a></span>get_max_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rpl_sidno Sid_map::get_max_sidno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the biggest sidno in this <a class="el" href="class_sid__map.html">Sid_map</a>.</p>
<p>The caller must hold the read or write lock on sid_lock before invoking this function. </p>

</div>
</div>
<a id="a136025a5e9fb2ea21eb4da9d44060fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136025a5e9fb2ea21eb4da9d44060fce">&#9670;&nbsp;</a></span>get_sorted_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rpl_sidno Sid_map::get_sorted_sidno </td>
          <td>(</td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the n'th smallest sidno, in the order of the SID's UUID.</p>
<p>The caller must hold the read or write lock on sid_lock before invoking this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A number in the interval [0, <a class="el" href="class_sid__map.html#a4e1dbe6bf6fbaf1d6c3199cd407a620c">get_max_sidno()</a>-1], inclusively. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1667fd040c720d4ab8c35871f63926f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1667fd040c720d4ab8c35871f63926f4">&#9670;&nbsp;</a></span>sid_to_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rpl_sidno Sid_map::sid_to_sidno </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_uuid.html">rpl_sid</a> &amp;&#160;</td>
          <td class="paramname"><em>sid</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the SIDNO for a given SID</p>
<p>The caller must hold the read lock on sid_lock before invoking this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid</td><td>The SID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SIDNO</td><td>if the given SID exists in this map. </td></tr>
    <tr><td class="paramname">0</td><td>if the given SID does not exist in this map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93ecf605e76bbc3862cda4588fe680b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ecf605e76bbc3862cda4588fe680b6">&#9670;&nbsp;</a></span>sidno_to_sid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_uuid.html">rpl_sid</a>&amp; Sid_map::sidno_to_sid </td>
          <td>(</td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the SID for a given SIDNO.</p>
<p>An assertion is raised if the caller does not hold a lock on sid_lock, or if the SIDNO is not valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>The SIDNO. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>The SIDNO does not exist in this map. </td></tr>
    <tr><td class="paramname">pointer</td><td>Pointer to the SID. The data is shared with this <a class="el" href="class_sid__map.html">Sid_map</a>, so should not be modified. It is safe to read the data even after this <a class="el" href="class_sid__map.html">Sid_map</a> is modified, but not if this <a class="el" href="class_sid__map.html">Sid_map</a> is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afe9a8b28cb71f03024ab88b40a0fa9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9a8b28cb71f03024ab88b40a0fa9fa">&#9670;&nbsp;</a></span>_sid_to_sidno</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__hash.html">HASH</a> Sid_map::_sid_to_sidno</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Hash that maps SID to SIDNO. The keys in this array are of type rpl_sid. </p>

</div>
</div>
<a id="aa7948054471515ffdf35bd8b5727ecb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7948054471515ffdf35bd8b5727ecb9">&#9670;&nbsp;</a></span>_sidno_to_sid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__dynamic__array.html">DYNAMIC_ARRAY</a> Sid_map::_sidno_to_sid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array that maps SIDNO to SID; the element at index N points to a <a class="el" href="struct_sid__map_1_1_node.html" title="Node pointed to by both the hash and the array. ">Node</a> with SIDNO N-1. </p>

</div>
</div>
<a id="a5e630d058f90d59bb7ea3cad7ad9ffd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e630d058f90d59bb7ea3cad7ad9ffd5">&#9670;&nbsp;</a></span>_sorted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__dynamic__array.html">DYNAMIC_ARRAY</a> Sid_map::_sorted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array that maps numbers in the interval [0, <a class="el" href="class_sid__map.html#a4e1dbe6bf6fbaf1d6c3199cd407a620c">get_max_sidno()</a>-1] to SIDNOs, in order of increasing SID.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_sid__map.html#a136025a5e9fb2ea21eb4da9d44060fce">Sid_map::get_sorted_sidno</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="rpl__gtid_8h_source.html">rpl_gtid.h</a></li>
<li>sql/rpl_gtid_sid_map.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

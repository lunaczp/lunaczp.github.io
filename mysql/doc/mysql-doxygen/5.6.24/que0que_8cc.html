<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/que/que0que.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_5eeac2119dec04680d96f14541694d8a.html">que</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">que0que.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="usr0sess_8h_source.html">usr0sess.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0roll_8h_source.html">trx0roll.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0undo_8h_source.html">row0undo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0ins_8h_source.html">row0ins.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0sel_8h_source.html">row0sel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0purge_8h_source.html">row0purge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0crea_8h_source.html">dict0crea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="eval0proc_8h_source.html">eval0proc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="eval0eval_8h_source.html">eval0eval.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0types_8h_source.html">pars0types.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a991efb2beff04c93fb6ccb71f370436f"><td class="memItemLeft" align="right" valign="top"><a id="a991efb2beff04c93fb6ccb71f370436f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QUE_MAX_LOOPS_WITHOUT_CHECK</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a991efb2beff04c93fb6ccb71f370436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac6c202738f754cd03c7f5c9344706f6d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#ac6c202738f754cd03c7f5c9344706f6d">que_thr_move_to_run_state</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:ac6c202738f754cd03c7f5c9344706f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42412ad74b9e2b7d40855de299b9a8c7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a42412ad74b9e2b7d40855de299b9a8c7">que_fork_create</a> (<a class="el" href="structque__fork__t.html">que_t</a> *graph, que_node_t *parent, ulint fork_type, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a42412ad74b9e2b7d40855de299b9a8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a3b8a9bb02ac12c7496810c5aa7c6e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#ac9a3b8a9bb02ac12c7496810c5aa7c6e">que_thr_create</a> (<a class="el" href="structque__fork__t.html">que_fork_t</a> *parent, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:ac9a3b8a9bb02ac12c7496810c5aa7c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14a94fa4823d01748dcc42960143e39"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#ad14a94fa4823d01748dcc42960143e39">que_thr_end_lock_wait</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:ad14a94fa4823d01748dcc42960143e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae667b1208b8979a5ff87d9a14017afc2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#ae667b1208b8979a5ff87d9a14017afc2">que_thr_init_command</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:ae667b1208b8979a5ff87d9a14017afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4f81056f3625381f6d5e940ada89ff"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a0f4f81056f3625381f6d5e940ada89ff">que_fork_scheduler_round_robin</a> (<a class="el" href="structque__fork__t.html">que_fork_t</a> *fork, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a0f4f81056f3625381f6d5e940ada89ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1b973937459a9d18fb082539545076"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#aaf1b973937459a9d18fb082539545076">que_fork_start_command</a> (<a class="el" href="structque__fork__t.html">que_fork_t</a> *fork)</td></tr>
<tr class="separator:aaf1b973937459a9d18fb082539545076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a787c6fb3ffe563f07a98478522f93e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a2a787c6fb3ffe563f07a98478522f93e">que_graph_free_stat_list</a> (que_node_t *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>)</td></tr>
<tr class="separator:a2a787c6fb3ffe563f07a98478522f93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc3067f26a90a1e35c64c14890de849"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#afbc3067f26a90a1e35c64c14890de849">que_graph_free_recursive</a> (que_node_t *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>)</td></tr>
<tr class="separator:afbc3067f26a90a1e35c64c14890de849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621d301600099cf15cf8af09880d310d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a621d301600099cf15cf8af09880d310d">que_graph_free</a> (<a class="el" href="structque__fork__t.html">que_t</a> *graph)</td></tr>
<tr class="separator:a621d301600099cf15cf8af09880d310d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0d7e97f75f1b3b97925841a30738a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#aec0d7e97f75f1b3b97925841a30738a5">que_thr_node_step</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:aec0d7e97f75f1b3b97925841a30738a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7969e50edf8cbee880796d7620c88e72"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a7969e50edf8cbee880796d7620c88e72">que_thr_stop</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a7969e50edf8cbee880796d7620c88e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfa0085c389868fc841e354d0d52e9e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#aecfa0085c389868fc841e354d0d52e9e">que_thr_dec_refer_count</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> **next_thr)</td></tr>
<tr class="separator:aecfa0085c389868fc841e354d0d52e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191fee220e300c94fcc9bd7d0e9ff67a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a191fee220e300c94fcc9bd7d0e9ff67a">que_thr_stop_for_mysql</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a191fee220e300c94fcc9bd7d0e9ff67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc61add9480c930e770a7b93a97780f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a2dc61add9480c930e770a7b93a97780f">que_thr_move_to_run_state_for_mysql</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a2dc61add9480c930e770a7b93a97780f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07d305f7b68f7a932b9782b6ced9fb7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#ad07d305f7b68f7a932b9782b6ced9fb7">que_thr_stop_for_mysql_no_error</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:ad07d305f7b68f7a932b9782b6ced9fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cb88d969bdb835226ae61becff02a9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN que_node_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#ab7cb88d969bdb835226ae61becff02a9">que_node_get_containing_loop_node</a> (que_node_t *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>)</td></tr>
<tr class="separator:ab7cb88d969bdb835226ae61becff02a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa334497e831e4b91b26c1046b0c30d57"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#aa334497e831e4b91b26c1046b0c30d57">que_node_print_info</a> (que_node_t *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>)</td></tr>
<tr class="separator:aa334497e831e4b91b26c1046b0c30d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1aaeb5dab6f4f9b18affe6eff40d8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#ac0e1aaeb5dab6f4f9b18affe6eff40d8">que_thr_step</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:ac0e1aaeb5dab6f4f9b18affe6eff40d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bb42fa29770f0a42644165905f81cb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a62bb42fa29770f0a42644165905f81cb">que_run_threads_low</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a62bb42fa29770f0a42644165905f81cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3735e10b1d2a1a16e95fa61cc9b94b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a7a3735e10b1d2a1a16e95fa61cc9b94b">que_run_threads</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a7a3735e10b1d2a1a16e95fa61cc9b94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680a6e5e75d83172c43e89e758d6fe77"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#a680a6e5e75d83172c43e89e758d6fe77">que_eval_sql</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *<a class="el" href="dict0crea_8cc.html#aecb2dd0da01a12f0e48213d6d9f3c5af">sql</a>, ibool reserve_dict_mutex, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a680a6e5e75d83172c43e89e758d6fe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add49aaae34310e1ee95563056f4797a0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#add49aaae34310e1ee95563056f4797a0">que_init</a> (void)</td></tr>
<tr class="separator:add49aaae34310e1ee95563056f4797a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d680348823193de2635e23c1b0cb53"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="que0que_8cc.html#ad8d680348823193de2635e23c1b0cb53">que_close</a> (void)</td></tr>
<tr class="separator:ad8d680348823193de2635e23c1b0cb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Query graph</p>
<p>Created 5/27/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad8d680348823193de2635e23c1b0cb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d680348823193de2635e23c1b0cb53">&#9670;&nbsp;</a></span>que_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void que_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the query sub-system. </p>

</div>
</div>
<a id="a680a6e5e75d83172c43e89e758d6fe77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680a6e5e75d83172c43e89e758d6fe77">&#9670;&nbsp;</a></span>que_eval_sql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> que_eval_sql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>reserve_dict_mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate the given SQL. </p><dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct, or NULL </td></tr>
    <tr><td class="paramname">sql</td><td>in: SQL string </td></tr>
    <tr><td class="paramname">reserve_dict_mutex</td><td>in: if TRUE, acquire/release dict_sys-&gt;mutex around call to pars_sql. </td></tr>
    <tr><td class="paramname">trx</td><td>in: trx </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42412ad74b9e2b7d40855de299b9a8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42412ad74b9e2b7d40855de299b9a8c7">&#9670;&nbsp;</a></span>que_fork_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__fork__t.html">que_fork_t</a>* que_fork_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__fork__t.html">que_t</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>fork_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a query graph fork node. </p><dl class="section return"><dt>Returns</dt><dd>own: fork node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>in: graph, if NULL then this fork node is assumed to be the graph root </td></tr>
    <tr><td class="paramname">parent</td><td>in: parent node </td></tr>
    <tr><td class="paramname">fork_type</td><td>in: fork type </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f4f81056f3625381f6d5e940ada89ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4f81056f3625381f6d5e940ada89ff">&#9670;&nbsp;</a></span>que_fork_scheduler_round_robin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a>* que_fork_scheduler_round_robin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td>
          <td class="paramname"><em>fork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Round robin scheduler. </p><dl class="section return"><dt>Returns</dt><dd>a query thread of the graph moved to QUE_THR_RUNNING state, or NULL; the query thread should be executed by que_run_threads by the caller </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fork</td><td>in: a query fork </td></tr>
    <tr><td class="paramname">thr</td><td>in: current pos </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf1b973937459a9d18fb082539545076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1b973937459a9d18fb082539545076">&#9670;&nbsp;</a></span>que_fork_start_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a>* que_fork_start_command </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td>
          <td class="paramname"><em>fork</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts execution of a command in a query fork. Picks a query thread which is not in the QUE_THR_RUNNING state and moves it to that state. If none can be chosen, a situation which may arise in parallelized fetches, NULL is returned. </p><dl class="section return"><dt>Returns</dt><dd>a query thread of the graph moved to QUE_THR_RUNNING state, or NULL; the query thread should be executed by que_run_threads by the caller </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fork</td><td>in: a query fork </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a621d301600099cf15cf8af09880d310d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621d301600099cf15cf8af09880d310d">&#9670;&nbsp;</a></span>que_graph_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void que_graph_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__fork__t.html">que_t</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a query graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>in: query graph; we assume that the memory heap where this graph was created is private to this graph: if not, then use que_graph_free_recursive and free the heap afterwards! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbc3067f26a90a1e35c64c14890de849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc3067f26a90a1e35c64c14890de849">&#9670;&nbsp;</a></span>que_graph_free_recursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void que_graph_free_recursive </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a query graph, but not the heap where it was created. Does not free explicit cursor declarations, they are freed in que_graph_free. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: query graph node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a787c6fb3ffe563f07a98478522f93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a787c6fb3ffe563f07a98478522f93e">&#9670;&nbsp;</a></span>que_graph_free_stat_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void que_graph_free_stat_list </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls que_graph_free_recursive for statements in a statement list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: first query graph node in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add49aaae34310e1ee95563056f4797a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add49aaae34310e1ee95563056f4797a0">&#9670;&nbsp;</a></span>que_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void que_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise the query sub-system. </p>

</div>
</div>
<a id="ab7cb88d969bdb835226ae61becff02a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cb88d969bdb835226ae61becff02a9">&#9670;&nbsp;</a></span>que_node_get_containing_loop_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN que_node_t* que_node_get_containing_loop_node </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the first containing loop node (e.g. <a class="el" href="structwhile__node__t.html">while_node_t</a> or <a class="el" href="structfor__node__t.html">for_node_t</a>) for the given node, or NULL if the node is not within a loop. </p><dl class="section return"><dt>Returns</dt><dd>containing loop node, or NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa334497e831e4b91b26c1046b0c30d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa334497e831e4b91b26c1046b0c30d57">&#9670;&nbsp;</a></span>que_node_print_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void que_node_print_info </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of an SQL query graph node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: query graph node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a3735e10b1d2a1a16e95fa61cc9b94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3735e10b1d2a1a16e95fa61cc9b94b">&#9670;&nbsp;</a></span>que_run_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void que_run_threads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run a query thread. Handles lock waits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62bb42fa29770f0a42644165905f81cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bb42fa29770f0a42644165905f81cb">&#9670;&nbsp;</a></span>que_run_threads_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void que_run_threads_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run a query thread until it finishes or encounters e.g. a lock wait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9a3b8a9bb02ac12c7496810c5aa7c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a3b8a9bb02ac12c7496810c5aa7c6e">&#9670;&nbsp;</a></span>que_thr_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a>* que_thr_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a query graph thread node. </p><dl class="section return"><dt>Returns</dt><dd>own: query thread node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>in: parent node, i.e., a fork node </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecfa0085c389868fc841e354d0d52e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfa0085c389868fc841e354d0d52e9e">&#9670;&nbsp;</a></span>que_thr_dec_refer_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void que_thr_dec_refer_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> **&#160;</td>
          <td class="paramname"><em>next_thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decrements the query thread reference counts in the query graph and the transaction. NOTE ***: This and que_thr_stop_for_mysql are the only functions where the reference count can be decremented and this function may only be called from inside que_run_threads! These restrictions exist to make the rollback code easier to maintain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">next_thr</td><td>in/out: next query thread to run; if the value which is passed in is a pointer to a NULL pointer, then the calling function can start running a new query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad14a94fa4823d01748dcc42960143e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14a94fa4823d01748dcc42960143e39">&#9670;&nbsp;</a></span>que_thr_end_lock_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a>* que_thr_end_lock_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves a suspended query thread to the QUE_THR_RUNNING state and may release a worker thread to execute it. This function should be used to end the wait state of a query thread waiting for a lock or a stored procedure completion. </p><dl class="section return"><dt>Returns</dt><dd>the query thread that needs to be released. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction with que_state in QUE_THR_LOCK_WAIT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae667b1208b8979a5ff87d9a14017afc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae667b1208b8979a5ff87d9a14017afc2">&#9670;&nbsp;</a></span>que_thr_init_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void que_thr_init_command </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inits a query thread for a command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6c202738f754cd03c7f5c9344706f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c202738f754cd03c7f5c9344706f6d">&#9670;&nbsp;</a></span>que_thr_move_to_run_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void que_thr_move_to_run_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves a thread from another state to the QUE_THR_RUNNING state. Increments the n_active_thrs counters of the query graph and transaction. NOTE***: This is the only function in which such a transition is allowed to happen! in: an query thread</p>
<p>Moves a thread from another state to the QUE_THR_RUNNING state. Increments the n_active_thrs counters of the query graph and transaction if thr was not active. NOTE***: This and ..._mysql are the only functions in which such a transition is allowed to happen! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: an query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dc61add9480c930e770a7b93a97780f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc61add9480c930e770a7b93a97780f">&#9670;&nbsp;</a></span>que_thr_move_to_run_state_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void que_thr_move_to_run_state_for_mysql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves a thread from another state to the QUE_THR_RUNNING state. Increments the n_active_thrs counters of the query graph and transaction if thr was not active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: an query thread </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec0d7e97f75f1b3b97925841a30738a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0d7e97f75f1b3b97925841a30738a5">&#9670;&nbsp;</a></span>que_thr_node_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structque__thr__t.html">que_thr_t</a>* que_thr_node_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs an execution step on a thr node. </p><dl class="section return"><dt>Returns</dt><dd>query thread to run next, or NULL if none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread where run_node must be the thread node itself </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0e1aaeb5dab6f4f9b18affe6eff40d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e1aaeb5dab6f4f9b18affe6eff40d8">&#9670;&nbsp;</a></span>que_thr_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structque__thr__t.html">que_thr_t</a>* que_thr_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an execution step on a query thread. </p><dl class="section return"><dt>Returns</dt><dd>query thread to run next: it may differ from the input parameter if, e.g., a subprocedure call is made </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7969e50edf8cbee880796d7620c88e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7969e50edf8cbee880796d7620c88e72">&#9670;&nbsp;</a></span>que_thr_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool que_thr_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops a query thread if graph or trx is in a state requiring it. The conditions are tested in the order (1) graph, (2) trx. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if stopped </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a191fee220e300c94fcc9bd7d0e9ff67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191fee220e300c94fcc9bd7d0e9ff67a">&#9670;&nbsp;</a></span>que_thr_stop_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void que_thr_stop_for_mysql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A patch for MySQL used to 'stop' a dummy query thread used in MySQL. The query thread is stopped and made inactive, except in the case where it was put to the lock wait state in <a class="el" href="lock0lock_8cc.html">lock0lock.cc</a>, but the lock has already been granted or the transaction chosen as a victim in deadlock resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad07d305f7b68f7a932b9782b6ced9fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07d305f7b68f7a932b9782b6ced9fb7">&#9670;&nbsp;</a></span>que_thr_stop_for_mysql_no_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void que_thr_stop_for_mysql_no_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A patch for MySQL used to 'stop' a dummy query thread used in MySQL select, when there is no error or lock wait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: MDL_context Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_m_d_l__context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MDL_context Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mdl_8h_source.html">mdl.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab0e1989a324f4a2918656245963f23fa"><td class="memItemLeft" align="right" valign="top"><a id="ab0e1989a324f4a2918656245963f23fa"></a>
typedef <a class="el" href="class_i___p___list.html">I_P_List</a>&lt; <a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a>, <a class="el" href="struct_i___p___list__adapter.html">I_P_List_adapter</a>&lt; <a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a>, &amp;<a class="el" href="class_m_d_l__ticket.html#a74155707577dfd12cc7f47229e4f0d17">MDL_ticket::next_in_context</a>, &amp;MDL_ticket::prev_in_context &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ticket_list</b></td></tr>
<tr class="separator:ab0e1989a324f4a2918656245963f23fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c46960d79806f52abbf0ba43af6ad04"><td class="memItemLeft" align="right" valign="top"><a id="a0c46960d79806f52abbf0ba43af6ad04"></a>
typedef <a class="el" href="class_i___p___list__iterator.html">Ticket_list::Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Ticket_iterator</b></td></tr>
<tr class="separator:a0c46960d79806f52abbf0ba43af6ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21b35ef90597dcd411bf091acd1f4a38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a21b35ef90597dcd411bf091acd1f4a38">MDL_context</a> ()</td></tr>
<tr class="separator:a21b35ef90597dcd411bf091acd1f4a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01a1f42bd9ed050556c434fb6d007ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#af01a1f42bd9ed050556c434fb6d007ac">destroy</a> ()</td></tr>
<tr class="separator:af01a1f42bd9ed050556c434fb6d007ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d07a861aaf9db6fda46da196a8b0d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#ab6d07a861aaf9db6fda46da196a8b0d0">try_acquire_lock</a> (<a class="el" href="class_m_d_l__request.html">MDL_request</a> *mdl_request)</td></tr>
<tr class="separator:ab6d07a861aaf9db6fda46da196a8b0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3702152de7ebdf6e2c54e5ba5cbecfda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a3702152de7ebdf6e2c54e5ba5cbecfda">acquire_lock</a> (<a class="el" href="class_m_d_l__request.html">MDL_request</a> *mdl_request, ulong lock_wait_timeout)</td></tr>
<tr class="separator:a3702152de7ebdf6e2c54e5ba5cbecfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4583e611d097158c5f08b8d1133fbd7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a4583e611d097158c5f08b8d1133fbd7e">acquire_locks</a> (<a class="el" href="class_i___p___list.html">MDL_request_list</a> *requests, ulong lock_wait_timeout)</td></tr>
<tr class="separator:a4583e611d097158c5f08b8d1133fbd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7108b456e7c5ee715ee6511c03d542"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a2a7108b456e7c5ee715ee6511c03d542">upgrade_shared_lock</a> (<a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *mdl_ticket, enum_mdl_type new_type, ulong lock_wait_timeout)</td></tr>
<tr class="separator:a2a7108b456e7c5ee715ee6511c03d542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ed5299b1da65397a7e6972425b5f2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a74ed5299b1da65397a7e6972425b5f2d">clone_ticket</a> (<a class="el" href="class_m_d_l__request.html">MDL_request</a> *mdl_request)</td></tr>
<tr class="separator:a74ed5299b1da65397a7e6972425b5f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bd65389a74778433291eb2d426c71f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a73bd65389a74778433291eb2d426c71f">release_all_locks_for_name</a> (<a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="separator:a73bd65389a74778433291eb2d426c71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d0df5eb422cbfa9a4225218c76141f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a58d0df5eb422cbfa9a4225218c76141f">release_lock</a> (<a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="separator:a58d0df5eb422cbfa9a4225218c76141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71b02abbb794806677dfc11db46edb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#ab71b02abbb794806677dfc11db46edb5">is_lock_owner</a> (<a class="el" href="class_m_d_l__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a> mdl_namespace, const char *db, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, enum_mdl_type mdl_type)</td></tr>
<tr class="separator:ab71b02abbb794806677dfc11db46edb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc9db02d0a60b144fd35770424ba1ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#adfc9db02d0a60b144fd35770424ba1ae">has_lock</a> (const <a class="el" href="class_m_d_l__savepoint.html">MDL_savepoint</a> &amp;mdl_savepoint, <a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *mdl_ticket)</td></tr>
<tr class="separator:adfc9db02d0a60b144fd35770424ba1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36680261ff26d6eb9ea19e2a290294d"><td class="memItemLeft" align="right" valign="top"><a id="ae36680261ff26d6eb9ea19e2a290294d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_locks</b> () const</td></tr>
<tr class="separator:ae36680261ff26d6eb9ea19e2a290294d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213edf20be43313e0346a489c2f47dd6"><td class="memItemLeft" align="right" valign="top"><a id="a213edf20be43313e0346a489c2f47dd6"></a>
<a class="el" href="class_m_d_l__savepoint.html">MDL_savepoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mdl_savepoint</b> ()</td></tr>
<tr class="separator:a213edf20be43313e0346a489c2f47dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357599f5af7c6ec7587ecb7b349f0313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a357599f5af7c6ec7587ecb7b349f0313">set_explicit_duration_for_all_locks</a> ()</td></tr>
<tr class="separator:a357599f5af7c6ec7587ecb7b349f0313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b07243d69f1354e3bb5936dd6ded15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#ad1b07243d69f1354e3bb5936dd6ded15">set_transaction_duration_for_all_locks</a> ()</td></tr>
<tr class="separator:ad1b07243d69f1354e3bb5936dd6ded15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5836b7c79f957c575c90ad4f1d8296de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a5836b7c79f957c575c90ad4f1d8296de">set_lock_duration</a> (<a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *mdl_ticket, enum_mdl_duration duration)</td></tr>
<tr class="separator:a5836b7c79f957c575c90ad4f1d8296de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55150d0bbe77cf0cd38e7005a4330e44"><td class="memItemLeft" align="right" valign="top"><a id="a55150d0bbe77cf0cd38e7005a4330e44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>release_statement_locks</b> ()</td></tr>
<tr class="separator:a55150d0bbe77cf0cd38e7005a4330e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce65a72bedc0c4384b2b4c231c070ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#afce65a72bedc0c4384b2b4c231c070ed">release_transactional_locks</a> ()</td></tr>
<tr class="separator:afce65a72bedc0c4384b2b4c231c070ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ff94d0928e9720df30643835e4ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a863ff94d0928e9720df30643835e4ef0">rollback_to_savepoint</a> (const <a class="el" href="class_m_d_l__savepoint.html">MDL_savepoint</a> &amp;mdl_savepoint)</td></tr>
<tr class="separator:a863ff94d0928e9720df30643835e4ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d362a81dc428c09c8a86323f380fb0"><td class="memItemLeft" align="right" valign="top"><a id="a15d362a81dc428c09c8a86323f380fb0"></a>
<a class="el" href="class_m_d_l__context__owner.html">MDL_context_owner</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_owner</b> ()</td></tr>
<tr class="separator:a15d362a81dc428c09c8a86323f380fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563d6d05aeb758f495f44c123c5306b"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a3563d6d05aeb758f495f44c123c5306b">get_deadlock_weight</a> () const</td></tr>
<tr class="separator:a3563d6d05aeb758f495f44c123c5306b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c29aa7919001edcdfaa82bc360c65df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a4c29aa7919001edcdfaa82bc360c65df">init</a> (<a class="el" href="class_m_d_l__context__owner.html">MDL_context_owner</a> *arg)</td></tr>
<tr class="separator:a4c29aa7919001edcdfaa82bc360c65df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74608d443dfc4754ce1b14c672a914f1"><td class="memItemLeft" align="right" valign="top"><a id="a74608d443dfc4754ce1b14c672a914f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_needs_thr_lock_abort</b> (bool needs_thr_lock_abort)</td></tr>
<tr class="separator:a74608d443dfc4754ce1b14c672a914f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc1ba94d5bbd550b7e1d0ab88882060"><td class="memItemLeft" align="right" valign="top"><a id="adbc1ba94d5bbd550b7e1d0ab88882060"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_needs_thr_lock_abort</b> () const</td></tr>
<tr class="separator:adbc1ba94d5bbd550b7e1d0ab88882060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e75a7f44e5bc687620aff289a00f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#aa0e75a7f44e5bc687620aff289a00f52">find_deadlock</a> ()</td></tr>
<tr class="separator:aa0e75a7f44e5bc687620aff289a00f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab778763f11b187ab171213c9fa08846e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#ab778763f11b187ab171213c9fa08846e">visit_subgraph</a> (<a class="el" href="class_m_d_l__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *dvisitor)</td></tr>
<tr class="separator:ab778763f11b187ab171213c9fa08846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd74a4227cf8ddea993d96ee3be25331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#afd74a4227cf8ddea993d96ee3be25331">will_wait_for</a> (<a class="el" href="class_m_d_l__wait__for__subgraph.html">MDL_wait_for_subgraph</a> *waiting_for_arg)</td></tr>
<tr class="separator:afd74a4227cf8ddea993d96ee3be25331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d3fb033110d449d894c95f33f6d9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#ad5d3fb033110d449d894c95f33f6d9b1">done_waiting_for</a> ()</td></tr>
<tr class="separator:ad5d3fb033110d449d894c95f33f6d9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca0ec235888a94af4dd25107a8af389"><td class="memItemLeft" align="right" valign="top"><a id="aaca0ec235888a94af4dd25107a8af389"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lock_deadlock_victim</b> ()</td></tr>
<tr class="separator:aaca0ec235888a94af4dd25107a8af389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a0ef8ba360e3d48885f711723aa3ea"><td class="memItemLeft" align="right" valign="top"><a id="af3a0ef8ba360e3d48885f711723aa3ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_deadlock_victim</b> ()</td></tr>
<tr class="separator:af3a0ef8ba360e3d48885f711723aa3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aeaf51be6c5480bb1e718aea933f55d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_d_l__wait.html">MDL_wait</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#aeaf51be6c5480bb1e718aea933f55d9d">m_wait</a></td></tr>
<tr class="separator:aeaf51be6c5480bb1e718aea933f55d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2260019c16977e8ed6aba3081f16348f"><td class="memItemLeft" align="right" valign="top"><a id="a2260019c16977e8ed6aba3081f16348f"></a>
THD *&#160;</td><td class="memItemRight" valign="bottom"><b>get_thd</b> () const</td></tr>
<tr class="separator:a2260019c16977e8ed6aba3081f16348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38694ab0fa2d63ac1c1d56c80966a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#ad38694ab0fa2d63ac1c1d56c80966a21">find_ticket</a> (<a class="el" href="class_m_d_l__request.html">MDL_request</a> *mdl_req, enum_mdl_duration *duration)</td></tr>
<tr class="separator:ad38694ab0fa2d63ac1c1d56c80966a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dc15bcb6b0b1558e7b2e96d124d0de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a77dc15bcb6b0b1558e7b2e96d124d0de">release_locks_stored_before</a> (enum_mdl_duration duration, <a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *sentinel)</td></tr>
<tr class="separator:a77dc15bcb6b0b1558e7b2e96d124d0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc52eee785b05fea372191de9af37df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#aedc52eee785b05fea372191de9af37df">release_lock</a> (enum_mdl_duration duration, <a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="separator:aedc52eee785b05fea372191de9af37df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9701e30aedce451d2311a6b4200b7935"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a9701e30aedce451d2311a6b4200b7935">try_acquire_lock_impl</a> (<a class="el" href="class_m_d_l__request.html">MDL_request</a> *mdl_request, <a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> **out_ticket)</td></tr>
<tr class="separator:a9701e30aedce451d2311a6b4200b7935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c39039b67527dbf53c8f40b3ba1c971"><td class="memItemLeft" align="right" valign="top"><a id="a9c39039b67527dbf53c8f40b3ba1c971"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MDL_context</b> (const <a class="el" href="class_m_d_l__context.html">MDL_context</a> &amp;rhs)</td></tr>
<tr class="separator:a9c39039b67527dbf53c8f40b3ba1c971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fe77708ce2d770e0b0145e1a6d9f24"><td class="memItemLeft" align="right" valign="top"><a id="a33fe77708ce2d770e0b0145e1a6d9f24"></a>
<a class="el" href="class_m_d_l__context.html">MDL_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_m_d_l__context.html">MDL_context</a> &amp;rhs)</td></tr>
<tr class="separator:a33fe77708ce2d770e0b0145e1a6d9f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a01de3127dcf1ec8fd35540620f8fdb7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i___p___list.html">Ticket_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a01de3127dcf1ec8fd35540620f8fdb7d">m_tickets</a> [MDL_DURATION_END]</td></tr>
<tr class="separator:a01de3127dcf1ec8fd35540620f8fdb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6586c3bee7136984083f6dc74952c7"><td class="memItemLeft" align="right" valign="top"><a id="a4f6586c3bee7136984083f6dc74952c7"></a>
<a class="el" href="class_m_d_l__context__owner.html">MDL_context_owner</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_owner</b></td></tr>
<tr class="separator:a4f6586c3bee7136984083f6dc74952c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dce4e93fbbc1eaeef6a819fb8e3945"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#ac2dce4e93fbbc1eaeef6a819fb8e3945">m_needs_thr_lock_abort</a></td></tr>
<tr class="separator:ac2dce4e93fbbc1eaeef6a819fb8e3945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7071f0afcce4718309d55797bdc165c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___thread__instrumentation.html#ga91f9e9de0d35a9c7ebfdaaeaf6934f52">mysql_prlock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#a7071f0afcce4718309d55797bdc165c0">m_LOCK_waiting_for</a></td></tr>
<tr class="separator:a7071f0afcce4718309d55797bdc165c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccb108b2dcf787b7f942b58382aafbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_d_l__wait__for__subgraph.html">MDL_wait_for_subgraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__context.html#acccb108b2dcf787b7f942b58382aafbf">m_waiting_for</a></td></tr>
<tr class="separator:acccb108b2dcf787b7f942b58382aafbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Context of the owner of metadata locks. I.e. each server connection has such a context. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a21b35ef90597dcd411bf091acd1f4a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b35ef90597dcd411bf091acd1f4a38">&#9670;&nbsp;</a></span>MDL_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MDL_context::MDL_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a metadata locking context.</p>
<p>This is to be called when a new server connection is created. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3702152de7ebdf6e2c54e5ba5cbecfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3702152de7ebdf6e2c54e5ba5cbecfda">&#9670;&nbsp;</a></span>acquire_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::acquire_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>mdl_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire one lock with waiting for conflicting locks to go away if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_request</td><td>[in/out] Lock request object for lock to be acquired</td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>[in] Seconds to wait before timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. <a class="el" href="class_m_d_l__request.html#a99421002fe2ea1580766846c0ef339ae">MDL_request::ticket</a> points to the ticket for the lock. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (Out of resources or waiting is aborted), </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4583e611d097158c5f08b8d1133fbd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4583e611d097158c5f08b8d1133fbd7e">&#9670;&nbsp;</a></span>acquire_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::acquire_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i___p___list.html">MDL_request_list</a> *&#160;</td>
          <td class="paramname"><em>mdl_requests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire exclusive locks. There must be no granted locks in the context.</p>
<p>This is a replacement of <a class="el" href="group___data___dictionary.html#gae06de7ce22001b035ca61edf2a3dea09">lock_table_names()</a>. It is used in RENAME, DROP and other DDL SQL statements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_requests</td><td><a class="el" href="class_list.html">List</a> of requests for locks to be acquired.</td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>Seconds to wait before timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The list of requests should not contain non-exclusive lock requests. There should not be any acquired locks in the context.</dd>
<dd>
Assumes that one already owns scoped intention exclusive lock.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74ed5299b1da65397a7e6972425b5f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ed5299b1da65397a7e6972425b5f2d">&#9670;&nbsp;</a></span>clone_ticket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::clone_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>mdl_request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a copy of a granted ticket. This is used to make sure that HANDLER ticket is never shared with a ticket that belongs to a transaction, so that when we HANDLER CLOSE, we don't release a transactional ticket, and vice versa &ndash; when we COMMIT, we don't mistakenly release a ticket for an open HANDLER.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Out of memory. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af01a1f42bd9ed050556c434fb6d007ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01a1f42bd9ed050556c434fb6d007ac">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy metadata locking context.</p>
<p>Assumes and asserts that there are no active or pending locks associated with this context at the time of the destruction.</p>
<p>Currently does nothing. Asserts that there are no pending or satisfied lock requests. The pending locks must be released prior to destruction. This is a new way to express the assertion that all tables are closed before a connection is destroyed. </p>

</div>
</div>
<a id="ad5d3fb033110d449d894c95f33f6d9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d3fb033110d449d894c95f33f6d9b1">&#9670;&nbsp;</a></span>done_waiting_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::done_waiting_for </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the wait-for edge from the graph after we're done waiting. </p>

</div>
</div>
<a id="aa0e75a7f44e5bc687620aff289a00f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e75a7f44e5bc687620aff289a00f52">&#9670;&nbsp;</a></span>find_deadlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::find_deadlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to find a deadlock. This function produces no errors.</p>
<dl class="section note"><dt>Note</dt><dd>If during deadlock resolution context which performs deadlock detection is chosen as a victim it will be informed about the fact by setting VICTIM status to its wait slot.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>A deadlock is found. </td></tr>
    <tr><td class="paramname">FALSE</td><td>No deadlock found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad38694ab0fa2d63ac1c1d56c80966a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38694ab0fa2d63ac1c1d56c80966a21">&#9670;&nbsp;</a></span>find_ticket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> * MDL_context::find_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>mdl_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_mdl_duration *&#160;</td>
          <td class="paramname"><em>result_duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> whether the context already holds a compatible lock ticket on an object. Start searching from list of locks for the same duration as lock being requested. If not look at lists for other durations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mdl_request</td><td>Lock request object for lock to be acquired </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_duration</td><td>Duration of lock which was found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Tickets which correspond to lock types "stronger" than one being requested are also considered compatible.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the lock ticket for the object or NULL otherwise. </dd></dl>

</div>
</div>
<a id="a3563d6d05aeb758f495f44c123c5306b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563d6d05aeb758f495f44c123c5306b">&#9670;&nbsp;</a></span>get_deadlock_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint MDL_context::get_deadlock_weight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section pre"><dt>Precondition</dt><dd>Only valid if we started waiting for lock. </dd></dl>

</div>
</div>
<a id="adfc9db02d0a60b144fd35770424ba1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc9db02d0a60b144fd35770424ba1ae">&#9670;&nbsp;</a></span>has_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::has_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_d_l__savepoint.html">MDL_savepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>mdl_savepoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>mdl_ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does this savepoint have this lock?</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>The ticket is older than the savepoint or is an LT, HA or GLR ticket. Thus it belongs to the savepoint or has explicit duration. </td></tr>
    <tr><td class="paramname">FALSE</td><td>The ticket is newer than the savepoint. and is not an LT, HA or GLR ticket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c29aa7919001edcdfaa82bc360c65df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c29aa7919001edcdfaa82bc360c65df">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__context__owner.html">MDL_context_owner</a> *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Post signal to the context (and wake it up if necessary).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>- Success, signal was posted. </td></tr>
    <tr><td class="paramname">TRUE</td><td>- Failure, signal was not posted since context already has received some signal or closed signal slot. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab71b02abbb794806677dfc11db46edb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71b02abbb794806677dfc11db46edb5">&#9670;&nbsp;</a></span>is_lock_owner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::is_lock_owner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a>&#160;</td>
          <td class="paramname"><em>mdl_namespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>mdl_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary function which allows to check if we have some kind of lock on a object. Returns TRUE if we have a lock of a given or stronger type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_namespace</td><td>Id of object namespace </td></tr>
    <tr><td class="paramname">db</td><td>Name of the database </td></tr>
    <tr><td class="paramname">name</td><td>Name of the object </td></tr>
    <tr><td class="paramname">mdl_type</td><td>Lock type. Pass in the weakest type to find out if there is at least some lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if current context contains satisfied lock for the object, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a73bd65389a74778433291eb2d426c71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bd65389a74778433291eb2d426c71f">&#9670;&nbsp;</a></span>release_all_locks_for_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::release_all_locks_for_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all explicit locks in the context which correspond to the same name/object as this lock request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticket</td><td>One of the locks for the name/object for which all locks should be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58d0df5eb422cbfa9a4225218c76141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d0df5eb422cbfa9a4225218c76141f">&#9670;&nbsp;</a></span>release_lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::release_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release lock with explicit duration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticket</td><td>Ticket for lock to be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedc52eee785b05fea372191de9af37df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc52eee785b05fea372191de9af37df">&#9670;&nbsp;</a></span>release_lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::release_lock </td>
          <td>(</td>
          <td class="paramtype">enum_mdl_duration&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>Lock duration. </td></tr>
    <tr><td class="paramname">ticket</td><td>Ticket for lock to be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77dc15bcb6b0b1558e7b2e96d124d0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dc15bcb6b0b1558e7b2e96d124d0de">&#9670;&nbsp;</a></span>release_locks_stored_before()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::release_locks_stored_before </td>
          <td>(</td>
          <td class="paramtype">enum_mdl_duration&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>sentinel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release all locks associated with the context. If the sentinel is not NULL, do not release locks stored in the list after and including the sentinel.</p>
<p>Statement and transactional locks are added to the beginning of the corresponding lists, i.e. stored in reverse temporal order. This allows to employ this function to:</p><ul>
<li>back off in case of a lock conflict.</li>
<li>release all locks in the end of a statment or transaction</li>
<li>rollback to a savepoint. </li>
</ul>

</div>
</div>
<a id="afce65a72bedc0c4384b2b4c231c070ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce65a72bedc0c4384b2b4c231c070ed">&#9670;&nbsp;</a></span>release_transactional_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::release_transactional_locks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release locks acquired by normal statements (SELECT, UPDATE, DELETE, etc) in the course of a transaction. Do not release HANDLER locks, if there are any.</p>
<p>This method is used at the end of a transaction, in implementation of COMMIT (implicit or explicit) and ROLLBACK. </p>

</div>
</div>
<a id="a863ff94d0928e9720df30643835e4ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ff94d0928e9720df30643835e4ef0">&#9670;&nbsp;</a></span>rollback_to_savepoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::rollback_to_savepoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_d_l__savepoint.html">MDL_savepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>mdl_savepoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases metadata locks that were acquired after a specific savepoint.</p>
<dl class="section note"><dt>Note</dt><dd>Used to release tickets acquired during a savepoint unit. </dd>
<dd>
It's safe to iterate and unlock any locks after taken after this savepoint because other statements that take other special locks cause a implicit commit (ie LOCK TABLES). </dd></dl>

</div>
</div>
<a id="a357599f5af7c6ec7587ecb7b349f0313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357599f5af7c6ec7587ecb7b349f0313">&#9670;&nbsp;</a></span>set_explicit_duration_for_all_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::set_explicit_duration_for_all_locks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set explicit duration for all locks in the context. </p>

</div>
</div>
<a id="a5836b7c79f957c575c90ad4f1d8296de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5836b7c79f957c575c90ad4f1d8296de">&#9670;&nbsp;</a></span>set_lock_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::set_lock_duration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>mdl_ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_mdl_duration&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change lock duration for transactional lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticket</td><td>Ticket representing lock. </td></tr>
    <tr><td class="paramname">duration</td><td>Lock duration to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method only supports changing duration of transactional lock to some other duration. </dd></dl>

</div>
</div>
<a id="ad1b07243d69f1354e3bb5936dd6ded15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b07243d69f1354e3bb5936dd6ded15">&#9670;&nbsp;</a></span>set_transaction_duration_for_all_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::set_transaction_duration_for_all_locks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set transactional duration for all locks in the context. </p>

</div>
</div>
<a id="ab6d07a861aaf9db6fda46da196a8b0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d07a861aaf9db6fda46da196a8b0d0">&#9670;&nbsp;</a></span>try_acquire_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::try_acquire_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>mdl_request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to acquire one lock.</p>
<p>Unlike exclusive locks, shared locks are acquired one by one. This is interface is chosen to simplify introduction of the new locking API to the system. <a class="el" href="class_m_d_l__context.html#ab6d07a861aaf9db6fda46da196a8b0d0">MDL_context::try_acquire_lock()</a> is currently used from <a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a>, and there we have only one table to work with.</p>
<p>This function may also be used to try to acquire an exclusive lock on a destination table, by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> ... RENAME.</p>
<p>Returns immediately without any side effect if encounters a lock conflict. Otherwise takes the lock.</p>
<p>FIXME: Compared to lock_table_name_if_not_cached() (from 5.1) it gives slightly more false negatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_request</td><td>[in/out] Lock request object for lock to be acquired</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. The lock may have not been acquired. <a class="el" href="struct_check.html">Check</a> the ticket, if it's NULL, a conflicting lock exists. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Out of resources, an error has been reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9701e30aedce451d2311a6b4200b7935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9701e30aedce451d2311a6b4200b7935">&#9670;&nbsp;</a></span>try_acquire_lock_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::try_acquire_lock_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>mdl_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> **&#160;</td>
          <td class="paramname"><em>out_ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary method for acquiring lock without waiting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_request</td><td>[in/out] Lock request object for lock to be acquired </td></tr>
    <tr><td class="paramname">out_ticket</td><td>[out] Ticket for the request in case when lock has not been acquired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. The lock may have not been acquired. <a class="el" href="struct_check.html">Check</a> <a class="el" href="class_m_d_l__request.html#a99421002fe2ea1580766846c0ef339ae">MDL_request::ticket</a>, if it's NULL, a conflicting lock exists. In this case "out_ticket" out parameter points to ticket which was constructed for the request. <a class="el" href="class_m_d_l__ticket.html#ac31749048c6f9a807473ef2849bda7fb">MDL_ticket::m_lock</a> points to the corresponding <a class="el" href="class_m_d_l__lock.html">MDL_lock</a> object and <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> write-locked. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Out of resources, an error has been reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a7108b456e7c5ee715ee6511c03d542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7108b456e7c5ee715ee6511c03d542">&#9670;&nbsp;</a></span>upgrade_shared_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::upgrade_shared_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>mdl_ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>new_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Upgrade a shared metadata lock.</p>
<p>Used in ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdl_ticket</td><td>Lock to upgrade. </td></tr>
    <tr><td class="paramname">new_type</td><td>Lock type to upgrade to. </td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>Seconds to wait before timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In case of failure to upgrade lock (e.g. because upgrader was killed) leaves lock in its original state (locked in shared mode).</dd>
<dd>
There can be only one upgrader for a lock or we will have deadlock. This invariant is ensured by the fact that upgradeable locks SU, SNW and SNRW are not compatible with each other and themselves in case of ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> operation. In case of CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> operation there is chance of deadlock as 'S' is compatible with 'S'. But the deadlock is recovered by backoff and retry mechanism.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (thread was killed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab778763f11b187ab171213c9fa08846e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab778763f11b187ab171213c9fa08846e">&#9670;&nbsp;</a></span>visit_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::visit_subgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *&#160;</td>
          <td class="paramname"><em>gvisitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A fragment of recursive traversal of the wait-for graph of MDL contexts in the server in search for deadlocks. Assume this MDL context is a node in the wait-for graph, and direct the visitor to all adjacent nodes. As long as the starting node is remembered in the visitor, a deadlock is found when the same node is visited twice. One MDL context is connected to another in the wait-for graph if it waits on a resource that is held by the other context.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>A deadlock is found. A pointer to deadlock victim is saved in the visitor. </td></tr>
    <tr><td class="paramname">FALSE</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd74a4227cf8ddea993d96ee3be25331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd74a4227cf8ddea993d96ee3be25331">&#9670;&nbsp;</a></span>will_wait_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_context::will_wait_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__wait__for__subgraph.html">MDL_wait_for_subgraph</a> *&#160;</td>
          <td class="paramname"><em>waiting_for_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inform the deadlock detector there is an edge in the wait-for graph. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7071f0afcce4718309d55797bdc165c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7071f0afcce4718309d55797bdc165c0">&#9670;&nbsp;</a></span>m_LOCK_waiting_for</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___thread__instrumentation.html#ga91f9e9de0d35a9c7ebfdaaeaf6934f52">mysql_prlock_t</a> MDL_context::m_LOCK_waiting_for</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read-write lock protecting m_waiting_for member.</p>
<dl class="section note"><dt>Note</dt><dd>The fact that this read-write lock prefers readers is important as deadlock detector won't work correctly otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Comment for <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a>. </dd></dl>

</div>
</div>
<a id="ac2dce4e93fbbc1eaeef6a819fb8e3945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dce4e93fbbc1eaeef6a819fb8e3945">&#9670;&nbsp;</a></span>m_needs_thr_lock_abort</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_context::m_needs_thr_lock_abort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TRUE - if for this context we will break protocol and try to acquire table-level locks while having only S lock on some table. To avoid deadlocks which might occur during concurrent upgrade of SNRW lock on such object to X lock we have to abort waits for table-level locks for such connections. FALSE - Otherwise. </p>

</div>
</div>
<a id="a01de3127dcf1ec8fd35540620f8fdb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01de3127dcf1ec8fd35540620f8fdb7d">&#9670;&nbsp;</a></span>m_tickets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i___p___list.html">Ticket_list</a> MDL_context::m_tickets[MDL_DURATION_END]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lists of all MDL tickets acquired by this connection.</p>
<h2>Lists of MDL tickets: </h2>
<p>The entire set of locks acquired by a connection can be separated in three subsets according to their: locks released at the end of statement, at the end of transaction and locks are released explicitly.</p>
<p>Statement and transactional locks are locks with automatic scope. They are accumulated in the course of a transaction, and released either at the end of uppermost statement (for statement locks) or on COMMIT, ROLLBACK or ROLLBACK TO SAVEPOINT (for transactional locks). They must not be (and never are) released manually, i.e. with <a class="el" href="class_m_d_l__context.html#a58d0df5eb422cbfa9a4225218c76141f">release_lock()</a> call.</p>
<p>Locks with explicit duration are taken for locks that span multiple transactions or savepoints. These are: HANDLER SQL locks (HANDLER SQL is transaction-agnostic), LOCK TABLES locks (you can COMMIT/etc under LOCK TABLES, and the locked tables stay locked), and locks implementing "global read lock".</p>
<p>Statement/transactional locks are always prepended to the beginning of the appropriate list. In other words, they are stored in reverse temporal order. Thus, when we rollback to a savepoint, we start popping and releasing tickets from the front until we reach the last ticket acquired after the savepoint.</p>
<p>Locks with explicit duration stored are not stored in any particular order, and among each other can be split into three sets:</p>
<p>[LOCK TABLES locks] [HANDLER locks] [GLOBAL READ LOCK locks]</p>
<p>The following is known about these sets:</p>
<p>GLOBAL READ LOCK locks are always stored after LOCK TABLES locks and after HANDLER locks. This is because one can't say SET GLOBAL read_only=1 or FLUSH TABLES WITH READ LOCK if one has locked tables. One can, however, LOCK TABLES after having entered the read only mode. Note, that subsequent LOCK TABLES statement will unlock the previous set of tables, but not the GRL! There are no HANDLER locks after GRL locks because SET GLOBAL read_only performs a FLUSH TABLES WITH READ LOCK internally, and FLUSH TABLES, in turn, implicitly closes all open HANDLERs. However, one can open a few HANDLERs after entering the read only mode. LOCK TABLES locks include intention exclusive locks on involved schemas and global intention exclusive lock. </p>

</div>
</div>
<a id="aeaf51be6c5480bb1e718aea933f55d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf51be6c5480bb1e718aea933f55d9d">&#9670;&nbsp;</a></span>m_wait</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_d_l__wait.html">MDL_wait</a> MDL_context::m_wait</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If our request for a lock is scheduled, or aborted by the deadlock detector, the result is recorded in this class. </p>

</div>
</div>
<a id="acccb108b2dcf787b7f942b58382aafbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccb108b2dcf787b7f942b58382aafbf">&#9670;&nbsp;</a></span>m_waiting_for</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_d_l__wait__for__subgraph.html">MDL_wait_for_subgraph</a>* MDL_context::m_waiting_for</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell the deadlock detector what metadata lock or table definition cache entry this session is waiting for. In principle, this is redundant, as information can be found by inspecting waiting queues, but we'd very much like it to be readily available to the wait-for graph iterator. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="mdl_8h_source.html">mdl.h</a></li>
<li>sql/mdl.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

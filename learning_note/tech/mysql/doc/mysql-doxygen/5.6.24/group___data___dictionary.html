<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Data Dictionary</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Data Dictionary</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__deadlock__handler.html">MDL_deadlock_handler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9103f1fde040b45e171c6df146d812f1"><td class="memItemLeft" align="right" valign="top"><a id="ga9103f1fde040b45e171c6df146d812f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WRONG_GRANT</b>&#160;&#160;&#160;(<a class="el" href="class_field.html">Field</a>*) -1</td></tr>
<tr class="separator:ga9103f1fde040b45e171c6df146d812f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab014a92f1538e370072fd987e2257a12"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gab014a92f1538e370072fd987e2257a12">init_tdc_psi_keys</a> (void)</td></tr>
<tr class="separator:gab014a92f1538e370072fd987e2257a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aceb8cbcd95476d794dd383f35555e5"><td class="memItemLeft" align="right" valign="top"><a id="ga3aceb8cbcd95476d794dd383f35555e5"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>modify_slave_open_temp_tables</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, int inc)</td></tr>
<tr class="separator:ga3aceb8cbcd95476d794dd383f35555e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab721de91242bfd20abab6c96d7d766f8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gab721de91242bfd20abab6c96d7d766f8">check_and_update_table_version</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *table_share)</td></tr>
<tr class="separator:gab721de91242bfd20abab6c96d7d766f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b865efd9b4d772778f22c18afe1fc5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gae6b865efd9b4d772778f22c18afe1fc5">open_table_entry_fini</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="struct__entry.html">entry</a>)</td></tr>
<tr class="separator:gae6b865efd9b4d772778f22c18afe1fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0ee1005814f445715e7c0ef76cfaa45"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gaa0ee1005814f445715e7c0ef76cfaa45">auto_repair_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="separator:gaa0ee1005814f445715e7c0ef76cfaa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c819320983fcb25b416750b5cb7207d"><td class="memItemLeft" align="right" valign="top"><a id="ga1c819320983fcb25b416750b5cb7207d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_write_table_with_auto_increment</b> (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>)</td></tr>
<tr class="separator:ga1c819320983fcb25b416750b5cb7207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573a61a4f79b513f7c61fd0c58c45e53"><td class="memItemLeft" align="right" valign="top"><a id="ga573a61a4f79b513f7c61fd0c58c45e53"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_write_table_with_auto_increment_and_select</b> (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>)</td></tr>
<tr class="separator:ga573a61a4f79b513f7c61fd0c58c45e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14447807f2c88fa2a9dafd7a852a38e3"><td class="memItemLeft" align="right" valign="top"><a id="ga14447807f2c88fa2a9dafd7a852a38e3"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_write_table_auto_increment_not_first_in_pk</b> (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>)</td></tr>
<tr class="separator:ga14447807f2c88fa2a9dafd7a852a38e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac06f4a70130921244905b9325fb03e91"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gac06f4a70130921244905b9325fb03e91">create_table_def_key</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, char *key, const char *db_name, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, bool tmp_table)</td></tr>
<tr class="separator:gac06f4a70130921244905b9325fb03e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga352a69aae26f998d4cbbf1d1d4937349"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga352a69aae26f998d4cbbf1d1d4937349">get_table_def_key</a> (const <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, const char **key)</td></tr>
<tr class="separator:ga352a69aae26f998d4cbbf1d1d4937349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae612f5e3d874864273e839029d1da07c"><td class="memItemLeft" align="right" valign="top"><a id="gae612f5e3d874864273e839029d1da07c"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_key</b> (const uchar *<a class="el" href="structrecord.html">record</a>, size_t *length, my_bool not_used <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:gae612f5e3d874864273e839029d1da07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga077897cee2dfe84c9220a17e467036bd"><td class="memItemLeft" align="right" valign="top"><a id="ga077897cee2dfe84c9220a17e467036bd"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_free_entry</b> (<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:ga077897cee2dfe84c9220a17e467036bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f57ec544a178c11c18d6900e2dcf6c"><td class="memItemLeft" align="right" valign="top"><a id="gad9f57ec544a178c11c18d6900e2dcf6c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_init</b> (void)</td></tr>
<tr class="separator:gad9f57ec544a178c11c18d6900e2dcf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb94e7a0682741b06d662be41fae480f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gabb94e7a0682741b06d662be41fae480f">table_def_start_shutdown</a> (void)</td></tr>
<tr class="separator:gabb94e7a0682741b06d662be41fae480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b09d5446051abdac04bf96a4d6a0c12"><td class="memItemLeft" align="right" valign="top"><a id="ga8b09d5446051abdac04bf96a4d6a0c12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_free</b> (void)</td></tr>
<tr class="separator:ga8b09d5446051abdac04bf96a4d6a0c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb76a30ed423c4cb98689fcedae48c60"><td class="memItemLeft" align="right" valign="top"><a id="gabb76a30ed423c4cb98689fcedae48c60"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>cached_table_definitions</b> (void)</td></tr>
<tr class="separator:gabb76a30ed423c4cb98689fcedae48c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a949628c076eb6e613b819c5359e23"><td class="memItemLeft" align="right" valign="top"><a id="ga29a949628c076eb6e613b819c5359e23"></a>
<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_table_share</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, const char *key, uint key_length, uint db_flags, int *<a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, my_hash_value_type hash_value)</td></tr>
<tr class="separator:ga29a949628c076eb6e613b819c5359e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21126bfd056ca09418ebd69121d98ad3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga21126bfd056ca09418ebd69121d98ad3">get_table_share_with_discover</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, const char *key, uint key_length, uint db_flags, int *<a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, my_hash_value_type hash_value)</td></tr>
<tr class="separator:ga21126bfd056ca09418ebd69121d98ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f27eb7444d2cec48296785a54e229f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga0f27eb7444d2cec48296785a54e229f2">release_table_share</a> (<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:ga0f27eb7444d2cec48296785a54e229f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da69eeda10a9b209a7daccf71afeb48"><td class="memItemLeft" align="right" valign="top"><a id="ga0da69eeda10a9b209a7daccf71afeb48"></a>
<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_cached_table_share</b> (const char *db, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>)</td></tr>
<tr class="separator:ga0da69eeda10a9b209a7daccf71afeb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b0693677aeecf9a38e98f36d3d31eb"><td class="memItemLeft" align="right" valign="top"><a id="ga54b0693677aeecf9a38e98f36d3d31eb"></a>
<a class="el" href="structst__open__table__list.html">OPEN_TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>list_open_tables</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const char *db, const char *wild)</td></tr>
<tr class="separator:ga54b0693677aeecf9a38e98f36d3d31eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2849c2d4c8cec7a89054e0033a8707"><td class="memItemLeft" align="right" valign="top"><a id="gaff2849c2d4c8cec7a89054e0033a8707"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>intern_close_table</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:gaff2849c2d4c8cec7a89054e0033a8707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga055df8e4470e8dfd7f8b41f4402f6774"><td class="memItemLeft" align="right" valign="top"><a id="ga055df8e4470e8dfd7f8b41f4402f6774"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_io_cache</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ga055df8e4470e8dfd7f8b41f4402f6774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99dc771d6ccccf4f33a23fc7962035f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga99dc771d6ccccf4f33a23fc7962035f9">kill_delayed_threads_for_table</a> (<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:ga99dc771d6ccccf4f33a23fc7962035f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8504b9f30ae84e60749639a2d03bc0d0"><td class="memItemLeft" align="right" valign="top"><a id="ga8504b9f30ae84e60749639a2d03bc0d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>close_cached_tables</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, bool wait_for_refresh, ulong timeout)</td></tr>
<tr class="separator:ga8504b9f30ae84e60749639a2d03bc0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab247c23689b3ce8b377cde2cbc0e47ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gab247c23689b3ce8b377cde2cbc0e47ef">close_cached_connection_tables</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *connection)</td></tr>
<tr class="separator:gab247c23689b3ce8b377cde2cbc0e47ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec5ae1a68fd60a81532c4560500e318"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga7ec5ae1a68fd60a81532c4560500e318">mark_temp_tables_as_free_for_reuse</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga7ec5ae1a68fd60a81532c4560500e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cc536b80faf27a1017cf4ddcc988ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gae2cc536b80faf27a1017cf4ddcc988ad">mark_tmp_table_for_reuse</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:gae2cc536b80faf27a1017cf4ddcc988ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1466eeeedbb2386ac9d5f9950a0cbcd8"><td class="memItemLeft" align="right" valign="top"><a id="ga1466eeeedbb2386ac9d5f9950a0cbcd8"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>mark_used_tables_as_free_for_reuse</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ga1466eeeedbb2386ac9d5f9950a0cbcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889e504f17316df5db4d2a980b025398"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga889e504f17316df5db4d2a980b025398">close_open_tables</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga889e504f17316df5db4d2a980b025398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86713fadf907edf57606406a10c1f994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga86713fadf907edf57606406a10c1f994">close_all_tables_for_name</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share, bool remove_from_locked_tables, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *skip_table)</td></tr>
<tr class="separator:ga86713fadf907edf57606406a10c1f994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ded5accefd985fce6ed115038ea92f7"><td class="memItemLeft" align="right" valign="top"><a id="ga3ded5accefd985fce6ed115038ea92f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_thread_tables</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga3ded5accefd985fce6ed115038ea92f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52b8d7410875b0048421f9386b4b6bd"><td class="memItemLeft" align="right" valign="top"><a id="gac52b8d7410875b0048421f9386b4b6bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_thread_table</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> **table_ptr)</td></tr>
<tr class="separator:gac52b8d7410875b0048421f9386b4b6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331a3b18efa8e338963de6e3bfc86ccd"><td class="memItemLeft" align="right" valign="top"><a id="ga331a3b18efa8e338963de6e3bfc86ccd"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>tmpkeyval</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ga331a3b18efa8e338963de6e3bfc86ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4991367acddcb2b2a0edeb169029917"><td class="memItemLeft" align="right" valign="top"><a id="gaa4991367acddcb2b2a0edeb169029917"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>close_temporary_tables</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:gaa4991367acddcb2b2a0edeb169029917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98920037a85177667356d2364893271d"><td class="memItemLeft" align="right" valign="top"><a id="ga98920037a85177667356d2364893271d"></a>
<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_table_in_list</b> (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *TABLE_LIST::*<a class="el" href="structlink.html">link</a>, const char *db_name, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>)</td></tr>
<tr class="separator:ga98920037a85177667356d2364893271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fd9282bd88273d46fa3ae4fb07945c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gab0fd9282bd88273d46fa3ae4fb07945c">find_dup_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, bool check_alias)</td></tr>
<tr class="separator:gab0fd9282bd88273d46fa3ae4fb07945c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5095dfc37db0400dbc6cb9f5efb38951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga5095dfc37db0400dbc6cb9f5efb38951">unique_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, bool check_alias)</td></tr>
<tr class="separator:ga5095dfc37db0400dbc6cb9f5efb38951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62ea49fa4b58a38f20af4754928e1be"><td class="memItemLeft" align="right" valign="top"><a id="gaa62ea49fa4b58a38f20af4754928e1be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_non_unique_table_error</b> (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, const char *operation, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *duplicate)</td></tr>
<tr class="separator:gaa62ea49fa4b58a38f20af4754928e1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0734400e8b6f0dab464f0da0f177086b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga0734400e8b6f0dab464f0da0f177086b">find_temporary_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const char *db, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>)</td></tr>
<tr class="separator:ga0734400e8b6f0dab464f0da0f177086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d31aeecf54e9bf14d05fa8a6478b7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga4d31aeecf54e9bf14d05fa8a6478b7e0">find_temporary_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="separator:ga4d31aeecf54e9bf14d05fa8a6478b7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b087bb99ab090df96292f53805138c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga16b087bb99ab090df96292f53805138c">find_temporary_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const char *table_key, uint table_key_length)</td></tr>
<tr class="separator:ga16b087bb99ab090df96292f53805138c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5683a94b25579c456f2c9f55f9f9b35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gab5683a94b25579c456f2c9f55f9f9b35">drop_temporary_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, bool *is_trans)</td></tr>
<tr class="separator:gab5683a94b25579c456f2c9f55f9f9b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f62c19b7f434d061bee6a75402aca1"><td class="memItemLeft" align="right" valign="top"><a id="ga62f62c19b7f434d061bee6a75402aca1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_temporary_table</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, bool <a class="el" href="ha__innodb_8cc.html#acb549c4785c91921c339ba3f5180186b">free_share</a>, bool delete_table)</td></tr>
<tr class="separator:ga62f62c19b7f434d061bee6a75402aca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4998a4b0d6b30f4f9669a8c1169ef41d"><td class="memItemLeft" align="right" valign="top"><a id="ga4998a4b0d6b30f4f9669a8c1169ef41d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_temporary</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, bool <a class="el" href="ha__innodb_8cc.html#acb549c4785c91921c339ba3f5180186b">free_share</a>, bool delete_table)</td></tr>
<tr class="separator:ga4998a4b0d6b30f4f9669a8c1169ef41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f79c4227effeafa7bad8b4582682e9a"><td class="memItemLeft" align="right" valign="top"><a id="ga1f79c4227effeafa7bad8b4582682e9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>rename_temporary_table</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char *db, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>)</td></tr>
<tr class="separator:ga1f79c4227effeafa7bad8b4582682e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19a8c14e089f35b82dc7a2ded67ea4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gac19a8c14e089f35b82dc7a2ded67ea4b">wait_while_table_is_used</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, enum ha_extra_function function)</td></tr>
<tr class="separator:gac19a8c14e089f35b82dc7a2ded67ea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f2e6710ec001734614f4a11cde9f0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gac9f2e6710ec001734614f4a11cde9f0f">drop_open_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char *db_name, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>)</td></tr>
<tr class="separator:gac9f2e6710ec001734614f4a11cde9f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7967950b623499bad7a7fc81612e16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga0f7967950b623499bad7a7fc81612e16">check_if_table_exists</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, bool *exists)</td></tr>
<tr class="separator:ga0f7967950b623499bad7a7fc81612e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979ec8c30f96cf01aecf1f8bd3f3e1c0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga979ec8c30f96cf01aecf1f8bd3f3e1c0">open_table_get_mdl_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_open__table__context.html">Open_table_context</a> *ot_ctx, <a class="el" href="class_m_d_l__request.html">MDL_request</a> *mdl_request, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> **mdl_ticket)</td></tr>
<tr class="separator:ga979ec8c30f96cf01aecf1f8bd3f3e1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa2ecba52b01f35d1ad6aa39d4ce15e8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gafa2ecba52b01f35d1ad6aa39d4ce15e8">tdc_wait_for_old_version</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const char *db, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, ulong wait_timeout, uint deadlock_weight)</td></tr>
<tr class="separator:gafa2ecba52b01f35d1ad6aa39d4ce15e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43cb5a9ba1064a36db89ad5c4d645528"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, <a class="el" href="class_open__table__context.html">Open_table_context</a> *ot_ctx)</td></tr>
<tr class="separator:ga43cb5a9ba1064a36db89ad5c4d645528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4458592b1c4d9ed293e5b2033349c3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga4458592b1c4d9ed293e5b2033349c3fb">find_locked_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *list, const char *db, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>)</td></tr>
<tr class="separator:ga4458592b1c4d9ed293e5b2033349c3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8692f5ebd7f6483f1dcc576eb2346f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga8692f5ebd7f6483f1dcc576eb2346f52">find_table_for_mdl_upgrade</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const char *db, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, bool no_error)</td></tr>
<tr class="separator:ga8692f5ebd7f6483f1dcc576eb2346f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098cb47bbc8bbdb790fcf28c253ab2b6"><td class="memItemLeft" align="right" valign="top"><a id="ga098cb47bbc8bbdb790fcf28c253ab2b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign_new_table_id</b> (<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:ga098cb47bbc8bbdb790fcf28c253ab2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685212f9bc8829944db21b37f6912f77"><td class="memItemLeft" align="right" valign="top"><a id="ga685212f9bc8829944db21b37f6912f77"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>inject_reprepare</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga685212f9bc8829944db21b37f6912f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6d716c2b2fbaec9eb41e9e18c9bef3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga0d6d716c2b2fbaec9eb41e9e18c9bef3">check_and_update_routine_version</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp)</td></tr>
<tr class="separator:ga0d6d716c2b2fbaec9eb41e9e18c9bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a6db70d8b4bedd682115942e96b09e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga97a6db70d8b4bedd682115942e96b09e">tdc_open_view</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, const char *alias, const char *cache_key, uint cache_key_length, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:ga97a6db70d8b4bedd682115942e96b09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fe4cc1a004bb6b5f07556a182f945b"><td class="memItemLeft" align="right" valign="top"><a id="ga24fe4cc1a004bb6b5f07556a182f945b"></a>
thr_lock_type&#160;</td><td class="memItemRight" valign="bottom"><b>read_lock_type_for_table</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, bool routine_modifies_data)</td></tr>
<tr class="separator:ga24fe4cc1a004bb6b5f07556a182f945b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ccfe40b5eb69eade8b02ded8236a8e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gae6ccfe40b5eb69eade8b02ded8236a8e">open_and_process_routine</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy, bool has_prelocking_list, <a class="el" href="class_open__table__context.html">Open_table_context</a> *ot_ctx, bool *need_prelocking, bool *routine_modifies_data)</td></tr>
<tr class="separator:gae6ccfe40b5eb69eade8b02ded8236a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95f93d766dbbf44d6f7c5c4fe097d00d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga95f93d766dbbf44d6f7c5c4fe097d00d">open_and_process_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, LEX *lex, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, uint *counter, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy, bool has_prelocking_list, <a class="el" href="class_open__table__context.html">Open_table_context</a> *ot_ctx)</td></tr>
<tr class="separator:ga95f93d766dbbf44d6f7c5c4fe097d00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c019d8ad6321d2bdb56aa234a19e35"><td class="memItemLeft" align="right" valign="top"><a id="gae5c019d8ad6321d2bdb56aa234a19e35"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>schema_set_get_key</b> (const uchar *<a class="el" href="structrecord.html">record</a>, size_t *length, my_bool not_used <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:gae5c019d8ad6321d2bdb56aa234a19e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae06de7ce22001b035ca61edf2a3dea09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gae06de7ce22001b035ca61edf2a3dea09">lock_table_names</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *tables_start, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *tables_end, ulong lock_wait_timeout, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:gae06de7ce22001b035ca61edf2a3dea09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df9051caf61d5a335efeef069ac34ad"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga5df9051caf61d5a335efeef069ac34ad">open_tables_check_upgradable_mdl</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *tables_start, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *tables_end, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:ga5df9051caf61d5a335efeef069ac34ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e488af7a3f47be08fad22370de07c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **start, uint *counter, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr class="separator:ga59e488af7a3f47be08fad22370de07c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e7c03bbd0b12e11920783cd5161eef"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga26e7c03bbd0b12e11920783cd5161eef">check_lock_and_start_stmt</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="separator:ga26e7c03bbd0b12e11920783cd5161eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a68932d1c35b3fd820c99d185d7888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga86a68932d1c35b3fd820c99d185d7888">open_n_lock_single_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_l, thr_lock_type lock_type, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr class="memdesc:ga86a68932d1c35b3fd820c99d185d7888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open and lock one table.  <a href="#ga86a68932d1c35b3fd820c99d185d7888">More...</a><br /></td></tr>
<tr class="separator:ga86a68932d1c35b3fd820c99d185d7888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5263e110baf47c9fe2f820bc649be5"><td class="memItemLeft" align="right" valign="top"><a id="ga3b5263e110baf47c9fe2f820bc649be5"></a>
<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>open_ltable</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, thr_lock_type lock_type, uint lock_flags)</td></tr>
<tr class="separator:ga3b5263e110baf47c9fe2f820bc649be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f8435e686a352b75b449c7bcd4c82c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga38f8435e686a352b75b449c7bcd4c82c">open_and_lock_tables</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, bool derived, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr class="separator:ga38f8435e686a352b75b449c7bcd4c82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258e3d35dfa1dbef9586f6f3d6a76326"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga258e3d35dfa1dbef9586f6f3d6a76326">open_normal_and_derived_tables</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:ga258e3d35dfa1dbef9586f6f3d6a76326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44874f07fb6dca6eb396c66116429d14"><td class="memItemLeft" align="right" valign="top"><a id="ga44874f07fb6dca6eb396c66116429d14"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>mark_real_tables_as_free_for_reuse</b> (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="separator:ga44874f07fb6dca6eb396c66116429d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399ec28859bb54829b1cabbeed845f78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, uint count, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:ga399ec28859bb54829b1cabbeed845f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bec964ecaaa7270a429e664643b746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga92bec964ecaaa7270a429e664643b746">close_tables_for_reopen</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, const <a class="el" href="class_m_d_l__savepoint.html">MDL_savepoint</a> &amp;start_of_statement_svp)</td></tr>
<tr class="separator:ga92bec964ecaaa7270a429e664643b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35659d6f0f8a6d39ee3f3db7c233df52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga35659d6f0f8a6d39ee3f3db7c233df52">open_table_uncached</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const char *path, const char *db, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, bool add_to_temporary_tables_list, bool open_in_engine)</td></tr>
<tr class="separator:ga35659d6f0f8a6d39ee3f3db7c233df52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6730cd1feb3014042adbf998ca9203"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga2f6730cd1feb3014042adbf998ca9203">rm_temporary_table</a> (<a class="el" href="structhandlerton.html">handlerton</a> *base, const char *path)</td></tr>
<tr class="separator:ga2f6730cd1feb3014042adbf998ca9203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044868a73f17b68d36af2600a37afed6"><td class="memItemLeft" align="right" valign="top"><a id="ga044868a73f17b68d36af2600a37afed6"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>update_field_dependencies</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_field.html">Field</a> *field, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ga044868a73f17b68d36af2600a37afed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c68673b37e4f394de31ffe4ac80fcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gab5c68673b37e4f394de31ffe4ac80fcc">open_temporary_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="separator:gab5c68673b37e4f394de31ffe4ac80fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c1cb71807d09d53273048447abf301"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gac4c1cb71807d09d53273048447abf301">open_temporary_tables</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *tl_list)</td></tr>
<tr class="separator:gac4c1cb71807d09d53273048447abf301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427f4011fc0f3c9a72e24bbe1a655443"><td class="memItemLeft" align="right" valign="top"><a id="ga427f4011fc0f3c9a72e24bbe1a655443"></a>
static <a class="el" href="class_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_view</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, uint length, const char *item_name, <a class="el" href="class_item.html">Item</a> **ref, bool register_tree_change)</td></tr>
<tr class="separator:ga427f4011fc0f3c9a72e24bbe1a655443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2125b8337d0f3840f107bc3980c3f744"><td class="memItemLeft" align="right" valign="top"><a id="ga2125b8337d0f3840f107bc3980c3f744"></a>
static <a class="el" href="class_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_natural_join</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_ref, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, uint length, <a class="el" href="class_item.html">Item</a> **ref, bool register_tree_change, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **actual_table)</td></tr>
<tr class="separator:ga2125b8337d0f3840f107bc3980c3f744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3607b2bf7c5d8073f388bb12f42a2464"><td class="memItemLeft" align="right" valign="top"><a id="ga3607b2bf7c5d8073f388bb12f42a2464"></a>
<a class="el" href="class_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_table</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, uint length, bool allow_rowid, uint *cached_field_index_ptr)</td></tr>
<tr class="separator:ga3607b2bf7c5d8073f388bb12f42a2464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8826dc597c12ef7501738af9da70e90d"><td class="memItemLeft" align="right" valign="top"><a id="ga8826dc597c12ef7501738af9da70e90d"></a>
<a class="el" href="class_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_table_ref</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, uint length, const char *item_name, const char *db_name, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, <a class="el" href="class_item.html">Item</a> **ref, bool check_privileges, bool allow_rowid, uint *cached_field_index_ptr, bool register_tree_change, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **actual_table)</td></tr>
<tr class="separator:ga8826dc597c12ef7501738af9da70e90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga795c727f9014b6fd6d0eed974e26c5c3"><td class="memItemLeft" align="right" valign="top"><a id="ga795c727f9014b6fd6d0eed974e26c5c3"></a>
<a class="el" href="class_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_table_sef</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ga795c727f9014b6fd6d0eed974e26c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9247db04d273c378aab8d6e1daff7c"><td class="memItemLeft" align="right" valign="top"><a id="ga4e9247db04d273c378aab8d6e1daff7c"></a>
<a class="el" href="class_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_tables</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item__ident.html">Item_ident</a> *item, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *first_table, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *last_table, <a class="el" href="class_item.html">Item</a> **ref, find_item_error_report_type report_error, bool check_privileges, bool register_tree_change)</td></tr>
<tr class="separator:ga4e9247db04d273c378aab8d6e1daff7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a568dc8a852240a792309974498e53"><td class="memItemLeft" align="right" valign="top"><a id="gad8a568dc8a852240a792309974498e53"></a>
<a class="el" href="class_item.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>find_item_in_list</b> (<a class="el" href="class_item.html">Item</a> *find, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="structitems.html">items</a>, uint *counter, find_item_error_report_type report_error, enum_resolution_type *resolution)</td></tr>
<tr class="separator:gad8a568dc8a852240a792309974498e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7829391d90c080cebbd2ef415179e65b"><td class="memItemLeft" align="right" valign="top"><a id="ga7829391d90c080cebbd2ef415179e65b"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_if_string_in_list</b> (const char *find, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_string.html">String</a> &gt; *str_list)</td></tr>
<tr class="separator:ga7829391d90c080cebbd2ef415179e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab59f6a54c7e4f0c4f0bca9b030fde625"><td class="memItemLeft" align="right" valign="top"><a id="gab59f6a54c7e4f0c4f0bca9b030fde625"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_new_item_local_context</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item__ident.html">Item_ident</a> *item, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_ref)</td></tr>
<tr class="separator:gab59f6a54c7e4f0c4f0bca9b030fde625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24d86e270cafa0948c88e0263c6de67f"><td class="memItemLeft" align="right" valign="top"><a id="ga24d86e270cafa0948c88e0263c6de67f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>mark_common_columns</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_ref_1, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_ref_2, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_string.html">String</a> &gt; *using_fields, uint *found_using_fields)</td></tr>
<tr class="separator:ga24d86e270cafa0948c88e0263c6de67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43aae24b1aed0c36e6fb1b370e4be230"><td class="memItemLeft" align="right" valign="top"><a id="ga43aae24b1aed0c36e6fb1b370e4be230"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>store_natural_using_join_columns</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *natural_using_join, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_ref_1, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_ref_2, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_string.html">String</a> &gt; *using_fields, uint found_using_fields)</td></tr>
<tr class="separator:ga43aae24b1aed0c36e6fb1b370e4be230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72bcb0af6f38b4d3c27aa82d9916cc8a"><td class="memItemLeft" align="right" valign="top"><a id="ga72bcb0af6f38b4d3c27aa82d9916cc8a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>store_top_level_join_columns</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_ref, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *left_neighbor, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *right_neighbor)</td></tr>
<tr class="separator:ga72bcb0af6f38b4d3c27aa82d9916cc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fcf532997d6bad04324e5847dc48584"><td class="memItemLeft" align="right" valign="top"><a id="ga3fcf532997d6bad04324e5847dc48584"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>setup_natural_join_row_types</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *from_clause, <a class="el" href="struct_name__resolution__context.html">Name_resolution_context</a> *context)</td></tr>
<tr class="separator:ga3fcf532997d6bad04324e5847dc48584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34fa1840c6d201b60e6e9a7c2ed4675c"><td class="memItemLeft" align="right" valign="top"><a id="ga34fa1840c6d201b60e6e9a7c2ed4675c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>setup_wild</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *sum_func_list, uint wild_num)</td></tr>
<tr class="separator:ga34fa1840c6d201b60e6e9a7c2ed4675c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a4772fb39984086378ab04521264f0"><td class="memItemLeft" align="right" valign="top"><a id="gaa7a4772fb39984086378ab04521264f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setup_fields</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, enum_mark_columns mark_used_columns, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *sum_func_list, bool allow_sum_func)</td></tr>
<tr class="separator:gaa7a4772fb39984086378ab04521264f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64373a3f8c4719f908ffc114c6d410c"><td class="memItemLeft" align="right" valign="top"><a id="gac64373a3f8c4719f908ffc114c6d410c"></a>
<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>make_leaves_list</b> (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **list, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>)</td></tr>
<tr class="separator:gac64373a3f8c4719f908ffc114c6d410c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga246a04773028f8776103a747a94d4c19"><td class="memItemLeft" align="right" valign="top"><a id="ga246a04773028f8776103a747a94d4c19"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setup_tables</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_name__resolution__context.html">Name_resolution_context</a> *context, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *from_clause, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **leaves, bool select_insert)</td></tr>
<tr class="separator:ga246a04773028f8776103a747a94d4c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cbd71e573571827be66b1314f50827f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga1cbd71e573571827be66b1314f50827f">setup_tables_and_check_access</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_name__resolution__context.html">Name_resolution_context</a> *context, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *from_clause, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **leaves, bool select_insert, ulong want_access_first, ulong want_access)</td></tr>
<tr class="separator:ga1cbd71e573571827be66b1314f50827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed6f7a411697a21f8e57aee4e40dcc9"><td class="memItemLeft" align="right" valign="top"><a id="ga3ed6f7a411697a21f8e57aee4e40dcc9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insert_fields</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_name__resolution__context.html">Name_resolution_context</a> *context, const char *db_name, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, <a class="el" href="class_list__iterator.html">List_iterator</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *it, bool any_privileges)</td></tr>
<tr class="separator:ga3ed6f7a411697a21f8e57aee4e40dcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e628d6e5bb1c49fc6c885b85adfc489"><td class="memItemLeft" align="right" valign="top"><a id="ga9e628d6e5bb1c49fc6c885b85adfc489"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>setup_conds</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *leaves, <a class="el" href="class_item.html">Item</a> **conds)</td></tr>
<tr class="separator:ga9e628d6e5bb1c49fc6c885b85adfc489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a8650491e7b1b416b0a6864721a2458"><td class="memItemLeft" align="right" valign="top"><a id="ga1a8650491e7b1b416b0a6864721a2458"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_record</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;values, bool ignore_errors, <a class="el" href="structst__bitmap.html">MY_BITMAP</a> *bitmap)</td></tr>
<tr class="separator:ga1a8650491e7b1b416b0a6864721a2458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba4b3e68ad8c8e28445ebb8fb181ae7"><td class="memItemLeft" align="right" valign="top"><a id="ga2ba4b3e68ad8c8e28445ebb8fb181ae7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_record_n_invoke_before_triggers</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;values, bool ignore_errors, <a class="el" href="class_table__triggers__list.html">Table_triggers_list</a> *triggers, enum trg_event_type <a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="separator:ga2ba4b3e68ad8c8e28445ebb8fb181ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf">fill_record</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_field.html">Field</a> **ptr, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;values, bool ignore_errors, <a class="el" href="structst__bitmap.html">MY_BITMAP</a> *bitmap)</td></tr>
<tr class="separator:gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga083df16f298e6e3257a7449c086f2222"><td class="memItemLeft" align="right" valign="top"><a id="ga083df16f298e6e3257a7449c086f2222"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_record_n_invoke_before_triggers</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_field.html">Field</a> **ptr, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;values, bool ignore_errors, <a class="el" href="class_table__triggers__list.html">Table_triggers_list</a> *triggers, enum trg_event_type <a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="separator:ga083df16f298e6e3257a7449c086f2222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadded8328656d64a663d994979a50b956"><td class="memItemLeft" align="right" valign="top"><a id="gadded8328656d64a663d994979a50b956"></a>
my_bool&#160;</td><td class="memItemRight" valign="bottom"><b>mysql_rm_tmp_tables</b> (void)</td></tr>
<tr class="separator:gadded8328656d64a663d994979a50b956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae1459addd4c75ddbf76468ba9a26a6"><td class="memItemLeft" align="right" valign="top"><a id="gaaae1459addd4c75ddbf76468ba9a26a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tdc_flush_unused_tables</b> ()</td></tr>
<tr class="separator:gaaae1459addd4c75ddbf76468ba9a26a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8faf6c6118b6677394e14994ae614075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga8faf6c6118b6677394e14994ae614075">tdc_remove_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, enum_tdc_remove_table_type remove_type, const char *db, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, bool has_lock)</td></tr>
<tr class="separator:ga8faf6c6118b6677394e14994ae614075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481e7e276a23583989ab7fc28bf70928"><td class="memItemLeft" align="right" valign="top"><a id="ga481e7e276a23583989ab7fc28bf70928"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>setup_ftfuncs</b> (SELECT_LEX *select_lex)</td></tr>
<tr class="separator:ga481e7e276a23583989ab7fc28bf70928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f79de1da20c6d99638e79c46b1606ef"><td class="memItemLeft" align="right" valign="top"><a id="ga8f79de1da20c6d99638e79c46b1606ef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>init_ftfuncs</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, SELECT_LEX *select_lex, bool no_order)</td></tr>
<tr class="separator:ga8f79de1da20c6d99638e79c46b1606ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b26ffd4f5885a763dc68dccf87ae547"><td class="memItemLeft" align="right" valign="top"><a id="ga8b26ffd4f5885a763dc68dccf87ae547"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_equal</b> (const <a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, const <a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>)</td></tr>
<tr class="separator:ga8b26ffd4f5885a763dc68dccf87ae547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf149aa7c1952464ab621b3eb4a4f73d2"><td class="memItemLeft" align="right" valign="top"><a id="gaf149aa7c1952464ab621b3eb4a4f73d2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>open_system_tables_for_read</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, Open_tables_backup *backup)</td></tr>
<tr class="separator:gaf149aa7c1952464ab621b3eb4a4f73d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae2add5b186deba41c77685a8f19c90"><td class="memItemLeft" align="right" valign="top"><a id="gaeae2add5b186deba41c77685a8f19c90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_system_tables</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Open_tables_backup *backup)</td></tr>
<tr class="separator:gaeae2add5b186deba41c77685a8f19c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9467ef8e03a8afbe8b937d699a0537f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga9467ef8e03a8afbe8b937d699a0537f2">close_mysql_tables</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga9467ef8e03a8afbe8b937d699a0537f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f08738b93443c024318ecbcc739f6f1"><td class="memItemLeft" align="right" valign="top"><a id="ga7f08738b93443c024318ecbcc739f6f1"></a>
<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>open_system_table_for_update</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *one_table)</td></tr>
<tr class="separator:ga7f08738b93443c024318ecbcc739f6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga065f6a0326ab135938fb38fd371dace5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga065f6a0326ab135938fb38fd371dace5">open_log_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *one_table, Open_tables_backup *backup)</td></tr>
<tr class="separator:ga065f6a0326ab135938fb38fd371dace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f22fa867e1bb56d350834b5497c9d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga8f22fa867e1bb56d350834b5497c9d6d">close_log_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Open_tables_backup *backup)</td></tr>
<tr class="separator:ga8f22fa867e1bb56d350834b5497c9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc37b30f3c1c06eeef7d1661381f9a6"><td class="memItemLeft" align="right" valign="top"><a id="ga9dc37b30f3c1c06eeef7d1661381f9a6"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>MDL_deadlock_handler::handle_condition</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, uint sql_errno, const char *sqlstate, Sql_condition::enum_warning_level <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, const char *<a class="el" href="structmsg.html">msg</a>, <a class="el" href="class_sql__condition.html">Sql_condition</a> **cond_hdl)</td></tr>
<tr class="separator:ga9dc37b30f3c1c06eeef7d1661381f9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eaa3b1fdce29eac72028f96c55607d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga8eaa3b1fdce29eac72028f96c55607d3">Open_table_context::Open_table_context</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:ga8eaa3b1fdce29eac72028f96c55607d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35889f70c8719510fb76899cf9cf20b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gaf35889f70c8719510fb76899cf9cf20b">Open_table_context::request_backoff_action</a> (enum_open_table_action action_arg, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:gaf35889f70c8719510fb76899cf9cf20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade48892bc4607303f7f4d3d6df4c39de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gade48892bc4607303f7f4d3d6df4c39de">Open_table_context::recover_from_failed_open</a> ()</td></tr>
<tr class="separator:gade48892bc4607303f7f4d3d6df4c39de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d51adf9905616e57f7b572081f537ac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga4d51adf9905616e57f7b572081f537ac">DML_prelocking_strategy::handle_routine</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp, bool *need_prelocking)</td></tr>
<tr class="separator:ga4d51adf9905616e57f7b572081f537ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4041a333019fb1a8ffb4e3772f627cf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#gab4041a333019fb1a8ffb4e3772f627cf">DML_prelocking_strategy::handle_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr class="separator:gab4041a333019fb1a8ffb4e3772f627cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga757cc4c5e9baf4dfae041368257e46e4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga757cc4c5e9baf4dfae041368257e46e4">DML_prelocking_strategy::handle_view</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr class="separator:ga757cc4c5e9baf4dfae041368257e46e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184abc9edd096f92b5e6a95545871685"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga184abc9edd096f92b5e6a95545871685">Lock_tables_prelocking_strategy::handle_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr class="separator:ga184abc9edd096f92b5e6a95545871685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d0312d3f9e2abb42e91b74f045d79"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga7e0d0312d3f9e2abb42e91b74f045d79">Alter_table_prelocking_strategy::handle_routine</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp, bool *need_prelocking)</td></tr>
<tr class="separator:ga7e0d0312d3f9e2abb42e91b74f045d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga572cfaf98399c14ebe9e318b4197c6f5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga572cfaf98399c14ebe9e318b4197c6f5">Alter_table_prelocking_strategy::handle_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr class="separator:ga572cfaf98399c14ebe9e318b4197c6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da56b0df4158af2defc12e836983529"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga3da56b0df4158af2defc12e836983529">Alter_table_prelocking_strategy::handle_view</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Query_tables_list *prelocking_ctx, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr class="separator:ga3da56b0df4158af2defc12e836983529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga99c8e1e3e72cd74032d5f11c486911fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___data___dictionary.html#ga99c8e1e3e72cd74032d5f11c486911fd">LOCK_open</a></td></tr>
<tr class="separator:ga99c8e1e3e72cd74032d5f11c486911fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab60dca1b3b1af3495883d46a09c15158"><td class="memItemLeft" align="right" valign="top"><a id="gab60dca1b3b1af3495883d46a09c15158"></a>
static <a class="el" href="group___instrumentation__interface.html#gaab1542573f750448abe64c7dc3f3b819">PSI_mutex_key</a>&#160;</td><td class="memItemRight" valign="bottom"><b>key_LOCK_open</b></td></tr>
<tr class="separator:gab60dca1b3b1af3495883d46a09c15158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb159f64cc354aa5df114e242b98bc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___instrumentation__interface.html#ga71c1548fde9983df2427c2ddc97085a9">PSI_mutex_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>all_tdc_mutexes</b> []</td></tr>
<tr class="separator:gadbb159f64cc354aa5df114e242b98bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f89faf859f3162a4d7476410c4a69e"><td class="memItemLeft" align="right" valign="top"><a id="gaf3f89faf859f3162a4d7476410c4a69e"></a>
<a class="el" href="structst__hash.html">HASH</a>&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_cache</b></td></tr>
<tr class="separator:gaf3f89faf859f3162a4d7476410c4a69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a357928bde371591f69e67d651f291"><td class="memItemLeft" align="right" valign="top"><a id="ga99a357928bde371591f69e67d651f291"></a>
static <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>oldest_unused_share</b></td></tr>
<tr class="separator:ga99a357928bde371591f69e67d651f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae404dad30542c069f3db869c8cb4d5e6"><td class="memItemLeft" align="right" valign="top"><a id="gae404dad30542c069f3db869c8cb4d5e6"></a>
static <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_of_unused_share</b></td></tr>
<tr class="separator:gae404dad30542c069f3db869c8cb4d5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fae5a31806f204c88c228286fdbcacb"><td class="memItemLeft" align="right" valign="top"><a id="ga0fae5a31806f204c88c228286fdbcacb"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_inited</b> = false</td></tr>
<tr class="separator:ga0fae5a31806f204c88c228286fdbcacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d84d00803df58397d89f86a2610f67"><td class="memItemLeft" align="right" valign="top"><a id="ga09d84d00803df58397d89f86a2610f67"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_shutdown_in_progress</b> = false</td></tr>
<tr class="separator:ga09d84d00803df58397d89f86a2610f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41c271d6f3b49310f4797fcb8b40431"><td class="memItemLeft" align="right" valign="top"><a id="gad41c271d6f3b49310f4797fcb8b40431"></a>
static <a class="el" href="class_table__id.html">Table_id</a>&#160;</td><td class="memItemRight" valign="bottom"><b>last_table_id</b></td></tr>
<tr class="separator:gad41c271d6f3b49310f4797fcb8b40431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9133e87930df59fe74ca492acf5295f7"><td class="memItemLeft" align="right" valign="top"><a id="ga9133e87930df59fe74ca492acf5295f7"></a>
<a class="el" href="class_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>not_found_field</b> = (<a class="el" href="class_field.html">Field</a>*) 0x1</td></tr>
<tr class="separator:ga9133e87930df59fe74ca492acf5295f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba50986729b2cfd3be1c762e666d3d18"><td class="memItemLeft" align="right" valign="top"><a id="gaba50986729b2cfd3be1c762e666d3d18"></a>
<a class="el" href="class_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>view_ref_found</b> = (<a class="el" href="class_field.html">Field</a>*) 0x2</td></tr>
<tr class="separator:gaba50986729b2cfd3be1c762e666d3d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac130a94f4d55acec35aa42626af9f37f"><td class="memItemLeft" align="right" valign="top"><a id="gac130a94f4d55acec35aa42626af9f37f"></a>
<a class="el" href="class_item.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>not_found_item</b> = (<a class="el" href="class_item.html">Item</a>**) 0x1</td></tr>
<tr class="separator:gac130a94f4d55acec35aa42626af9f37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa0ee1005814f445715e7c0ef76cfaa45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0ee1005814f445715e7c0ef76cfaa45">&#9670;&nbsp;</a></span>auto_repair_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool auto_repair_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary routine which is used for performing automatical table repair. </p>

</div>
</div>
<a id="ga0d6d716c2b2fbaec9eb41e9e18c9bef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d6d716c2b2fbaec9eb41e9e18c9bef3">&#9670;&nbsp;</a></span>check_and_update_routine_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool check_and_update_routine_version </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares versions of a stored routine obtained from the sp cache and the version used at prepare.</p>
<p>If the new and the old values mismatch, invoke Metadata_version_observer. At prepared statement prepare, all <a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a> version values are NULL and we always have a mismatch. But there is no observer set in THD, and therefore no error is reported. Instead, we update the value in <a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a>, effectively recording the original version. At prepared statement execute, an observer may be installed. If there is a version mismatch, we push an error and return TRUE.</p>
<p>For conventional execution (no prepared statements), the observer is never installed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>used to report errors </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab721de91242bfd20abab6c96d7d766f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab721de91242bfd20abab6c96d7d766f8">&#9670;&nbsp;</a></span>check_and_update_table_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool check_and_update_table_version </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>table_share</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare metadata versions of an element obtained from the table definition cache and its corresponding node in the parse tree.</p>
<p>If the new and the old values mismatch, invoke Metadata_version_observer. At prepared statement prepare, all <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> version values are NULL and we always have a mismatch. But there is no observer set in THD, and therefore no error is reported. Instead, we update the value in the parse tree, effectively recording the original version. At prepared statement execute, an observer may be installed. If there is a version mismatch, we push an error and return TRUE.</p>
<p>For conventional execution (no prepared statements), the observer is never installed.</p>
<dl class="section see"><dt>See also</dt><dd>Execute_observer </dd>
<dd>
<a class="el" href="sql__prepare_8cc.html#a09a9e88eae130d1ce53ae9ce4d3d84b5">check_prepared_statement()</a> <a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a> see cases when an observer is installed </dd>
<dd>
<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html#a187525004d9f242ed0b6291d333ebea0">TABLE_LIST::is_table_ref_id_equal()</a> </dd>
<dd>
TABLE_SHARE::get_table_ref_id()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>used to report errors </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tables</td><td><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> instance created by the parser Metadata version information in this object is updated upon success. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_share</td><td>an element from the table definition cache</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>an error, which has been reported </td></tr>
    <tr><td class="paramname">FALSE</td><td>success, version in <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> has been updated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f7967950b623499bad7a7fc81612e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7967950b623499bad7a7fc81612e16">&#9670;&nbsp;</a></span>check_if_table_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool check_if_table_exists </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>exists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> that table exists in table definition cache, on disk or in some storage engine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table list element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exists</td><td>Out parameter which is set to TRUE if table exists and to FALSE otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function acquires LOCK_open internally.</dd>
<dd>
If there is no .FRM file for the table but it exists in one of engines (e.g. it was created on another node of NDB cluster) this function will fetch and create proper .FRM file for it.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Some error occurred </td></tr>
    <tr><td class="paramname">FALSE</td><td>No error. 'exists' out parameter set accordingly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26e7c03bbd0b12e11920783cd5161eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e7c03bbd0b12e11920783cd5161eef">&#9670;&nbsp;</a></span>check_lock_and_start_stmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool check_lock_and_start_stmt </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> that lock is ok for tables; Call start stmt if ok</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle. </td></tr>
    <tr><td class="paramname">prelocking_ctx</td><td>Prelocking context. </td></tr>
    <tr><td class="paramname">table_list</td><td>Table list element for table to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>- Ok. </td></tr>
    <tr><td class="paramname">TRUE</td><td>- Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86713fadf907edf57606406a10c1f994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86713fadf907edf57606406a10c1f994">&#9670;&nbsp;</a></span>close_all_tables_for_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_all_tables_for_name </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_from_locked_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>skip_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close all open instances of the table but keep the MDL lock.</p>
<p>Works both under LOCK TABLES and in the normal mode. Removes all closed instances of the table from the table cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">share</td><td>table share, but is just a handy way to access the table cache key</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_from_locked_tables</td><td>TRUE if the table is being dropped or renamed. In that case the documented behaviour is to implicitly remove the table from LOCK TABLES list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance that should be kept open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called with an X MDL lock on the table. </dd></dl>

</div>
</div>
<a id="gab247c23689b3ce8b377cde2cbc0e47ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab247c23689b3ce8b377cde2cbc0e47ef">&#9670;&nbsp;</a></span>close_cached_connection_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool close_cached_connection_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *&#160;</td>
          <td class="paramname"><em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close all tables which match specified connection string or if specified string is NULL, then any table with a connection string. </p>

</div>
</div>
<a id="ga8f22fa867e1bb56d350834b5497c9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f22fa867e1bb56d350834b5497c9d6d">&#9670;&nbsp;</a></span>close_log_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_log_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Open_tables_backup *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a log table. The last table opened by <a class="el" href="group___data___dictionary.html#ga065f6a0326ab135938fb38fd371dace5">open_log_table()</a> is closed, then the thread context is restored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">backup</td><td>[in] the context to restore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9467ef8e03a8afbe8b937d699a0537f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9467ef8e03a8afbe8b937d699a0537f2">&#9670;&nbsp;</a></span>close_mysql_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_mysql_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A helper function to close a mysql.* table opened in an auxiliary THD during bootstrap or in the main connection, when we know that there are no locks held by the connection due to a preceding implicit commit.</p>
<p>This function assumes that there is no statement transaction started for the operation itself, since mysql.* tables are not transactional and when they are used the binlog is off (DDL binlogging is always statement-based.</p>
<p>We need this function since we'd like to not just close the system table, but also release the metadata lock on it.</p>
<p>Note, that in LOCK TABLES mode this function does not release the metadata lock. But in this mode the table can be opened only if it is locked explicitly with LOCK TABLES. </p>

</div>
</div>
<a id="ga889e504f17316df5db4d2a980b025398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga889e504f17316df5db4d2a980b025398">&#9670;&nbsp;</a></span>close_open_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void close_open_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary function to close all tables in the open_tables list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It should not ordinarily be called directly. </dd></dl>

</div>
</div>
<a id="ga92bec964ecaaa7270a429e664643b746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92bec964ecaaa7270a429e664643b746">&#9670;&nbsp;</a></span>close_tables_for_reopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_tables_for_reopen </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_d_l__savepoint.html">MDL_savepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>start_of_statement_svp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare statement for reopening of tables and recalculation of set of prelocked tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tables</td><td><a class="el" href="class_list.html">List</a> of tables which we were trying to open and lock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_of_statement_svp</td><td>MDL savepoint which represents the set of metadata locks which the current transaction managed to acquire before execution of the current statement and to which we should revert before trying to reopen tables. NULL if no metadata locks were held and thus all metadata locks should be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac06f4a70130921244905b9325fb03e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac06f4a70130921244905b9325fb03e91">&#9670;&nbsp;</a></span>create_table_def_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint create_table_def_key </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tmp_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a table cache/table definition cache key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">key</td><td>Buffer for the key to be created (must be of size MAX_DBKEY_LENGTH). </td></tr>
    <tr><td class="paramname">db_name</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">tmp_table</td><td>Set if table is a tmp table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The table cache_key is created from: db_name + \0 table_name + \0</dd></dl>
<p>if the table is a tmp table, we add the following to make each tmp table unique on the slave:</p>
<p>4 bytes for master thread id 4 bytes pseudo thread id</p>
<dl class="section return"><dt>Returns</dt><dd>Length of key. </dd></dl>

</div>
</div>
<a id="gac9f2e6710ec001734614f4a11cde9f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9f2e6710ec001734614f4a11cde9f0f">&#9670;&nbsp;</a></span>drop_open_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drop_open_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a and drop a just created table in CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> ... SELECT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for the table to be dropped </td></tr>
    <tr><td class="paramname">db_name</td><td>Name of database for this table </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of this table</td></tr>
  </table>
  </dd>
</dl>
<p>This routine assumes that the table to be closed is open only by the calling thread, so we needn't wait until other threads close the table. It also assumes that the table is first in thd-&gt;open_ables and a data lock on it, if any, has been released. To sum up, it's tuned to work with CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> ... SELECT and CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> .. SELECT only. Note, that currently CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> ... SELECT is not supported under LOCK TABLES. This function, still, can be called in prelocked mode, e.g. if we do CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> .. SELECT f1(); </p>

</div>
</div>
<a id="gab5683a94b25579c456f2c9f55f9f9b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5683a94b25579c456f2c9f55f9f9b35">&#9670;&nbsp;</a></span>drop_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int drop_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drop a temporary table.</p>
<p>Try to locate the table in the list of thd-&gt;temporary_tables. If the table is found:</p><ul>
<li>if the table is being used by some outer statement, fail.</li>
<li>if the table is locked with LOCK TABLES or by prelocking, unlock it and remove it from the list of locked tables (THD::lock). Currently only transactional temporary tables are locked.</li>
<li>Close the temporary table, remove its .FRM</li>
<li>remove the table from the list of temporary tables</li>
</ul>
<p>This function is used to drop user temporary tables, as well as internal tables created in CREATE TEMPORARY <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> ... SELECT or ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a>. Even though part of the work done by this function is redundant when the table is internal, as long as we link both internal and user temporary tables into the same thd-&gt;temporary_tables list, it's impossible to tell here whether we're dealing with an internal or a user temporary table.</p>
<p>In is_trans out-parameter, we return the type of the table: either transactional (e.g. innodb) as TRUE or non-transactional (e.g. myisam) as FALSE.</p>
<p>This function assumes that table to be dropped was pre-opened using table list provided.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>the table was found and dropped successfully. </td></tr>
    <tr><td class="paramname">1</td><td>the table was not found in the list of temporary tables of this thread </td></tr>
    <tr><td class="paramname">-1</td><td>the table is in use by a outer query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf">&#9670;&nbsp;</a></span>fill_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fill_record </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__bitmap.html">MY_BITMAP</a> *&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill field buffer with values from <a class="el" href="class_field.html">Field</a> list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer on pointer to record </td></tr>
    <tr><td class="paramname">values</td><td>list of fields </td></tr>
    <tr><td class="paramname">ignore_errors</td><td>True if we should ignore errors </td></tr>
    <tr><td class="paramname">bitmap</td><td><a class="el" href="class_bitmap.html">Bitmap</a> over fields to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group___data___dictionary.html#gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf">fill_record()</a> may set table-&gt;auto_increment_field_not_null and a caller should make sure that it is reset after their last call to this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occured </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab0fd9282bd88273d46fa3ae4fb07945c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0fd9282bd88273d46fa3ae4fb07945c">&#9670;&nbsp;</a></span>find_dup_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a>* find_dup_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test that table is unique (It's only exists once in the table list)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">table</td><td>table which should be checked </td></tr>
    <tr><td class="paramname">table_list</td><td>list of tables </td></tr>
    <tr><td class="paramname">check_alias</td><td>whether to check tables' aliases</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: to exclude derived tables from check we use following mechanism: a) during derived table processing set THD::derived_tables_processing b) <a class="el" href="group___query___resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a> set SELECT::exclude_from_table_unique_test if THD::derived_tables_processing set. (we can't use JOIN::execute because for PS we perform only <a class="el" href="group___query___resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a>, but we can't set this flag in <a class="el" href="group___query___resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a> if we are not sure that we are in derived table processing loop, because multi-update call fix_fields() for some its items (which mean <a class="el" href="group___query___resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a> for subqueries) before unique_table call to detect which tables should be locked for write). c) find_dup_table skip all tables which belong to SELECT with SELECT::exclude_from_table_unique_test set. Also SELECT::exclude_from_table_unique_test used to exclude from check tables of main SELECT of multi-delete and multi-update</p>
<p>We also skip tables with TABLE_LIST::prelocking_placeholder set, because we want to allow SELECTs from them, and their modification will rise the error anyway.</p>
<p>TODO: when we will have table/view change detection we can do this check only once for PS/SP</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">!=0</td><td>found duplicate </td></tr>
    <tr><td class="paramname">0</td><td>if table is unique </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4458592b1c4d9ed293e5b2033349c3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4458592b1c4d9ed293e5b2033349c3fb">&#9670;&nbsp;</a></span>find_locked_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* find_locked_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find table in the list of open tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><a class="el" href="class_list.html">List</a> of <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> objects to be inspected. </td></tr>
    <tr><td class="paramname">db</td><td>Database name </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object found, 0 if no table found. </dd></dl>

</div>
</div>
<a id="ga8692f5ebd7f6483f1dcc576eb2346f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8692f5ebd7f6483f1dcc576eb2346f52">&#9670;&nbsp;</a></span>find_table_for_mdl_upgrade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* find_table_for_mdl_upgrade </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find instance of <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> with upgradable or exclusive metadata lock from the list of open tables, emit error if no such table found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table. </td></tr>
    <tr><td class="paramname">no_error</td><td>Don't emit error if no suitable <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance were found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function checks if the connection holds a global IX metadata lock. If no such lock is found, it is not safe to upgrade the lock and ER_TABLE_NOT_LOCKED_FOR_WRITE will be reported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance with MDL_SHARED_UPGRADABLE MDL_SHARED_NO_WRITE, MDL_SHARED_NO_READ_WRITE, or MDL_EXCLUSIVE metadata lock, NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga0734400e8b6f0dab464f0da0f177086b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0734400e8b6f0dab464f0da0f177086b">&#9670;&nbsp;</a></span>find_temporary_table() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* find_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find temporary table specified by database and table names in the THD::temporary_tables list.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga4d31aeecf54e9bf14d05fa8a6478b7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d31aeecf54e9bf14d05fa8a6478b7e0">&#9670;&nbsp;</a></span>find_temporary_table() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* find_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a temporary table specified by <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> instance in the THD::temporary_tables list.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga16b087bb99ab090df96292f53805138c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16b087bb99ab090df96292f53805138c">&#9670;&nbsp;</a></span>find_temporary_table() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* find_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_key_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a temporary table specified by a key in the THD::temporary_tables list.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga352a69aae26f998d4cbbf1d1d4937349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga352a69aae26f998d4cbbf1d1d4937349">&#9670;&nbsp;</a></span>get_table_def_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint get_table_def_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get table cache key for a table list element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_list[in]</td><td>Table list element. </td></tr>
    <tr><td class="paramname">key[out]</td><td>On return points to table cache key for the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlike <a class="el" href="group___data___dictionary.html#gac06f4a70130921244905b9325fb03e91">create_table_def_key()</a> call this function doesn't construct key in a buffer provider by caller. Instead it relies on the fact that table list element for which key is requested has properly initialized <a class="el" href="class_m_d_l__request.html">MDL_request</a> object and the fact that table definition cache key is suffix of key used in MDL subsystem. So to get table definition key it simply needs to return pointer to appropriate part of <a class="el" href="class_m_d_l__key.html">MDL_key</a> object nested in this table list element. Indeed, this means that lifetime of key produced by this call is limited by the lifetime of table list element which it got as parameter.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Length of key. </dd></dl>

</div>
</div>
<a id="ga21126bfd056ca09418ebd69121d98ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21126bfd056ca09418ebd69121d98ad3">&#9670;&nbsp;</a></span>get_table_share_with_discover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a>* get_table_share_with_discover </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>db_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">my_hash_value_type&#160;</td>
          <td class="paramname"><em>hash_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a table share. If it didn't exist, try creating it from engine</p>
<p>For arguments and return values, see get_table_share() </p>

</div>
</div>
<a id="ga4d51adf9905616e57f7b572081f537ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d51adf9905616e57f7b572081f537ac">&#9670;&nbsp;</a></span>handle_routine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DML_prelocking_strategy::handle_routine </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines how prelocking algorithm for DML statements should handle routines:</p><ul>
<li>For CALL statements we do unrolling (i.e. open and lock tables for each sub-statement individually). So for such statements prelocking is enabled only if stored functions are used in parameter list and only for period during which we calculate values of parameters. Thus in this strategy we ignore procedure which is directly called by such statement and extend the prelocking set only with tables/functions used by SF called from the parameter list.</li>
<li>For any other statement any routine which is directly or indirectly called by statement is going to be executed in prelocked mode. So in this case we simply add all tables and routines used by it to the prelocking set.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rt</td><td>Prelocking set element describing routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga7e0d0312d3f9e2abb42e91b74f045d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e0d0312d3f9e2abb42e91b74f045d79">&#9670;&nbsp;</a></span>handle_routine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Alter_table_prelocking_strategy::handle_routine </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines how prelocking algorithm for ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> statement should handle routines - do nothing as this statement is not supposed to call routines.</p>
<p>We still can end up in this method when someone tries to define a foreign key referencing a view, and not just a simple view, but one that uses stored routines. </p>

<p>Implements <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="gab4041a333019fb1a8ffb4e3772f627cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4041a333019fb1a8ffb4e3772f627cf">&#9670;&nbsp;</a></span>handle_table() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DML_prelocking_strategy::handle_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines how prelocking algorithm for DML statements should handle table list elements:</p><ul>
<li>If table has triggers we should add all tables and routines used by them to the prelocking set.</li>
</ul>
<p>We do not need to acquire metadata locks on trigger names in DML statements, since all DDL statements that change trigger metadata always lock their subject tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a>.</p>

<p>Reimplemented in <a class="el" href="group___data___dictionary.html#ga184abc9edd096f92b5e6a95545871685">Lock_tables_prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga184abc9edd096f92b5e6a95545871685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga184abc9edd096f92b5e6a95545871685">&#9670;&nbsp;</a></span>handle_table() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Lock_tables_prelocking_strategy::handle_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines how prelocking algorithm for LOCK TABLES statement should handle table list elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group___data___dictionary.html#gab4041a333019fb1a8ffb4e3772f627cf">DML_prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga572cfaf98399c14ebe9e318b4197c6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga572cfaf98399c14ebe9e318b4197c6f5">&#9670;&nbsp;</a></span>handle_table() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Alter_table_prelocking_strategy::handle_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines how prelocking algorithm for ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> statement should handle table list elements.</p>
<p>Unlike in DML, we do not process triggers here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga757cc4c5e9baf4dfae041368257e46e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga757cc4c5e9baf4dfae041368257e46e4">&#9670;&nbsp;</a></span>handle_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DML_prelocking_strategy::handle_view </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines how prelocking algorithm for DML statements should handle view - all view routines should be added to the prelocking set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for view. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga3da56b0df4158af2defc12e836983529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3da56b0df4158af2defc12e836983529">&#9670;&nbsp;</a></span>handle_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Alter_table_prelocking_strategy::handle_view </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines how prelocking algorithm for ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> statement should handle view - do nothing. We don't need to add view routines to the prelocking set in this case as view is not going to be materialized. </p>

<p>Implements <a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="gab014a92f1538e370072fd987e2257a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab014a92f1538e370072fd987e2257a12">&#9670;&nbsp;</a></span>init_tdc_psi_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void init_tdc_psi_keys </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize performance schema instrumentation points used by the table cache. </p>

</div>
</div>
<a id="ga99dc771d6ccccf4f33a23fc7962035f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99dc771d6ccccf4f33a23fc7962035f9">&#9670;&nbsp;</a></span>kill_delayed_threads_for_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void kill_delayed_threads_for_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary function which allows to kill delayed threads for particular table identified by its share.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">share</td><td>Table share.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Caller should own locks on all <a class="el" href="class_table__cache.html">Table_cache</a> instances. </dd></dl>

</div>
</div>
<a id="gae06de7ce22001b035ca61edf2a3dea09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae06de7ce22001b035ca61edf2a3dea09">&#9670;&nbsp;</a></span>lock_table_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lock_table_names </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire upgradable (SNW, SNRW) metadata locks on tables used by LOCK TABLES or by a DDL statement. Acquire lock "S" on table being created in CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> statement.</p>
<dl class="section note"><dt>Note</dt><dd>Under LOCK TABLES, we can't take new locks, so use <a class="el" href="group___data___dictionary.html#ga5df9051caf61d5a335efeef069ac34ad">open_tables_check_upgradable_mdl()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables_start</td><td>Start of list of tables on which upgradable locks should be acquired. </td></tr>
    <tr><td class="paramname">tables_end</td><td>End of list of tables. </td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>Seconds to wait before timeout. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="class_bitmap.html">Bitmap</a> of flags to modify how the tables will be open, see <a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> description for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (e.g. connection was killed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga399ec28859bb54829b1cabbeed845f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399ec28859bb54829b1cabbeed845f78">&#9670;&nbsp;</a></span>lock_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lock_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock all tables in a list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Tables to lock </td></tr>
    <tr><td class="paramname">count</td><td>Number of opened tables </td></tr>
    <tr><td class="paramname">flags</td><td>Options (see <a class="el" href="group___locking.html#ga3a5f18c7a05b36a6e93c1d8e33cece78">mysql_lock_tables()</a> for details)</td></tr>
  </table>
  </dd>
</dl>
<p>You can't call <a class="el" href="group___data___dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables()</a> while holding thr_lock locks, as this would break the dead-lock-free handling thr_lock gives us. You must always get all needed locks at once.</p>
<p>If the query for which we are calling this function is marked as requiring prelocking, this function will change locked_tables_mode to LTM_PRELOCKED.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>A lock wait timeout, deadlock or out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ec5ae1a68fd60a81532c4560500e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ec5ae1a68fd60a81532c4560500e318">&#9670;&nbsp;</a></span>mark_temp_tables_as_free_for_reuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mark_temp_tables_as_free_for_reuse </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mark all temporary tables which were used by the current statement or substatement as free for reuse, but only if the query_id can be cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For temp tables associated with a open SQL HANDLER the query_id is not reset until the HANDLER is closed. </dd></dl>

</div>
</div>
<a id="gae2cc536b80faf27a1017cf4ddcc988ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2cc536b80faf27a1017cf4ddcc988ad">&#9670;&nbsp;</a></span>mark_tmp_table_for_reuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark_tmp_table_for_reuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset a single temporary table. Effectively this "closes" one temporary table, in a session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Temporary table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38f8435e686a352b75b449c7bcd4c82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38f8435e686a352b75b449c7bcd4c82c">&#9670;&nbsp;</a></span>open_and_lock_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_and_lock_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open all tables in list, locks them and optionally process derived tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables</td><td><a class="el" href="class_list.html">List</a> of tables for open and locking. </td></tr>
    <tr><td class="paramname">derived</td><td>If to handle derived tables. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="class_bitmap.html">Bitmap</a> of options to be used to open and lock tables (see <a class="el" href="group___data___dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables()</a> and <a class="el" href="group___locking.html#ga3a5f18c7a05b36a6e93c1d8e33cece78">mysql_lock_tables()</a> for details). </td></tr>
    <tr><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The thr_lock locks will automatically be freed by close_thread_tables().</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6ccfe40b5eb69eade8b02ded8236a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ccfe40b5eb69eade8b02ded8236a8e">&#9670;&nbsp;</a></span>open_and_process_routine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool open_and_process_routine </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_prelocking_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>routine_modifies_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We add trigger entries to lex-&gt;sroutines_list, but we don't load them here. The trigger entry is only used when building a transitive closure of objects used in a statement, to avoid adding to this closure objects that are used in the trigger more than once. E.g. if a trigger trg refers to table t2, and the trigger table t1 is used multiple times in the statement (say, because it's used in function f1() twice), we will only add t2 once to the list of tables to prelock.</p>
<p>We don't take metadata locks on triggers either: they are protected by a respective lock on the table, on which the trigger is defined.</p>
<p>The only two cases which give "trouble" are SHOW CREATE TRIGGER and DROP TRIGGER statements. For these, statement syntax doesn't specify the table on which this trigger is defined, so we have to make a "dirty" read in the data dictionary to find out the table name. Once we discover the table name, we take a metadata lock on it, and this protects all trigger operations. Of course the table, in theory, may disappear between the dirty read and metadata lock acquisition, but in that case we just return a run-time error.</p>
<p>Grammar of other trigger DDL statements (CREATE, DROP) requires the table to be specified explicitly, so we use the table metadata lock to protect trigger metadata in these statements. Similarly, in DML we always use triggers together with their tables, and thus don't need to take separate metadata locks on them.</p>

</div>
</div>
<a id="ga95f93d766dbbf44d6f7c5c4fe097d00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95f93d766dbbf44d6f7c5c4fe097d00d">&#9670;&nbsp;</a></span>open_and_process_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool open_and_process_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_prelocking_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Handle table list element by obtaining metadata lock, opening table or view and, if prelocking strategy prescribes so, extending the prelocking set with tables and routines used by it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lex</td><td>LEX structure for statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tables</td><td>Table list element to be processed. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counter</td><td>Number of tables which are open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td><a class="el" href="class_bitmap.html">Bitmap</a> of flags to modify how the tables will be open, see <a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> description for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how the prelocking set should be extended when table or view is processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">has_prelocking_list</td><td>Indicates that prelocking set/list for this statement has already been built. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ot_ctx</td><td>Context used to recover from a failed <a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error, reported unless there is a chance to recover from it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga065f6a0326ab135938fb38fd371dace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga065f6a0326ab135938fb38fd371dace5">&#9670;&nbsp;</a></span>open_log_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* open_log_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>one_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Open_tables_backup *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a log table. Opening such tables is performed internally in the server implementation, and is a 'nested' open, since some tables might be already opened by the current thread. The thread context before this call is saved, and is restored when calling <a class="el" href="group___data___dictionary.html#ga8f22fa867e1bb56d350834b5497c9d6d">close_log_table()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">one_table</td><td>Log table to open </td></tr>
    <tr><td class="paramname">backup</td><td>[out] Temporary storage used to save the thread context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86a68932d1c35b3fd820c99d185d7888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86a68932d1c35b3fd820c99d185d7888">&#9670;&nbsp;</a></span>open_n_lock_single_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* open_n_lock_single_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open and lock one table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_l</td><td>table to open is first table in this list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_type</td><td>lock to use for table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>options to be used while opening and locking table (see <a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a>, <a class="el" href="group___locking.html#ga3a5f18c7a05b36a6e93c1d8e33cece78">mysql_lock_tables()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">!=</td><td>NULL OK, opened table returned </td></tr>
    <tr><td class="paramname">NULL</td><td>Error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If ok, the following are also set: table_list-&gt;lock_type lock_type table_list-&gt;table table</dd>
<dd>
If table_l is a list, not a single table, the list is temporarily broken.</dd></dl>
<p>This function is meant as a replacement for open_ltable() when MERGE tables can be opened. open_ltable() cannot open MERGE tables.</p>
<p>There may be more differences between <a class="el" href="group___data___dictionary.html#ga86a68932d1c35b3fd820c99d185d7888" title="Open and lock one table. ">open_n_lock_single_table()</a> and open_ltable(). One known difference is that open_ltable() does neither call thd-&gt;decide_logging_format() nor handle some other logging and locking issues because it does not call <a class="el" href="group___data___dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables()</a>. </p>

</div>
</div>
<a id="ga258e3d35dfa1dbef9586f6f3d6a76326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258e3d35dfa1dbef9586f6f3d6a76326">&#9670;&nbsp;</a></span>open_normal_and_derived_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_normal_and_derived_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open all tables in list and process derived tables</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>list of tables for open </td></tr>
    <tr><td class="paramname">flags</td><td>bitmap of flags to modify how the tables will be open: MYSQL_LOCK_IGNORE_FLUSH - open table even if someone has done a flush on it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- ok </td></tr>
    <tr><td class="paramname">true</td><td>- error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is to be used on prepare stage when you don't read any data from the tables.</dd>
<dd>
Updates Query_tables_list::table_count as side-effect. </dd></dl>

</div>
</div>
<a id="ga43cb5a9ba1064a36db89ad5c4d645528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43cb5a9ba1064a36db89ad5c4d645528">&#9670;&nbsp;</a></span>open_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a base table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">table_list</td><td>Open first table in list. </td></tr>
    <tr><td class="paramname">ot_ctx</td><td>Context with flags which modify how open works and which is used to recover from a failed <a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> attempt. Some examples of flags: MYSQL_OPEN_IGNORE_FLUSH - Open table even if someone has done a flush. No version number checking is done. MYSQL_OPEN_HAS_MDL_LOCK - instead of acquiring metadata locks rely on that caller already has appropriate ones.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses a cache of open tables to find a <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance not in use.</p>
<p>If <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html#a61f69375c1e80e14b773d1f406189237">TABLE_LIST::open_strategy</a> is set to OPEN_IF_EXISTS, the table is opened only if it exists. If the open strategy is OPEN_STUB, the underlying table is never opened. In both cases, metadata locks are always taken according to the lock strategy.</p>
<p>The function used to open temporary tables, but now it opens base tables only.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Open failed. "action" parameter may contain type of action needed to remedy problem before retrying again. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Success. Members of <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> structure are filled properly (e.g. TABLE_LIST::table is set for real tables and TABLE_LIST::view is set for views). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8eaa3b1fdce29eac72028f96c55607d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eaa3b1fdce29eac72028f96c55607d3">&#9670;&nbsp;</a></span>Open_table_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Open_table_context::Open_table_context </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_open__table__context.html">Open_table_context</a> </p>

</div>
</div>
<a id="gae6b865efd9b4d772778f22c18afe1fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b865efd9b4d772778f22c18afe1fc5">&#9670;&nbsp;</a></span>open_table_entry_fini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool open_table_entry_fini </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finalize the process of <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> creation by loading table triggers and taking action if a HEAP table content was emptied implicitly. </p>

</div>
</div>
<a id="ga979ec8c30f96cf01aecf1f8bd3f3e1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979ec8c30f96cf01aecf1f8bd3f3e1c0">&#9670;&nbsp;</a></span>open_table_get_mdl_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool open_table_get_mdl_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>mdl_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> **&#160;</td>
          <td class="paramname"><em>mdl_ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to acquire an MDL lock for a table being opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thd</td><td>Session context, to report errors. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ot_ctx</td><td>Open table context, to hold the back off state. If we failed to acquire a lock due to a lock conflict, we add the failed request to the open table context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mdl_request</td><td>A request for an MDL lock. If we managed to acquire a ticket (no errors or lock conflicts occurred), contains a reference to it on return. However, is not modified if MDL lock type- modifying flags were provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>flags MYSQL_OPEN_FORCE_SHARED_MDL, MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL or MYSQL_OPEN_FAIL_ON_MDL_CONFLICT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mdl_ticket</td><td>Only modified if there was no error. If we managed to acquire an MDL lock, contains a reference to the ticket, otherwise is set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>An error occurred. </td></tr>
    <tr><td class="paramname">FALSE</td><td>No error, but perhaps a lock conflict, check mdl_ticket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35659d6f0f8a6d39ee3f3db7c233df52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35659d6f0f8a6d39ee3f3db7c233df52">&#9670;&nbsp;</a></span>open_table_uncached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* open_table_uncached </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_to_temporary_tables_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>open_in_engine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a single table without table caching and don't add it to THD::open_tables. Depending on the 'add_to_temporary_tables_list' value, the opened <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance will be addded to THD::temporary_tables list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">path</td><td>Path (without .frm) </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">add_to_temporary_tables_list</td><td>Specifies if the opened <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance should be linked into THD::temporary_tables list. </td></tr>
    <tr><td class="paramname">open_in_engine</td><td>Indicates that we need to open table in storage engine in addition to constructing <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is used:<ul>
<li>by alter_table() to open a temporary table;</li>
<li>when creating a temporary table with CREATE TEMPORARY <a class="el" href="struct_t_a_b_l_e.html">TABLE</a>.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance for opened table. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59e488af7a3f47be08fad22370de07c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e488af7a3f47be08fad22370de07c5">&#9670;&nbsp;</a></span>open_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_prelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open all tables in list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">start</td><td><a class="el" href="class_list.html">List</a> of tables to be open (it can be adjusted for statement that uses tables only implicitly, e.g. for "SELECT f1()"). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter</td><td>Number of tables which were open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td><a class="el" href="class_bitmap.html">Bitmap</a> of flags to modify how the tables will be open, see <a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> description for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unless we are already in prelocked mode and prelocking strategy prescribes so this function will also precache all SP/SFs explicitly or implicitly (via views and triggers) used by the query and add tables needed for their execution to table list. Statement that uses SFs, invokes triggers or requires foreign key checks will be marked as requiring prelocking. Prelocked mode will be enabled for such query during <a class="el" href="group___data___dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables()</a> call.</dd></dl>
<p>If query for which we are opening tables is already marked as requiring prelocking it won't do such precaching and will simply reuse table list which is already built.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error, reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5df9051caf61d5a335efeef069ac34ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5df9051caf61d5a335efeef069ac34ad">&#9670;&nbsp;</a></span>open_tables_check_upgradable_mdl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool open_tables_check_upgradable_mdl </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> for upgradable (SNW, SNRW) metadata locks on tables to be opened for a DDL statement. Under LOCK TABLES, we can't take new locks, so we must check if appropriate locks were pre-acquired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables_start</td><td>Start of list of tables on which upgradable locks should be searched for. </td></tr>
    <tr><td class="paramname">tables_end</td><td>End of list of tables. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="class_bitmap.html">Bitmap</a> of flags to modify how the tables will be open, see <a class="el" href="group___data___dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> description for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (e.g. connection was killed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab5c68673b37e4f394de31ffe4ac80fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c68673b37e4f394de31ffe4ac80fcc">&#9670;&nbsp;</a></span>open_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a temporary table specified by <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> instance in the cache and prepare its <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance for use.</p>
<p>This function tries to resolve this table in the list of temporary tables of this thread. Temporary tables are thread-local and "shadow" base tables with the same name.</p>
<dl class="section note"><dt>Note</dt><dd>In most cases one should use <a class="el" href="group___data___dictionary.html#gac4c1cb71807d09d53273048447abf301">open_temporary_tables()</a> instead of this call.</dd>
<dd>
One should finalize process of opening temporary table for table list element by calling <a class="el" href="group___data___dictionary.html#ga95f93d766dbbf44d6f7c5c4fe097d00d">open_and_process_table()</a>. This function is responsible for table version checking and handling of merge tables.</dd>
<dd>
We used to check global_read_lock before opening temporary tables. However, that limitation was artificial and is removed now.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>On success. If a temporary table exists for the given key, tl-&gt;table is set. </td></tr>
    <tr><td class="paramname">TRUE</td><td>On error. my_error() has been called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4c1cb71807d09d53273048447abf301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c1cb71807d09d53273048447abf301">&#9670;&nbsp;</a></span>open_temporary_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_temporary_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pre-open temporary tables corresponding to table list elements.</p>
<dl class="section note"><dt>Note</dt><dd>One should finalize process of opening temporary tables by calling <a class="el" href="group___data___dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables()</a>. This function is responsible for table version checking and handling of merge tables.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>On success. If a temporary tables exists for the given element, tl-&gt;table is set. </td></tr>
    <tr><td class="paramname">TRUE</td><td>On error. my_error() has been called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade48892bc4607303f7f4d3d6df4c39de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade48892bc4607303f7f4d3d6df4c39de">&#9670;&nbsp;</a></span>recover_from_failed_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Open_table_context::recover_from_failed_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recover from failed attempt of open table by performing requested action.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function should be called only with "action" != OT_NO_ACTION and after having called </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___data___dictionary.html#ga92bec964ecaaa7270a429e664643b746">close_tables_for_reopen()</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>- Success. One should try to open tables once again. </td></tr>
    <tr><td class="paramname">TRUE</td><td>- Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f27eb7444d2cec48296785a54e229f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f27eb7444d2cec48296785a54e229f2">&#9670;&nbsp;</a></span>release_table_share()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void release_table_share </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark that we are not using table share anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">share</td><td>Table share</td></tr>
  </table>
  </dd>
</dl>
<p>If the share has no open tables and (we have done a refresh or if we have already too many open table shares) then delete the definition. </p>

</div>
</div>
<a id="gaf35889f70c8719510fb76899cf9cf20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf35889f70c8719510fb76899cf9cf20b">&#9670;&nbsp;</a></span>request_backoff_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Open_table_context::request_backoff_action </td>
          <td>(</td>
          <td class="paramtype">enum_open_table_action&#160;</td>
          <td class="paramname"><em>action_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if we can back-off and set back off action if we can. Otherwise report and return error.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if back-off is impossible. </td></tr>
    <tr><td class="paramname">FALSE</td><td>if we can back off. Back off action has been set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f6730cd1feb3014042adbf998ca9203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6730cd1feb3014042adbf998ca9203">&#9670;&nbsp;</a></span>rm_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rm_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a temporary table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Handlerton for table to be deleted. </td></tr>
    <tr><td class="paramname">path</td><td>Path to the table to be deleted (i.e. path to its .frm without an extension).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- success. </td></tr>
    <tr><td class="paramname">true</td><td>- failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cbd71e573571827be66b1314f50827f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cbd71e573571827be66b1314f50827f">&#9670;&nbsp;</a></span>setup_tables_and_check_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setup_tables_and_check_access </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_name__resolution__context.html">Name_resolution_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>from_clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>select_insert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>want_access_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>want_access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare tables and check access for the view tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">context</td><td>Name resolution contest to setup table list there. </td></tr>
    <tr><td class="paramname">from_clause</td><td>Top-level list of table references in the FROM clause. </td></tr>
    <tr><td class="paramname">tables</td><td>Table list (select_lex-&gt;table_list). </td></tr>
    <tr><td class="paramname">leaves[in/out]</td><td><a class="el" href="class_list.html">List</a> of join table leaves list (select_lex-&gt;leaf_tables). </td></tr>
    <tr><td class="paramname">select_insert</td><td>It is SELECT ... INSERT command/ </td></tr>
    <tr><td class="paramname">want_access_first</td><td>What access is requested of the first leaf. </td></tr>
    <tr><td class="paramname">want_access</td><td>What access is requested on the rest of leaves.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A wrapper for check_tables that will also check the resulting table leaves list for access to all the tables that belong to a view.</dd>
<dd>
Beware that it can't properly check privileges in cases when table being changed is not the first table in the list of leaf tables (for example, for multi-UPDATE).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>- Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>- Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb94e7a0682741b06d662be41fae480f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb94e7a0682741b06d662be41fae480f">&#9670;&nbsp;</a></span>table_def_start_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void table_def_start_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notify table definition cache that process of shutting down server has started so it has to keep number of <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> objects minimal in order to reduce number of references to pluggable engines. </p>

</div>
</div>
<a id="ga97a6db70d8b4bedd682115942e96b09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97a6db70d8b4bedd682115942e96b09e">&#9670;&nbsp;</a></span>tdc_open_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tdc_open_view </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>cache_key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open view by getting its definition from disk (and table cache in future).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">table_list</td><td><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> with db, table_name &amp; belong_to_view </td></tr>
    <tr><td class="paramname">alias</td><td>Alias name </td></tr>
    <tr><td class="paramname">cache_key</td><td><a class="el" href="class_key.html">Key</a> for table definition cache </td></tr>
    <tr><td class="paramname">cache_key_length</td><td>Length of cache_key </td></tr>
    <tr><td class="paramname">flags</td><td>Flags which modify how we open the view</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000086">Todo:</a></b></dt><dd>This function is needed for special handling of views under LOCK TABLES. We probably should get rid of it in long term.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if success, TRUE - otherwise. </dd></dl>

</div>
</div>
<a id="ga8faf6c6118b6677394e14994ae614075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8faf6c6118b6677394e14994ae614075">&#9670;&nbsp;</a></span>tdc_remove_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tdc_remove_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_tdc_remove_table_type&#160;</td>
          <td class="paramname"><em>remove_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all or some (depending on parameter) instances of <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> from the table definition cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">remove_type</td><td>Type of removal: TDC_RT_REMOVE_ALL - remove all <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instances and <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> instance. There should be no used <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> objects and caller should have exclusive metadata lock on the table. TDC_RT_REMOVE_NOT_OWN - remove all <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instances except those that belong to this thread. There should be no <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> objects used by other threads and caller should have exclusive metadata lock on the table. TDC_RT_REMOVE_UNUSED - remove all unused <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instances (if there are no used instances will also remove <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a>). TDC_RT_REMOVE_NOT_OWN_KEEP_SHARE - remove all <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instances except those that belong to this thread, but don't mark <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> as old. There should be no <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> objects used by other threads and caller should have exclusive metadata lock on the table. </td></tr>
    <tr><td class="paramname">db</td><td>Name of database </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table </td></tr>
    <tr><td class="paramname">has_lock</td><td>If TRUE, LOCK_open is already acquired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It assumes that table instances are already not used by any (other) thread (this should be achieved by using meta-data locks). </dd></dl>

</div>
</div>
<a id="gafa2ecba52b01f35d1ad6aa39d4ce15e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa2ecba52b01f35d1ad6aa39d4ce15e8">&#9670;&nbsp;</a></span>tdc_wait_for_old_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tdc_wait_for_old_version </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>wait_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>deadlock_weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if table's share is being removed from the table definition cache and, if yes, wait until the flush is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">table_list</td><td>Table which share should be checked. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout for waiting. </td></tr>
    <tr><td class="paramname">deadlock_weight</td><td>Weight of this wait for deadlock detector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. Share is up to date or has been flushed. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error (OOM, our was killed, the wait resulted in a deadlock or timeout). Reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5095dfc37db0400dbc6cb9f5efb38951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5095dfc37db0400dbc6cb9f5efb38951">&#9670;&nbsp;</a></span>unique_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a>* unique_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test that the subject table of INSERT/UPDATE/DELETE/CREATE or (in case of MyISAMMRG) one of its children are not used later in the query.</p>
<p>For MyISAMMRG tables, it is assumed that all the underlying tables of <code>table</code> (if any) are listed right after it and that their <code>parent_l</code> field points at the main table.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">non-NULL</td><td>The table list element for the table that represents the duplicate. </td></tr>
    <tr><td class="paramname">NULL</td><td>No duplicates found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac19a8c14e089f35b82dc7a2ded67ea4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac19a8c14e089f35b82dc7a2ded67ea4b">&#9670;&nbsp;</a></span>wait_while_table_is_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait_while_table_is_used </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_extra_function&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force all other threads to stop using the table by upgrading metadata lock on it and remove unused <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instances from cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">table</td><td>Table to remove from cache </td></tr>
    <tr><td class="paramname">function</td><td>HA_EXTRA_PREPARE_FOR_DROP if table is to be deleted HA_EXTRA_FORCE_REOPEN if table is not be used HA_EXTRA_PREPARE_FOR_RENAME if table is to be renamed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When returning, the table will be unusable for other threads until metadata lock is downgraded.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (e.g. because thread was killed). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gadbb159f64cc354aa5df114e242b98bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbb159f64cc354aa5df114e242b98bc8">&#9670;&nbsp;</a></span>all_tdc_mutexes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___instrumentation__interface.html#ga71c1548fde9983df2427c2ddc97085a9">PSI_mutex_info</a> all_tdc_mutexes[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">  { &amp;key_LOCK_open, <span class="stringliteral">&quot;LOCK_open&quot;</span>, <a class="code" href="group___instrumentation__interface.html#ga08fa9418d5ac5ee85fcb6a9e3b76b988">PSI_FLAG_GLOBAL</a> }</div><div class="line">}</div><div class="ttc" id="group___instrumentation__interface_html_ga08fa9418d5ac5ee85fcb6a9e3b76b988"><div class="ttname"><a href="group___instrumentation__interface.html#ga08fa9418d5ac5ee85fcb6a9e3b76b988">PSI_FLAG_GLOBAL</a></div><div class="ttdeci">#define PSI_FLAG_GLOBAL</div><div class="ttdef"><b>Definition:</b> psi.h:583</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ga99c8e1e3e72cd74032d5f11c486911fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c8e1e3e72cd74032d5f11c486911fd">&#9670;&nbsp;</a></span>LOCK_open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> LOCK_open</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LOCK_open protects the following variables/objects:</p>
<p>1) The table_def_cache This is the hash table mapping table name to a table share object. The hash table can only be manipulated while holding LOCK_open. 2) last_table_id Generation of a new unique table_map_id for a table share is done through incrementing last_table_id, a global variable used for this purpose. 3) LOCK_open protects the initialisation of the table share object and all its members and also protects reading the .frm file from where the table share is initialised. 4) In particular the share-&gt;ref_count is updated each time a new table object is created that refers to a table share. This update is protected by LOCK_open. 5) oldest_unused_share, end_of_unused_share and share-&gt;next and share-&gt;prev are variables to handle the lists of table share objects, these can only be read and manipulated while holding the LOCK_open mutex. 6) table_def_shutdown_in_progress can be updated only while holding LOCK_open and ALL table cache mutexes. 7) refresh_version This variable can only be updated while holding LOCK_open AND all table cache mutexes. 8) share-&gt;version This variable is initialised while holding LOCK_open. It can only be updated while holding LOCK_open AND all table cache mutexes. So if a table share is found through a reference its version won't change if any of those mutexes are held. 9) share-&gt;m_flush_tickets </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

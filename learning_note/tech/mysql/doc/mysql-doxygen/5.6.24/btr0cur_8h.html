<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/btr0cur.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">btr0cur.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0cur_8h_source.html">page0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0types_8h_source.html">btr0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0types_8h_source.html">que0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0types_8h_source.html">row0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha0ha_8h_source.html">ha0ha.h</a>&quot;</code><br />
<code>#include &quot;btr0cur.ic&quot;</code><br />
</div>
<p><a href="btr0cur_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtr__path__t.html">btr_path_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a89f1a6886c93a569c625ff76e4445e3f"><td class="memItemLeft" align="right" valign="top"><a id="a89f1a6886c93a569c625ff76e4445e3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BTR_CUR_ADAPT</b></td></tr>
<tr class="separator:a89f1a6886c93a569c625ff76e4445e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababcccef629f8c18436f6a1df93b01ea"><td class="memItemLeft" align="right" valign="top"><a id="ababcccef629f8c18436f6a1df93b01ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BTR_CUR_HASH_ADAPT</b></td></tr>
<tr class="separator:ababcccef629f8c18436f6a1df93b01ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca06d42fe1b307bd15fe92ace58e00b6"><td class="memItemLeft" align="right" valign="top"><a id="aca06d42fe1b307bd15fe92ace58e00b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_get_page_cur</b>(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)&#160;&#160;&#160;(&amp;(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)-&gt;<a class="el" href="ibuf0ibuf_8cc.html#a19816ebf980d4c823b1b966f16807d6a">page_cur</a>)</td></tr>
<tr class="separator:aca06d42fe1b307bd15fe92ace58e00b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ae99b132fb50696ef37480551667e2"><td class="memItemLeft" align="right" valign="top"><a id="ac7ae99b132fb50696ef37480551667e2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_get_block</b>(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)&#160;&#160;&#160;((<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)-&gt;<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">page_cur.block</a>)</td></tr>
<tr class="separator:ac7ae99b132fb50696ef37480551667e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25750d0762b1da9e94edc622d9d627a7"><td class="memItemLeft" align="right" valign="top"><a id="a25750d0762b1da9e94edc622d9d627a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_get_rec</b>(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)&#160;&#160;&#160;((<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)-&gt;<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">page_cur.rec</a>)</td></tr>
<tr class="separator:a25750d0762b1da9e94edc622d9d627a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7d338c847f204984733a9fdbe14789"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a5a7d338c847f204984733a9fdbe14789">btr_cur_get_index</a>(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)&#160;&#160;&#160;((<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)-&gt;<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a5a7d338c847f204984733a9fdbe14789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8f65d3ff6c409b5a5a948098916698"><td class="memItemLeft" align="right" valign="top"><a id="a5c8f65d3ff6c409b5a5a948098916698"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_open_at_index_side</b>(f,  <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>,  l,  c,  lv,  m)&#160;&#160;&#160;<a class="el" href="btr0cur_8h.html#a54bdd3e372239c9c7b4a8fbb827d89ba">btr_cur_open_at_index_side_func</a>(f,<a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>,l,c,lv,__FILE__,__LINE__,m)</td></tr>
<tr class="separator:a5c8f65d3ff6c409b5a5a948098916698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945c2e96d9be4a7c908eab83dbbfea40"><td class="memItemLeft" align="right" valign="top"><a id="a945c2e96d9be4a7c908eab83dbbfea40"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_open_at_rnd_pos</b>(<a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>,  l,  c,  m)&#160;&#160;&#160;<a class="el" href="btr0cur_8h.html#ac6b17c00c932d341c9b0cbe9e0b23642">btr_cur_open_at_rnd_pos_func</a>(<a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>,l,c,__FILE__,__LINE__,m)</td></tr>
<tr class="separator:a945c2e96d9be4a7c908eab83dbbfea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5762abb71e85466cd85e563461bacc18"><td class="memItemLeft" align="right" valign="top"><a id="a5762abb71e85466cd85e563461bacc18"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_update_alloc_zip</b>(page_zip,  <a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>,  <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>,  <a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>,  <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>,  cr,  <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)&#160;&#160;&#160;<a class="el" href="btr0cur_8h.html#ad44d4c6a99e331e3cd01f0921d87f7b1">btr_cur_update_alloc_zip_func</a>(page_zip,<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>,<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>,<a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>,cr,<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a5762abb71e85466cd85e563461bacc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee4744ed5f9d94ff1ad4026226475c5"><td class="memItemLeft" align="right" valign="top"><a id="abee4744ed5f9d94ff1ad4026226475c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_optimistic_delete</b>(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>,  <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>,  <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)&#160;&#160;&#160;<a class="el" href="btr0cur_8h.html#a97b3412d20530bc99d0bfe2b1120a16c">btr_cur_optimistic_delete_func</a>(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:abee4744ed5f9d94ff1ad4026226475c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304f2cc2922cdde4941f42d38d984db9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a304f2cc2922cdde4941f42d38d984db9">BTR_CUR_PAGE_COMPRESS_LIMIT</a>&#160;&#160;&#160;(UNIV_PAGE_SIZE / 2)</td></tr>
<tr class="separator:a304f2cc2922cdde4941f42d38d984db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d03f55936b83f0125d0d45116459421"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a4d03f55936b83f0125d0d45116459421">BTR_PATH_ARRAY_N_SLOTS</a>&#160;&#160;&#160;250</td></tr>
<tr class="separator:a4d03f55936b83f0125d0d45116459421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bff9b3a120d816b69c28745df3a1c74"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a5bff9b3a120d816b69c28745df3a1c74">BTR_CUR_RETRY_DELETE_N_TIMES</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:a5bff9b3a120d816b69c28745df3a1c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275ba443abeacaaaf592c871624ce84b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a275ba443abeacaaaf592c871624ce84b">BTR_CUR_RETRY_SLEEP_TIME</a>&#160;&#160;&#160;50000</td></tr>
<tr class="separator:a275ba443abeacaaaf592c871624ce84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aae65cf0e896285b40f88c4b6da04ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a2aae65cf0e896285b40f88c4b6da04ee">BTR_EXTERN_SPACE_ID</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a2aae65cf0e896285b40f88c4b6da04ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ce803aaeda0b57a2a9df787e6fbfe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a6b5ce803aaeda0b57a2a9df787e6fbfe">BTR_EXTERN_PAGE_NO</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a6b5ce803aaeda0b57a2a9df787e6fbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f4fdf4020b5635b568e2c281974d89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#af2f4fdf4020b5635b568e2c281974d89">BTR_EXTERN_OFFSET</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:af2f4fdf4020b5635b568e2c281974d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa982d3e1451a9520baadb6d6e4394e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a8aa982d3e1451a9520baadb6d6e4394e">BTR_EXTERN_LEN</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:a8aa982d3e1451a9520baadb6d6e4394e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9a69e0b59d0aefc436131d51b72e93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a5e9a69e0b59d0aefc436131d51b72e93">BTR_EXTERN_OWNER_FLAG</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a5e9a69e0b59d0aefc436131d51b72e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb40edeff5f816dea0643db34370ff33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#abb40edeff5f816dea0643db34370ff33">BTR_EXTERN_INHERITED_FLAG</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:abb40edeff5f816dea0643db34370ff33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa7df87806f64f3b241c8cde9eb57cad5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5a1fb016f118032fcb677c3b2a4f107e2b">BTR_NO_UNDO_LOG_FLAG</a> = 1, 
<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5a046932973ff414437088666363342436">BTR_NO_LOCKING_FLAG</a> = 2, 
<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5a159501d7bc944849faa8082ce7b55466">BTR_KEEP_SYS_FLAG</a> = 4, 
<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5a1a9e17a40a357b5194b5b12eccdf9eee">BTR_KEEP_POS_FLAG</a> = 8, 
<br />
&#160;&#160;<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5aa2e940baf537747a3cda3db0a2cbb865">BTR_CREATE_FLAG</a> = 16, 
<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5a1891f77b4a41b153e3445a43c806efcf">BTR_KEEP_IBUF_BITMAP</a> = 32
<br />
 }</td></tr>
<tr class="separator:aa7df87806f64f3b241c8cde9eb57cad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3361a59faf9e0a4f09a76ecf15177dfa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a> { <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfaace3dea2a3d10c4fb37196ff5cb6e5201">BTR_STORE_INSERT</a> = 0, 
<a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfaa1ff8c4d532e7e416faa55e72f9beca51">BTR_STORE_INSERT_UPDATE</a>, 
<a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfaa7f978bffba76536408f3c51cacc0b916">BTR_STORE_UPDATE</a>
 }</td></tr>
<tr class="separator:a3361a59faf9e0a4f09a76ecf15177dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafc257d9789b9b946149978d1934a96"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96">btr_cur_method</a> { <br />
&#160;&#160;<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96aa5e657955c98714ac4df0abd6c2856c0">BTR_CUR_HASH</a> = 1, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96a0c0b480a0e2ff01e08a968319e27135d">BTR_CUR_HASH_FAIL</a>, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96a9e995eb02ca7ee7e67da00cbe8bf2eda">BTR_CUR_BINARY</a>, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96a6c64e9fa37d7185525aa24d3dcffd915">BTR_CUR_INSERT_TO_IBUF</a>, 
<br />
&#160;&#160;<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96aee5660b8b720720ebbf507080a04739f">BTR_CUR_DEL_MARK_IBUF</a>, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96acf08a9d1477925822b67557699699f67">BTR_CUR_DELETE_IBUF</a>, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96a3761d0d9cf510bcb30c8a63336f4d4c7">BTR_CUR_DELETE_REF</a>
<br />
 }</td></tr>
<tr class="separator:acafc257d9789b9b946149978d1934a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a16857b9aaf748152f3d8729a81adc742"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a16857b9aaf748152f3d8729a81adc742">btr_cur_get_page_zip</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:a16857b9aaf748152f3d8729a81adc742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7421ec8e267ec27fb024146eaa431dd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac7421ec8e267ec27fb024146eaa431dd">btr_cur_invalidate</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:ac7421ec8e267ec27fb024146eaa431dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5024b078b665885c29921798da75dc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#aed5024b078b665885c29921798da75dc">btr_cur_get_page</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:aed5024b078b665885c29921798da75dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd6e4cb05606cefb5d21f1e73825d41"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#aefd6e4cb05606cefb5d21f1e73825d41">btr_cur_position</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:aefd6e4cb05606cefb5d21f1e73825d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a13fbc0aaa77d0f1164914785757c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint has_search_latch, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a82a13fbc0aaa77d0f1164914785757c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bdd3e372239c9c7b4a8fbb827d89ba"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a54bdd3e372239c9c7b4a8fbb827d89ba">btr_cur_open_at_index_side_func</a> (bool from_left, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a54bdd3e372239c9c7b4a8fbb827d89ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b17c00c932d341c9b0cbe9e0b23642"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac6b17c00c932d341c9b0cbe9e0b23642">btr_cur_open_at_rnd_pos_func</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac6b17c00c932d341c9b0cbe9e0b23642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae358457a28aeea57013840d722927677"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ae358457a28aeea57013840d722927677">btr_cur_optimistic_insert</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, rec_t **<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **<a class="el" href="row0ins_8cc.html#af030ac6538d68182f7760506abdafc69">big_rec</a>, ulint <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull(2</td></tr>
<tr class="separator:ae358457a28aeea57013840d722927677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba69f71adc2012c2f50a4af1f3ca1c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a6ba69f71adc2012c2f50a4af1f3ca1c0">btr_cur_pessimistic_insert</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, rec_t **<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **<a class="el" href="row0ins_8cc.html#af030ac6538d68182f7760506abdafc69">big_rec</a>, ulint <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull(2</td></tr>
<tr class="separator:a6ba69f71adc2012c2f50a4af1f3ca1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44d4c6a99e331e3cd01f0921d87f7b1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ad44d4c6a99e331e3cd01f0921d87f7b1">btr_cur_update_alloc_zip_func</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structpage__cur__t.html">page_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint length, bool create, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:ad44d4c6a99e331e3cd01f0921d87f7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7e65fb75bc1ee9351b2618cf5434ec"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a3a7e65fb75bc1ee9351b2618cf5434ec">btr_cur_update_in_place</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, ulint <a class="el" href="btr0cur_8cc.html#ab7e363c98b33d8339e7170309cd05207">cmpl_info</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result</td></tr>
<tr class="separator:a3a7e65fb75bc1ee9351b2618cf5434ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ae576d53d200651f58cfec34e9efd8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ae1ae576d53d200651f58cfec34e9efd8">btr_cur_update_in_place_log</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> <a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:ae1ae576d53d200651f58cfec34e9efd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6b740ee71ea58b3e5f5de1f1398214"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#add6b740ee71ea58b3e5f5de1f1398214">btr_cur_optimistic_update</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, ulint <a class="el" href="btr0cur_8cc.html#ab7e363c98b33d8339e7170309cd05207">cmpl_info</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result</td></tr>
<tr class="separator:add6b740ee71ea58b3e5f5de1f1398214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854fc24b414c1b05bae15fcc5b38c841"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a854fc24b414c1b05bae15fcc5b38c841">btr_cur_pessimistic_update</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="row0upd_8cc.html#af327d0841463e479f70421eaf979de1b">offsets_heap</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *entry_heap, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **<a class="el" href="row0ins_8cc.html#af030ac6538d68182f7760506abdafc69">big_rec</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, ulint <a class="el" href="btr0cur_8cc.html#ab7e363c98b33d8339e7170309cd05207">cmpl_info</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result</td></tr>
<tr class="separator:a854fc24b414c1b05bae15fcc5b38c841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c44b51c51e3525a1a86a38e02368ef"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a49c44b51c51e3525a1a86a38e02368ef">btr_cur_del_mark_set_clust_rec</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a49c44b51c51e3525a1a86a38e02368ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6564ae7b0a51093216c6c9be4c5ac3a8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a6564ae7b0a51093216c6c9be4c5ac3a8">btr_cur_del_mark_set_sec_rec</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ibool val, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a6564ae7b0a51093216c6c9be4c5ac3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cc41ddbb44c6b7d6d1725f1566063d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ae0cc41ddbb44c6b7d6d1725f1566063d">btr_cur_compress_if_useful</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ibool adjust, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:ae0cc41ddbb44c6b7d6d1725f1566063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b3412d20530bc99d0bfe2b1120a16c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a97b3412d20530bc99d0bfe2b1120a16c">btr_cur_optimistic_delete_func</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a97b3412d20530bc99d0bfe2b1120a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6fbd0c022f053955e2e53e84916400"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#aeb6fbd0c022f053955e2e53e84916400">btr_cur_pessimistic_delete</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *<a class="el" href="row0import_8cc.html#a52482fdd3721e7db69dc740aefee8ad4">err</a>, ibool has_reserved_extents, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a> rb_ctx, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:aeb6fbd0c022f053955e2e53e84916400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c6cbe14c2af25f2240b5e54aa1d5a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ad06c6cbe14c2af25f2240b5e54aa1d5a">btr_cur_parse_update_in_place</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:ad06c6cbe14c2af25f2240b5e54aa1d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67626b88e4c9b6e4bd41bc71d432e095"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a67626b88e4c9b6e4bd41bc71d432e095">btr_cur_parse_del_mark_set_clust_rec</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a67626b88e4c9b6e4bd41bc71d432e095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8d168c724c8ac87371442df85fc233"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a3d8d168c724c8ac87371442df85fc233">btr_cur_parse_del_mark_set_sec_rec</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:a3d8d168c724c8ac87371442df85fc233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56a487d045ea12d204c0cbe34ff4c95"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ib_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac56a487d045ea12d204c0cbe34ff4c95">btr_estimate_n_rows_in_range</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple1, ulint mode1, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple2, ulint mode2)</td></tr>
<tr class="separator:ac56a487d045ea12d204c0cbe34ff4c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50de491c34525f93cbe27307044ea89"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ab50de491c34525f93cbe27307044ea89">btr_estimate_number_of_different_key_vals</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:ab50de491c34525f93cbe27307044ea89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58003b4ea2270cb2170f97974b5f36fa"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a58003b4ea2270cb2170f97974b5f36fa">btr_rec_get_externally_stored_len</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:a58003b4ea2270cb2170f97974b5f36fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebf93cb29595f773a208944d0240483"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a2ebf93cb29595f773a208944d0240483">btr_cur_disown_inherited_fields</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull(2</td></tr>
<tr class="separator:a2ebf93cb29595f773a208944d0240483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea113b52cb11ea9b46cbc9bd078118a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a5ea113b52cb11ea9b46cbc9bd078118a">btr_blob_op_is_update</a> (enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a> <a class="el" href="ibuf0ibuf_8cc.html#a02d89caeb1f64de105ee1c3988799855">op</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result))</td></tr>
<tr class="separator:a5ea113b52cb11ea9b46cbc9bd078118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce6d7f2269e2dba87f7a820d9494978"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a2ce6d7f2269e2dba87f7a820d9494978">btr_store_big_rec_extern_fields</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *rec_block, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *big_rec_vec, <a class="el" href="structmtr__t.html">mtr_t</a> *btr_mtr, enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a> <a class="el" href="ibuf0ibuf_8cc.html#a02d89caeb1f64de105ee1c3988799855">op</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a2ce6d7f2269e2dba87f7a820d9494978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74d8a6bde9542fcafed8fa7ca14ab7d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac74d8a6bde9542fcafed8fa7ca14ab7d">btr_free_externally_stored_field</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, byte *field_ref, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>, enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a> rb_ctx, <a class="el" href="structmtr__t.html">mtr_t</a> *local_mtr)</td></tr>
<tr class="separator:ac74d8a6bde9542fcafed8fa7ca14ab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24703540cfa917a52abe379751f5004"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ab24703540cfa917a52abe379751f5004">btr_copy_externally_stored_field_prefix</a> (byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, const byte *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ulint local_len)</td></tr>
<tr class="separator:ab24703540cfa917a52abe379751f5004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c5f0fcaabcc7487018ae03937c2412"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac3c5f0fcaabcc7487018ae03937c2412">btr_copy_externally_stored_field</a> (ulint *<a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, const byte *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint local_len, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:ac3c5f0fcaabcc7487018ae03937c2412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c383bd105f982d216a7a430935f5706"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a2c383bd105f982d216a7a430935f5706">btr_rec_copy_externally_stored_field</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint no, ulint *<a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a2c383bd105f982d216a7a430935f5706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ddea099260509f55653d07cfcbbc2d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ad1ddea099260509f55653d07cfcbbc2d">btr_push_update_extern_fields</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:ad1ddea099260509f55653d07cfcbbc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c43a7dff2e949e99467e0323bcc24f9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a0c43a7dff2e949e99467e0323bcc24f9">btr_cur_set_deleted_flag_for_ibuf</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ibool val, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a0c43a7dff2e949e99467e0323bcc24f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9de1fa5a5c99bbc84b5678762a623cf3"><td class="memItemLeft" align="right" valign="top"><a id="a9de1fa5a5c99bbc84b5678762a623cf3"></a>
UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>warn_unused_result</b></td></tr>
<tr class="separator:a9de1fa5a5c99bbc84b5678762a623cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e52cc2e3285acc40bf3590695c8f2b"><td class="memItemLeft" align="right" valign="top"><a id="a40e52cc2e3285acc40bf3590695c8f2b"></a>
UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nonnull</b></td></tr>
<tr class="separator:a40e52cc2e3285acc40bf3590695c8f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7a92b1123d6493729904f846f05a03"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a7b7a92b1123d6493729904f846f05a03">btr_cur_n_non_sea</a></td></tr>
<tr class="separator:a7b7a92b1123d6493729904f846f05a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b3d4f868488aa0addf8d9fa32df663"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ae0b3d4f868488aa0addf8d9fa32df663">btr_cur_n_sea</a></td></tr>
<tr class="separator:ae0b3d4f868488aa0addf8d9fa32df663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefef1d2e4bf03540d18ff799bf9c0a74"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#aefef1d2e4bf03540d18ff799bf9c0a74">btr_cur_n_non_sea_old</a></td></tr>
<tr class="separator:aefef1d2e4bf03540d18ff799bf9c0a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df6a65d39b12848a998a57d2cc328d0"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a8df6a65d39b12848a998a57d2cc328d0">btr_cur_n_sea_old</a></td></tr>
<tr class="separator:a8df6a65d39b12848a998a57d2cc328d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The index tree cursor</p>
<p>Created 10/16/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5a7d338c847f204984733a9fdbe14789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7d338c847f204984733a9fdbe14789">&#9670;&nbsp;</a></span>btr_cur_get_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_cur_get_index</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a></td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)-&gt;<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of a cursor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>b-tree cursor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index </dd></dl>

</div>
</div>
<a id="a304f2cc2922cdde4941f42d38d984db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304f2cc2922cdde4941f42d38d984db9">&#9670;&nbsp;</a></span>BTR_CUR_PAGE_COMPRESS_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_CUR_PAGE_COMPRESS_LIMIT&#160;&#160;&#160;(UNIV_PAGE_SIZE / 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the pessimistic delete, if the page data size drops below this limit, merging it to a neighbor is tried </p>

</div>
</div>
<a id="a5bff9b3a120d816b69c28745df3a1c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bff9b3a120d816b69c28745df3a1c74">&#9670;&nbsp;</a></span>BTR_CUR_RETRY_DELETE_N_TIMES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_CUR_RETRY_DELETE_N_TIMES&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If pessimistic delete fails because of lack of file space, there is still a good change of success a little later. Try this many times. </p>

</div>
</div>
<a id="a275ba443abeacaaaf592c871624ce84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275ba443abeacaaaf592c871624ce84b">&#9670;&nbsp;</a></span>BTR_CUR_RETRY_SLEEP_TIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_CUR_RETRY_SLEEP_TIME&#160;&#160;&#160;50000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If pessimistic delete fails because of lack of file space, there is still a good change of success a little later. Sleep this many microseconds between retries. </p>

</div>
</div>
<a id="abb40edeff5f816dea0643db34370ff33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb40edeff5f816dea0643db34370ff33">&#9670;&nbsp;</a></span>BTR_EXTERN_INHERITED_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_INHERITED_FLAG&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the second most significant bit of BTR_EXTERN_LEN (i.e., the second most significant bit of the byte at smallest address) is 1 then it means that the externally stored field was inherited from an earlier version of the row. In rollback we are not allowed to free an inherited external field. </p>

</div>
</div>
<a id="a8aa982d3e1451a9520baadb6d6e4394e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa982d3e1451a9520baadb6d6e4394e">&#9670;&nbsp;</a></span>BTR_EXTERN_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_LEN&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>8 bytes containing the length of the externally stored part of the BLOB. The 2 highest bits are reserved to the flags below. </p>

</div>
</div>
<a id="af2f4fdf4020b5635b568e2c281974d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f4fdf4020b5635b568e2c281974d89">&#9670;&nbsp;</a></span>BTR_EXTERN_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_OFFSET&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>offset of BLOB header on that page </p>

</div>
</div>
<a id="a5e9a69e0b59d0aefc436131d51b72e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9a69e0b59d0aefc436131d51b72e93">&#9670;&nbsp;</a></span>BTR_EXTERN_OWNER_FLAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_OWNER_FLAG&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The most significant bit of BTR_EXTERN_LEN (i.e., the most significant bit of the byte at smallest address) is set to 1 if this field does not 'own' the externally stored field; only the owner field is allowed to free the field in purge! </p>

</div>
</div>
<a id="a6b5ce803aaeda0b57a2a9df787e6fbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5ce803aaeda0b57a2a9df787e6fbfe">&#9670;&nbsp;</a></span>BTR_EXTERN_PAGE_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_PAGE_NO&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>page no where stored </p>

</div>
</div>
<a id="a2aae65cf0e896285b40f88c4b6da04ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aae65cf0e896285b40f88c4b6da04ee">&#9670;&nbsp;</a></span>BTR_EXTERN_SPACE_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_SPACE_ID&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The reference in a field for which data is stored on a different page. The reference is at the end of the 'locally' stored part of the field. 'Locally' means storage in the index record. We store locally a long enough prefix of each column so that we can determine the ordering parts of each index record without looking into the externally stored part. space id where stored </p>

</div>
</div>
<a id="a4d03f55936b83f0125d0d45116459421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d03f55936b83f0125d0d45116459421">&#9670;&nbsp;</a></span>BTR_PATH_ARRAY_N_SLOTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_PATH_ARRAY_N_SLOTS&#160;&#160;&#160;250</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>size of path array (in slots) </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa7df87806f64f3b241c8cde9eb57cad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7df87806f64f3b241c8cde9eb57cad5">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mode flags for btr_cur operations; these can be ORed </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa7df87806f64f3b241c8cde9eb57cad5a1fb016f118032fcb677c3b2a4f107e2b"></a>BTR_NO_UNDO_LOG_FLAG&#160;</td><td class="fielddoc"><p>do no undo logging </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7df87806f64f3b241c8cde9eb57cad5a046932973ff414437088666363342436"></a>BTR_NO_LOCKING_FLAG&#160;</td><td class="fielddoc"><p>do no record lock checking </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7df87806f64f3b241c8cde9eb57cad5a159501d7bc944849faa8082ce7b55466"></a>BTR_KEEP_SYS_FLAG&#160;</td><td class="fielddoc"><p>sys fields will be found in the update vector or inserted entry </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7df87806f64f3b241c8cde9eb57cad5a1a9e17a40a357b5194b5b12eccdf9eee"></a>BTR_KEEP_POS_FLAG&#160;</td><td class="fielddoc"><p><a class="el" href="btr0cur_8h.html#a854fc24b414c1b05bae15fcc5b38c841">btr_cur_pessimistic_update()</a> must keep cursor position when moving columns to big_rec </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7df87806f64f3b241c8cde9eb57cad5aa2e940baf537747a3cda3db0a2cbb865"></a>BTR_CREATE_FLAG&#160;</td><td class="fielddoc"><p>the caller is creating the index or wants to bypass the index-&gt;info.online creation log </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7df87806f64f3b241c8cde9eb57cad5a1891f77b4a41b153e3445a43c806efcf"></a>BTR_KEEP_IBUF_BITMAP&#160;</td><td class="fielddoc"><p>the caller of <a class="el" href="btr0cur_8h.html#add6b740ee71ea58b3e5f5de1f1398214">btr_cur_optimistic_update()</a> or <a class="el" href="btr0cur_8h.html#a3a7e65fb75bc1ee9351b2618cf5434ec">btr_cur_update_in_place()</a> will take care of updating IBUF_BITMAP_FREE </p>
</td></tr>
</table>

</div>
</div>
<a id="a3361a59faf9e0a4f09a76ecf15177dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3361a59faf9e0a4f09a76ecf15177dfa">&#9670;&nbsp;</a></span>blob_op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operation code for <a class="el" href="btr0cur_8h.html#a2ce6d7f2269e2dba87f7a820d9494978">btr_store_big_rec_extern_fields()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3361a59faf9e0a4f09a76ecf15177dfaace3dea2a3d10c4fb37196ff5cb6e5201"></a>BTR_STORE_INSERT&#160;</td><td class="fielddoc"><p>Store off-page columns for a freshly inserted record </p>
</td></tr>
<tr><td class="fieldname"><a id="a3361a59faf9e0a4f09a76ecf15177dfaa1ff8c4d532e7e416faa55e72f9beca51"></a>BTR_STORE_INSERT_UPDATE&#160;</td><td class="fielddoc"><p>Store off-page columns for an insert by update </p>
</td></tr>
<tr><td class="fieldname"><a id="a3361a59faf9e0a4f09a76ecf15177dfaa7f978bffba76536408f3c51cacc0b916"></a>BTR_STORE_UPDATE&#160;</td><td class="fielddoc"><p>Store off-page columns for an update </p>
</td></tr>
</table>

</div>
</div>
<a id="acafc257d9789b9b946149978d1934a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafc257d9789b9b946149978d1934a96">&#9670;&nbsp;</a></span>btr_cur_method</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96">btr_cur_method</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values for the flag documenting the used search method </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acafc257d9789b9b946149978d1934a96aa5e657955c98714ac4df0abd6c2856c0"></a>BTR_CUR_HASH&#160;</td><td class="fielddoc"><p>successful shortcut using the hash index </p>
</td></tr>
<tr><td class="fieldname"><a id="acafc257d9789b9b946149978d1934a96a0c0b480a0e2ff01e08a968319e27135d"></a>BTR_CUR_HASH_FAIL&#160;</td><td class="fielddoc"><p>failure using hash, success using binary search: the misleading hash reference is stored in the field hash_node, and might be necessary to update </p>
</td></tr>
<tr><td class="fieldname"><a id="acafc257d9789b9b946149978d1934a96a9e995eb02ca7ee7e67da00cbe8bf2eda"></a>BTR_CUR_BINARY&#160;</td><td class="fielddoc"><p>success using the binary search </p>
</td></tr>
<tr><td class="fieldname"><a id="acafc257d9789b9b946149978d1934a96a6c64e9fa37d7185525aa24d3dcffd915"></a>BTR_CUR_INSERT_TO_IBUF&#160;</td><td class="fielddoc"><p>performed the intended insert to the insert buffer </p>
</td></tr>
<tr><td class="fieldname"><a id="acafc257d9789b9b946149978d1934a96aee5660b8b720720ebbf507080a04739f"></a>BTR_CUR_DEL_MARK_IBUF&#160;</td><td class="fielddoc"><p>performed the intended delete mark in the insert/delete buffer </p>
</td></tr>
<tr><td class="fieldname"><a id="acafc257d9789b9b946149978d1934a96acf08a9d1477925822b67557699699f67"></a>BTR_CUR_DELETE_IBUF&#160;</td><td class="fielddoc"><p>performed the intended delete in the insert/delete buffer </p>
</td></tr>
<tr><td class="fieldname"><a id="acafc257d9789b9b946149978d1934a96a3761d0d9cf510bcb30c8a63336f4d4c7"></a>BTR_CUR_DELETE_REF&#160;</td><td class="fielddoc"><p><a class="el" href="row0purge_8h.html#a0be9e0b634ec09a297f99fadeb093c8d">row_purge_poss_sec()</a> failed </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5ea113b52cb11ea9b46cbc9bd078118a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea113b52cb11ea9b46cbc9bd078118a">&#9670;&nbsp;</a></span>btr_blob_op_is_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool btr_blob_op_is_update </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if an operation on off-page columns is an update. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if op != BTR_STORE_INSERT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>in: operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3c5f0fcaabcc7487018ae03937c2412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c5f0fcaabcc7487018ae03937c2412">&#9670;&nbsp;</a></span>btr_copy_externally_stored_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_copy_externally_stored_field </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>local_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies an externally stored field of a record to mem heap. The clustered index record must be protected by a lock or a page latch. </p><dl class="section return"><dt>Returns</dt><dd>the whole field copied to heap in: mem heap</dd></dl>
<p>Copies an externally stored field of a record to mem heap. The clustered index record must be protected by a lock or a page latch. </p><dl class="section return"><dt>Returns</dt><dd>the whole field copied to heap </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>out: length of the whole field </td></tr>
    <tr><td class="paramname">data</td><td>in: 'internally' stored part of the field containing also the reference to the external part; must be protected by a lock or a page latch </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">local_len</td><td>in: length of data </td></tr>
    <tr><td class="paramname">heap</td><td>in: mem heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24703540cfa917a52abe379751f5004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24703540cfa917a52abe379751f5004">&#9670;&nbsp;</a></span>btr_copy_externally_stored_field_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_copy_externally_stored_field_prefix </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>local_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the prefix of an externally stored field of a record. The clustered index record must be protected by a lock or a page latch. </p><dl class="section return"><dt>Returns</dt><dd>the length of the copied field, or 0 if the column was being or has been deleted in: length of data, in bytes</dd></dl>
<p>Copies the prefix of an externally stored field of a record. The clustered index record must be protected by a lock or a page latch. </p><dl class="section return"><dt>Returns</dt><dd>the length of the copied field, or 0 if the column was being or has been deleted </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: the field, or a prefix of it </td></tr>
    <tr><td class="paramname">len</td><td>in: length of buf, in bytes </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">data</td><td>in: 'internally' stored part of the field containing also the reference to the external part; must be protected by a lock or a page latch </td></tr>
    <tr><td class="paramname">local_len</td><td>in: length of data, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0cc41ddbb44c6b7d6d1725f1566063d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cc41ddbb44c6b7d6d1725f1566063d">&#9670;&nbsp;</a></span>btr_cur_compress_if_useful()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_cur_compress_if_useful </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>adjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to compress a page of the tree if it seems useful. It is assumed that mtr holds an x-latch on the tree and on the cursor page. To avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. NOTE: it is assumed that the caller has reserved enough free extents so that the compression will always succeed if done! </p><dl class="section return"><dt>Returns</dt><dd>TRUE if compression occurred </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the page to compress; cursor does not stay valid if !adjust and compression occurs </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE if should adjust the cursor position even if compression occurs </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49c44b51c51e3525a1a86a38e02368ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c44b51c51e3525a1a86a38e02368ef">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_del_mark_set_clust_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a clustered index record deleted. Writes an undo log record to undo log on this delete marking. Writes in the trx id field the id of the deleting transaction, and in the roll ptr field pointer to the undo log record created. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: buffer block of the record </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index of the record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6564ae7b0a51093216c6c9be4c5ac3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6564ae7b0a51093216c6c9be4c5ac3a8">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_sec_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_del_mark_set_sec_rec </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a secondary index record delete mark to TRUE or FALSE. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: locking flag </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ebf93cb29595f773a208944d0240483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebf93cb29595f773a208944d0240483">&#9670;&nbsp;</a></span>btr_cur_disown_inherited_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_disown_inherited_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks non-updated off-page fields as disowned by this record. The ownership must be transferred to the updated record which is inserted elsewhere in the index tree. In purge only the owner of externally stored field is allowed to free the field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record in a clustered index </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the page </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed5024b078b665885c29921798da75dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5024b078b665885c29921798da75dc">&#9670;&nbsp;</a></span>btr_cur_get_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>* btr_cur_get_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the page of a tree cursor. </p><dl class="section return"><dt>Returns</dt><dd>pointer to page in: tree cursor </dd></dl>

</div>
</div>
<a id="a16857b9aaf748152f3d8729a81adc742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16857b9aaf748152f3d8729a81adc742">&#9670;&nbsp;</a></span>btr_cur_get_page_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a>* btr_cur_get_page_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the compressed page on which the tree cursor is positioned. </p><dl class="section return"><dt>Returns</dt><dd>pointer to compressed page, or NULL if the page is not compressed in: tree cursor </dd></dl>

</div>
</div>
<a id="ac7421ec8e267ec27fb024146eaa431dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7421ec8e267ec27fb024146eaa431dd">&#9670;&nbsp;</a></span>btr_cur_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_cur_invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalidates a tree cursor by setting record pointer to NULL. in: tree cursor </p>

</div>
</div>
<a id="a54bdd3e372239c9c7b4a8fbb827d89ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bdd3e372239c9c7b4a8fbb827d89ba">&#9670;&nbsp;</a></span>btr_cur_open_at_index_side_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_open_at_index_side_func </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a cursor at either end of an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_left</td><td>in: true if open to the low end, false if to the high end </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: latch mode </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: cursor </td></tr>
    <tr><td class="paramname">level</td><td>in: level to search for (0=leaf). </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b17c00c932d341c9b0cbe9e0b23642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b17c00c932d341c9b0cbe9e0b23642">&#9670;&nbsp;</a></span>btr_cur_open_at_rnd_pos_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_open_at_rnd_pos_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Positions a cursor at a randomly chosen position within a B-tree. in: mtr</p>
<p>Positions a cursor at a randomly chosen position within a B-tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ... </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: B-tree cursor </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97b3412d20530bc99d0bfe2b1120a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b3412d20530bc99d0bfe2b1120a16c">&#9670;&nbsp;</a></span>btr_cur_optimistic_delete_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_cur_optimistic_delete_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the record on which the tree cursor is positioned. It is assumed that the mtr has an x-latch on the page where the cursor is positioned, but no latch on the whole tree. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success, i.e., the page did not become too empty </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to delete; cursor stays valid: if deletion succeeds, on function exit it points to the successor of the deleted record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr; if this function returns TRUE on a leaf page of a secondary index, the mtr must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae358457a28aeea57013840d722927677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae358457a28aeea57013840d722927677">&#9670;&nbsp;</a></span>btr_cur_optimistic_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_optimistic_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to perform an insert to a page in an index tree, next to cursor. It is assumed that mtr holds an x-latch on the page. The operation does not succeed if there is too little space on the page. If there is just one record on the page, the insert will always succeed; this is to prevent trying to split a page with just one record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_WAIT_LOCK, DB_FAIL, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags: if not zero, the parameters index and thr should be specified </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on page after which to insert; cursor stays valid </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>out: pointer to inserted record if succeed </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this function returns DB_SUCCESS on a leaf page of a secondary index in a compressed tablespace, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add6b740ee71ea58b3e5f5de1f1398214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6b740ee71ea58b3e5f5de1f1398214">&#9670;&nbsp;</a></span>btr_cur_optimistic_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_optimistic_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to update a record on a page in an index tree. It is assumed that mtr holds an x-latch on the page. The operation does not succeed if there is too little space on the page or if the update would result in too empty a page, so that tree compression is recommended. </p><dl class="section return"><dt>Returns</dt><dd>error code, including </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_OVERFLOW</td><td>if the updated record does not fit </td></tr>
    <tr><td class="paramname">DB_UNDERFLOW</td><td>if the page would become too empty </td></tr>
    <tr><td class="paramname">DB_ZIP_OVERFLOW</td><td>if there is not enough space left on the compressed page </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to update; cursor stays valid and positioned on the same record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to NULL or memory heap </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector; this must also contain trx id and roll ptr fields </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this is a secondary index, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67626b88e4c9b6e4bd41bc71d432e095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67626b88e4c9b6e4bd41bc71d432e095">&#9670;&nbsp;</a></span>btr_cur_parse_del_mark_set_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_cur_parse_del_mark_set_clust_rec </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the redo log record for delete marking or unmarking of a clustered index record. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL in: index corresponding to page</dd></dl>
<p>Parses the redo log record for delete marking or unmarking of a clustered index record. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index corresponding to page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d8d168c724c8ac87371442df85fc233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8d168c724c8ac87371442df85fc233">&#9670;&nbsp;</a></span>btr_cur_parse_del_mark_set_sec_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_cur_parse_del_mark_set_sec_rec </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the redo log record for delete marking or unmarking of a secondary index record. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL in/out: compressed page, or NULL</dd></dl>
<p>Parses the redo log record for delete marking or unmarking of a secondary index record. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad06c6cbe14c2af25f2240b5e54aa1d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c6cbe14c2af25f2240b5e54aa1d5a">&#9670;&nbsp;</a></span>btr_cur_parse_update_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_cur_parse_update_in_place </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a redo log record of updating a record in-place. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL in: index corresponding to page</dd></dl>
<p>Parses a redo log record of updating a record in-place. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index corresponding to page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb6fbd0c022f053955e2e53e84916400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6fbd0c022f053955e2e53e84916400">&#9670;&nbsp;</a></span>btr_cur_pessimistic_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_cur_pessimistic_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>has_reserved_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a>&#160;</td>
          <td class="paramname"><em>rb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the record on which the tree cursor is positioned. Tries to compress the page if its fillfactor drops below a threshold or if it is the only page on the level. It is assumed that mtr holds an x-latch on the tree and on the cursor page. To avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if compression occurred </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>out: DB_SUCCESS or DB_OUT_OF_FILE_SPACE; the latter may occur because we may have to update node pointers on upper levels, and in the case of variable length keys these may actually grow in size </td></tr>
    <tr><td class="paramname">has_reserved_extents</td><td>in: TRUE if the caller has already reserved enough free extents so that he knows that the operation will succeed </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to delete; if compression does not occur, the cursor stays valid: it points to successor of deleted record on function exit </td></tr>
    <tr><td class="paramname">flags</td><td>in: BTR_CREATE_FLAG or 0 </td></tr>
    <tr><td class="paramname">rb_ctx</td><td>in: rollback context </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ba69f71adc2012c2f50a4af1f3ca1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba69f71adc2012c2f50a4af1f3ca1c0">&#9670;&nbsp;</a></span>btr_cur_pessimistic_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_pessimistic_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an insert on a page of an index tree. It is assumed that mtr holds an x-latch on the tree and on the cursor page. If the insert is made on the leaf level, to avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags: if not zero, the parameter thr should be specified; if no undo logging is specified, then the caller must have reserved enough free extents in the file space so that the insertion will certainly succeed </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor after which to insert; cursor stays valid </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>out: pointer to inserted record if succeed </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854fc24b414c1b05bae15fcc5b38c841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854fc24b414c1b05bae15fcc5b38c841">&#9670;&nbsp;</a></span>btr_cur_pessimistic_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_pessimistic_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offsets_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>entry_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an update of a record on a page of a tree. It is assumed that mtr holds an x-latch on the tree and on the cursor page. If the update is made on the leaf level, to avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging, locking, and rollback flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the record to update; cursor may become invalid if *big_rec == NULL || !(flags &amp; BTR_KEEP_POS_FLAG) </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">offsets_heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">entry_heap</td><td>in/out: memory heap for allocating big_rec and the index tuple </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector; this is allowed also contain trx id and roll ptr fields, but the values in update vector have no effect </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefd6e4cb05606cefb5d21f1e73825d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd6e4cb05606cefb5d21f1e73825d41">&#9670;&nbsp;</a></span>btr_cur_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_cur_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Positions a tree cursor at a given record. in: cursor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">rec</td><td>in: record in tree </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82a13fbc0aaa77d0f1164914785757c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a13fbc0aaa77d0f1164914785757c0">&#9670;&nbsp;</a></span>btr_cur_search_to_nth_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_search_to_nth_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>has_search_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches an index tree and positions a tree cursor on a given level. NOTE: n_fields_cmp in tuple must be set so that it cannot be compared to node pointer page number fields on the upper levels of the tree! Note that if mode is PAGE_CUR_LE, which is used in inserts, then cursor-&gt;up_match and cursor-&gt;low_match both will have sensible values. If mode is PAGE_CUR_GE, then up_match will a have a sensible value. in: mtr</p>
<p>Searches an index tree and positions a tree cursor on a given level. NOTE: n_fields_cmp in tuple must be set so that it cannot be compared to node pointer page number fields on the upper levels of the tree! Note that if mode is PAGE_CUR_LE, which is used in inserts, then cursor-&gt;up_match and cursor-&gt;low_match both will have sensible values. If mode is PAGE_CUR_GE, then up_match will a have a sensible value.</p>
<p>If mode is PAGE_CUR_LE , cursor is left at the place where an insert of the search tuple should be performed in the B-tree. InnoDB does an insert immediately after the cursor. Thus, the cursor may end up on a user record, or on a page infimum record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: the tree level of search </td></tr>
    <tr><td class="paramname">tuple</td><td>in: data tuple; NOTE: n_fields_cmp in tuple must be set so that it cannot get compared to the node ptr page number field! </td></tr>
    <tr><td class="paramname">mode</td><td>in: PAGE_CUR_L, ...; Inserts should always be made using PAGE_CUR_LE to search the position! </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ..., ORed with at most one of BTR_INSERT, BTR_DELETE_MARK, BTR_DELETE, or BTR_ESTIMATE; cursor-&gt;left_block is used to store a pointer to the left neighbor page, in the cases BTR_SEARCH_PREV and BTR_MODIFY_PREV; NOTE that if has_search_latch is != 0, we maybe do not have a latch set on the cursor page, we assume the caller uses his search latch to protect the record! </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: tree cursor; the cursor page is s- or x-latched, but see also above! </td></tr>
    <tr><td class="paramname">has_search_latch</td><td>in: info on the latch mode the caller currently has on btr_search_latch: RW_S_LATCH, or 0 </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c43a7dff2e949e99467e0323bcc24f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c43a7dff2e949e99467e0323bcc24f9">&#9670;&nbsp;</a></span>btr_cur_set_deleted_flag_for_ibuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_set_deleted_flag_for_ibuf </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a secondary index record's delete mark to the given value. This function is only used by the insert buffer merge mechanism. in/out: mini-transaction</p>
<p>Sets a secondary index record's delete mark to the given value. This function is only used by the insert buffer merge mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page corresponding to rec, or NULL when the tablespace is uncompressed </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad44d4c6a99e331e3cd01f0921d87f7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44d4c6a99e331e3cd01f0921d87f7b1">&#9670;&nbsp;</a></span>btr_cur_update_alloc_zip_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool btr_cur_update_alloc_zip_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See if there is enough place in the page modification log to log an update-in-place.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if out of space; IBUF_BITMAP_FREE will be reset outside mtr if the page was recompressed </td></tr>
    <tr><td class="paramname">true</td><td>if enough place;</td></tr>
  </table>
  </dd>
</dl>
<p>IMPORTANT: The caller will have to update IBUF_BITMAP_FREE if this is a secondary index leaf page. This has to be done either within the same mini-transaction, or by invoking <a class="el" href="ibuf0ibuf_8cc.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits()</a> before mtr_commit(mtr). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: B-tree page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index corresponding to cursor </td></tr>
    <tr><td class="paramname">length</td><td>in: size needed </td></tr>
    <tr><td class="paramname">create</td><td>in: true=delete-and-insert, false=update-in-place </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a7e65fb75bc1ee9351b2618cf5434ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7e65fb75bc1ee9351b2618cf5434ec">&#9670;&nbsp;</a></span>btr_cur_update_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_update_in_place </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates a record when the update causes no size changes in its fields. </p><dl class="section return"><dt>Returns</dt><dd>locking or undo log related error code, or </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_ZIP_OVERFLOW</td><td>if there is not enough space left on the compressed page (IBUF_BITMAP_FREE was reset outside mtr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to update; cursor stays valid and positioned on the same record </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this is a secondary index, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1ae576d53d200651f58cfec34e9efd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ae576d53d200651f58cfec34e9efd8">&#9670;&nbsp;</a></span>btr_cur_update_in_place_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_update_in_place_log </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a redo log record of updating a record in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: flags </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the record </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac56a487d045ea12d204c0cbe34ff4c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56a487d045ea12d204c0cbe34ff4c95">&#9670;&nbsp;</a></span>btr_estimate_n_rows_in_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ib_int64_t btr_estimate_n_rows_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimates the number of rows in a given index range. </p><dl class="section return"><dt>Returns</dt><dd>estimated number of rows in: search mode for range end</dd></dl>
<p>Estimates the number of rows in a given index range. </p><dl class="section return"><dt>Returns</dt><dd>estimated number of rows </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">tuple1</td><td>in: range start, may also be empty tuple </td></tr>
    <tr><td class="paramname">mode1</td><td>in: search mode for range start </td></tr>
    <tr><td class="paramname">tuple2</td><td>in: range end, may also be empty tuple </td></tr>
    <tr><td class="paramname">mode2</td><td>in: search mode for range end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50de491c34525f93cbe27307044ea89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50de491c34525f93cbe27307044ea89">&#9670;&nbsp;</a></span>btr_estimate_number_of_different_key_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_estimate_number_of_different_key_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimates the number of different key values in a given index, for each n-column prefix of the index where 1 &lt;= n &lt;= dict_index_get_n_unique(index). The estimates are stored in the array index-&gt;stat_n_diff_key_vals[] (indexed 0..n_uniq-1) and the number of pages that were sampled is saved in index-&gt;stat_n_sample_sizes[]. If innodb_stats_method is nulls_ignored, we also record the number of non-null values for each prefix and stored the estimates in array index-&gt;stat_n_non_null_key_vals. in: index</p>
<p>Estimates the number of different key values in a given index, for each n-column prefix of the index where 1 &lt;= n &lt;= dict_index_get_n_unique(index). The estimates are stored in the array index-&gt;stat_n_diff_key_vals[] (indexed 0..n_uniq-1) and the number of pages that were sampled is saved in index-&gt;stat_n_sample_sizes[]. If innodb_stats_method is nulls_ignored, we also record the number of non-null values for each prefix and stored the estimates in array index-&gt;stat_n_non_null_key_vals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac74d8a6bde9542fcafed8fa7ca14ab7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74d8a6bde9542fcafed8fa7ca14ab7d">&#9670;&nbsp;</a></span>btr_free_externally_stored_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_free_externally_stored_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>field_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a>&#160;</td>
          <td class="paramname"><em>rb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>local_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the space in an externally stored field to the file space management if the field in data is owned the externally stored field, in a rollback we may have the additional condition that the field must not be inherited. in: mtr containing the latch to data an an X-latch to the index tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of the data, the index tree MUST be X-latched; if the tree height is 1, then also the root page must be X-latched! (this is relevant in the case this function is called from purge where 'data' is located on an undo log page, not an index page) </td></tr>
    <tr><td class="paramname">field_ref</td><td>in/out: field reference </td></tr>
    <tr><td class="paramname">rec</td><td>in: record containing field_ref, for <a class="el" href="page0zip_8h.html#a9fb82f7de3a6622169bd966a7c97949f">page_zip_write_blob_ptr()</a>, or NULL </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index), or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in: compressed page corresponding to rec, or NULL if rec == NULL </td></tr>
    <tr><td class="paramname">i</td><td>in: field number of field_ref; ignored if rec == NULL </td></tr>
    <tr><td class="paramname">rb_ctx</td><td>in: rollback context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1ddea099260509f55653d07cfcbbc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ddea099260509f55653d07cfcbbc2d">&#9670;&nbsp;</a></span>btr_push_update_extern_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_push_update_extern_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags the data tuple fields that are marked as extern storage in the update vector. We use this function to remember which fields we must mark as extern storage in a record inserted for an update. </p><dl class="section return"><dt>Returns</dt><dd>number of flagged external columns </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in/out: data tuple </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c383bd105f982d216a7a430935f5706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c383bd105f982d216a7a430935f5706">&#9670;&nbsp;</a></span>btr_rec_copy_externally_stored_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_rec_copy_externally_stored_field </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies an externally stored field of a record to mem heap. </p><dl class="section return"><dt>Returns</dt><dd>the field copied to heap, or NULL if the field is incomplete in: mem heap</dd></dl>
<p>Copies an externally stored field of a record to mem heap. </p><dl class="section return"><dt>Returns</dt><dd>the field copied to heap, or NULL if the field is incomplete </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record in a clustered index; must be protected by a lock or a page latch </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">no</td><td>in: field number </td></tr>
    <tr><td class="paramname">len</td><td>out: length of the field </td></tr>
    <tr><td class="paramname">heap</td><td>in: mem heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58003b4ea2270cb2170f97974b5f36fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58003b4ea2270cb2170f97974b5f36fa">&#9670;&nbsp;</a></span>btr_rec_get_externally_stored_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_rec_get_externally_stored_len </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the externally stored size of a record, in units of a database page. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>array returned by rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>externally stored part, in units of a database page </dd></dl>

</div>
</div>
<a id="a2ce6d7f2269e2dba87f7a820d9494978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce6d7f2269e2dba87f7a820d9494978">&#9670;&nbsp;</a></span>btr_store_big_rec_extern_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_store_big_rec_extern_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>rec_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *&#160;</td>
          <td class="paramname"><em>big_rec_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>btr_mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the fields in big_rec_vec to the tablespace and puts pointers to them in rec. The extern flags in rec will have to be set beforehand. The fields are stored on pages allocated from leaf node file segment of the index tree. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>in: operation code </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of rec; the index tree MUST be X-latched </td></tr>
    <tr><td class="paramname">rec_block</td><td>in/out: block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index); the "external storage" flags in offsets will not correspond to rec when this function returns </td></tr>
    <tr><td class="paramname">big_rec_vec</td><td>in: vector containing fields to be stored externally </td></tr>
    <tr><td class="paramname">btr_mtr</td><td>in: mtr containing the latches to the clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7b7a92b1123d6493729904f846f05a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7a92b1123d6493729904f846f05a03">&#9670;&nbsp;</a></span>btr_cur_n_non_sea</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_non_sea</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of searches down the B-tree in <a class="el" href="btr0cur_8h.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level()</a>. </p>

</div>
</div>
<a id="aefef1d2e4bf03540d18ff799bf9c0a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefef1d2e4bf03540d18ff799bf9c0a74">&#9670;&nbsp;</a></span>btr_cur_n_non_sea_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_non_sea_old</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Old value of btr_cur_n_non_sea. Copied by <a class="el" href="srv0srv_8cc.html#aa7037cea22c187eff94afb8389fe04f2">srv_refresh_innodb_monitor_stats()</a>. Referenced by <a class="el" href="srv0srv_8h.html#ad9cbe424aaafd2138998d34630066322">srv_printf_innodb_monitor()</a>. </p>

</div>
</div>
<a id="ae0b3d4f868488aa0addf8d9fa32df663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b3d4f868488aa0addf8d9fa32df663">&#9670;&nbsp;</a></span>btr_cur_n_sea</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_sea</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of successful adaptive hash index lookups in <a class="el" href="btr0cur_8h.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level()</a>. </p>

</div>
</div>
<a id="a8df6a65d39b12848a998a57d2cc328d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df6a65d39b12848a998a57d2cc328d0">&#9670;&nbsp;</a></span>btr_cur_n_sea_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_sea_old</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Old value of btr_cur_n_sea. Copied by <a class="el" href="srv0srv_8cc.html#aa7037cea22c187eff94afb8389fe04f2">srv_refresh_innodb_monitor_stats()</a>. Referenced by <a class="el" href="srv0srv_8h.html#ad9cbe424aaafd2138998d34630066322">srv_printf_innodb_monitor()</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

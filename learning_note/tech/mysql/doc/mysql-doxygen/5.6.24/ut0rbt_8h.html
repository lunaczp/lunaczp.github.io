<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/ut0rbt.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ut0rbt.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br />
</div>
<p><a href="ut0rbt_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:abbcd716ac5577397bc81f82417d86337"><td class="memItemLeft" align="right" valign="top"><a id="abbcd716ac5577397bc81f82417d86337"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rbt_size</b>(t)&#160;&#160;&#160;(t-&gt;n_nodes)</td></tr>
<tr class="separator:abbcd716ac5577397bc81f82417d86337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf4e25de6b4252aa93c17bdf4bad67b"><td class="memItemLeft" align="right" valign="top"><a id="a4bf4e25de6b4252aa93c17bdf4bad67b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rbt_empty</b>(t)&#160;&#160;&#160;(rbt_size(t) == 0)</td></tr>
<tr class="separator:a4bf4e25de6b4252aa93c17bdf4bad67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5870ca128fed1c26f19cb8a52987ba06"><td class="memItemLeft" align="right" valign="top"><a id="a5870ca128fed1c26f19cb8a52987ba06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rbt_value</b>(t,  <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)&#160;&#160;&#160;((t*) &amp;<a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>-&gt;value[0])</td></tr>
<tr class="separator:a5870ca128fed1c26f19cb8a52987ba06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af451a2d6740076a82080c1fddb8f7af1"><td class="memItemLeft" align="right" valign="top"><a id="af451a2d6740076a82080c1fddb8f7af1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rbt_compare</b>(t,  k,  <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)&#160;&#160;&#160;(t-&gt;<a class="el" href="field_8cc.html#a59a13a7009755ede163e43c1068704c7">compare</a>(k, <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>-&gt;value))</td></tr>
<tr class="separator:af451a2d6740076a82080c1fddb8f7af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0981da6b36540be737400160cc16b086"><td class="memItemLeft" align="right" valign="top"><a id="a0981da6b36540be737400160cc16b086"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>ib_rbt_print_node</b>) (const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>)</td></tr>
<tr class="separator:a0981da6b36540be737400160cc16b086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b05afbe624a4289c59995130829566"><td class="memItemLeft" align="right" valign="top"><a id="ad9b05afbe624a4289c59995130829566"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>ib_rbt_compare</b>) (const void *p1, const void *p2)</td></tr>
<tr class="separator:ad9b05afbe624a4289c59995130829566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae8ba09d0fb0dd7de2b59a89cc8b6e2"><td class="memItemLeft" align="right" valign="top"><a id="a3ae8ba09d0fb0dd7de2b59a89cc8b6e2"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>ib_rbt_arg_compare</b>) (const void *, const void *p1, const void *p2)</td></tr>
<tr class="separator:a3ae8ba09d0fb0dd7de2b59a89cc8b6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1715bf199a80c83f5be40165079ed339"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a1715bf199a80c83f5be40165079ed339">ib_rbt_color_t</a> { <b>IB_RBT_RED</b>, 
<b>IB_RBT_BLACK</b>
 }</td></tr>
<tr class="separator:a1715bf199a80c83f5be40165079ed339"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a160680a842fc674633f59f527c7bcdfd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a160680a842fc674633f59f527c7bcdfd">rbt_free</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="separator:a160680a842fc674633f59f527c7bcdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae582d916e935fac8ec45850cb1255082"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#ae582d916e935fac8ec45850cb1255082">rbt_create</a> (size_t sizeof_value, ib_rbt_compare <a class="el" href="field_8cc.html#a59a13a7009755ede163e43c1068704c7">compare</a>)</td></tr>
<tr class="separator:ae582d916e935fac8ec45850cb1255082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cfa8f5baa48789af0e457bd3c57bd0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a88cfa8f5baa48789af0e457bd3c57bd0">rbt_create_arg_cmp</a> (size_t sizeof_value, ib_rbt_arg_compare <a class="el" href="field_8cc.html#a59a13a7009755ede163e43c1068704c7">compare</a>, void *cmp_arg)</td></tr>
<tr class="separator:a88cfa8f5baa48789af0e457bd3c57bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a776fb52186a413fc859d393c90165"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#ad8a776fb52186a413fc859d393c90165">rbt_delete</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key)</td></tr>
<tr class="separator:ad8a776fb52186a413fc859d393c90165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d12d6639f6ab93891188f7fe1b802b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a75d12d6639f6ab93891188f7fe1b802b">rbt_remove_node</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>)</td></tr>
<tr class="separator:a75d12d6639f6ab93891188f7fe1b802b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0cf8e2e61d016b06c22ae5eb26234b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#ada0cf8e2e61d016b06c22ae5eb26234b">rbt_lookup</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key)</td></tr>
<tr class="separator:ada0cf8e2e61d016b06c22ae5eb26234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d037d4ead5e59454a7e11ac3e5c97c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a97d037d4ead5e59454a7e11ac3e5c97c">rbt_insert</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key, const void *value)</td></tr>
<tr class="separator:a97d037d4ead5e59454a7e11ac3e5c97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda0e7602a733198120cc93e21be2cef"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#abda0e7602a733198120cc93e21be2cef">rbt_add_node</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, <a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *parent, const void *value)</td></tr>
<tr class="separator:abda0e7602a733198120cc93e21be2cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bfcc467fec46eb6670b0bebd2ac993"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a51bfcc467fec46eb6670b0bebd2ac993">rbt_first</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="separator:a51bfcc467fec46eb6670b0bebd2ac993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d9ec1c12b3e25cd4d2a5e5d2ddf292"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a21d9ec1c12b3e25cd4d2a5e5d2ddf292">rbt_last</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="separator:a21d9ec1c12b3e25cd4d2a5e5d2ddf292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4f896a1d07d6014b439a9090f78fd7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#aaa4f896a1d07d6014b439a9090f78fd7">rbt_next</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *current)</td></tr>
<tr class="separator:aaa4f896a1d07d6014b439a9090f78fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5870b12e1ec4fe06556c1d5e54290cb3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a5870b12e1ec4fe06556c1d5e54290cb3">rbt_prev</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *current)</td></tr>
<tr class="separator:a5870b12e1ec4fe06556c1d5e54290cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c8a8983d0db6dd18936255f0600b0a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#af0c8a8983d0db6dd18936255f0600b0a">rbt_lower_bound</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key)</td></tr>
<tr class="separator:af0c8a8983d0db6dd18936255f0600b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7811896fd44ca0e33013fe3968843e3c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a7811896fd44ca0e33013fe3968843e3c">rbt_upper_bound</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key)</td></tr>
<tr class="separator:a7811896fd44ca0e33013fe3968843e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570e162e588a362ad5ce2af9c0d7917f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a570e162e588a362ad5ce2af9c0d7917f">rbt_search</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, <a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *parent, const void *key)</td></tr>
<tr class="separator:a570e162e588a362ad5ce2af9c0d7917f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200f386d57dffaa8835bbb663c0aef4c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a200f386d57dffaa8835bbb663c0aef4c">rbt_search_cmp</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, <a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *parent, const void *key, ib_rbt_compare <a class="el" href="field_8cc.html#a59a13a7009755ede163e43c1068704c7">compare</a>, ib_rbt_arg_compare arg_compare)</td></tr>
<tr class="separator:a200f386d57dffaa8835bbb663c0aef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c18f12889d9fd2ce0fb1515bc534637"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a2c18f12889d9fd2ce0fb1515bc534637">rbt_clear</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="separator:a2c18f12889d9fd2ce0fb1515bc534637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6691fac5e02bca98466ba10c371989b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#aa6691fac5e02bca98466ba10c371989b">rbt_merge_uniq</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *dst, const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *src)</td></tr>
<tr class="separator:aa6691fac5e02bca98466ba10c371989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a2d6cc0999684a60bee9f5185a0c3e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#ac7a2d6cc0999684a60bee9f5185a0c3e">rbt_merge_uniq_destructive</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *dst, <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *src)</td></tr>
<tr class="separator:ac7a2d6cc0999684a60bee9f5185a0c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95ee9e8fb929ee4336d27cb2aacb2f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a4a95ee9e8fb929ee4336d27cb2aacb2f">rbt_validate</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="separator:a4a95ee9e8fb929ee4336d27cb2aacb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec7ec29a13db727194019b3bf13b6b0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#aaec7ec29a13db727194019b3bf13b6b0">rbt_print</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, ib_rbt_print_node print)</td></tr>
<tr class="separator:aaec7ec29a13db727194019b3bf13b6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (c) 2007, 2010, Oracle and/or its affiliates. All Rights Reserved.</p>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; version 2 of the License.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA</p>
<p>Various utilities</p>
<p>Created 2007-03-20 Sunny Bains </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1715bf199a80c83f5be40165079ed339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1715bf199a80c83f5be40165079ed339">&#9670;&nbsp;</a></span>ib_rbt_color_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ut0rbt_8h.html#a1715bf199a80c83f5be40165079ed339">ib_rbt_color_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Red black tree color types </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abda0e7602a733198120cc93e21be2cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda0e7602a733198120cc93e21be2cef">&#9670;&nbsp;</a></span>rbt_add_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new node to the tree, useful for data that is pre-sorted. </p><dl class="section return"><dt>Returns</dt><dd>appended node in: this value is copied to the node</dd></dl>
<p>Add a new node to the tree, useful for data that is pre-sorted. </p><dl class="section return"><dt>Returns</dt><dd>appended node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">parent</td><td>in: bounds </td></tr>
    <tr><td class="paramname">value</td><td>in: this value is copied to the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c18f12889d9fd2ce0fb1515bc534637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c18f12889d9fd2ce0fb1515bc534637">&#9670;&nbsp;</a></span>rbt_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rbt_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the tree, deletes (and free's) all the nodes. in: rb tree</p>
<p>Reset the tree. Delete all the nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae582d916e935fac8ec45850cb1255082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae582d916e935fac8ec45850cb1255082">&#9670;&nbsp;</a></span>rbt_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structib__rbt__t.html">ib_rbt_t</a>* rbt_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeof_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an instance of a red black tree </p><dl class="section return"><dt>Returns</dt><dd>rb tree instance in: comparator</dd></dl>
<p>Create an instance of a red black tree. </p><dl class="section return"><dt>Returns</dt><dd>an empty rb tree </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeof_value</td><td>in: sizeof data item </td></tr>
    <tr><td class="paramname">compare</td><td>in: fn to compare items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88cfa8f5baa48789af0e457bd3c57bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cfa8f5baa48789af0e457bd3c57bd0">&#9670;&nbsp;</a></span>rbt_create_arg_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structib__rbt__t.html">ib_rbt_t</a>* rbt_create_arg_cmp </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeof_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_arg_compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cmp_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an instance of a red black tree, whose comparison function takes an argument </p><dl class="section return"><dt>Returns</dt><dd>rb tree instance in: compare fn arg</dd></dl>
<p>Create an instance of a red black tree, whose comparison function takes an argument </p><dl class="section return"><dt>Returns</dt><dd>an empty rb tree </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeof_value</td><td>in: sizeof data item </td></tr>
    <tr><td class="paramname">compare</td><td>in: fn to compare items </td></tr>
    <tr><td class="paramname">cmp_arg</td><td>in: compare fn arg </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8a776fb52186a413fc859d393c90165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a776fb52186a413fc859d393c90165">&#9670;&nbsp;</a></span>rbt_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool rbt_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a node from the red black tree, identified by key</p>
<p>Delete a node indentified by key. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success FALSE if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">key</td><td>in: key to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51bfcc467fec46eb6670b0bebd2ac993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bfcc467fec46eb6670b0bebd2ac993">&#9670;&nbsp;</a></span>rbt_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the left most data node in the tree </p><dl class="section return"><dt>Returns</dt><dd>left most node in: rb tree</dd></dl>
<p>Return the left most node in the tree. </p>

</div>
</div>
<a id="a160680a842fc674633f59f527c7bcdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160680a842fc674633f59f527c7bcdfd">&#9670;&nbsp;</a></span>rbt_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rbt_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an instance of a red black tree in: rb tree to free</p>
<p>Free all the nodes and free the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97d037d4ead5e59454a7e11ac3e5c97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d037d4ead5e59454a7e11ac3e5c97c">&#9670;&nbsp;</a></span>rbt_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add data to the red black tree, identified by key (no dups yet!) </p><dl class="section return"><dt>Returns</dt><dd>inserted node in: data that will be copied to the node.</dd></dl>
<p>Generic insert of a value in the rb tree. </p><dl class="section return"><dt>Returns</dt><dd>inserted node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">key</td><td>in: key for ordering </td></tr>
    <tr><td class="paramname">value</td><td>in: value of key, this value is copied to the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21d9ec1c12b3e25cd4d2a5e5d2ddf292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d9ec1c12b3e25cd4d2a5e5d2ddf292">&#9670;&nbsp;</a></span>rbt_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the right most data node in the tree </p><dl class="section return"><dt>Returns</dt><dd>right most node in: rb tree</dd></dl>
<p>Return the right most node in the tree. </p><dl class="section return"><dt>Returns</dt><dd>the rightmost node or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada0cf8e2e61d016b06c22ae5eb26234b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0cf8e2e61d016b06c22ae5eb26234b">&#9670;&nbsp;</a></span>rbt_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a node from the red black tree, identified by key, NULL if not found </p><dl class="section return"><dt>Returns</dt><dd>node if found else return NULL in: key to lookup</dd></dl>
<p>Find a matching node in the rb tree. </p><dl class="section return"><dt>Returns</dt><dd>NULL if not found else the node where key was found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">key</td><td>in: key to use for search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0c8a8983d0db6dd18936255f0600b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c8a8983d0db6dd18936255f0600b0a">&#9670;&nbsp;</a></span>rbt_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the node that has the lowest key that is &gt;= key. </p><dl class="section return"><dt>Returns</dt><dd>node that satisfies the lower bound constraint or NULL in: key to search</dd></dl>
<p>Find the node that has the lowest key that is &gt;= key. </p><dl class="section return"><dt>Returns</dt><dd>node satisfying the lower bound constraint or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">key</td><td>in: key to search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6691fac5e02bca98466ba10c371989b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6691fac5e02bca98466ba10c371989b">&#9670;&nbsp;</a></span>rbt_merge_uniq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint rbt_merge_uniq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the node from dst into src. Return the number of nodes merged. </p><dl class="section return"><dt>Returns</dt><dd>no. of recs merged in: src rb tree</dd></dl>
<p>Merge the node from dst into src. Return the number of nodes merged. </p><dl class="section return"><dt>Returns</dt><dd>no. of recs merged </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>in: dst rb tree </td></tr>
    <tr><td class="paramname">src</td><td>in: src rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a2d6cc0999684a60bee9f5185a0c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2d6cc0999684a60bee9f5185a0c3e">&#9670;&nbsp;</a></span>rbt_merge_uniq_destructive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint rbt_merge_uniq_destructive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the node from dst into src. Return the number of nodes merged. Delete the nodes from src after copying node to dst. As a side effect the duplicates will be left untouched in the src, since we don't support duplicates (yet). NOTE: src and dst must be similar, the function doesn't check for this condition (yet). </p><dl class="section return"><dt>Returns</dt><dd>no. of recs merged in: src rb tree</dd></dl>
<p>Merge the node from dst into src. Return the number of nodes merged. Delete the nodes from src after copying node to dst. As a side effect the duplicates will be left untouched in the src. </p><dl class="section return"><dt>Returns</dt><dd>no. of recs merged </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>in: dst rb tree </td></tr>
    <tr><td class="paramname">src</td><td>in: src rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa4f896a1d07d6014b439a9090f78fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4f896a1d07d6014b439a9090f78fd7">&#9670;&nbsp;</a></span>rbt_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the next node from current. </p><dl class="section return"><dt>Returns</dt><dd>successor node to current that is passed in.</dd></dl>
<p>Return the next node. </p><dl class="section return"><dt>Returns</dt><dd>node next from current </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">current</td><td>in: current node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5870b12e1ec4fe06556c1d5e54290cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5870b12e1ec4fe06556c1d5e54290cb3">&#9670;&nbsp;</a></span>rbt_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the prev node from current. </p><dl class="section return"><dt>Returns</dt><dd>precedessor node to current that is passed in</dd></dl>
<p>Return the previous node. </p><dl class="section return"><dt>Returns</dt><dd>node prev from current </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">current</td><td>in: current node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaec7ec29a13db727194019b3bf13b6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec7ec29a13db727194019b3bf13b6b0">&#9670;&nbsp;</a></span>rbt_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rbt_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_print_node&#160;</td>
          <td class="paramname"><em>print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over the tree in depth first order. in: print function</p>
<p>Iterate over the tree in depth first order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: tree to traverse </td></tr>
    <tr><td class="paramname">print</td><td>in: print function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75d12d6639f6ab93891188f7fe1b802b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d12d6639f6ab93891188f7fe1b802b">&#9670;&nbsp;</a></span>rbt_remove_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td>
          <td class="paramname"><em>const_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a node from the red black tree, NOTE: This function will not delete the node instance, THAT IS THE CALLERS RESPONSIBILITY. </p><dl class="section return"><dt>Returns</dt><dd>the deleted node with the const. in: node to delete, this is a fudge and declared const because the caller has access only to const nodes.</dd></dl>
<p>Remove a node from the rb tree, the node is not free'd, that is the callers responsibility. </p><dl class="section return"><dt>Returns</dt><dd>deleted node but without the const </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">const_node</td><td>in: node to delete, this is a fudge and declared const because the caller can access only const nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a570e162e588a362ad5ce2af9c0d7917f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570e162e588a362ad5ce2af9c0d7917f">&#9670;&nbsp;</a></span>rbt_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int rbt_search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the key, a node will be retuned in parent.last, whether it was found or not. If not found then parent.last will contain the parent node for the possibly new key otherwise the matching node. </p><dl class="section return"><dt>Returns</dt><dd>result of last comparison in: key to search</dd></dl>
<p>Find the node that has the greatest key that is &lt;= key. </p><dl class="section return"><dt>Returns</dt><dd>value of result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">parent</td><td>in: search bounds </td></tr>
    <tr><td class="paramname">key</td><td>in: key to search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a200f386d57dffaa8835bbb663c0aef4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200f386d57dffaa8835bbb663c0aef4c">&#9670;&nbsp;</a></span>rbt_search_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int rbt_search_cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_arg_compare&#160;</td>
          <td class="paramname"><em>arg_compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the key, a node will be retuned in parent.last, whether it was found or not. If not found then parent.last will contain the parent node for the possibly new key otherwise the matching node. </p><dl class="section return"><dt>Returns</dt><dd>result of last comparison in: fn to compare items with argument</dd></dl>
<p>Find the node that has the greatest key that is &lt;= key. But use the supplied comparison function. </p><dl class="section return"><dt>Returns</dt><dd>value of result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">parent</td><td>in: search bounds </td></tr>
    <tr><td class="paramname">key</td><td>in: key to search </td></tr>
    <tr><td class="paramname">compare</td><td>in: fn to compare items </td></tr>
    <tr><td class="paramname">arg_compare</td><td>in: fn to compare items with argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7811896fd44ca0e33013fe3968843e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7811896fd44ca0e33013fe3968843e3c">&#9670;&nbsp;</a></span>rbt_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the node that has the greatest key that is &lt;= key. </p><dl class="section return"><dt>Returns</dt><dd>node that satisifies the upper bound constraint or NULL in: key to search</dd></dl>
<p>Find the node that has the greatest key that is &lt;= key. </p><dl class="section return"><dt>Returns</dt><dd>node satisfying the upper bound constraint or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">key</td><td>in: key to search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a95ee9e8fb929ee4336d27cb2aacb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a95ee9e8fb929ee4336d27cb2aacb2f">&#9670;&nbsp;</a></span>rbt_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool rbt_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify the integrity of the RB tree. For debugging. 0 failure else height of tree (in count of black nodes). </p><dl class="section return"><dt>Returns</dt><dd>TRUE if OK FALSE if tree invalid. in: tree to validate</dd></dl>
<p><a class="el" href="struct_check.html">Check</a> that every path from the root to the leaves has the same count and the tree nodes are in order. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if OK FALSE otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: RB tree to validate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/buf0flu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0flu.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0types_8h_source.html">mtr0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br />
<code>#include &quot;buf0flu.ic&quot;</code><br />
</div>
<p><a href="buf0flu_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2c10073f8f2608c74511614b3fb6c63d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a2c10073f8f2608c74511614b3fb6c63d">buf_flush_remove</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:a2c10073f8f2608c74511614b3fb6c63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab103ef786b28c99629d79d8f89e768e8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ab103ef786b28c99629d79d8f89e768e8">buf_flush_relocate_on_flush_list</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *dpage)</td></tr>
<tr class="separator:ab103ef786b28c99629d79d8f89e768e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4d812b4926a7d43eaf8dfc386e904d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#aeb4d812b4926a7d43eaf8dfc386e904d">buf_flush_write_complete</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:aeb4d812b4926a7d43eaf8dfc386e904d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4460ad4f28ba2c245bda6cc4bfbfbe2c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a4460ad4f28ba2c245bda6cc4bfbfbe2c">buf_flush_init_for_writing</a> (byte *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, void *page_zip_, lsn_t newest_lsn)</td></tr>
<tr class="separator:a4460ad4f28ba2c245bda6cc4bfbfbe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9c99474dd78fbb55e8ed2e1dd5cea9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#abe9c99474dd78fbb55e8ed2e1dd5cea9">buf_flush_list</a> (ulint min_n, lsn_t lsn_limit, ulint *n_processed)</td></tr>
<tr class="separator:abe9c99474dd78fbb55e8ed2e1dd5cea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdcc4f760f8ebd33c02f0cd042490b4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a9cdcc4f760f8ebd33c02f0cd042490b4">buf_flush_single_page_from_LRU</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="separator:a9cdcc4f760f8ebd33c02f0cd042490b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae775b5ae847bc1c02cb581bf69ce1931"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ae775b5ae847bc1c02cb581bf69ce1931">buf_flush_wait_batch_end</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:ae775b5ae847bc1c02cb581bf69ce1931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6980abb9a2999e94fa8774fd501828d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#af6980abb9a2999e94fa8774fd501828d">buf_flush_wait_batch_end_wait_only</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:af6980abb9a2999e94fa8774fd501828d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b6a156aad91f522c6d48e19d707d2c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a48b6a156aad91f522c6d48e19d707d2c">buf_flush_note_modification</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a48b6a156aad91f522c6d48e19d707d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109aff89cdb96f674786a8b913be0043"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a109aff89cdb96f674786a8b913be0043">buf_flush_recv_note_modification</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, lsn_t start_lsn, lsn_t end_lsn)</td></tr>
<tr class="separator:a109aff89cdb96f674786a8b913be0043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ddaefb5098a15d7b40822fc0108dc0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a03ddaefb5098a15d7b40822fc0108dc0">buf_flush_ready_for_replace</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:a03ddaefb5098a15d7b40822fc0108dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514fb1b0bfe633eb72bbfe7f4b6bb491"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a514fb1b0bfe633eb72bbfe7f4b6bb491">buf_flush_page_cleaner_thread</a> (void *arg)</td></tr>
<tr class="separator:a514fb1b0bfe633eb72bbfe7f4b6bb491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c9b352f7400e101a335d34f36f6021"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a18c9b352f7400e101a335d34f36f6021">buf_flush_LRU_tail</a> (void)</td></tr>
<tr class="separator:a18c9b352f7400e101a335d34f36f6021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ba4c6df1e52b8f19586ee715ebda7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a516ba4c6df1e52b8f19586ee715ebda7">buf_flush_wait_LRU_batch_end</a> (void)</td></tr>
<tr class="separator:a516ba4c6df1e52b8f19586ee715ebda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49fa7dbba8849c77339ecf1a363ac3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#aeb49fa7dbba8849c77339ecf1a363ac3">buf_flush_init_flush_rbt</a> (void)</td></tr>
<tr class="separator:aeb49fa7dbba8849c77339ecf1a363ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e647da62f866e246ae0c827700a1959"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a3e647da62f866e246ae0c827700a1959">buf_flush_free_flush_rbt</a> (void)</td></tr>
<tr class="separator:a3e647da62f866e246ae0c827700a1959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5914fbbf06f6b008435e61ba0e3dadc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ab5914fbbf06f6b008435e61ba0e3dadc">buf_flush_page</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type, bool <a class="el" href="ibuf0ibuf_8cc.html#a6265893dd43b2df4e241408f9e736f2e">sync</a>)</td></tr>
<tr class="separator:ab5914fbbf06f6b008435e61ba0e3dadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f78450b4f183226e473298bc324d106"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a2f78450b4f183226e473298bc324d106">buf_flush_ready_for_flush</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result))</td></tr>
<tr class="separator:a2f78450b4f183226e473298bc324d106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa3430b20c0430c4730079e4d2242568a"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#aa3430b20c0430c4730079e4d2242568a">buf_page_cleaner_is_active</a></td></tr>
<tr class="separator:aa3430b20c0430c4730079e4d2242568a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The database buffer pool flush algorithm</p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3e647da62f866e246ae0c827700a1959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e647da62f866e246ae0c827700a1959">&#9670;&nbsp;</a></span>buf_flush_free_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_free_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees up the red-black tree. </p>

</div>
</div>
<a id="aeb49fa7dbba8849c77339ecf1a363ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49fa7dbba8849c77339ecf1a363ac3">&#9670;&nbsp;</a></span>buf_flush_init_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_init_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the red-black tree to speed up insertions into the flush_list during recovery process. Should be called at the start of recovery process before any page has been read/written. </p>

</div>
</div>
<a id="a4460ad4f28ba2c245bda6cc4bfbfbe2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4460ad4f28ba2c245bda6cc4bfbfbe2c">&#9670;&nbsp;</a></span>buf_flush_init_for_writing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_init_for_writing </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>page_zip_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>newest_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a page for writing to the tablespace. in: newest modification lsn to the page</p>
<p>Initializes a page for writing to the tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in/out: page </td></tr>
    <tr><td class="paramname">page_zip_</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">newest_lsn</td><td>in: newest modification lsn to the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe9c99474dd78fbb55e8ed2e1dd5cea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9c99474dd78fbb55e8ed2e1dd5cea9">&#9670;&nbsp;</a></span>buf_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_flush_list </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_processed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This utility flushes dirty blocks from the end of the flush list of all buffer pool instances. NOTE: The calling thread is not allowed to own any latches on pages! </p><dl class="section return"><dt>Returns</dt><dd>true if a batch was queued successfully for each buffer pool instance. false if another batch of same type was already running in at least one of the buffer pool instance out: the number of pages which were processed is passed back to caller. Ignored if NULL</dd></dl>
<p>This utility flushes dirty blocks from the end of the flush list of all buffer pool instances. NOTE: The calling thread is not allowed to own any latches on pages! </p><dl class="section return"><dt>Returns</dt><dd>true if a batch was queued successfully for each buffer pool instance. false if another batch of same type was already running in at least one of the buffer pool instance </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_n</td><td>in: wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramname">lsn_limit</td><td>in the case BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
    <tr><td class="paramname">n_processed</td><td>out: the number of pages which were processed is passed back to caller. Ignored if NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18c9b352f7400e101a335d34f36f6021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c9b352f7400e101a335d34f36f6021">&#9670;&nbsp;</a></span>buf_flush_LRU_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_flush_LRU_tail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears up tail of the LRU lists: Put replaceable pages at the tail of LRU to the free list Flush dirty pages at the tail of LRU to the disk The depth to which we scan each buffer pool is controlled by dynamic config parameter innodb_LRU_scan_depth. </p><dl class="section return"><dt>Returns</dt><dd>total pages flushed </dd></dl>

</div>
</div>
<a id="a48b6a156aad91f522c6d48e19d707d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b6a156aad91f522c6d48e19d707d2c">&#9670;&nbsp;</a></span>buf_flush_note_modification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_flush_note_modification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called at a mini-transaction commit, if a page was modified in it. Puts the block to the list of modified blocks, if it not already in it. in: mtr </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block which is modified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5914fbbf06f6b008435e61ba0e3dadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5914fbbf06f6b008435e61ba0e3dadc">&#9670;&nbsp;</a></span>buf_flush_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_flush_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a flushable page asynchronously from the buffer pool to a file. NOTE: in simulated aio we must call os_aio_simulated_wake_handler_threads after we have posted a batch of writes! NOTE: buf_pool-&gt;mutex and buf_page_get_mutex(bpage) must be held upon entering this function, and they will be released by this function if it returns true. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the page was flushed in: true if sync IO request</dd></dl>
<p>Writes a flushable page asynchronously from the buffer pool to a file. NOTE: in simulated aio we must call os_aio_simulated_wake_handler_threads after we have posted a batch of writes! NOTE: buf_pool-&gt;mutex and buf_page_get_mutex(bpage) must be held upon entering this function, and they will be released by this function if it returns true. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the page was flushed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: buffer control block </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: type of flush </td></tr>
    <tr><td class="paramname">sync</td><td>in: true if sync IO request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a514fb1b0bfe633eb72bbfe7f4b6bb491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514fb1b0bfe633eb72bbfe7f4b6bb491">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>() buf_flush_page_cleaner_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>page_cleaner thread tasked with flushing dirty pages from the buffer pools. As of now we'll have only one instance of this thread. </p><dl class="section return"><dt>Returns</dt><dd>a dummy parameter in: a dummy parameter required by os_thread_create </dd></dl>

</div>
</div>
<a id="a2f78450b4f183226e473298bc324d106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f78450b4f183226e473298bc324d106">&#9670;&nbsp;</a></span>buf_flush_ready_for_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_flush_ready_for_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the block is modified and ready for flushing. </p><dl class="section return"><dt>Returns</dt><dd>true if can flush immediately </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer control block, must be buf_page_in_file(bpage) </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: type of flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03ddaefb5098a15d7b40822fc0108dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ddaefb5098a15d7b40822fc0108dc0">&#9670;&nbsp;</a></span>buf_flush_ready_for_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_flush_ready_for_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the file page block is immediately suitable for replacement, i.e., transition FILE_PAGE =&gt; NOT_USED allowed. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if can replace immediately in: buffer control block, must be buf_page_in_file(bpage) and in the LRU list</dd></dl>
<p>Returns TRUE if the file page block is immediately suitable for replacement, i.e., the transition FILE_PAGE =&gt; NOT_USED allowed. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if can replace immediately </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer control block, must be buf_page_in_file(bpage) and in the LRU list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a109aff89cdb96f674786a8b913be0043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109aff89cdb96f674786a8b913be0043">&#9670;&nbsp;</a></span>buf_flush_recv_note_modification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_flush_recv_note_modification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>end_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called when recovery has modified a buffer page. in: end lsn of the last mtr in the set of mtr's </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block which is modified </td></tr>
    <tr><td class="paramname">start_lsn</td><td>in: start lsn of the first mtr in a set of mtr's </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab103ef786b28c99629d79d8f89e768e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab103ef786b28c99629d79d8f89e768e8">&#9670;&nbsp;</a></span>buf_flush_relocate_on_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_relocate_on_flush_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>dpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relocates a buffer control block on the flush_list. Note that it is assumed that the contents of bpage has already been copied to dpage. in/out: destination block</p>
<p>Relocates a buffer control block on the flush_list. Note that it is assumed that the contents of bpage have already been copied to dpage. IMPORTANT: When this function is called bpage and dpage are not exact copies of each other. For example, they both will have different ::state. Also the ::list pointers in dpage may be stale. We need to use the current list node (bpage) to do the list manipulation because the list pointers could have changed between the time that we copied the contents of bpage to the dpage and the flush list manipulation below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block being moved </td></tr>
    <tr><td class="paramname">dpage</td><td>in/out: destination block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c10073f8f2608c74511614b3fb6c63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c10073f8f2608c74511614b3fb6c63d">&#9670;&nbsp;</a></span>buf_flush_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a block from the flush list of modified blocks. in: pointer to the block in question</p>
<p>Remove a block from the flush list of modified blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cdcc4f760f8ebd33c02f0cd042490b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdcc4f760f8ebd33c02f0cd042490b4">&#9670;&nbsp;</a></span>buf_flush_single_page_from_LRU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_flush_single_page_from_LRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function picks up a single dirty page from the tail of the LRU list, flushes it, removes it from page_hash and LRU list and puts it on the free list. It is called from user threads when they are unable to find a replacable page at the tail of the LRU list i.e.: when the background LRU flushing in the page_cleaner thread is not fast enough to keep pace with the workload. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success. in/out: buffer pool instance</dd></dl>
<p>This function picks up a single dirty page from the tail of the LRU list, flushes it, removes it from page_hash and LRU list and puts it on the free list. It is called from user threads when they are unable to find a replaceable page at the tail of the LRU list i.e.: when the background LRU flushing in the page_cleaner thread is not fast enough to keep pace with the workload. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae775b5ae847bc1c02cb581bf69ce1931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae775b5ae847bc1c02cb581bf69ce1931">&#9670;&nbsp;</a></span>buf_flush_wait_batch_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_wait_batch_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until a flush batch of the given type ends in: BUF_FLUSH_LRU or BUF_FLUSH_LIST</p>
<p>Waits until a flush batch of the given type ends </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">type</td><td>in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6980abb9a2999e94fa8774fd501828d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6980abb9a2999e94fa8774fd501828d">&#9670;&nbsp;</a></span>buf_flush_wait_batch_end_wait_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_wait_batch_end_wait_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until a flush batch of the given type ends. This is called by a thread that only wants to wait for a flush to end but doesn't do any flushing itself. in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a516ba4c6df1e52b8f19586ee715ebda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516ba4c6df1e52b8f19586ee715ebda7">&#9670;&nbsp;</a></span>buf_flush_wait_LRU_batch_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_wait_LRU_batch_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for any possible LRU flushes that are in progress to end. </p>

</div>
</div>
<a id="aeb4d812b4926a7d43eaf8dfc386e904d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4d812b4926a7d43eaf8dfc386e904d">&#9670;&nbsp;</a></span>buf_flush_write_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_write_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the flush system data structures when a write is completed. in: pointer to the block in question</p>
<p>Updates the flush system data structures when a write is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa3430b20c0430c4730079e4d2242568a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3430b20c0430c4730079e4d2242568a">&#9670;&nbsp;</a></span>buf_page_cleaner_is_active</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_page_cleaner_is_active</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicating if the page_cleaner is in active state.</p>
<p>Flag indicating if the page_cleaner is in active state. This flag is set to TRUE by the page_cleaner thread when it is spawned and is set back to FALSE at shutdown by the page_cleaner as well. Therefore no need to protect it by a mutex. It is only ever read by the thread doing the shutdown </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

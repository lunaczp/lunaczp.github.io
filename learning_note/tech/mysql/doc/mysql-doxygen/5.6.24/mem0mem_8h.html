<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/mem0mem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mem0mem.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0rnd_8h_source.html">ut0rnd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0lst_8h_source.html">ut0lst.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mach0data_8h_source.html">mach0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem0dbg_8h_source.html">mem0dbg.h</a>&quot;</code><br />
<code>#include &quot;mem0mem.ic&quot;</code><br />
</div>
<p><a href="mem0mem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmem__block__info__t.html">mem_block_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac7fc6050ef7fde046b8aa0af92c2afae"><td class="memItemLeft" align="right" valign="top"><a id="ac7fc6050ef7fde046b8aa0af92c2afae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_DYNAMIC</b>&#160;&#160;&#160;0	/* the most common <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a> */</td></tr>
<tr class="separator:ac7fc6050ef7fde046b8aa0af92c2afae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2623d2577c63e89bd0173f928be08e9"><td class="memItemLeft" align="right" valign="top"><a id="ad2623d2577c63e89bd0173f928be08e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_BUFFER</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ad2623d2577c63e89bd0173f928be08e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6621ead8a647eed62fbd8a311a62330c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_BTR_SEARCH</b></td></tr>
<tr class="separator:a6621ead8a647eed62fbd8a311a62330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d3586895796c6473e46aa6a64bd998"><td class="memItemLeft" align="right" valign="top"><a id="a47d3586895796c6473e46aa6a64bd998"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_FOR_BTR_SEARCH</b>&#160;&#160;&#160;(MEM_HEAP_BTR_SEARCH | MEM_HEAP_BUFFER)</td></tr>
<tr class="separator:a47d3586895796c6473e46aa6a64bd998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1e03a482e10cf25756bb96b3368bc2"><td class="memItemLeft" align="right" valign="top"><a id="a7c1e03a482e10cf25756bb96b3368bc2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_FOR_PAGE_HASH</b>&#160;&#160;&#160;(MEM_HEAP_DYNAMIC)</td></tr>
<tr class="separator:a7c1e03a482e10cf25756bb96b3368bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e266b884663510a1c569492edfc3a4"><td class="memItemLeft" align="right" valign="top"><a id="a83e266b884663510a1c569492edfc3a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_FOR_RECV_SYS</b>&#160;&#160;&#160;(MEM_HEAP_BUFFER)</td></tr>
<tr class="separator:a83e266b884663510a1c569492edfc3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a390063fcee97542cade99064c3014"><td class="memItemLeft" align="right" valign="top"><a id="a68a390063fcee97542cade99064c3014"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_FOR_LOCK_HEAP</b>&#160;&#160;&#160;(MEM_HEAP_BUFFER)</td></tr>
<tr class="separator:a68a390063fcee97542cade99064c3014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07412b5b33ff3b94be36b581449cbeb7"><td class="memItemLeft" align="right" valign="top"><a id="a07412b5b33ff3b94be36b581449cbeb7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_BLOCK_START_SIZE</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a07412b5b33ff3b94be36b581449cbeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff86ded019fa67facacc67b8a615001b"><td class="memItemLeft" align="right" valign="top"><a id="aff86ded019fa67facacc67b8a615001b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_BLOCK_STANDARD_SIZE</b>&#160;&#160;&#160;(UNIV_PAGE_SIZE &gt;= 16384 ? 8000 : MEM_MAX_ALLOC_IN_BUF)</td></tr>
<tr class="separator:aff86ded019fa67facacc67b8a615001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737ff56ffe835fe44b1a133a459141e8"><td class="memItemLeft" align="right" valign="top"><a id="a737ff56ffe835fe44b1a133a459141e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_MAX_ALLOC_IN_BUF</b>&#160;&#160;&#160;(UNIV_PAGE_SIZE - 200)</td></tr>
<tr class="separator:a737ff56ffe835fe44b1a133a459141e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b03a5cbf64e5271e6c62a9cc6bb5b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a37b03a5cbf64e5271e6c62a9cc6bb5b5">mem_heap_create</a>(N)</td></tr>
<tr class="separator:a37b03a5cbf64e5271e6c62a9cc6bb5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cad9edc7402f0af61a42fbd09343b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#aa3cad9edc7402f0af61a42fbd09343b9">mem_heap_create_typed</a>(N,  T)</td></tr>
<tr class="separator:aa3cad9edc7402f0af61a42fbd09343b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a31a8babbb6dc93262e47aff362638"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a84a31a8babbb6dc93262e47aff362638">mem_heap_free</a>(<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a84a31a8babbb6dc93262e47aff362638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933476069d9c87d190e4d6a18eeca199"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a933476069d9c87d190e4d6a18eeca199">mem_zalloc</a>(N)&#160;&#160;&#160;memset(mem_alloc(N), 0, (N))</td></tr>
<tr class="separator:a933476069d9c87d190e4d6a18eeca199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbb534010925c9124d8ec0c855b75b9"><td class="memItemLeft" align="right" valign="top"><a id="accbb534010925c9124d8ec0c855b75b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>mem_alloc</b>(N)&#160;&#160;&#160;<a class="el" href="mem0mem_8h.html#a66d9ae9432065dd57d4719ee3429c8b6">mem_alloc_func</a>((N), NULL)</td></tr>
<tr class="separator:accbb534010925c9124d8ec0c855b75b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406a62553140ff71eb7bca005631dd33"><td class="memItemLeft" align="right" valign="top"><a id="a406a62553140ff71eb7bca005631dd33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>mem_alloc2</b>(N,  S)&#160;&#160;&#160;<a class="el" href="mem0mem_8h.html#a66d9ae9432065dd57d4719ee3429c8b6">mem_alloc_func</a>((N), (S))</td></tr>
<tr class="separator:a406a62553140ff71eb7bca005631dd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdeda261ea5f6db299898f33e6bbdbf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a4cdeda261ea5f6db299898f33e6bbdbf">mem_free</a>(PTR)&#160;&#160;&#160;<a class="el" href="mem0mem_8h.html#a8b8f05469f9f6eec258bbe5e75bc4b1a">mem_free_func</a>((PTR), __FILE__, __LINE__)</td></tr>
<tr class="separator:a4cdeda261ea5f6db299898f33e6bbdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339a3734708830e0bee01de7eaf96715"><td class="memItemLeft" align="right" valign="top"><a id="a339a3734708830e0bee01de7eaf96715"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_BLOCK_MAGIC_N</b>&#160;&#160;&#160;764741555</td></tr>
<tr class="separator:a339a3734708830e0bee01de7eaf96715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708a8efd990e3d65c4446d992cb6ee4d"><td class="memItemLeft" align="right" valign="top"><a id="a708a8efd990e3d65c4446d992cb6ee4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_FREED_BLOCK_MAGIC_N</b>&#160;&#160;&#160;547711122</td></tr>
<tr class="separator:a708a8efd990e3d65c4446d992cb6ee4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a2ed79ee7aa82b1c09651e1047eda1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_BLOCK_HEADER_SIZE</b></td></tr>
<tr class="separator:ad6a2ed79ee7aa82b1c09651e1047eda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5e3855e50a4a7a806a1f012dbb63e0f5"><td class="memItemLeft" align="right" valign="top"><a id="a5e3855e50a4a7a806a1f012dbb63e0f5"></a>
typedef struct <a class="el" href="structmem__block__info__t.html">mem_block_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mem_block_t</b></td></tr>
<tr class="separator:a5e3855e50a4a7a806a1f012dbb63e0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a10a74bdb0acc8a530dd6ec3c8538a"><td class="memItemLeft" align="right" valign="top"><a id="a29a10a74bdb0acc8a530dd6ec3c8538a"></a>
typedef <a class="el" href="structmem__block__info__t.html">mem_block_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mem_heap_t</b></td></tr>
<tr class="separator:a29a10a74bdb0acc8a530dd6ec3c8538a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a35202ac8c0599fd2ba745cf7c8660104"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a35202ac8c0599fd2ba745cf7c8660104">mem_init</a> (ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a35202ac8c0599fd2ba745cf7c8660104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c1e14f38416a0128af1ddf92f4a08d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ac8c1e14f38416a0128af1ddf92f4a08d">mem_close</a> (void)</td></tr>
<tr class="separator:ac8c1e14f38416a0128af1ddf92f4a08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf080bbde5be34046a3bebba11be4155"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#acf080bbde5be34046a3bebba11be4155">mem_heap_create_func</a> (ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:acf080bbde5be34046a3bebba11be4155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34047c1601b14ffef20989e6da7697c3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a34047c1601b14ffef20989e6da7697c3">mem_heap_free_func</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const char *file_name, ulint line)</td></tr>
<tr class="separator:a34047c1601b14ffef20989e6da7697c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8162d816aada62ef8f84c83b6787befa"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a8162d816aada62ef8f84c83b6787befa">mem_heap_zalloc</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a8162d816aada62ef8f84c83b6787befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f7ee9ca3354fdd5bc633f5ae7b9421"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a92f7ee9ca3354fdd5bc633f5ae7b9421">mem_heap_alloc</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a92f7ee9ca3354fdd5bc633f5ae7b9421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf86da5f1414a8bb3f80e50321a8e55e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#abf86da5f1414a8bb3f80e50321a8e55e">mem_heap_get_heap_top</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:abf86da5f1414a8bb3f80e50321a8e55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b274fd0d860517ff623eef01a6a099a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a8b274fd0d860517ff623eef01a6a099a">mem_heap_free_heap_top</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, byte *old_top)</td></tr>
<tr class="separator:a8b274fd0d860517ff623eef01a6a099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ae9a39a4d557c68977578bd0db3fa8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a98ae9a39a4d557c68977578bd0db3fa8">mem_heap_empty</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a98ae9a39a4d557c68977578bd0db3fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854d0114bb14a2fc66685af99642c4f2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a854d0114bb14a2fc66685af99642c4f2">mem_heap_get_top</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a854d0114bb14a2fc66685af99642c4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbaa90de4133e744d809cfd6c764046"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a0bbaa90de4133e744d809cfd6c764046">mem_heap_free_top</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a0bbaa90de4133e744d809cfd6c764046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469829136569041fbd26404dd7af7e08"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a469829136569041fbd26404dd7af7e08">mem_heap_get_size</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a469829136569041fbd26404dd7af7e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d9ae9432065dd57d4719ee3429c8b6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a66d9ae9432065dd57d4719ee3429c8b6">mem_alloc_func</a> (ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, ulint *<a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a66d9ae9432065dd57d4719ee3429c8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8f05469f9f6eec258bbe5e75bc4b1a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a8b8f05469f9f6eec258bbe5e75bc4b1a">mem_free_func</a> (void *ptr, const char *file_name, ulint line)</td></tr>
<tr class="separator:a8b8f05469f9f6eec258bbe5e75bc4b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40ee2ae09b8776ea6f7b258d94ee276"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ad40ee2ae09b8776ea6f7b258d94ee276">mem_strdup</a> (const char *str)</td></tr>
<tr class="separator:ad40ee2ae09b8776ea6f7b258d94ee276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601462ebfa8661c981f405734f77cf22"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a601462ebfa8661c981f405734f77cf22">mem_strdupl</a> (const char *str, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:a601462ebfa8661c981f405734f77cf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de3ebcaa704fafbfb878154e0eb8367"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a3de3ebcaa704fafbfb878154e0eb8367">mem_heap_strdup</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const char *str)</td></tr>
<tr class="separator:a3de3ebcaa704fafbfb878154e0eb8367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb6550c0724daf639e0cef00b7b5b63"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a4cb6550c0724daf639e0cef00b7b5b63">mem_heap_strdupl</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const char *str, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:a4cb6550c0724daf639e0cef00b7b5b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c7003eedd1e8e7d40eab34c3569658"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a14c7003eedd1e8e7d40eab34c3569658">mem_heap_strcat</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const char *s1, const char *s2)</td></tr>
<tr class="separator:a14c7003eedd1e8e7d40eab34c3569658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8024cec0a01e9107caaee5c69ec2f1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ada8024cec0a01e9107caaee5c69ec2f1">mem_heap_dup</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:ada8024cec0a01e9107caaee5c69ec2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c1e2f9a469adbce56ed68d44b7363e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#af1c1e2f9a469adbce56ed68d44b7363e">mem_heap_printf</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const char *format,...) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((format(printf</td></tr>
<tr class="separator:af1c1e2f9a469adbce56ed68d44b7363e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The memory management</p>
<p>Created 6/9/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad6a2ed79ee7aa82b1c09651e1047eda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a2ed79ee7aa82b1c09651e1047eda1">&#9670;&nbsp;</a></span>MEM_BLOCK_HEADER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_BLOCK_HEADER_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="ut0ut_8h.html#adb061a676254d8943de08e15cafa062a">ut_calc_align</a>(<span class="keyword">sizeof</span>(<a class="code" href="structmem__block__info__t.html">mem_block_info_t</a>),\</div><div class="line">                                                        UNIV_MEM_ALIGNMENT)</div><div class="ttc" id="structmem__block__info__t_html"><div class="ttname"><a href="structmem__block__info__t.html">mem_block_info_t</a></div><div class="ttdef"><b>Definition:</b> mem0mem.h:371</div></div>
<div class="ttc" id="ut0ut_8h_html_adb061a676254d8943de08e15cafa062a"><div class="ttname"><a href="ut0ut_8h.html#adb061a676254d8943de08e15cafa062a">ut_calc_align</a></div><div class="ttdeci">#define ut_calc_align(n, m)</div><div class="ttdef"><b>Definition:</b> ut0ut.h:194</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4cdeda261ea5f6db299898f33e6bbdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdeda261ea5f6db299898f33e6bbdbf">&#9670;&nbsp;</a></span>mem_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PTR</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="mem0mem_8h.html#a8b8f05469f9f6eec258bbe5e75bc4b1a">mem_free_func</a>((PTR), __FILE__, __LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this macro instead of the corresponding function! Macro for memory buffer freeing </p>

</div>
</div>
<a id="a6621ead8a647eed62fbd8a311a62330c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6621ead8a647eed62fbd8a311a62330c">&#9670;&nbsp;</a></span>MEM_HEAP_BTR_SEARCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_HEAP_BTR_SEARCH</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">2       <span class="comment">/* this flag can optionally be</span></div><div class="line"><span class="comment">                                        ORed to MEM_HEAP_BUFFER, in which</span></div><div class="line"><span class="comment">                                        case heap-&gt;free_block is used in</span></div><div class="line"><span class="comment">                                        some cases for memory allocations,</span></div><div class="line"><span class="comment">                                        and if it&#39;s NULL, the memory</span></div><div class="line"><span class="comment">                                        allocation functions can return</span></div><div class="line"><span class="comment">                                        NULL. */</span></div></div><!-- fragment -->
</div>
</div>
<a id="a37b03a5cbf64e5271e6c62a9cc6bb5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b03a5cbf64e5271e6c62a9cc6bb5b5">&#9670;&nbsp;</a></span>mem_heap_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_heap_create</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">N</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="mem0mem_8h.html#acf080bbde5be34046a3bebba11be4155">mem_heap_create_func</a>(           \</div><div class="line">                (N), MEM_HEAP_DYNAMIC)</div><div class="ttc" id="mem0mem_8h_html_acf080bbde5be34046a3bebba11be4155"><div class="ttname"><a href="mem0mem_8h.html#acf080bbde5be34046a3bebba11be4155">mem_heap_create_func</a></div><div class="ttdeci">UNIV_INLINE mem_heap_t * mem_heap_create_func(ulint n, ulint type)</div></div>
</div><!-- fragment --><p>Use this macro instead of the corresponding function! Macro for memory heap creation. </p>

</div>
</div>
<a id="aa3cad9edc7402f0af61a42fbd09343b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cad9edc7402f0af61a42fbd09343b9">&#9670;&nbsp;</a></span>mem_heap_create_typed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_heap_create_typed</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">N, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="mem0mem_8h.html#acf080bbde5be34046a3bebba11be4155">mem_heap_create_func</a>(   \</div><div class="line">                (N), (T))</div><div class="ttc" id="mem0mem_8h_html_acf080bbde5be34046a3bebba11be4155"><div class="ttname"><a href="mem0mem_8h.html#acf080bbde5be34046a3bebba11be4155">mem_heap_create_func</a></div><div class="ttdeci">UNIV_INLINE mem_heap_t * mem_heap_create_func(ulint n, ulint type)</div></div>
</div><!-- fragment --><p>Use this macro instead of the corresponding function! Macro for memory heap creation. </p>

</div>
</div>
<a id="a84a31a8babbb6dc93262e47aff362638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a31a8babbb6dc93262e47aff362638">&#9670;&nbsp;</a></span>mem_heap_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mem_heap_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="mem0mem_8h.html#a34047c1601b14ffef20989e6da7697c3">mem_heap_free_func</a>(\</div><div class="line">                                          (<a class="code" href="btr0btr_8cc.html#aa45d2d8916ab5959a689743fca2a83df">heap</a>), __FILE__, __LINE__)</div><div class="ttc" id="btr0btr_8cc_html_aa45d2d8916ab5959a689743fca2a83df"><div class="ttname"><a href="btr0btr_8cc.html#aa45d2d8916ab5959a689743fca2a83df">heap</a></div><div class="ttdeci">static const rec_t ulint const dtuple_t ulint mem_heap_t ** heap</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:2512</div></div>
<div class="ttc" id="mem0mem_8h_html_a34047c1601b14ffef20989e6da7697c3"><div class="ttname"><a href="mem0mem_8h.html#a34047c1601b14ffef20989e6da7697c3">mem_heap_free_func</a></div><div class="ttdeci">UNIV_INLINE void mem_heap_free_func(mem_heap_t *heap, const char *file_name, ulint line)</div></div>
</div><!-- fragment --><p>Use this macro instead of the corresponding function! Macro for memory heap freeing. </p>

</div>
</div>
<a id="a933476069d9c87d190e4d6a18eeca199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933476069d9c87d190e4d6a18eeca199">&#9670;&nbsp;</a></span>mem_zalloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_zalloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">N</td><td>)</td>
          <td>&#160;&#160;&#160;memset(mem_alloc(N), 0, (N))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this macro instead of the corresponding function! Macro for memory buffer allocation </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a66d9ae9432065dd57d4719ee3429c8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d9ae9432065dd57d4719ee3429c8b6">&#9670;&nbsp;</a></span>mem_alloc_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_alloc_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE: Use the corresponding macro instead of this function. Allocates a single buffer of memory from the dynamic memory of the C compiler. Is like malloc of C. The buffer must be freed with mem_free. </p><dl class="section return"><dt>Returns</dt><dd>own: free storage out: allocated size in bytes, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: requested size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8c1e14f38416a0128af1ddf92f4a08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c1e14f38416a0128af1ddf92f4a08d">&#9670;&nbsp;</a></span>mem_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void mem_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the memory system. </p>

</div>
</div>
<a id="a8b8f05469f9f6eec258bbe5e75bc4b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8f05469f9f6eec258bbe5e75bc4b1a">&#9670;&nbsp;</a></span>mem_free_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_free_func </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE: Use the corresponding macro instead of this function. Frees a single buffer of storage from the dynamic memory of C compiler. Similar to free of C. in: line where created </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in, own: buffer to be freed </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92f7ee9ca3354fdd5bc633f5ae7b9421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f7ee9ca3354fdd5bc633f5ae7b9421">&#9670;&nbsp;</a></span>mem_heap_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates n bytes of memory from a memory heap. </p><dl class="section return"><dt>Returns</dt><dd>allocated storage, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) in: number of bytes; if the heap is allowed to grow into the buffer pool, this must be &lt;= MEM_MAX_ALLOC_IN_BUF </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf080bbde5be34046a3bebba11be4155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf080bbde5be34046a3bebba11be4155">&#9670;&nbsp;</a></span>mem_heap_create_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* mem_heap_create_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE: Use the corresponding macros instead of this function. Creates a memory heap. For debugging purposes, takes also the file name and line as arguments. </p><dl class="section return"><dt>Returns</dt><dd>own: memory heap, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) in: heap type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: desired start block size, this means that a single user buffer of size n will fit in the block, 0 creates a default size block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada8024cec0a01e9107caaee5c69ec2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8024cec0a01e9107caaee5c69ec2f1">&#9670;&nbsp;</a></span>mem_heap_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void* mem_heap_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicate a block of data, allocated from a memory heap. </p><dl class="section return"><dt>Returns</dt><dd>own: a copy of the data in: length of data, in bytes</dd></dl>
<p>Duplicate a block of data, allocated from a memory heap. </p><dl class="section return"><dt>Returns</dt><dd>own: a copy of the data </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where copy is allocated </td></tr>
    <tr><td class="paramname">data</td><td>in: data to be copied </td></tr>
    <tr><td class="paramname">len</td><td>in: length of data, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98ae9a39a4d557c68977578bd0db3fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ae9a39a4d557c68977578bd0db3fa8">&#9670;&nbsp;</a></span>mem_heap_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empties a memory heap. The first memory block of the heap is not freed. in: heap to empty </p>

</div>
</div>
<a id="a34047c1601b14ffef20989e6da7697c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34047c1601b14ffef20989e6da7697c3">&#9670;&nbsp;</a></span>mem_heap_free_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_free_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE: Use the corresponding macro instead of this function. Frees the space occupied by a memory heap. In the debug version erases the heap memory blocks. in: line where freed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in, own: heap to be freed </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b274fd0d860517ff623eef01a6a099a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b274fd0d860517ff623eef01a6a099a">&#9670;&nbsp;</a></span>mem_heap_free_heap_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_free_heap_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>old_top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the space in a memory heap exceeding the pointer given. The pointer must have been acquired from mem_heap_get_heap_top. The first memory block of the heap is not freed. in: pointer to old top of heap </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: heap from which to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bbaa90de4133e744d809cfd6c764046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbaa90de4133e744d809cfd6c764046">&#9670;&nbsp;</a></span>mem_heap_free_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_free_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the topmost element in a memory heap. The size of the element must be given. in: size of the topmost element </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf86da5f1414a8bb3f80e50321a8e55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf86da5f1414a8bb3f80e50321a8e55e">&#9670;&nbsp;</a></span>mem_heap_get_heap_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE byte* mem_heap_get_heap_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the heap top. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the heap top in: memory heap </dd></dl>

</div>
</div>
<a id="a469829136569041fbd26404dd7af7e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469829136569041fbd26404dd7af7e08">&#9670;&nbsp;</a></span>mem_heap_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint mem_heap_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the space in bytes occupied by a memory heap. in: heap </p>

</div>
</div>
<a id="a854d0114bb14a2fc66685af99642c4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854d0114bb14a2fc66685af99642c4f2">&#9670;&nbsp;</a></span>mem_heap_get_top()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_get_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the topmost element in a memory heap. The size of the element must be given. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the topmost element in: size of the topmost element </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1c1e2f9a469adbce56ed68d44b7363e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c1e2f9a469adbce56ed68d44b7363e">&#9670;&nbsp;</a></span>mem_heap_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* mem_heap_printf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple sprintf replacement that dynamically allocates the space for the formatted string from the given heap. This supports a very limited set of the printf syntax: types 's' and 'u' and length modifier 'l' (which is required for the 'u' type). </p><dl class="section return"><dt>Returns</dt><dd>heap-allocated formatted string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
    <tr><td class="paramname">format</td><td>in: format string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14c7003eedd1e8e7d40eab34c3569658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c7003eedd1e8e7d40eab34c3569658">&#9670;&nbsp;</a></span>mem_heap_strcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* mem_heap_strcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate two strings and return the result, using a memory heap. </p><dl class="section return"><dt>Returns</dt><dd>own: the result in: string 2</dd></dl>
<p>Concatenate two strings and return the result, using a memory heap. </p><dl class="section return"><dt>Returns</dt><dd>own: the result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where string is allocated </td></tr>
    <tr><td class="paramname">s1</td><td>in: string 1 </td></tr>
    <tr><td class="paramname">s2</td><td>in: string 2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de3ebcaa704fafbfb878154e0eb8367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de3ebcaa704fafbfb878154e0eb8367">&#9670;&nbsp;</a></span>mem_heap_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* mem_heap_strdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicates a NUL-terminated string, allocated from a memory heap. </p><dl class="section return"><dt>Returns</dt><dd>own: a copy of the string in: string to be copied</dd></dl>
<p>Duplicates a NUL-terminated string, allocated from a memory heap. </p><dl class="section return"><dt>Returns</dt><dd>own: a copy of the string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where string is allocated </td></tr>
    <tr><td class="paramname">str</td><td>in: string to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cb6550c0724daf639e0cef00b7b5b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb6550c0724daf639e0cef00b7b5b63">&#9670;&nbsp;</a></span>mem_heap_strdupl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_heap_strdupl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a NUL-terminated copy of a nonterminated string, allocated from a memory heap. </p><dl class="section return"><dt>Returns</dt><dd>own: a copy of the string in: length of str, in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where string is allocated </td></tr>
    <tr><td class="paramname">str</td><td>in: string to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8162d816aada62ef8f84c83b6787befa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8162d816aada62ef8f84c83b6787befa">&#9670;&nbsp;</a></span>mem_heap_zalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_zalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates and zero-fills n bytes of memory from a memory heap. </p><dl class="section return"><dt>Returns</dt><dd>allocated, zero-filled storage in: number of bytes; if the heap is allowed to grow into the buffer pool, this must be &lt;= MEM_MAX_ALLOC_IN_BUF </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35202ac8c0599fd2ba745cf7c8660104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35202ac8c0599fd2ba745cf7c8660104">&#9670;&nbsp;</a></span>mem_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void mem_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the memory system. in: common pool size in bytes</p>
<p>Initializes the memory system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>in: common pool size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad40ee2ae09b8776ea6f7b258d94ee276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40ee2ae09b8776ea6f7b258d94ee276">&#9670;&nbsp;</a></span>mem_strdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicates a NUL-terminated string. </p><dl class="section return"><dt>Returns</dt><dd>own: a copy of the string, must be deallocated with mem_free in: string to be copied </dd></dl>

</div>
</div>
<a id="a601462ebfa8661c981f405734f77cf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601462ebfa8661c981f405734f77cf22">&#9670;&nbsp;</a></span>mem_strdupl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_strdupl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a NUL-terminated copy of a nonterminated string. </p><dl class="section return"><dt>Returns</dt><dd>own: a copy of the string, must be deallocated with mem_free in: length of str, in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: sp_head Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsp__head-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sp_head Class Reference<div class="ingroups"><a class="el" href="group___runtime___environment.html">Runtime Environment</a> &raquo; <a class="el" href="group___stored___routines.html">Stored Routines</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sp__head_8h_source.html">sp_head.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sp_head:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsp__head.png" usemap="#sp_5Fhead_map" alt=""/>
  <map id="sp_5Fhead_map" name="sp_5Fhead_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aed1ec3b123a2b494343acfd70a68121e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>HAS_RETURN</b> = 1, 
<b>MULTI_RESULTS</b> = 8, 
<b>CONTAINS_DYNAMIC_SQL</b> = 16, 
<b>IS_INVOKED</b> = 32, 
<br />
&#160;&#160;<b>HAS_SET_AUTOCOMMIT_STMT</b> = 64, 
<b>HAS_COMMIT_OR_ROLLBACK</b> = 128, 
<b>LOG_SLOW_STATEMENTS</b> = 256, 
<b>LOG_GENERAL_LOG</b> = 512, 
<br />
&#160;&#160;<b>HAS_SQLCOM_RESET</b> = 1024, 
<b>HAS_SQLCOM_FLUSH</b> = 2048, 
<a class="el" href="classsp__head.html#aed1ec3b123a2b494343acfd70a68121ea2b0e1fb757a290996d14136d2f75a931">MODIFIES_DATA</a> = 4096
<br />
 }</td></tr>
<tr class="separator:aed1ec3b123a2b494343acfd70a68121e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a92f33f22ca3e595933c6d8cac926c3db"><td class="memItemLeft" align="right" valign="top"><a id="a92f33f22ca3e595933c6d8cac926c3db"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a92f33f22ca3e595933c6d8cac926c3db">is_invoked</a> () const</td></tr>
<tr class="memdesc:a92f33f22ca3e595933c6d8cac926c3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this routine being executed? <br /></td></tr>
<tr class="separator:a92f33f22ca3e595933c6d8cac926c3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39c766ea25ed5216f844fdbe0553d1a"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ab39c766ea25ed5216f844fdbe0553d1a">sp_cache_version</a> () const</td></tr>
<tr class="separator:ab39c766ea25ed5216f844fdbe0553d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726d7b6c8b5ba1eaf3e50d86495d04ed"><td class="memItemLeft" align="right" valign="top"><a id="a726d7b6c8b5ba1eaf3e50d86495d04ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a726d7b6c8b5ba1eaf3e50d86495d04ed">set_sp_cache_version</a> (ulong <a class="el" href="classsp__head.html#ab39c766ea25ed5216f844fdbe0553d1a">sp_cache_version</a>)</td></tr>
<tr class="memdesc:a726d7b6c8b5ba1eaf3e50d86495d04ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the SP cache version. <br /></td></tr>
<tr class="separator:a726d7b6c8b5ba1eaf3e50d86495d04ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5916757d63f55ca220987dfa0b7322"><td class="memItemLeft" align="right" valign="top"><a id="a5a5916757d63f55ca220987dfa0b7322"></a>
<a class="el" href="class_stored__program__creation__ctx.html">Stored_program_creation_ctx</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_creation_ctx</b> ()</td></tr>
<tr class="separator:a5a5916757d63f55ca220987dfa0b7322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c316c316db8fd1b57ca6cdcfd1e962"><td class="memItemLeft" align="right" valign="top"><a id="a03c316c316db8fd1b57ca6cdcfd1e962"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_creation_ctx</b> (<a class="el" href="class_stored__program__creation__ctx.html">Stored_program_creation_ctx</a> *creation_ctx)</td></tr>
<tr class="separator:a03c316c316db8fd1b57ca6cdcfd1e962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab529ba0d2ad8ecda32a95f9f3811502d"><td class="memItemLeft" align="right" valign="top"><a id="ab529ba0d2ad8ecda32a95f9f3811502d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ab529ba0d2ad8ecda32a95f9f3811502d">set_body_start</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const char *begin_ptr)</td></tr>
<tr class="memdesc:ab529ba0d2ad8ecda32a95f9f3811502d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the body-definition start position. <br /></td></tr>
<tr class="separator:ab529ba0d2ad8ecda32a95f9f3811502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a37a7536ba117e27a2341303fcc3ee"><td class="memItemLeft" align="right" valign="top"><a id="a31a37a7536ba117e27a2341303fcc3ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a31a37a7536ba117e27a2341303fcc3ee">set_body_end</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="memdesc:a31a37a7536ba117e27a2341303fcc3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the statement-definition (body-definition) end position. <br /></td></tr>
<tr class="separator:a31a37a7536ba117e27a2341303fcc3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac113041f45cd9bef83a5c53431e2b860"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ac113041f45cd9bef83a5c53431e2b860">execute_trigger</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const <a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *db_name, const <a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, <a class="el" href="structst__grant__info.html">GRANT_INFO</a> *grant_info)</td></tr>
<tr class="separator:ac113041f45cd9bef83a5c53431e2b860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c125eeeef415da5d45fdf16de43ecb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a1c125eeeef415da5d45fdf16de43ecb7">execute_function</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item.html">Item</a> **args, uint argcount, <a class="el" href="class_field.html">Field</a> *return_fld)</td></tr>
<tr class="separator:a1c125eeeef415da5d45fdf16de43ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525a0ec61c3707d2c1be6c6a56d8dd66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a525a0ec61c3707d2c1be6c6a56d8dd66">execute_procedure</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *args)</td></tr>
<tr class="separator:a525a0ec61c3707d2c1be6c6a56d8dd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e01f461cd612f8d76b5990b874af7b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a3e01f461cd612f8d76b5990b874af7b5">show_create_routine</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, enum_sp_type <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:a3e01f461cd612f8d76b5990b874af7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10df6d89545f93d20ef4cb46e9c2599c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a10df6d89545f93d20ef4cb46e9c2599c">add_instr</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="classsp__instr.html">sp_instr</a> *instr)</td></tr>
<tr class="separator:a10df6d89545f93d20ef4cb46e9c2599c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b540cea8cf7bc09f6cdcba57b2c69e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ad8b540cea8cf7bc09f6cdcba57b2c69e">modifies_data</a> () const</td></tr>
<tr class="separator:ad8b540cea8cf7bc09f6cdcba57b2c69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40302a2e45c03e4128994a2d1f0725e5"><td class="memItemLeft" align="right" valign="top"><a id="a40302a2e45c03e4128994a2d1f0725e5"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>instructions</b> ()</td></tr>
<tr class="separator:a40302a2e45c03e4128994a2d1f0725e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366359e935e6163df4cb33240dcb3f95"><td class="memItemLeft" align="right" valign="top"><a id="a366359e935e6163df4cb33240dcb3f95"></a>
<a class="el" href="classsp__instr.html">sp_instr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>last_instruction</b> ()</td></tr>
<tr class="separator:a366359e935e6163df4cb33240dcb3f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc6754187b9fadc8e2450d73ef0e59b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#acfc6754187b9fadc8e2450d73ef0e59b">reset_lex</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:acfc6754187b9fadc8e2450d73ef0e59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa69ac1fb3285a0e5fd7d1983daab49d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#aaa69ac1fb3285a0e5fd7d1983daab49d">restore_lex</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:aaa69ac1fb3285a0e5fd7d1983daab49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1042cc630fece9a1a7037fc1ad805f2e"><td class="memItemLeft" align="right" valign="top"><a id="a1042cc630fece9a1a7037fc1ad805f2e"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> (uint *lenp=0) const</td></tr>
<tr class="separator:a1042cc630fece9a1a7037fc1ad805f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af520798ea72c88e5ccee72b48667a8c3"><td class="memItemLeft" align="right" valign="top"><a id="af520798ea72c88e5ccee72b48667a8c3"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>create_string</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, ulong *lenp)</td></tr>
<tr class="separator:af520798ea72c88e5ccee72b48667a8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8694d40f898c7b872736695b448b2912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_field.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a8694d40f898c7b872736695b448b2912">create_result_field</a> (uint field_max_length, const char *field_name, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a8694d40f898c7b872736695b448b2912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320004b2aa52ff238893df60a1a31ede"><td class="memItemLeft" align="right" valign="top"><a id="a320004b2aa52ff238893df60a1a31ede"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_info</b> (longlong created, longlong modified, st_sp_chistics *chistics, sql_mode_t sql_mode)</td></tr>
<tr class="separator:a320004b2aa52ff238893df60a1a31ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f2f335b12370556e11c784c4493616"><td class="memItemLeft" align="right" valign="top"><a id="af5f2f335b12370556e11c784c4493616"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_definer</b> (const char *definer, uint definerlen)</td></tr>
<tr class="separator:af5f2f335b12370556e11c784c4493616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886e2c2a8489523f68054eb35dde5613"><td class="memItemLeft" align="right" valign="top"><a id="a886e2c2a8489523f68054eb35dde5613"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_definer</b> (const <a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *user_name, const <a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *host_name)</td></tr>
<tr class="separator:a886e2c2a8489523f68054eb35dde5613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f429d0eff3b51e9c5965d613f4bf11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ad7f429d0eff3b51e9c5965d613f4bf11">optimize</a> ()</td></tr>
<tr class="separator:ad7f429d0eff3b51e9c5965d613f4bf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab590080fc066fab935e9e2bdbc66f2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ab590080fc066fab935e9e2bdbc66f2f0">add_mark_lead</a> (uint ip, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="classsp__instr.html">sp_instr</a> &gt; *leads)</td></tr>
<tr class="separator:ab590080fc066fab935e9e2bdbc66f2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce4927b716b5d339d3642aa85103961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsp__instr.html">sp_instr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a2ce4927b716b5d339d3642aa85103961">get_instr</a> (uint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>)</td></tr>
<tr class="separator:a2ce4927b716b5d339d3642aa85103961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2c6fb8737864052de31be61051942e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#aab2c6fb8737864052de31be61051942e">add_used_tables_to_table_list</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> ***query_tables_last_ptr, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *belong_to_view)</td></tr>
<tr class="separator:aab2c6fb8737864052de31be61051942e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce7aa5389adb5438b6fe84e08846f97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a7ce7aa5389adb5438b6fe84e08846f97">is_not_allowed_in_function</a> (const char *where)</td></tr>
<tr class="separator:a7ce7aa5389adb5438b6fe84e08846f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e21bc35a54f6ae0906389b2af13d93c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a5e21bc35a54f6ae0906389b2af13d93c">show_routine_code</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:a5e21bc35a54f6ae0906389b2af13d93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab7115bbb7e05a3544b697b481f3db8"><td class="memItemLeft" align="right" valign="top"><a id="adab7115bbb7e05a3544b697b481f3db8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_attributes</b> (Query_tables_list *prelocking_ctx)</td></tr>
<tr class="separator:adab7115bbb7e05a3544b697b481f3db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36e4506a4d63fef79403721a4739907"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsp__pcontext.html">sp_pcontext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ae36e4506a4d63fef79403721a4739907">get_root_parsing_context</a> () const</td></tr>
<tr class="separator:ae36e4506a4d63fef79403721a4739907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a505191b322f3bb15699f83fe69330b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__mem__root.html">MEM_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a0a505191b322f3bb15699f83fe69330b">get_persistent_mem_root</a> () const</td></tr>
<tr class="separator:a0a505191b322f3bb15699f83fe69330b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a94755ad9108d04de8dc9f66a4ec017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__mem__root.html">MEM_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a1a94755ad9108d04de8dc9f66a4ec017">get_current_mem_root</a> () const</td></tr>
<tr class="separator:a1a94755ad9108d04de8dc9f66a4ec017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7223ece8e80d26c9b2fd53f2712724"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a6e7223ece8e80d26c9b2fd53f2712724">check_show_access</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool *full_access)</td></tr>
<tr class="separator:a6e7223ece8e80d26c9b2fd53f2712724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7c4aad6b9627d1f38b569b39f66419"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#afe7c4aad6b9627d1f38b569b39f66419">set_security_ctx</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, Security_context **save_ctx)</td></tr>
<tr class="separator:afe7c4aad6b9627d1f38b569b39f66419"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afc4dcd258833ce64ce703a9a3bd9b322"><td class="memItemLeft" align="right" valign="top"><a id="afc4dcd258833ce64ce703a9a3bd9b322"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)  throw ()</td></tr>
<tr class="separator:afc4dcd258833ce64ce703a9a3bd9b322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a295f7132b0b3a13c24cb503531464"><td class="memItemLeft" align="right" valign="top"><a id="a53a295f7132b0b3a13c24cb503531464"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)  throw ()</td></tr>
<tr class="separator:a53a295f7132b0b3a13c24cb503531464"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad83c5aad553b4463038e3c429821a78e"><td class="memItemLeft" align="right" valign="top"><a id="ad83c5aad553b4463038e3c429821a78e"></a>
enum_sp_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ad83c5aad553b4463038e3c429821a78e">m_type</a></td></tr>
<tr class="memdesc:ad83c5aad553b4463038e3c429821a78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stored program type. <br /></td></tr>
<tr class="separator:ad83c5aad553b4463038e3c429821a78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ea2e94c7500a299654665e7b9a0cc8"><td class="memItemLeft" align="right" valign="top"><a id="a52ea2e94c7500a299654665e7b9a0cc8"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a52ea2e94c7500a299654665e7b9a0cc8">m_flags</a></td></tr>
<tr class="memdesc:a52ea2e94c7500a299654665e7b9a0cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stored program flags. <br /></td></tr>
<tr class="separator:a52ea2e94c7500a299654665e7b9a0cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ffe5b534816fc045d51ed4eb3af785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_create__field.html">Create_field</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a44ffe5b534816fc045d51ed4eb3af785">m_return_field_def</a></td></tr>
<tr class="separator:a44ffe5b534816fc045d51ed4eb3af785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac488567354fff13b29eaa9cd5b26144f"><td class="memItemLeft" align="right" valign="top"><a id="ac488567354fff13b29eaa9cd5b26144f"></a>
<a class="el" href="classsp__parser__data.html">sp_parser_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ac488567354fff13b29eaa9cd5b26144f">m_parser_data</a></td></tr>
<tr class="memdesc:ac488567354fff13b29eaa9cd5b26144f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used during the parsing stage only. <br /></td></tr>
<tr class="separator:ac488567354fff13b29eaa9cd5b26144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2de0f4a011e5b7038a9da4bf172c47"><td class="memItemLeft" align="right" valign="top"><a id="a1c2de0f4a011e5b7038a9da4bf172c47"></a>
st_sp_chistics *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a1c2de0f4a011e5b7038a9da4bf172c47">m_chistics</a></td></tr>
<tr class="memdesc:a1c2de0f4a011e5b7038a9da4bf172c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stored program characteristics. <br /></td></tr>
<tr class="separator:a1c2de0f4a011e5b7038a9da4bf172c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deb9606abdbc7358ed6f5917126058d"><td class="memItemLeft" align="right" valign="top">sql_mode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a9deb9606abdbc7358ed6f5917126058d">m_sql_mode</a></td></tr>
<tr class="separator:a9deb9606abdbc7358ed6f5917126058d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b76913952fa8438a82e9461bb6cfe78"><td class="memItemLeft" align="right" valign="top"><a id="a9b76913952fa8438a82e9461bb6cfe78"></a>
<a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a9b76913952fa8438a82e9461bb6cfe78">m_qname</a></td></tr>
<tr class="memdesc:a9b76913952fa8438a82e9461bb6cfe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully qualified name (&lt;db name&gt;=""&gt;.&lt;sp name&gt;=""&gt;). <br /></td></tr>
<tr class="separator:a9b76913952fa8438a82e9461bb6cfe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba47e6fca020a90e6b2122c79469b7c"><td class="memItemLeft" align="right" valign="top"><a id="a7ba47e6fca020a90e6b2122c79469b7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a7ba47e6fca020a90e6b2122c79469b7c">m_explicit_name</a></td></tr>
<tr class="memdesc:a7ba47e6fca020a90e6b2122c79469b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend the db name? */. <br /></td></tr>
<tr class="separator:a7ba47e6fca020a90e6b2122c79469b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683009a71fd418e423e6ae39d499a6e0"><td class="memItemLeft" align="right" valign="top"><a id="a683009a71fd418e423e6ae39d499a6e0"></a>
<a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_db</b></td></tr>
<tr class="separator:a683009a71fd418e423e6ae39d499a6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b365478f2754a77773662b238bed723"><td class="memItemLeft" align="right" valign="top"><a id="a1b365478f2754a77773662b238bed723"></a>
<a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_name</b></td></tr>
<tr class="separator:a1b365478f2754a77773662b238bed723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e026148fa4b066fe5b191587eaa6ea5"><td class="memItemLeft" align="right" valign="top"><a id="a5e026148fa4b066fe5b191587eaa6ea5"></a>
<a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_params</b></td></tr>
<tr class="separator:a5e026148fa4b066fe5b191587eaa6ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07182a721aec32b26b05f5a9e04ba8c4"><td class="memItemLeft" align="right" valign="top"><a id="a07182a721aec32b26b05f5a9e04ba8c4"></a>
<a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_body</b></td></tr>
<tr class="separator:a07182a721aec32b26b05f5a9e04ba8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0a379a2d7df0a03d0c1da69d441a89"><td class="memItemLeft" align="right" valign="top"><a id="a2e0a379a2d7df0a03d0c1da69d441a89"></a>
<a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_body_utf8</b></td></tr>
<tr class="separator:a2e0a379a2d7df0a03d0c1da69d441a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524c167fb6673790421590dd56dc89f2"><td class="memItemLeft" align="right" valign="top"><a id="a524c167fb6673790421590dd56dc89f2"></a>
<a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_defstr</b></td></tr>
<tr class="separator:a524c167fb6673790421590dd56dc89f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafac2c7a9d6616d888c4eb2025c60d74"><td class="memItemLeft" align="right" valign="top"><a id="aafac2c7a9d6616d888c4eb2025c60d74"></a>
<a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_definer_user</b></td></tr>
<tr class="separator:aafac2c7a9d6616d888c4eb2025c60d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bde7186173cfbf1aa442feaa458d05b"><td class="memItemLeft" align="right" valign="top"><a id="a9bde7186173cfbf1aa442feaa458d05b"></a>
<a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_definer_host</b></td></tr>
<tr class="separator:a9bde7186173cfbf1aa442feaa458d05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3465517562f6b4a445594c650980b5e7"><td class="memItemLeft" align="right" valign="top"><a id="a3465517562f6b4a445594c650980b5e7"></a>
longlong&#160;</td><td class="memItemRight" valign="bottom"><b>m_created</b></td></tr>
<tr class="separator:a3465517562f6b4a445594c650980b5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa779525c25debfd42b3c1aafd17db13a"><td class="memItemLeft" align="right" valign="top"><a id="aa779525c25debfd42b3c1aafd17db13a"></a>
longlong&#160;</td><td class="memItemRight" valign="bottom"><b>m_modified</b></td></tr>
<tr class="separator:aa779525c25debfd42b3c1aafd17db13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d1ce8702cb51f35b9de5475037da9a"><td class="memItemLeft" align="right" valign="top"><a id="a32d1ce8702cb51f35b9de5475037da9a"></a>
ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a32d1ce8702cb51f35b9de5475037da9a">m_recursion_level</a></td></tr>
<tr class="memdesc:a32d1ce8702cb51f35b9de5475037da9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion level of the current SP instance. The levels are numbered from 0. <br /></td></tr>
<tr class="separator:a32d1ce8702cb51f35b9de5475037da9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac847a6b14ed40b05c7587891b419adc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ac847a6b14ed40b05c7587891b419adc3">m_next_cached_sp</a></td></tr>
<tr class="separator:ac847a6b14ed40b05c7587891b419adc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdc3a02699fd59bc9b54f4296354709"><td class="memItemLeft" align="right" valign="top"><a id="a3cdc3a02699fd59bc9b54f4296354709"></a>
<a class="el" href="classsp__head.html">sp_head</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a3cdc3a02699fd59bc9b54f4296354709">m_first_instance</a></td></tr>
<tr class="memdesc:a3cdc3a02699fd59bc9b54f4296354709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the first element of the above list. <br /></td></tr>
<tr class="separator:a3cdc3a02699fd59bc9b54f4296354709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad340ae0be6cb8ce662082c48cfc03d27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ad340ae0be6cb8ce662082c48cfc03d27">m_first_free_instance</a></td></tr>
<tr class="separator:ad340ae0be6cb8ce662082c48cfc03d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c36bbb7794aab5f12f10bb29f3e31f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ae0c36bbb7794aab5f12f10bb29f3e31f">m_last_cached_sp</a></td></tr>
<tr class="separator:ae0c36bbb7794aab5f12f10bb29f3e31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26a4954ad2a135c3876fa3e0f738ed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__hash.html">HASH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ab26a4954ad2a135c3876fa3e0f738ed9">m_sroutines</a></td></tr>
<tr class="separator:ab26a4954ad2a135c3876fa3e0f738ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442d114d3644a71a454e8c8f22b8c6ba"><td class="memItemLeft" align="right" valign="top"><a id="a442d114d3644a71a454e8c8f22b8c6ba"></a>
Security_context&#160;</td><td class="memItemRight" valign="bottom"><b>m_security_ctx</b></td></tr>
<tr class="separator:a442d114d3644a71a454e8c8f22b8c6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55085dcc463202909164fe39c4f7bad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt; <a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt; <a class="el" href="class_item__trigger__field.html">Item_trigger_field</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a55085dcc463202909164fe39c4f7bad9">m_list_of_trig_fields_item_lists</a></td></tr>
<tr class="separator:a55085dcc463202909164fe39c4f7bad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff67bb1a63eae95edb8b96677229b537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt; <a class="el" href="class_item__trigger__field.html">Item_trigger_field</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#aff67bb1a63eae95edb8b96677229b537">m_cur_instr_trig_field_items</a></td></tr>
<tr class="separator:aff67bb1a63eae95edb8b96677229b537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad265c159d0acb031f7a47526cc4f6f97"><td class="memItemLeft" align="right" valign="top"><a id="ad265c159d0acb031f7a47526cc4f6f97"></a>
st_trg_chistics&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ad265c159d0acb031f7a47526cc4f6f97">m_trg_chistics</a></td></tr>
<tr class="memdesc:ad265c159d0acb031f7a47526cc4f6f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger characteristics. <br /></td></tr>
<tr class="separator:ad265c159d0acb031f7a47526cc4f6f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405b9b614069c8837200772f50064c95"><td class="memItemLeft" align="right" valign="top"><a id="a405b9b614069c8837200772f50064c95"></a>
class <a class="el" href="class_table__triggers__list.html">Table_triggers_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a405b9b614069c8837200772f50064c95">m_trg_list</a></td></tr>
<tr class="memdesc:a405b9b614069c8837200772f50064c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_table__triggers__list.html">Table_triggers_list</a> instance, where this trigger belongs to. <br /></td></tr>
<tr class="separator:a405b9b614069c8837200772f50064c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2cd4f42786f7f1b74dd1a67aaa182001"><td class="memItemLeft" align="right" valign="top"><a id="a2cd4f42786f7f1b74dd1a67aaa182001"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a2cd4f42786f7f1b74dd1a67aaa182001">sp_head</a> (enum_sp_type <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="memdesc:a2cd4f42786f7f1b74dd1a67aaa182001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="classsp__head.html#a4b89bf4f505bfbf1b646caa220eff8e0">sp_start_parsing()</a> to create instances of <a class="el" href="classsp__head.html">sp_head</a>. <br /></td></tr>
<tr class="separator:a2cd4f42786f7f1b74dd1a67aaa182001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c22c2c8417307d7095012e96b0c08f0"><td class="memItemLeft" align="right" valign="top"><a id="a2c22c2c8417307d7095012e96b0c08f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a2c22c2c8417307d7095012e96b0c08f0">init_sp_name</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="classsp__name.html">sp_name</a> *spname)</td></tr>
<tr class="memdesc:a2c22c2c8417307d7095012e96b0c08f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy sp name from parser. <br /></td></tr>
<tr class="separator:a2c22c2c8417307d7095012e96b0c08f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a692195fb3636528697c091f4578e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a42a692195fb3636528697c091f4578e0">execute</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool merge_da_on_success)</td></tr>
<tr class="separator:a42a692195fb3636528697c091f4578e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef627e4b6327d83bbb688fb2de681c9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#aef627e4b6327d83bbb688fb2de681c9c">opt_mark</a> ()</td></tr>
<tr class="separator:aef627e4b6327d83bbb688fb2de681c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c63a4c46be06c9f9b9c8cb86fd9abbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a3c63a4c46be06c9f9b9c8cb86fd9abbd">merge_table_list</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, LEX *lex_for_tmp_check)</td></tr>
<tr class="separator:a3c63a4c46be06c9f9b9c8cb86fd9abbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46b6af5bc080e7fbb5bfa48bc3c5180"><td class="memItemLeft" align="right" valign="top"><a id="af46b6af5bc080e7fbb5bfa48bc3c5180"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>sp_head</b> (const <a class="el" href="classsp__head.html">sp_head</a> &amp;)</td></tr>
<tr class="separator:af46b6af5bc080e7fbb5bfa48bc3c5180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cc07566b1a41db5616408fc49e5e57"><td class="memItemLeft" align="right" valign="top"><a id="a23cc07566b1a41db5616408fc49e5e57"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsp__head.html">sp_head</a> &amp;)</td></tr>
<tr class="separator:a23cc07566b1a41db5616408fc49e5e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ad03fbb78b20c5958d1e118b2323e70e6"><td class="memItemLeft" align="right" valign="top"><a id="ad03fbb78b20c5958d1e118b2323e70e6"></a>
<a class="el" href="structst__mem__root.html">MEM_ROOT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#ad03fbb78b20c5958d1e118b2323e70e6">main_mem_root</a></td></tr>
<tr class="memdesc:ad03fbb78b20c5958d1e118b2323e70e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SP-persistent memory root (for instructions and expressions). <br /></td></tr>
<tr class="separator:ad03fbb78b20c5958d1e118b2323e70e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c380febe2329d2075c84196a828a1e2"><td class="memItemLeft" align="right" valign="top"><a id="a5c380febe2329d2075c84196a828a1e2"></a>
<a class="el" href="classsp__pcontext.html">sp_pcontext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a5c380febe2329d2075c84196a828a1e2">m_root_parsing_ctx</a></td></tr>
<tr class="memdesc:a5c380febe2329d2075c84196a828a1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root parsing context (topmost BEGIN..END block) of this SP. <br /></td></tr>
<tr class="separator:a5c380febe2329d2075c84196a828a1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9158ab1a0960caf5333fb08de691725"><td class="memItemLeft" align="right" valign="top"><a id="aa9158ab1a0960caf5333fb08de691725"></a>
<a class="el" href="class_dynamic__array.html">Dynamic_array</a>&lt; <a class="el" href="classsp__instr.html">sp_instr</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#aa9158ab1a0960caf5333fb08de691725">m_instructions</a></td></tr>
<tr class="memdesc:aa9158ab1a0960caf5333fb08de691725"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SP-instructions. <br /></td></tr>
<tr class="separator:aa9158ab1a0960caf5333fb08de691725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa977349c173bd7644daf0c70b91ed594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__hash.html">HASH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#aa977349c173bd7644daf0c70b91ed594">m_sptabs</a></td></tr>
<tr class="separator:aa977349c173bd7644daf0c70b91ed594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fdbc6cd803d3949cccfcade0c9c979"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a58fdbc6cd803d3949cccfcade0c9c979">m_sp_cache_version</a></td></tr>
<tr class="separator:a58fdbc6cd803d3949cccfcade0c9c979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91860af6aee8549aa0c5e69a78c605f0"><td class="memItemLeft" align="right" valign="top"><a id="a91860af6aee8549aa0c5e69a78c605f0"></a>
<a class="el" href="class_stored__program__creation__ctx.html">Stored_program_creation_ctx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a91860af6aee8549aa0c5e69a78c605f0">m_creation_ctx</a></td></tr>
<tr class="memdesc:a91860af6aee8549aa0c5e69a78c605f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snapshot of several system variables at CREATE-time. <br /></td></tr>
<tr class="separator:a91860af6aee8549aa0c5e69a78c605f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b387f0d661c54ac905d1fd724277a78"><td class="memItemLeft" align="right" valign="top"><a id="a8b387f0d661c54ac905d1fd724277a78"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a8b387f0d661c54ac905d1fd724277a78">unsafe_flags</a></td></tr>
<tr class="memdesc:a8b387f0d661c54ac905d1fd724277a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags of LEX::enum_binlog_stmt_unsafe. <br /></td></tr>
<tr class="separator:a8b387f0d661c54ac905d1fd724277a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4b89bf4f505bfbf1b646caa220eff8e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsp__head.html#a4b89bf4f505bfbf1b646caa220eff8e0">sp_start_parsing</a> (THD *, enum_sp_type, <a class="el" href="classsp__name.html">sp_name</a> *)</td></tr>
<tr class="separator:a4b89bf4f505bfbf1b646caa220eff8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classsp__head.html">sp_head</a> represents one instance of a stored program. It might be of any type (stored procedure, function, trigger, event). </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aed1ec3b123a2b494343acfd70a68121e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1ec3b123a2b494343acfd70a68121e">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible values of m_flags </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed1ec3b123a2b494343acfd70a68121ea2b0e1fb757a290996d14136d2f75a931"></a>MODIFIES_DATA&#160;</td><td class="fielddoc"><p>Marks routines that directly (i.e. not by calling other routines) change tables. Note that this flag is set automatically based on type of statements used in the stored routine and is different from routine characteristic provided by user in a form of CONTAINS SQL, READS SQL DATA, MODIFIES SQL DATA clauses. The latter are accepted by parser but pretty much ignored after that. We don't rely on them: a) for compatibility reasons. b) because in CONTAINS SQL case they don't provide enough information anyway. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a10df6d89545f93d20ef4cb46e9c2599c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10df6d89545f93d20ef4cb46e9c2599c">&#9670;&nbsp;</a></span>add_instr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::add_instr </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__instr.html">sp_instr</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add instruction to SP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">instr</td><td>Instruction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ab590080fc066fab935e9e2bdbc66f2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab590080fc066fab935e9e2bdbc66f2f0">&#9670;&nbsp;</a></span>add_mark_lead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sp_head::add_mark_lead </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="classsp__instr.html">sp_instr</a> &gt; *&#160;</td>
          <td class="paramname"><em>leads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper used during flow analysis during code optimization. See the implementation of <code><a class="el" href="classsp__head.html#aef627e4b6327d83bbb688fb2de681c9c">opt_mark()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>the instruction to add to the leads list </td></tr>
    <tr><td class="paramname">leads</td><td>the list of remaining paths to explore in the graph that represents the code, during flow analysis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab2c6fb8737864052de31be61051942e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2c6fb8737864052de31be61051942e">&#9670;&nbsp;</a></span>add_used_tables_to_table_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::add_used_tables_to_table_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> ***&#160;</td>
          <td class="paramname"><em>query_tables_last_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>belong_to_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add tables used by routine to the table list.</p>
<p>Converts multi-set of tables used by this routine to table list and adds this list to the end of table list specified by 'query_tables_last_ptr'.</p>
<p>Elements of list will be allocated in PS memroot, so this list will be persistent between PS executions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">query_tables_last_ptr</td><td>Pointer to the next_global member of last element of the list where tables will be added (or to its root). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">belong_to_view</td><td>Uppermost view which uses this routine, NULL if none.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if some elements were added </td></tr>
    <tr><td class="paramname">false</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e7223ece8e80d26c9b2fd53f2712724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7223ece8e80d26c9b2fd53f2712724">&#9670;&nbsp;</a></span>check_show_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::check_show_access </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>full_access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if a user has access right to a SP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">full_access</td><td>Set to 1 if the user has SELECT to the 'mysql.proc' table or is the owner of the stored program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="a8694d40f898c7b872736695b448b2912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8694d40f898c7b872736695b448b2912">&#9670;&nbsp;</a></span>create_result_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_field.html">Field</a> * sp_head::create_result_field </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>field_max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create Field-object corresponding to the RETURN field of a stored function. This operation makes sense for stored functions only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_max_length</td><td>the max length (in the sense of <a class="el" href="class_item.html">Item</a> classes). </td></tr>
    <tr><td class="paramname">field_name</td><td>the field name (item name). </td></tr>
    <tr><td class="paramname">table</td><td>the field's table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly created and initialized Field-instance, or NULL in case of error. </dd></dl>

</div>
</div>
<a id="a42a692195fb3636528697c091f4578e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a692195fb3636528697c091f4578e0">&#9670;&nbsp;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::execute </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge_da_on_success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute the routine. The main instruction jump loop is there. Assume the parameters already set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">merge_da_on_success</td><td>Flag specifying if Warning Info should be propagated to the caller on Completion Condition or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000082">Todo:</a></b></dt><dd><ul>
<li>Will write this SP statement into binlog separately (TODO: consider changing the condition to "not inside event union")</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>
<p>When inside a substatement (a stored function or trigger statement), clear the metadata observer in THD, if any. Remember the value of the observer here, to be able to restore it when leaving the substatement.</p>
<p>We reset the observer to suppress errors when a substatement uses temporary tables. If a temporary table does not exist at start of the main statement, it's not prelocked and thus is not validated with other prelocked tables.</p>
<p>Later on, when the temporary table is opened, metadata versions mismatch, expectedly.</p>
<p>The proper solution for the problem is to re-validate tables of substatements (Bug#12257, Bug#27011, Bug#32868, Bug#33000), but it's not implemented yet.</p>

</div>
</div>
<a id="a1c125eeeef415da5d45fdf16de43ecb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c125eeeef415da5d45fdf16de43ecb7">&#9670;&nbsp;</a></span>execute_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::execute_function </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> **&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>argcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> *&#160;</td>
          <td class="paramname"><em>return_fld</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute a function.</p>
<ul>
<li>evaluate parameters</li>
<li>changes security context for SUID routines</li>
<li>switch to new memroot</li>
<li>call <a class="el" href="classsp__head.html#a42a692195fb3636528697c091f4578e0">sp_head::execute</a></li>
<li>restore old memroot</li>
<li>evaluate the return value</li>
<li>restores security context</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">argp</td><td>Passed arguments (these are items from containing statement?) </td></tr>
    <tr><td class="paramname">argcount</td><td>Number of passed arguments. We need to check if this is correct. </td></tr>
    <tr><td class="paramname">return_value_fld</td><td>Save result here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000079">Todo:</a></b></dt><dd>We should create <a class="el" href="classsp__rcontext.html">sp_rcontext</a> once per command and reuse it on subsequent executions of a function/trigger.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000080">Todo:</a></b></dt><dd>In future we should associate call arena/mem_root with <a class="el" href="classsp__rcontext.html">sp_rcontext</a> and allocate all these objects (and <a class="el" href="classsp__rcontext.html">sp_rcontext</a> itself) on it directly rather than juggle with arenas.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="a525a0ec61c3707d2c1be6c6a56d8dd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525a0ec61c3707d2c1be6c6a56d8dd66">&#9670;&nbsp;</a></span>execute_procedure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::execute_procedure </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute a procedure.</p>
<p>The function does the following steps:</p><ul>
<li>Set all parameters</li>
<li>changes security context for SUID routines</li>
<li>call <a class="el" href="classsp__head.html#a42a692195fb3636528697c091f4578e0">sp_head::execute</a></li>
<li>copy back values of INOUT and OUT parameters</li>
<li>restores security context</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">args</td><td><a class="el" href="class_list.html">List</a> of values passed as arguments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ac113041f45cd9bef83a5c53431e2b860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac113041f45cd9bef83a5c53431e2b860">&#9670;&nbsp;</a></span>execute_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::execute_trigger </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__mysql__lex__string.html">LEX_STRING</a> *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__grant__info.html">GRANT_INFO</a> *&#160;</td>
          <td class="paramname"><em>grant_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute trigger stored program.</p>
<ul>
<li>changes security context for triggers</li>
<li>switch to new memroot</li>
<li>call <a class="el" href="classsp__head.html#a42a692195fb3636528697c091f4578e0">sp_head::execute</a></li>
<li>restore old memroot</li>
<li>restores security context</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">db</td><td>database name </td></tr>
    <tr><td class="paramname">table</td><td>table name </td></tr>
    <tr><td class="paramname">grant_info</td><td>GRANT_INFO structure to be filled with information about definer's privileges on subject table</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000078">Todo:</a></b></dt><dd><ul>
<li>TODO: we should create <a class="el" href="classsp__rcontext.html">sp_rcontext</a> once per command and reuse it on subsequent executions of a trigger.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="a1a94755ad9108d04de8dc9f66a4ec017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a94755ad9108d04de8dc9f66a4ec017">&#9670;&nbsp;</a></span>get_current_mem_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__mem__root.html">MEM_ROOT</a>* sp_head::get_current_mem_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>currently used mem-root. </dd></dl>

</div>
</div>
<a id="a2ce4927b716b5d339d3642aa85103961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce4927b716b5d339d3642aa85103961">&#9670;&nbsp;</a></span>get_instr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsp__instr.html">sp_instr</a>* sp_head::get_instr </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get SP-instruction at given index.</p>
<p>NOTE: it is important to have <em>unsigned</em> int here, sometimes we get (-1) passed here, so it get's converted to MAX_INT, and the result of the function call is NULL. </p>

</div>
</div>
<a id="a0a505191b322f3bb15699f83fe69330b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a505191b322f3bb15699f83fe69330b">&#9670;&nbsp;</a></span>get_persistent_mem_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__mem__root.html">MEM_ROOT</a>* sp_head::get_persistent_mem_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>SP-persistent mem-root. Instructions and expressions are stored in its memory between executions. </dd></dl>

</div>
</div>
<a id="ae36e4506a4d63fef79403721a4739907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36e4506a4d63fef79403721a4739907">&#9670;&nbsp;</a></span>get_root_parsing_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsp__pcontext.html">sp_pcontext</a>* sp_head::get_root_parsing_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>root parsing context for this stored program. </dd></dl>

</div>
</div>
<a id="a7ce7aa5389adb5438b6fe84e08846f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce7aa5389adb5438b6fe84e08846f97">&#9670;&nbsp;</a></span>is_not_allowed_in_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::is_not_allowed_in_function </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>where</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if this stored routine contains statements disallowed in a stored function or trigger, and set an appropriate error message if this is the case. </p>

</div>
</div>
<a id="a3c63a4c46be06c9f9b9c8cb86fd9abbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c63a4c46be06c9f9b9c8cb86fd9abbd">&#9670;&nbsp;</a></span>merge_table_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::merge_table_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex_for_tmp_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge the list of tables used by some query into the multi-set of tables used by routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">table</td><td>Table list. </td></tr>
    <tr><td class="paramname">lex_for_tmp_check</td><td>LEX of the query for which we are merging table list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method will use LEX provided to check whenever we are creating temporary table and mark it as such in target multi-set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ad8b540cea8cf7bc09f6cdcba57b2c69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b540cea8cf7bc09f6cdcba57b2c69e">&#9670;&nbsp;</a></span>modifies_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::modifies_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if any substatement in the routine directly (not through another routine) modifies data/changes table.</p>
<dl class="section see"><dt>See also</dt><dd>Comment for <a class="el" href="classsp__head.html#aed1ec3b123a2b494343acfd70a68121ea2b0e1fb757a290996d14136d2f75a931">MODIFIES_DATA</a> flag. </dd></dl>

</div>
</div>
<a id="aef627e4b6327d83bbb688fb2de681c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef627e4b6327d83bbb688fb2de681c9c">&#9670;&nbsp;</a></span>opt_mark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sp_head::opt_mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a forward flow analysis in the generated code. Mark reachable instructions, for the optimizer. </p>

</div>
</div>
<a id="ad7f429d0eff3b51e9c5965d613f4bf11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f429d0eff3b51e9c5965d613f4bf11">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sp_head::optimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do some minimal optimization of the code:</p><ol type="1">
<li>Mark used instructions</li>
<li>While doing this, shortcut jumps to jump instructions</li>
<li>Compact the code, removing unused instructions.</li>
</ol>
<p>This is the main mark and move loop; it relies on the following methods in <a class="el" href="classsp__instr.html">sp_instr</a> and its subclasses:</p>
<ul>
<li><a class="el" href="classsp__head.html#aef627e4b6327d83bbb688fb2de681c9c">opt_mark()</a> : Mark instruction as reachable</li>
<li>opt_shortcut_jump(): Shortcut jumps to the final destination; used by <a class="el" href="classsp__head.html#aef627e4b6327d83bbb688fb2de681c9c">opt_mark()</a>.</li>
<li>opt_move() : Update moved instruction</li>
<li>set_destination() : Set the new destination (jump instructions only) </li>
</ul>

</div>
</div>
<a id="acfc6754187b9fadc8e2450d73ef0e59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc6754187b9fadc8e2450d73ef0e59b">&#9670;&nbsp;</a></span>reset_lex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::reset_lex </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset LEX-object during parsing, before we parse a sub statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="aaa69ac1fb3285a0e5fd7d1983daab49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa69ac1fb3285a0e5fd7d1983daab49d">&#9670;&nbsp;</a></span>restore_lex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::restore_lex </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restore LEX-object during parsing, after we have parsed a sub statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="afe7c4aad6b9627d1f38b569b39f66419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7c4aad6b9627d1f38b569b39f66419">&#9670;&nbsp;</a></span>set_security_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::set_security_ctx </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Security_context **&#160;</td>
          <td class="paramname"><em>save_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change routine security context, and check if there is an EXECUTE privilege in new context. If there is no EXECUTE privilege, change the context back and return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">save_ctx</td><td>Where to save the old security context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000081">Todo:</a></b></dt><dd>Cache if the definer has the rights to use the object on the first usage and reset the cache only if someone does a GRANT statement that 'may' affect this.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="a3e01f461cd612f8d76b5990b874af7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e01f461cd612f8d76b5990b874af7b5">&#9670;&nbsp;</a></span>show_create_routine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::show_create_routine </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_sp_type&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implement SHOW CREATE statement for stored routines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">type</td><td>Stored routine type (SP_TYPE_PROCEDURE or SP_TYPE_FUNCTION)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="a5e21bc35a54f6ae0906389b2af13d93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e21bc35a54f6ae0906389b2af13d93c">&#9670;&nbsp;</a></span>show_routine_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sp_head::show_routine_code </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the routine instructions as a result set. </p><dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ab39c766ea25ed5216f844fdbe0553d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39c766ea25ed5216f844fdbe0553d1a">&#9670;&nbsp;</a></span>sp_cache_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong sp_head::sp_cache_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value of the SP cache version, as remembered when the routine was inserted into the cache. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4b89bf4f505bfbf1b646caa220eff8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b89bf4f505bfbf1b646caa220eff8e0">&#9670;&nbsp;</a></span>sp_start_parsing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsp__head.html">sp_head</a>* sp_start_parsing </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_sp_type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__name.html">sp_name</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start parsing of a stored program.</p>
<p>This function encapsulates all the steps necessary to initialize <a class="el" href="classsp__head.html">sp_head</a> to start parsing SP.</p>
<p>Every successful call of <a class="el" href="classsp__head.html#a4b89bf4f505bfbf1b646caa220eff8e0">sp_start_parsing()</a> must finish with sp_finish_parsing().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">sp_type</td><td>The stored program type </td></tr>
    <tr><td class="paramname"><a class="el" href="classsp__name.html">sp_name</a></td><td>The stored progam name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>properly initialized sp_head-instance in case of success, or NULL is case of out-of-memory error. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aff67bb1a63eae95edb8b96677229b537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff67bb1a63eae95edb8b96677229b537">&#9670;&nbsp;</a></span>m_cur_instr_trig_field_items</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt;<a class="el" href="class_item__trigger__field.html">Item_trigger_field</a>&gt; sp_head::m_cur_instr_trig_field_items</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_list.html">List</a> of all the <a class="el" href="class_item__trigger__field.html">Item_trigger_field</a> items created while parsing sp instruction. After parsing, in add_instr method this list is moved to per instruction <a class="el" href="class_item__trigger__field.html">Item_trigger_field</a> list "sp_lex_instr::m_trig_field_list". </p>

</div>
</div>
<a id="ad340ae0be6cb8ce662082c48cfc03d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad340ae0be6cb8ce662082c48cfc03d27">&#9670;&nbsp;</a></span>m_first_free_instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsp__head.html">sp_head</a>* sp_head::m_first_free_instance</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the first free (non-INVOKED) routine in the list of cached instances for this SP. This pointer is set only for the first SP in the list of instances (see above m_first_cached_sp pointer). The pointer equal to 0 if we have no free instances. For non-first instance value of this pointer meaningless (point to itself); </p>

</div>
</div>
<a id="ae0c36bbb7794aab5f12f10bb29f3e31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c36bbb7794aab5f12f10bb29f3e31f">&#9670;&nbsp;</a></span>m_last_cached_sp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsp__head.html">sp_head</a>* sp_head::m_last_cached_sp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to the last element in the list of instances of the SP. For non-first instance value of this pointer meaningless (point to itself); </p>

</div>
</div>
<a id="a55085dcc463202909164fe39c4f7bad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55085dcc463202909164fe39c4f7bad9">&#9670;&nbsp;</a></span>m_list_of_trig_fields_item_lists</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt;<a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt;<a class="el" href="class_item__trigger__field.html">Item_trigger_field</a>&gt; &gt; sp_head::m_list_of_trig_fields_item_lists</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_list.html">List</a> of item (<a class="el" href="class_item__trigger__field.html">Item_trigger_field</a> objects)'s lists representing fields in old/new version of row in trigger. We use this list for checking whether all such fields are valid or not at trigger creation time and for binding these fields to <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object at table open (although for latter pointer to table being opened is probably enough). </p>

</div>
</div>
<a id="ac847a6b14ed40b05c7587891b419adc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac847a6b14ed40b05c7587891b419adc3">&#9670;&nbsp;</a></span>m_next_cached_sp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsp__head.html">sp_head</a>* sp_head::m_next_cached_sp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A list of diferent recursion level instances for the same procedure. For every recursion level we have a <a class="el" href="classsp__head.html">sp_head</a> instance. This instances connected in the list. The list ordered by increasing recursion level (m_recursion_level). </p>

</div>
</div>
<a id="a44ffe5b534816fc045d51ed4eb3af785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ffe5b534816fc045d51ed4eb3af785">&#9670;&nbsp;</a></span>m_return_field_def</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_create__field.html">Create_field</a> sp_head::m_return_field_def</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Definition of the RETURN-field (from the RETURNS-clause). It's used (and valid) for stored functions only. </p>

</div>
</div>
<a id="a58fdbc6cd803d3949cccfcade0c9c979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fdbc6cd803d3949cccfcade0c9c979">&#9670;&nbsp;</a></span>m_sp_cache_version</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong sp_head::m_sp_cache_version</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Version of the stored routine cache at the moment when the routine was added to it. Is used only for functions and procedures, not used for triggers or events. When <a class="el" href="classsp__head.html">sp_head</a> is created, its version is 0. When it's added to the cache, the version is assigned the global value 'Cversion'. If later on Cversion is incremented, we know that the routine is obsolete and should not be used &ndash; sp_cache_flush_obsolete() will purge it. </p>

</div>
</div>
<a id="aa977349c173bd7644daf0c70b91ed594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa977349c173bd7644daf0c70b91ed594">&#9670;&nbsp;</a></span>m_sptabs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__hash.html">HASH</a> sp_head::m_sptabs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multi-set representing optimized list of tables to be locked by this routine. Does not include tables which are used by invoked routines.</p>
<dl class="section note"><dt>Note</dt><dd>For prelocking-free SPs this multiset is constructed too. We do so because the same instance of <a class="el" href="classsp__head.html">sp_head</a> may be called both in prelocked mode and in non-prelocked mode. </dd></dl>

</div>
</div>
<a id="a9deb9606abdbc7358ed6f5917126058d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9deb9606abdbc7358ed6f5917126058d">&#9670;&nbsp;</a></span>m_sql_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sql_mode_t sp_head::m_sql_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The value of sql_mode system variable at the CREATE-time.</p>
<p>It should be stored along with the character sets in the <a class="el" href="class_stored__program__creation__ctx.html">Stored_program_creation_ctx</a>. </p>

</div>
</div>
<a id="ab26a4954ad2a135c3876fa3e0f738ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26a4954ad2a135c3876fa3e0f738ed9">&#9670;&nbsp;</a></span>m_sroutines</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__hash.html">HASH</a> sp_head::m_sroutines</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set containing names of stored routines used by this routine. Note that unlike elements of similar set for statement elements of this set are not linked in one list. Because of this we are able save memory by using for this set same objects that are used in 'sroutines' sets for statements of which this stored routine consists. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="sp__head_8h_source.html">sp_head.h</a></li>
<li>sql/sp_head.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/log/log0log.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_7c61b8982e4f26eda8a4a9a87fddd769.html">log</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">log0log.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0flu_8h_source.html">buf0flu.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0recv_8h_source.html">log0recv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0sys_8h_source.html">trx0sys.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0roll_8h_source.html">trx0roll.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a61a4fc395abd21bf9a9af0fcaa8e4925"><td class="memItemLeft" align="right" valign="top"><a id="a61a4fc395abd21bf9a9af0fcaa8e4925"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_BUF_WRITE_MARGIN</b>&#160;&#160;&#160;(4 * <a class="el" href="os0file_8h.html#a893c38aa3aedd6efa1439b5ec00213f9">OS_FILE_LOG_BLOCK_SIZE</a>)</td></tr>
<tr class="separator:a61a4fc395abd21bf9a9af0fcaa8e4925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d7e2bc4ef696abc3bd992d08bf5a5"><td class="memItemLeft" align="right" valign="top"><a id="a108d7e2bc4ef696abc3bd992d08bf5a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_BUF_FLUSH_RATIO</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a108d7e2bc4ef696abc3bd992d08bf5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e59bc863aba34234a1a78aa96cf4493"><td class="memItemLeft" align="right" valign="top"><a id="a1e59bc863aba34234a1a78aa96cf4493"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_BUF_FLUSH_MARGIN</b>&#160;&#160;&#160;(LOG_BUF_WRITE_MARGIN + 4 * UNIV_PAGE_SIZE)</td></tr>
<tr class="separator:a1e59bc863aba34234a1a78aa96cf4493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824f4971c3f3f6b87925d1e8079b94b8"><td class="memItemLeft" align="right" valign="top"><a id="a824f4971c3f3f6b87925d1e8079b94b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_CHECKPOINT_FREE_PER_THREAD</b>&#160;&#160;&#160;(4 * UNIV_PAGE_SIZE)</td></tr>
<tr class="separator:a824f4971c3f3f6b87925d1e8079b94b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a55a208d712134943df0b61a5de15d"><td class="memItemLeft" align="right" valign="top"><a id="a14a55a208d712134943df0b61a5de15d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_CHECKPOINT_EXTRA_FREE</b>&#160;&#160;&#160;(8 * UNIV_PAGE_SIZE)</td></tr>
<tr class="separator:a14a55a208d712134943df0b61a5de15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac449a5f390a5b42ea4024d84fbf1a45d"><td class="memItemLeft" align="right" valign="top"><a id="ac449a5f390a5b42ea4024d84fbf1a45d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_POOL_CHECKPOINT_RATIO_ASYNC</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ac449a5f390a5b42ea4024d84fbf1a45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cb937387e7494f7d5cf571265d7bc7"><td class="memItemLeft" align="right" valign="top"><a id="a53cb937387e7494f7d5cf571265d7bc7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_POOL_PREFLUSH_RATIO_SYNC</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a53cb937387e7494f7d5cf571265d7bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b41a134ac978473f4ba745dececd6d1"><td class="memItemLeft" align="right" valign="top"><a id="a6b41a134ac978473f4ba745dececd6d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_POOL_PREFLUSH_RATIO_ASYNC</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a6b41a134ac978473f4ba745dececd6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2700bd1cb8a11aafcf9b73d8b08a21f"><td class="memItemLeft" align="right" valign="top"><a id="ae2700bd1cb8a11aafcf9b73d8b08a21f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_ARCHIVE_EXTRA_MARGIN</b>&#160;&#160;&#160;(4 * UNIV_PAGE_SIZE)</td></tr>
<tr class="separator:ae2700bd1cb8a11aafcf9b73d8b08a21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e92af94f5538949b14295818b6cc52"><td class="memItemLeft" align="right" valign="top"><a id="ae2e92af94f5538949b14295818b6cc52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_ARCHIVE_RATIO_ASYNC</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ae2e92af94f5538949b14295818b6cc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7d2e95adadb25a1a41b6e133b09dd9"><td class="memItemLeft" align="right" valign="top"><a id="ace7d2e95adadb25a1a41b6e133b09dd9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_UNLOCK_NONE_FLUSHED_LOCK</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ace7d2e95adadb25a1a41b6e133b09dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990dff962d284c537097e6662555e1c0"><td class="memItemLeft" align="right" valign="top"><a id="a990dff962d284c537097e6662555e1c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_UNLOCK_FLUSH_LOCK</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a990dff962d284c537097e6662555e1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba16b9b63ee38ace94f0ed882b59a17"><td class="memItemLeft" align="right" valign="top"><a id="a2ba16b9b63ee38ace94f0ed882b59a17"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_ARCHIVE_READ</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a2ba16b9b63ee38ace94f0ed882b59a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca954e88083c4b017650f52751af679b"><td class="memItemLeft" align="right" valign="top"><a id="aca954e88083c4b017650f52751af679b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_ARCHIVE_WRITE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aca954e88083c4b017650f52751af679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac332d68dfe76bf3f12e43c505aaa7056"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ac332d68dfe76bf3f12e43c505aaa7056">log_io_complete_checkpoint</a> (void)</td></tr>
<tr class="separator:ac332d68dfe76bf3f12e43c505aaa7056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0021ed19b118a59ddcd4b54cb1465bd8"><td class="memItemLeft" align="right" valign="top">static lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a0021ed19b118a59ddcd4b54cb1465bd8">log_buf_pool_get_oldest_modification</a> (void)</td></tr>
<tr class="separator:a0021ed19b118a59ddcd4b54cb1465bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e84e3e782879921b893620d0236086"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ab1e84e3e782879921b893620d0236086">log_buffer_extend</a> (ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:ab1e84e3e782879921b893620d0236086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec5b91f6f128d1669d09e778e6b81dc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a5ec5b91f6f128d1669d09e778e6b81dc">log_reserve_and_open</a> (ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:a5ec5b91f6f128d1669d09e778e6b81dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cff24613386ffb6069d6e7dd55587ac"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a3cff24613386ffb6069d6e7dd55587ac">log_write_low</a> (byte *str, ulint str_len)</td></tr>
<tr class="separator:a3cff24613386ffb6069d6e7dd55587ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed620ef4b4e7871e2a4c840b927f12e3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#aed620ef4b4e7871e2a4c840b927f12e3">log_close</a> (void)</td></tr>
<tr class="separator:aed620ef4b4e7871e2a4c840b927f12e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fe86d066e8239dfebf9cdc3348a2e9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ac6fe86d066e8239dfebf9cdc3348a2e9">log_group_get_capacity</a> (const <a class="el" href="structlog__group__t.html">log_group_t</a> *group)</td></tr>
<tr class="separator:ac6fe86d066e8239dfebf9cdc3348a2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4fb6fee7e4117a116d70a77c494478"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a7c4fb6fee7e4117a116d70a77c494478">log_group_calc_size_offset</a> (lsn_t <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, const <a class="el" href="structlog__group__t.html">log_group_t</a> *group)</td></tr>
<tr class="separator:a7c4fb6fee7e4117a116d70a77c494478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba082c558c6c9e25fc6d1432d51802a5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#aba082c558c6c9e25fc6d1432d51802a5">log_group_calc_real_offset</a> (lsn_t <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, const <a class="el" href="structlog__group__t.html">log_group_t</a> *group)</td></tr>
<tr class="separator:aba082c558c6c9e25fc6d1432d51802a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa043fda0b7a9be9577bb62eb59d34e21"><td class="memItemLeft" align="right" valign="top">static lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#aa043fda0b7a9be9577bb62eb59d34e21">log_group_calc_lsn_offset</a> (lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>, const <a class="el" href="structlog__group__t.html">log_group_t</a> *group)</td></tr>
<tr class="separator:aa043fda0b7a9be9577bb62eb59d34e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde13ce11adec5f933b8bb53abf609a9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#adde13ce11adec5f933b8bb53abf609a9">log_calc_where_lsn_is</a> (ib_int64_t *log_file_offset, ib_uint64_t first_header_lsn, ib_uint64_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>, ulint n_log_files, ib_int64_t log_file_size)</td></tr>
<tr class="separator:adde13ce11adec5f933b8bb53abf609a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9299535359f2c242ee46906daa290e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#abb9299535359f2c242ee46906daa290e">log_group_set_fields</a> (<a class="el" href="structlog__group__t.html">log_group_t</a> *group, lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>)</td></tr>
<tr class="separator:abb9299535359f2c242ee46906daa290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9241ba3887f7b8df4aca204a3f8e2357"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a9241ba3887f7b8df4aca204a3f8e2357">log_calc_max_ages</a> (void)</td></tr>
<tr class="separator:a9241ba3887f7b8df4aca204a3f8e2357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9223c6fc0464a4919240eacd19f587"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#afa9223c6fc0464a4919240eacd19f587">log_init</a> (void)</td></tr>
<tr class="separator:afa9223c6fc0464a4919240eacd19f587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad009b76f41d30e177bb4572d0fe0ec20"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ad009b76f41d30e177bb4572d0fe0ec20">log_group_init</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ulint n_files, lsn_t file_size, ulint space_id, ulint archive_space_id <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:ad009b76f41d30e177bb4572d0fe0ec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406a571d0858e377442738040f59c4ec"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a406a571d0858e377442738040f59c4ec">log_flush_do_unlocks</a> (ulint code)</td></tr>
<tr class="separator:a406a571d0858e377442738040f59c4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eedfb5c34442f087ee93e52f5ee81cb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a7eedfb5c34442f087ee93e52f5ee81cb">log_group_check_flush_completion</a> (<a class="el" href="structlog__group__t.html">log_group_t</a> *group)</td></tr>
<tr class="separator:a7eedfb5c34442f087ee93e52f5ee81cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66c946c6df9c16e103762f31a375761"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#af66c946c6df9c16e103762f31a375761">log_sys_check_flush_completion</a> (void)</td></tr>
<tr class="separator:af66c946c6df9c16e103762f31a375761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3f4d29bfb0107693588e398aa515be"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#adc3f4d29bfb0107693588e398aa515be">log_io_complete</a> (<a class="el" href="structlog__group__t.html">log_group_t</a> *group)</td></tr>
<tr class="separator:adc3f4d29bfb0107693588e398aa515be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c34e16be2b0a319926bd68fe84cb03f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a8c34e16be2b0a319926bd68fe84cb03f">log_group_file_header_flush</a> (<a class="el" href="structlog__group__t.html">log_group_t</a> *group, ulint nth_file, lsn_t start_lsn)</td></tr>
<tr class="separator:a8c34e16be2b0a319926bd68fe84cb03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62b0678cff975764623cbe56fe7910"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ada62b0678cff975764623cbe56fe7910">log_block_store_checksum</a> (byte *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:ada62b0678cff975764623cbe56fe7910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdf3eb29ae186d08cdc9cf4e4118a4e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a5cdf3eb29ae186d08cdc9cf4e4118a4e">log_group_write_buf</a> (<a class="el" href="structlog__group__t.html">log_group_t</a> *group, byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, lsn_t start_lsn, ulint new_data_offset)</td></tr>
<tr class="separator:a5cdf3eb29ae186d08cdc9cf4e4118a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf92d6be658e10a45b643c2a559da1af"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#acf92d6be658e10a45b643c2a559da1af">log_write_up_to</a> (lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>, ulint wait, ibool flush_to_disk)</td></tr>
<tr class="separator:acf92d6be658e10a45b643c2a559da1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf96601c4184bc20a859dda2f44d3d18"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#aaf96601c4184bc20a859dda2f44d3d18">log_buffer_flush_to_disk</a> (void)</td></tr>
<tr class="separator:aaf96601c4184bc20a859dda2f44d3d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12d8c13ab6a43127f83343ce871846e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ad12d8c13ab6a43127f83343ce871846e">log_buffer_sync_in_background</a> (ibool <a class="el" href="buf0lru_8cc.html#a4558737b6ae02896c172abc60f58745e">flush</a>)</td></tr>
<tr class="separator:ad12d8c13ab6a43127f83343ce871846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a7b1edd41fe6e8397daad05e61343f"><td class="memItemLeft" align="right" valign="top"><a id="a77a7b1edd41fe6e8397daad05e61343f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>log_flush_margin</b> (void)</td></tr>
<tr class="separator:a77a7b1edd41fe6e8397daad05e61343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7cbfd5778eee8d474808ba1a1c1bc3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a6c7cbfd5778eee8d474808ba1a1c1bc3">log_preflush_pool_modified_pages</a> (lsn_t new_oldest)</td></tr>
<tr class="separator:a6c7cbfd5778eee8d474808ba1a1c1bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31f302f3bb872e2c0171419884da485"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ae31f302f3bb872e2c0171419884da485">log_complete_checkpoint</a> (void)</td></tr>
<tr class="separator:ae31f302f3bb872e2c0171419884da485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14fa7d8fdc43fb1da4ccc2c5f45342e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#af14fa7d8fdc43fb1da4ccc2c5f45342e">log_checkpoint_set_nth_group_info</a> (byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, ulint file_no, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:af14fa7d8fdc43fb1da4ccc2c5f45342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961f5de6014ea815f1b553713a42bb9b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a961f5de6014ea815f1b553713a42bb9b">log_checkpoint_get_nth_group_info</a> (const byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, ulint *file_no, ulint *<a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a961f5de6014ea815f1b553713a42bb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5153462d5bbe4871cb0a6bd14c6fc9e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a5153462d5bbe4871cb0a6bd14c6fc9e2">log_group_checkpoint</a> (<a class="el" href="structlog__group__t.html">log_group_t</a> *group)</td></tr>
<tr class="separator:a5153462d5bbe4871cb0a6bd14c6fc9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f48ef1d75e65a28f952bbed00594081"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a0f48ef1d75e65a28f952bbed00594081">log_group_read_checkpoint_info</a> (<a class="el" href="structlog__group__t.html">log_group_t</a> *group, ulint field)</td></tr>
<tr class="separator:a0f48ef1d75e65a28f952bbed00594081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4b6c7a3d7fcb0c746f9345953a6533"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#aff4b6c7a3d7fcb0c746f9345953a6533">log_groups_write_checkpoint_info</a> (void)</td></tr>
<tr class="separator:aff4b6c7a3d7fcb0c746f9345953a6533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e528c0af0cb866a36bc5f0bc204105"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#af6e528c0af0cb866a36bc5f0bc204105">log_checkpoint</a> (ibool <a class="el" href="ibuf0ibuf_8cc.html#a6265893dd43b2df4e241408f9e736f2e">sync</a>, ibool write_always)</td></tr>
<tr class="separator:af6e528c0af0cb866a36bc5f0bc204105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7573dd5004534067b2c9509812c62e1c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a7573dd5004534067b2c9509812c62e1c">log_make_checkpoint_at</a> (lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>, ibool write_always)</td></tr>
<tr class="separator:a7573dd5004534067b2c9509812c62e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cdb4484165ad7db6359b888980ea0f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ae3cdb4484165ad7db6359b888980ea0f">log_checkpoint_margin</a> (void)</td></tr>
<tr class="separator:ae3cdb4484165ad7db6359b888980ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4753b9ce016e234e3303247f5b532c85"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a4753b9ce016e234e3303247f5b532c85">log_group_read_log_seg</a> (ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, <a class="el" href="structlog__group__t.html">log_group_t</a> *group, lsn_t start_lsn, lsn_t end_lsn)</td></tr>
<tr class="separator:a4753b9ce016e234e3303247f5b532c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d911427feb357b849c170e74657818d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a3d911427feb357b849c170e74657818d">log_check_margins</a> (void)</td></tr>
<tr class="separator:a3d911427feb357b849c170e74657818d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc3be421065454846977694aeaf71e8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a5bc3be421065454846977694aeaf71e8">logs_empty_and_mark_files_at_shutdown</a> (void)</td></tr>
<tr class="separator:a5bc3be421065454846977694aeaf71e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8785464bbe3037989eeb20b6b91956c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ad8785464bbe3037989eeb20b6b91956c">log_peek_lsn</a> (lsn_t *<a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>)</td></tr>
<tr class="separator:ad8785464bbe3037989eeb20b6b91956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7203d9622cbb373917e7dad97e35254"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#aa7203d9622cbb373917e7dad97e35254">log_print</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:aa7203d9622cbb373917e7dad97e35254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e7346dc1d9ec80c6e2d446bcbd83d0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a06e7346dc1d9ec80c6e2d446bcbd83d0">log_refresh_stats</a> (void)</td></tr>
<tr class="separator:a06e7346dc1d9ec80c6e2d446bcbd83d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4dd422aafd4bbe60ab6706ddff3523"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a1f4dd422aafd4bbe60ab6706ddff3523">log_group_close</a> (<a class="el" href="structlog__group__t.html">log_group_t</a> *group)</td></tr>
<tr class="separator:a1f4dd422aafd4bbe60ab6706ddff3523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed07fea43f6c359905616e196a8a252a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#aed07fea43f6c359905616e196a8a252a">log_group_close_all</a> (void)</td></tr>
<tr class="separator:aed07fea43f6c359905616e196a8a252a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531694c4b83c2bbb98b9761de8b0bf16"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#a531694c4b83c2bbb98b9761de8b0bf16">log_shutdown</a> (void)</td></tr>
<tr class="separator:a531694c4b83c2bbb98b9761de8b0bf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f36b817a66219122eaa8a72c536f6e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0log_8cc.html#ab0f36b817a66219122eaa8a72c536f6e">log_mem_free</a> (void)</td></tr>
<tr class="separator:ab0f36b817a66219122eaa8a72c536f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a974d61c01081f53076ca2e7aff0a5133"><td class="memItemLeft" align="right" valign="top"><a id="a974d61c01081f53076ca2e7aff0a5133"></a>
UNIV_INTERN <a class="el" href="structlog__t.html">log_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>log_sys</b> = NULL</td></tr>
<tr class="separator:a974d61c01081f53076ca2e7aff0a5133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fda8d87d05a4e1a245a41fe0dd11136"><td class="memItemLeft" align="right" valign="top"><a id="a6fda8d87d05a4e1a245a41fe0dd11136"></a>
UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><b>log_has_printed_chkp_warning</b> = FALSE</td></tr>
<tr class="separator:a6fda8d87d05a4e1a245a41fe0dd11136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cb0b8afff369289904b04d097f0b3c"><td class="memItemLeft" align="right" valign="top"><a id="af0cb0b8afff369289904b04d097f0b3c"></a>
UNIV_INTERN time_t&#160;</td><td class="memItemRight" valign="bottom"><b>log_last_warning_time</b></td></tr>
<tr class="separator:af0cb0b8afff369289904b04d097f0b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Database log</p>
<p>Created 12/9/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ada62b0678cff975764623cbe56fe7910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada62b0678cff975764623cbe56fe7910">&#9670;&nbsp;</a></span>log_block_store_checksum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_block_store_checksum </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a 4-byte checksum to the trailer checksum field of a log block before writing it to a log file. This checksum is used in recovery to check the consistency of a log block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: pointer to a log block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0021ed19b118a59ddcd4b54cb1465bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0021ed19b118a59ddcd4b54cb1465bd8">&#9670;&nbsp;</a></span>log_buf_pool_get_oldest_modification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static lsn_t log_buf_pool_get_oldest_modification </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the oldest modified block lsn in the pool, or log_sys-&gt;lsn if none exists. </p><dl class="section return"><dt>Returns</dt><dd>LSN of oldest modification </dd></dl>

</div>
</div>
<a id="ab1e84e3e782879921b893620d0236086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e84e3e782879921b893620d0236086">&#9670;&nbsp;</a></span>log_buffer_extend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_buffer_extend </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extends the log buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>requested minimum size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf96601c4184bc20a859dda2f44d3d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf96601c4184bc20a859dda2f44d3d18">&#9670;&nbsp;</a></span>log_buffer_flush_to_disk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_buffer_flush_to_disk </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does a syncronous flush of the log buffer to disk. </p>

</div>
</div>
<a id="ad12d8c13ab6a43127f83343ce871846e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12d8c13ab6a43127f83343ce871846e">&#9670;&nbsp;</a></span>log_buffer_sync_in_background()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_buffer_sync_in_background </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>flush</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This functions writes the log buffer to the log file and if 'flush' is set it forces a flush of the log file as well. This is meant to be called from background master thread only as it does not wait for the write (+ possible flush) to finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush</td><td>in: flush the logs to disk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9241ba3887f7b8df4aca204a3f8e2357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9241ba3887f7b8df4aca204a3f8e2357">&#9670;&nbsp;</a></span>log_calc_max_ages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool log_calc_max_ages </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the recommended highest values for lsn - last_checkpoint_lsn, lsn - buf_get_oldest_modification(), and lsn - max_archive_lsn_age. </p><dl class="section return"><dt>Returns</dt><dd>error value FALSE if the smallest log group is too small to accommodate the number of OS threads in the database server </dd></dl>

</div>
</div>
<a id="adde13ce11adec5f933b8bb53abf609a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde13ce11adec5f933b8bb53abf609a9">&#9670;&nbsp;</a></span>log_calc_where_lsn_is()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint log_calc_where_lsn_is </td>
          <td>(</td>
          <td class="paramtype">ib_int64_t *&#160;</td>
          <td class="paramname"><em>log_file_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>first_header_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_log_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_int64_t&#160;</td>
          <td class="paramname"><em>log_file_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates where in log files we find a specified lsn. </p><dl class="section return"><dt>Returns</dt><dd>log file number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_file_offset</td><td>out: offset in that file (including the header) </td></tr>
    <tr><td class="paramname">first_header_lsn</td><td>in: first log file start lsn </td></tr>
    <tr><td class="paramname">lsn</td><td>in: lsn whose position to determine </td></tr>
    <tr><td class="paramname">n_log_files</td><td>in: total number of log files </td></tr>
    <tr><td class="paramname">log_file_size</td><td>in: log file size (including the header) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d911427feb357b849c170e74657818d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d911427feb357b849c170e74657818d">&#9670;&nbsp;</a></span>log_check_margins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_check_margins </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that there is enough free space in the log to start a new query step. Flushes the log buffer or makes a new checkpoint if necessary. NOTE: this function may only be called if the calling thread owns no synchronization objects! </p>

</div>
</div>
<a id="af6e528c0af0cb866a36bc5f0bc204105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e528c0af0cb866a36bc5f0bc204105">&#9670;&nbsp;</a></span>log_checkpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool log_checkpoint </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>write_always</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a checkpoint. Note that this function does not flush dirty blocks from the buffer pool: it only checks what is lsn of the oldest modification in the pool, and writes information about the lsn in log files. Use log_make_checkpoint_at to flush also the pool. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success, FALSE if a checkpoint write was already running </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>in: TRUE if synchronous operation is desired </td></tr>
    <tr><td class="paramname">write_always</td><td>in: the function normally checks if the the new checkpoint would have a greater lsn than the previous one: if not, then no physical write is done; by setting this parameter TRUE, a physical write will always be made to log files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a961f5de6014ea815f1b553713a42bb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961f5de6014ea815f1b553713a42bb9b">&#9670;&nbsp;</a></span>log_checkpoint_get_nth_group_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_checkpoint_get_nth_group_info </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>file_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets info from a checkpoint about a log group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in: buffer containing checkpoint info </td></tr>
    <tr><td class="paramname">n</td><td>in: nth slot </td></tr>
    <tr><td class="paramname">file_no</td><td>out: archived file number </td></tr>
    <tr><td class="paramname">offset</td><td>out: archived file offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3cdb4484165ad7db6359b888980ea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cdb4484165ad7db6359b888980ea0f">&#9670;&nbsp;</a></span>log_checkpoint_margin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_checkpoint_margin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to establish a big enough margin of free space in the log groups, such that a new log entry can be catenated without an immediate need for a checkpoint. NOTE: this function may only be called if the calling thread owns no synchronization objects! </p>

</div>
</div>
<a id="af14fa7d8fdc43fb1da4ccc2c5f45342e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14fa7d8fdc43fb1da4ccc2c5f45342e">&#9670;&nbsp;</a></span>log_checkpoint_set_nth_group_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_checkpoint_set_nth_group_info </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>file_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes info to a checkpoint about a log group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in: buffer for checkpoint info </td></tr>
    <tr><td class="paramname">n</td><td>in: nth slot </td></tr>
    <tr><td class="paramname">file_no</td><td>in: archived file number </td></tr>
    <tr><td class="paramname">offset</td><td>in: archived file offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed620ef4b4e7871e2a4c840b927f12e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed620ef4b4e7871e2a4c840b927f12e3">&#9670;&nbsp;</a></span>log_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN lsn_t log_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the log. </p><dl class="section return"><dt>Returns</dt><dd>lsn </dd></dl>

</div>
</div>
<a id="ae31f302f3bb872e2c0171419884da485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31f302f3bb872e2c0171419884da485">&#9670;&nbsp;</a></span>log_complete_checkpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_complete_checkpoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Completes a checkpoint. </p>

</div>
</div>
<a id="a406a571d0858e377442738040f59c4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406a571d0858e377442738040f59c4ec">&#9670;&nbsp;</a></span>log_flush_do_unlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void log_flush_do_unlocks </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does the unlockings needed in flush i/o completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>in: any ORed combination of LOG_UNLOCK_FLUSH_LOCK and LOG_UNLOCK_NONE_FLUSHED_LOCK </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa043fda0b7a9be9577bb62eb59d34e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa043fda0b7a9be9577bb62eb59d34e21">&#9670;&nbsp;</a></span>log_group_calc_lsn_offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static lsn_t log_group_calc_lsn_offset </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the offset of an lsn within a log group. </p><dl class="section return"><dt>Returns</dt><dd>offset within the log group </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lsn</td><td>in: lsn </td></tr>
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba082c558c6c9e25fc6d1432d51802a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba082c558c6c9e25fc6d1432d51802a5">&#9670;&nbsp;</a></span>log_group_calc_real_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE lsn_t log_group_calc_real_offset </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the offset within a log group, when the log file headers are included. </p><dl class="section return"><dt>Returns</dt><dd>real offset (&gt;= offset) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>in: size offset within the log group </td></tr>
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c4fb6fee7e4117a116d70a77c494478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4fb6fee7e4117a116d70a77c494478">&#9670;&nbsp;</a></span>log_group_calc_size_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE lsn_t log_group_calc_size_offset </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the offset within a log group, when the log file headers are not included. </p><dl class="section return"><dt>Returns</dt><dd>size offset (&lt;= offset) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>in: real offset within the log group </td></tr>
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eedfb5c34442f087ee93e52f5ee81cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eedfb5c34442f087ee93e52f5ee81cb">&#9670;&nbsp;</a></span>log_group_check_flush_completion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint log_group_check_flush_completion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a flush is completed for a log group and does the completion routine if yes. </p><dl class="section return"><dt>Returns</dt><dd>LOG_UNLOCK_NONE_FLUSHED_LOCK or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5153462d5bbe4871cb0a6bd14c6fc9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5153462d5bbe4871cb0a6bd14c6fc9e2">&#9670;&nbsp;</a></span>log_group_checkpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_group_checkpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the checkpoint info to a log group header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f4dd422aafd4bbe60ab6706ddff3523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4dd422aafd4bbe60ab6706ddff3523">&#9670;&nbsp;</a></span>log_group_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_group_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes a log group. </p>

</div>
</div>
<a id="aed07fea43f6c359905616e196a8a252a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed07fea43f6c359905616e196a8a252a">&#9670;&nbsp;</a></span>log_group_close_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_group_close_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes all log groups. </p>

</div>
</div>
<a id="a8c34e16be2b0a319926bd68fe84cb03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c34e16be2b0a319926bd68fe84cb03f">&#9670;&nbsp;</a></span>log_group_file_header_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_group_file_header_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>nth_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>start_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes a log file header to a log file space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
    <tr><td class="paramname">nth_file</td><td>in: header to the nth file in the log file space </td></tr>
    <tr><td class="paramname">start_lsn</td><td>in: log file data starts at this lsn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6fe86d066e8239dfebf9cdc3348a2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fe86d066e8239dfebf9cdc3348a2e9">&#9670;&nbsp;</a></span>log_group_get_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN lsn_t log_group_get_capacity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the data capacity of a log group, when the log file headers are not included. </p><dl class="section return"><dt>Returns</dt><dd>capacity in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad009b76f41d30e177bb4572d0fe0ec20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad009b76f41d30e177bb4572d0fe0ec20">&#9670;&nbsp;</a></span>log_group_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_group_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>file_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint archive_space_id &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inits a log group to the log system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: group id </td></tr>
    <tr><td class="paramname">n_files</td><td>in: number of log files </td></tr>
    <tr><td class="paramname">file_size</td><td>in: log file size in bytes </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id of the file space which contains the log files of this group </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in: space id of the file space which contains some archived log files for this group; currently, only for the first log group this is used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f48ef1d75e65a28f952bbed00594081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f48ef1d75e65a28f952bbed00594081">&#9670;&nbsp;</a></span>log_group_read_checkpoint_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_group_read_checkpoint_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a checkpoint info from a log group header to log_sys-&gt;checkpoint_buf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
    <tr><td class="paramname">field</td><td>in: LOG_CHECKPOINT_1 or LOG_CHECKPOINT_2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4753b9ce016e234e3303247f5b532c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4753b9ce016e234e3303247f5b532c85">&#9670;&nbsp;</a></span>log_group_read_log_seg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_group_read_log_seg </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>end_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a specified log segment to a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: LOG_ARCHIVE or LOG_RECOVER </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer where to read </td></tr>
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
    <tr><td class="paramname">start_lsn</td><td>in: read area start </td></tr>
    <tr><td class="paramname">end_lsn</td><td>in: read area end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb9299535359f2c242ee46906daa290e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9299535359f2c242ee46906daa290e">&#9670;&nbsp;</a></span>log_group_set_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_group_set_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the field values in group to correspond to a given lsn. For this function to work, the values must already be correctly initialized to correspond to some lsn, for instance, a checkpoint lsn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>in/out: group </td></tr>
    <tr><td class="paramname">lsn</td><td>in: lsn for which the values should be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cdf3eb29ae186d08cdc9cf4e4118a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdf3eb29ae186d08cdc9cf4e4118a4e">&#9670;&nbsp;</a></span>log_group_write_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_group_write_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>new_data_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a buffer to a log file group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer </td></tr>
    <tr><td class="paramname">len</td><td>in: buffer len; must be divisible by OS_FILE_LOG_BLOCK_SIZE </td></tr>
    <tr><td class="paramname">start_lsn</td><td>in: start lsn of the buffer; must be divisible by OS_FILE_LOG_BLOCK_SIZE </td></tr>
    <tr><td class="paramname">new_data_offset</td><td>in: start offset of new data in buf: this parameter is used to decide if we have to write a new log file header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff4b6c7a3d7fcb0c746f9345953a6533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4b6c7a3d7fcb0c746f9345953a6533">&#9670;&nbsp;</a></span>log_groups_write_checkpoint_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_groups_write_checkpoint_info </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes checkpoint info to groups. </p>

</div>
</div>
<a id="afa9223c6fc0464a4919240eacd19f587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9223c6fc0464a4919240eacd19f587">&#9670;&nbsp;</a></span>log_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the log. </p>

</div>
</div>
<a id="adc3f4d29bfb0107693588e398aa515be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3f4d29bfb0107693588e398aa515be">&#9670;&nbsp;</a></span>log_io_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_io_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes an i/o to a log file. </p>
<p>&lt; We currently use synchronous writing of the logs and cannot end up here! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>in: log group or a dummy pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac332d68dfe76bf3f12e43c505aaa7056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac332d68dfe76bf3f12e43c505aaa7056">&#9670;&nbsp;</a></span>log_io_complete_checkpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void log_io_complete_checkpoint </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Completes a checkpoint write i/o to a log file.</p>
<p>Completes an asynchronous checkpoint info write i/o to a log file. </p>

</div>
</div>
<a id="a7573dd5004534067b2c9509812c62e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7573dd5004534067b2c9509812c62e1c">&#9670;&nbsp;</a></span>log_make_checkpoint_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_make_checkpoint_at </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>write_always</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a checkpoint at a given lsn or later. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lsn</td><td>in: make a checkpoint at this or a later lsn, if LSN_MAX, makes a checkpoint at the latest lsn </td></tr>
    <tr><td class="paramname">write_always</td><td>in: the function normally checks if the new checkpoint would have a greater lsn than the previous one: if not, then no physical write is done; by setting this parameter TRUE, a physical write will always be made to log files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0f36b817a66219122eaa8a72c536f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f36b817a66219122eaa8a72c536f6e">&#9670;&nbsp;</a></span>log_mem_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_mem_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the log system data structures. </p>

</div>
</div>
<a id="ad8785464bbe3037989eeb20b6b91956c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8785464bbe3037989eeb20b6b91956c">&#9670;&nbsp;</a></span>log_peek_lsn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool log_peek_lsn </td>
          <td>(</td>
          <td class="paramtype">lsn_t *&#160;</td>
          <td class="paramname"><em>lsn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Peeks the current lsn. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success, FALSE if could not get the log system mutex </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lsn</td><td>out: if returns TRUE, current lsn is here </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c7cbfd5778eee8d474808ba1a1c1bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7cbfd5778eee8d474808ba1a1c1bc3">&#9670;&nbsp;</a></span>log_preflush_pool_modified_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool log_preflush_pool_modified_pages </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>new_oldest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advances the smallest lsn for which there are unflushed dirty blocks in the buffer pool. NOTE: this function may only be called if the calling thread owns no synchronization objects! </p><dl class="section return"><dt>Returns</dt><dd>false if there was a flush batch of the same type running, which means that we could not start this flush batch </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_oldest</td><td>in: try to advance oldest_modified_lsn at least to this lsn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7203d9622cbb373917e7dad97e35254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7203d9622cbb373917e7dad97e35254">&#9670;&nbsp;</a></span>log_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of the log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06e7346dc1d9ec80c6e2d446bcbd83d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e7346dc1d9ec80c6e2d446bcbd83d0">&#9670;&nbsp;</a></span>log_refresh_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_refresh_stats </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refreshes the statistics used to print per-second averages. </p>

</div>
</div>
<a id="a5ec5b91f6f128d1669d09e778e6b81dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec5b91f6f128d1669d09e778e6b81dc">&#9670;&nbsp;</a></span>log_reserve_and_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN lsn_t log_reserve_and_open </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens the log for log_write_low. The log must be closed with log_close and released with log_release. </p><dl class="section return"><dt>Returns</dt><dd>start lsn of the log record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>in: length of data to be catenated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a531694c4b83c2bbb98b9761de8b0bf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531694c4b83c2bbb98b9761de8b0bf16">&#9670;&nbsp;</a></span>log_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shutdown the log system but do not release all the memory. </p>

</div>
</div>
<a id="af66c946c6df9c16e103762f31a375761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66c946c6df9c16e103762f31a375761">&#9670;&nbsp;</a></span>log_sys_check_flush_completion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint log_sys_check_flush_completion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a flush is completed and does the completion routine if yes. </p><dl class="section return"><dt>Returns</dt><dd>LOG_UNLOCK_FLUSH_LOCK or 0 </dd></dl>

</div>
</div>
<a id="a3cff24613386ffb6069d6e7dd55587ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cff24613386ffb6069d6e7dd55587ac">&#9670;&nbsp;</a></span>log_write_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_write_low </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>str_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to the log the string given. It is assumed that the caller holds the log mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string </td></tr>
    <tr><td class="paramname">str_len</td><td>in: string length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf92d6be658e10a45b643c2a559da1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf92d6be658e10a45b643c2a559da1af">&#9670;&nbsp;</a></span>log_write_up_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void log_write_up_to </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>flush_to_disk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called, e.g., when a transaction wants to commit. It checks that the log has been written to the log file up to the last log entry written by the transaction. If there is a flush running, it waits and checks if the flush flushed enough. If not, starts a new flush. </p>
<p>&lt; We assume here that we have only one log group! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lsn</td><td>in: log sequence number up to which the log should be written, LSN_MAX if not specified </td></tr>
    <tr><td class="paramname">wait</td><td>in: LOG_NO_WAIT, LOG_WAIT_ONE_GROUP, or LOG_WAIT_ALL_GROUPS </td></tr>
    <tr><td class="paramname">flush_to_disk</td><td>in: TRUE if we want the written log also to be flushed to disk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bc3be421065454846977694aeaf71e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc3be421065454846977694aeaf71e8">&#9670;&nbsp;</a></span>logs_empty_and_mark_files_at_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void logs_empty_and_mark_files_at_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a checkpoint at the latest lsn and writes it to first page of each data file in the database, so that we know that the file spaces contain all modifications up to that lsn. This can only be called at database shutdown. This function also writes all log in log files to the log archive. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo <a class="el" href="class_list.html">List</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="class_alter__inplace__info.html#a1774915f106804ab1aeb6629d58bcae4">Alter_inplace_info::key_info_buffer</a>  </dt>
<dd>This is mainly due to the fact that we need to keep compatibility with removed handler::add_index() call. We plan to switch to TABLE::key_info numbering later. </dd>
<dt><a class="anchor" id="_todo000012"></a>Class <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a>  </dt>
<dd>All the access functions for the flags suggest that the encapsuling is not done correctly, so try to move any logic that requires access to the flags into the cache.  </dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="group___binary___log.html#ga3da95c9d936e5ea3023159e0e2c73d53">binlog_commit</a>  (handlerton *hton, THD *thd, bool all)</dt>
<dd>This function is currently not used any more and will eventually be eliminated. The real commit job is done in the <a class="el" href="group___binary___log.html#ga94fdcfcfb5d2c85ca2a114ad2115b20e">MYSQL_BIN_LOG::commit</a> function. </dd>
<dt><a class="anchor" id="_todo000118"></a>Member <a class="el" href="group___query___optimizer.html#gab0ca922593fe6b15db19791f8133f407">calc_used_field_length</a>  (THD *thd, JOIN_TAB *join_tab)</dt>
<dd>why don't we count the rowids that we might need to store when using DuplicateElimination?  </dd>
<dt><a class="anchor" id="_todo000116"></a>Member <a class="el" href="group___query___resolver.html#ga6b65d5d2bec2545a151691d14378e118">change_group_ref</a>  (THD *thd, <a class="el" href="class_item__func.html">Item_func</a> *expr, ORDER *group_list, bool *changed)</dt>
<dd><ul>
<li>TODO: Some functions are not null-preserving. For those functions updating of the maybe_null attribute is an overkill.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000087"></a>Class <a class="el" href="class_c_o_p_y___i_n_f_o.html">COPY_INFO</a>  </dt>
<dd>Rename this class. </dd>
<dt><a class="anchor" id="_todo000063"></a>Member <a class="el" href="my__decimal_8h.html#a2f8281ea4229757f5d01f04c292d32d5">decimal_operation_results</a>  (int result)</dt>
<dd>Fix error messages </dd>
<dt><a class="anchor" id="_todo000097"></a>Member <a class="el" href="group___runtime___environment.html#ga3ee16ca35fd31e7babfd4afbe8a5914f">dispatch_command</a>  (enum enum_server_command command, THD *thd, char *packet, uint packet_length)</dt>
<dd><p class="startdd">set thd-&gt;lex-&gt;sql_command to SQLCOM_END here. </p>
<p class="enddd">The following has to be changed to an 8 byte integer </p>
</dd>
<dt><a class="anchor" id="_todo000109"></a>Member <a class="el" href="class_ed__connection.html#ad80317ac21aa245c7a0d1162ac98b264">Ed_connection::store_result_set</a>  ()</dt>
<dd>Use double-linked list, when this is really used. </dd>
<dt><a class="anchor" id="_todo000111"></a>Class <a class="el" href="class_ed__result__set.html">Ed_result_set</a>  </dt>
<dd>Implement support for result set metadata and automatic type conversion.  </dd>
<dt><a class="anchor" id="_todo000023"></a>Class <a class="el" href="class_field__bit__as__char.html">Field_bit_as_char</a>  </dt>
<dd>The inheritance relationship is backwards since <a class="el" href="class_field__bit.html">Field_bit</a> is an extended version of <a class="el" href="class_field__bit__as__char.html">Field_bit_as_char</a> and not the other way around. Hence, we should refactor it to fix the hierarchy order.  </dd>
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="class_field__new__decimal.html#a05d9f15a2a8a5148871c947dfe7a9dbe">Field_new_decimal::store</a>  (double nr)</dt>
<dd>Fix following when double2my_decimal when double2decimal will return E_DEC_TRUNCATED always correctly  </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="class_field__num.html#a4aba1e99e15d07a40cb6ae9fbff720b7">Field_num::check_int</a>  (const CHARSET_INFO *cs, const char *str, int length, const char *int_end, int error)</dt>
<dd>Make this multi-byte-character safe </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="class_field__str.html#ae0a260a3e657aa6778dcf651ff3e9b95">Field_str::store_decimal</a>  (const <a class="el" href="classmy__decimal.html">my_decimal</a> *)</dt>
<dd>use decimal2string? </dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="class_field__temporal__with__date__and__time.html#ac497834ddc1ef395a387790d97cfb63d">Field_temporal_with_date_and_time::init_timestamp_flags</a>  ()</dt>
<dd>get rid of TIMESTAMP_FLAG and ON_UPDATE_NOW_FLAG.  </dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="class_field__time__common.html#ab30cf710ffb3f033da46e5e43430490d">Field_time_common::convert_number_to_TIME</a>  (longlong nr, bool unsigned_val, int nanoseconds, MYSQL_TIME *ltime, int *warning)</dt>
<dd>: convert_number_to_TIME returns conversion status through two different interfaces: return value and warning. It should be refactored to only use return value.  </dd>
<dt><a class="anchor" id="_todo000130"></a>Member <a class="el" href="sys__vars_8cc.html#a995ff555f60375cf17a4408c516c43a2">fix_delay_key_write</a>  (<a class="el" href="classsys__var.html">sys_var</a> *self, THD *thd, enum_var_type type)</dt>
<dd>When updating myisam_delay_key_write, we should do a 'flush tables' of all MyISAM tables to ensure that they are reopen with the new attribute.  </dd>
<dt><a class="anchor" id="_todo000026"></a>File <a class="el" href="gen__lex__hash_8cc.html">gen_lex_hash.cc</a>  </dt>
<dd><p class="startdd">use instead to_upper_lex, special array (substitute chars) without skip codes.. </p>
<p class="enddd">try use reverse order of comparing.. </p>
</dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="handler_8cc.html#ad012444cc24f2178ff92e9e7ecbfbc85">get_canonical_filename</a>  (handler *file, const char *path, char *tmp_path)</dt>
<dd>This may be done more efficiently when table path gets built. Convert this function to something like ASSERT_CANONICAL_FILENAME.  </dd>
<dt><a class="anchor" id="_todo000067"></a>Member <a class="el" href="class_group__cache.html#aec761cec5484308a4006aa22cf6b4426">Group_cache::write_to_log_prepare</a>  (<a class="el" href="class_group__cache.html">Group_cache</a> *trx_group_cache, rpl_binlog_pos offset_after_last_statement, <a class="el" href="struct_cached__group.html">Cached_group</a> **last_non_empty_group)</dt>
<dd>The group log is not yet implemented. /Sven </dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="group___binary___log.html#ga8072c6b6890022e3919455e77017ab0d">gtid_before_write_cache</a>  (THD *thd, <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *cache_data)</dt>
<dd>Move this function into the cache class?  </dd>
<dt><a class="anchor" id="_todo000068"></a>Member <a class="el" href="class_gtid__set.html#a9a384be7c735d018d5fc0c8c0c64344e">Gtid_set::intersection</a>  (const <a class="el" href="class_gtid__set.html">Gtid_set</a> *other, <a class="el" href="class_gtid__set.html">Gtid_set</a> *result)</dt>
<dd>: This algorithm is simple, a little bit slower than necessary. It would be more efficient to iterate over intervals of 'this' and 'other' similar to <a class="el" href="class_gtid__set.html#a631a429070b1828cff450a493fe913aa">add_gno_interval()</a>. At the moment the performance of this is not super-important. /Sven  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="handler_8cc.html#a4b52399a74d9db4f3421851b46ff6dc9">ha_check_if_supported_system_table</a>  (handlerton *hton, const char *db, const char *table_name)</dt>
<dd>There is another function called is_system_table_name() used by get_table_category(), which is used to set <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> table_category. It checks only a subset of table name like proc, event and time*. We cannot use below function in get_table_category(), as that affects locking mechanism. If we need to unify these functions, we need to fix locking issues generated. </dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="handler_8cc.html#a9a81ce45b63a150449fb897a34572bb1">ha_commit_trans</a>  (THD *thd, bool all, bool ignore_global_read_lock)</dt>
<dd>Since we don't support nested statement transactions in 5.0, we can't commit or rollback stmt transactions while we are inside stored functions or triggers. So we simply do nothing now. TODO: This should be fixed in later ( &gt;= 5.1) releases.  </dd>
<dt><a class="anchor" id="_todo000031"></a>Member <a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">handler::index_only_read_time</a>  (uint keynr, double records)</dt>
<dd>Consider joining this function and <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">handler::read_time()</a> into one handler::read_time(keynr, records, ranges, bool index_only) function. </dd>
<dt><a class="anchor" id="_todo000034"></a>Member <a class="el" href="struct_hybrid__type__traits__decimal.html#abacf79142edb4cc12105279b750ac73d">Hybrid_type_traits_decimal::div</a>  (<a class="el" href="struct_hybrid__type.html">Hybrid_type</a> *val, ulonglong u) const</dt>
<dd>what is '4' for scale?  </dd>
<dt><a class="anchor" id="_todo000039"></a>Member <a class="el" href="class_item.html#a7cf3cc4b8db99b2fa1bbc00a6c0c86f7">Item::copy_andor_structure</a>  (THD *thd, bool real_items=false)</dt>
<dd>this argument should be always false and removed in WL#7082.  </dd>
<dt><a class="anchor" id="_todo000035"></a>Member <a class="el" href="class_item.html#a875594d2b9d99ccff3863bfd435828f0">Item::val_bool</a>  ()</dt>
<dd>Make this functions class dependent  </dd>
<dt><a class="anchor" id="_todo000040"></a>Member <a class="el" href="class_item__func__case.html#a72dc07ea4fc65211872b8b7e0c53813a">Item_func_case::print</a>  (<a class="el" href="class_string.html">String</a> *str, enum_query_type query_type)</dt>
<dd>Fix this so that it prints the whole CASE expression  </dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="class_item__func__format.html#a9f01cf724eacb711a5874955671fdc67">Item_func_format::val_str_ascii</a>  (<a class="el" href="class_string.html">String</a> *)</dt>
<dd>This needs to be fixed for multi-byte character set where numbers are stored in more than one byte  </dd>
<dt><a class="anchor" id="_todo000042"></a>Member <a class="el" href="class_item__func__match.html#ac2648c61e31b90bc16b7afa8a5fe37c2">Item_func_match::allows_search_on_non_indexed_columns</a>  (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table_arg)</dt>
<dd>A flag should be added to the extended fulltext API so that it may be checked whether search on non-indexed columns are supported. Currently, it is not possible to check for such a flag since <code>this-&gt;ft_handler</code> is not yet set when this function is called. The current hack is to assume that search on non-indexed columns are supported for engines that does not support the extended fulltext API (e.g., MyISAM), while it is not supported for other engines (e.g., InnoDB) </dd>
<dt><a class="anchor" id="_todo000044"></a>Member <a class="el" href="class_item__func__replace.html#a339fa98601454ef99451c1c2daf5d1a4">Item_func_replace::val_str</a>  (<a class="el" href="class_string.html">String</a> *)</dt>
<dd>Fix that this works with binary strings when using USE_MB  </dd>
<dt><a class="anchor" id="_todo000041"></a>Member <a class="el" href="class_item__func__xor.html#abf20b3f1b71cb4c4b588c5a04d77ba05">Item_func_xor::val_int</a>  ()</dt>
<dd>(low priority) Change this to be optimized as: <br />
 A XOR B -&gt; (A) == 1 AND (B) &lt;&gt; 1) OR (A &lt;&gt; 1 AND (B) == 1) <br />
 To be able to do this, we would however first have to extend the MySQL range optimizer to handle OR better. </dd>
<dt><a class="anchor" id="_todo000048"></a>Member <a class="el" href="class_item__in__subselect.html#a5b227952590f09ea10b9a2c95d33551b">Item_in_subselect::row_value_in_to_exists_transformer</a>  (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</dt>
<dd>The IF-ELSE below can be refactored so that there is no duplication of the statements that create the new conditions. For this we have to invert the IF and the FOR statements as this: for (each left operand) create the equi-join condition if (is_having_used || !abort_on_null) create the "is null" and is_not_null_test items if (is_having_used) add the equi-join and the null tests to HAVING else add the equi-join and the "is null" to WHERE add the is_not_null_test to HAVING  </dd>
<dt><a class="anchor" id="_todo000037"></a>Member <a class="el" href="class_item__param.html#aa9b9af6fd0ae3281fc3bbcd2ce6cf741">Item_param::query_val_str</a>  (THD *thd, <a class="el" href="class_string.html">String</a> *str) const</dt>
<dd><ul>
<li>Change interface and implementation to fill log data in place and avoid one more memcpy/alloc between str and log string.</li>
<li>In case of error we need to notify replication that binary log contains wrong statement  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="class_item__ref.html#a6a78e05b0db89e799f61808c621b808f">Item_ref::fix_fields</a>  (THD *, <a class="el" href="class_item.html">Item</a> **)</dt>
<dd>Here we could first find the field anyway, and then test this condition, so that we can give a better error message - ER_WRONG_FIELD_WITH_GROUP, instead of the less informative ER_BAD_FIELD_ERROR which we produce now. </dd>
<dt><a class="anchor" id="_todo000043"></a>Member <a class="el" href="class_item__row.html#aeddb642ba1780904980f6b4e2d29dffb">Item_row::Item_row</a>  (<a class="el" href="class_list.html">List&lt; Item &gt;</a> &amp;)</dt>
<dd>think placing 2-3 component items in item (as it done for function  </dd>
<dt><a class="anchor" id="_todo000047"></a>Member <a class="el" href="class_item__singlerow__subselect.html#a61aa448d7333365d599e518eefdeb468">Item_singlerow_subselect::select_transformer</a>  (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</dt>
<dd><ul>
<li>We cant change name of <a class="el" href="class_item__field.html">Item_field</a> or <a class="el" href="class_item__ref.html">Item_ref</a>, because it will prevent it's correct resolving, but we should save name of removed item =&gt; we do not make optimization if top item of list is field or reference.</li>
<li>switch off this optimization for prepare statement, because we do not rollback this changes. Make rollback for it, or special name resolving mode in 5.0.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000036"></a>Member <a class="el" href="class_item__string.html#a4226f4dfd6a0c9eb1b97c33da0b3db78">Item_string::val_int</a>  ()</dt>
<dd>Give error if we wanted a signed integer and we got an unsigned one  </dd>
<dt><a class="anchor" id="_todo000046"></a>File <a class="el" href="item__subselect_8cc.html">item_subselect.cc</a>  </dt>
<dd><ul>
<li>add function from mysql_select that use JOIN* as parameter to <a class="el" href="class_j_o_i_n.html">JOIN</a> methods (<a class="el" href="sql__select_8h.html" title="classes to use when handling where clause ">sql_select.h</a>/sql_select.cc)  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000051"></a>Member <a class="el" href="class_item__sum__hybrid.html#ad7d563ebdca9c58beec529763623c3fb">Item_sum_hybrid::min_max_update_decimal_field</a>  ()</dt>
<dd>optimize: do not get result_field in case of args[0] is NULL  </dd>
<dt><a class="anchor" id="_todo000050"></a>Member <a class="el" href="class_item__sum__sum.html#af259b3fb68c269dba5d29d7f1e2323eb">Item_sum_sum::Item_sum_sum</a>  (THD *thd, <a class="el" href="class_item__sum__sum.html">Item_sum_sum</a> *item)</dt>
<dd>check if the following assignments are really needed  </dd>
<dt><a class="anchor" id="_todo000052"></a>File <a class="el" href="item__timefunc_8cc.html">item_timefunc.cc</a>  </dt>
<dd>Move month and days to language files  </dd>
<dt><a class="anchor" id="_todo000090"></a>Member <a class="el" href="group___query___executor.html#ga31581f58624b85919d7c6cd632157929">JOIN::exec</a>  ()</dt>
<dd>When can we have here thd-&gt;net.report_error not zero?  </dd>
<dt><a class="anchor" id="_todo000121"></a>Member <a class="el" href="group___query___optimizer.html#gaa62d47da29f3853e87b1069ee5c1ff21">JOIN::join_free</a>  ()</dt>
<dd>Unlock tables even if the join isn't top level select in the tree  </dd>
<dt><a class="anchor" id="_todo000094"></a>Member <a class="el" href="group___query___optimizer.html#ga7f722315c64ce97cff639d705107c660">JOIN::optimize</a>  ()</dt>
<dd>Above we passed unique=false. But for this query: (oe1, oe2) IN (SELECT primary_key, non_key_maybe_null_field FROM tbl) we could use "unique=true" for the first index component and let <a class="el" href="class_item__is__not__null__test.html">Item_is_not_null_test(non_key_maybe_null_field)</a> handle the second.  </dd>
<dt><a class="anchor" id="_todo000113"></a>Member <a class="el" href="group___query___resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a>  (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *tables, uint wind_num, <a class="el" href="class_item.html">Item</a> *conds, uint og_num, ORDER *order, ORDER *group, <a class="el" href="class_item.html">Item</a> *having, SELECT_LEX *select, SELECT_LEX_UNIT *unit)</dt>
<dd>Add check of calculation of GROUP functions and fields: SELECT COUNT(*)+table.col1 from table1; </dd>
<dt><a class="anchor" id="_todo000096"></a>Member <a class="el" href="group___query___optimizer.html#ga1b521ce8c8cc3192c6ba5f38af9929b4">JOIN::replace_item_field</a>  (const char *field_name, <a class="el" href="class_item.html">Item</a> *new_item)</dt>
<dd>So far this function only handles SELECT list and WHERE clause, For more general use, ON clause, ORDER BY list, GROUP BY list and HAVING clause also needs to be handled. </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="handler_8cc.html#a136dfdf479102e63c8ddf02af552c445">key_uses_partial_cols</a>  (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table, uint keyno)</dt>
<dd>Allow use of DS-MRR in cases where the index has partially-covered components but they are not used for scanning. </dd>
<dt><a class="anchor" id="_todo000139"></a>Member <a class="el" href="client__plugin_8c.html#aec5285246b92f70410a7ed2c6170ea51">load_env_plugins</a>  (MYSQL *mysql)</dt>
<dd>Support extended syntax, passing parameters to plugins, for example LIBMYSQL_PLUGINS="plugin1(param1,param2);plugin2;..." or LIBMYSQL_PLUGINS="plugin1=int:param1,str:param2;plugin2;..."  </dd>
<dt><a class="anchor" id="_todo000053"></a>File <a class="el" href="lock_8cc.html">lock.cc</a>  </dt>
<dd>Change to use my_malloc() ONLY when using LOCK TABLES command or when we are forced to use mysql_lock_merge.  </dd>
<dt><a class="anchor" id="_todo000054"></a>File <a class="el" href="log_8cc.html">log.cc</a>  </dt>
<dd>Abort logging when we get an error in reading or writing log files  </dd>
<dt><a class="anchor" id="_todo000055"></a>Member <a class="el" href="class_log__to__csv__event__handler.html#a5174e86bbcc9f91b3e8a7683f8a1e785">Log_to_csv_event_handler::log_general</a>  (THD *thd, time_t event_time, const char *user_host, uint user_host_len, my_thread_id thread_id, const char *command_type, uint command_type_len, const char *sql_text, uint sql_text_len, const CHARSET_INFO *client_cs)</dt>
<dd>: how?). If a write to the table has failed, the function attempts to write to a short error message to the file. The failure is also indicated in the return value.  </dd>
<dt><a class="anchor" id="_todo000062"></a>Member <a class="el" href="class_m_d_l__ticket.html#aeb3ea2a00b6f11c07c18483de8c69060">MDL_ticket::create</a>  (<a class="el" href="class_m_d_l__context.html">MDL_context</a> *ctx_arg, enum_mdl_type type_arg, enum_mdl_duration duration_arg)</dt>
<dd>This naive implementation should be replaced with one that saves on memory allocation by reusing released objects.  </dd>
<dt><a class="anchor" id="_todo000095"></a>Member <a class="el" href="group___query___optimizer.html#ga1de27fe9f2c08ca72261a3eb995c5b76">merge_key_fields</a>  (<a class="el" href="struct_key__field.html" title="Used when finding key fields. ">Key_field</a> *start, <a class="el" href="struct_key__field.html" title="Used when finding key fields. ">Key_field</a> *new_fields, <a class="el" href="struct_key__field.html" title="Used when finding key fields. ">Key_field</a> *end, uint and_level)</dt>
<dd>The result of this is that we're missing some 'ref' accesses. OptimizerTeam: Fix this  </dd>
<dt><a class="anchor" id="_todo000140"></a>Class <a class="el" href="class_mrg__child__def.html">Mrg_child_def</a>  </dt>
<dd>: Add MYRG_SHARE and store chlidren names in the share.  </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="group___binary___log.html#ga1eb09393ab56b2ba8a7620cbd4cb34b9">MYSQL_BIN_LOG::open_binlog</a>  (const char *log_name, const char *new_name, enum cache_type io_cache_type_arg, ulong max_size, bool null_created, bool need_lock_index, bool need_sid_lock, <a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *extra_description_event)</dt>
<dd>: although this was introduced to appease valgrind when injecting emulated faults using fault_injection_registering_index it may be good to consider what actually happens when open_purge_index_file succeeds but register or sync fails. </dd>
<dt><a class="anchor" id="_todo000018"></a>Member <a class="el" href="group___binary___log.html#ga44de4e3109fc4d50d4968191ab0f3544">MYSQL_BIN_LOG::open_binlog</a>  (const char *opt_name)</dt>
<dd>keep in-memory list of prepared transactions (add to list in <a class="el" href="row0log_8cc.html#a800f12bb442b5fb971fb19d203766eb4">log()</a>, remove on unlog()) and copy it to the new binlog if rotated but let's check the behaviour of tc_log_page_waits first!  </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="group___binary___log.html#gadd6e1e70093afedf97ac7266268db0fe">MYSQL_BIN_LOG::ordered_commit</a>  (THD *thd, bool all, bool skip_commit=false)</dt>
<dd>The use of <code>skip_commit</code> is a hack that we use since the <code><a class="el" href="class_t_c___l_o_g.html">TC_LOG</a></code> Interface does not contain functions to handle savepoints. Once the binary log is eliminated as a handlerton and the <code><a class="el" href="class_t_c___l_o_g.html">TC_LOG</a></code> interface is extended with savepoint handling, this parameter can be removed. </dd>
<dt><a class="anchor" id="_todo000098"></a>Member <a class="el" href="group___runtime___environment.html#ga6a69efbbf47bbcab9d2e517e285679d9">mysql_execute_command</a>  (THD *thd)</dt>
<dd><ul>
<li>Invalidate the table in the query cache if something changed after unlocking when changes become visible. </li>
</ul>
<p class="enddd">: this is workaround. right way will be move invalidating in the unlock procedure.</p><ul>
<li>TODO: use check_change_password() </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000056"></a>Member <a class="el" href="class_m_y_s_q_l___l_o_g.html#a5bbba2bb951d6ff27d3676b0d6a15057">MYSQL_LOG::generate_name</a>  (const char *log_name, const char *suffix, bool strip_ext, char *buff)</dt>
<dd>The following should be using fn_format(); We just need to first change fn_format() to cut the file name if it's too long.  </dd>
<dt><a class="anchor" id="_todo000099"></a>Member <a class="el" href="group___runtime___environment.html#gab37db6950d3b6bc16bbbb2ae0484ae55">mysql_reset_thd_for_next_command</a>  (THD *thd)</dt>
<dd><p class="startdd">Remove mysql_reset_thd_for_next_command and only use the member function.</p>
<p class="enddd">Call it after we use THD for queries, not before.  </p>
</dd>
<dt><a class="anchor" id="_todo000106"></a>Member <a class="el" href="sql__prepare_8cc.html#a4a49c9a3e7c6e4df379e3bd05e5e5002">mysql_test_update</a>  (<a class="el" href="class_prepared__statement.html">Prepared_statement</a> *stmt, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list)</dt>
<dd><ul>
<li>here we should send types of placeholders to the client. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000101"></a>Member <a class="el" href="group___query___planner.html#ga1345da559c5841bf89d657bf2348e230">Optimize_table_order::determine_search_depth</a>  (uint search_depth, uint table_count)</dt>
<dd><p class="startdd">this value should be determined dynamically, based on statistics: uint max_tables_for_exhaustive_opt= 7;</p>
<p class="enddd">this value could be determined by some mapping of the form: depth : table_count -&gt; [max_tables_for_exhaustive_opt..MAX_EXHAUSTIVE] </p>
</dd>
<dt><a class="anchor" id="_todo000103"></a>Member <a class="el" href="group___query___planner.html#gabf8bc9bccf882a55db6cb971dbfbc8d9">Optimize_table_order::semijoin_dupsweedout_access_paths</a>  (uint first_tab, uint last_tab, table_map remaining_tables, double *newcount, double *newcost)</dt>
<dd>: Some times, some outer fanout is "absorbed" into the inner fanout. In this case, we should make a better estimate for outer_fanout that is used to calculate the output rowcount. Trial code: if (inner_fanout &gt; 1.0) { We have inner table(s) before an outer table. If there are dependencies between these tables, the fanout for the outer table is not a good estimate for the final number of rows from the weedout execution, therefore we convert some of the inner fanout into an outer fanout, limited to the number of possible rows in the outer table. double fanout= min(inner_fanout*p-&gt;records_read, p-&gt;table-&gt;table-&gt;quick_condition_rows); inner_fanout*= p-&gt;records_read / fanout; outer_fanout*= fanout; } else outer_fanout*= p-&gt;records_read;  </dd>
<dt><a class="anchor" id="_todo000108"></a>Member <a class="el" href="class_prepared__statement.html#a3a050c5a74f19e2b1d19600542a1a3d1">Prepared_statement::set_parameters</a>  (<a class="el" href="class_string.html">String</a> *expanded_query, uchar *packet, uchar *packet_end)</dt>
<dd>Use a paremeter source class family instead of 'if's, and support stored procedure variables. </dd>
<dt><a class="anchor" id="_todo000066"></a>Member <a class="el" href="class_protocol__text.html#a66166244c73b0d710d2896c411514890">Protocol_text::store</a>  (MYSQL_TIME *time, uint precision)</dt>
<dd>Second_part format ("%06") needs to change when we support 0-6 decimals for time.  </dd>
<dt><a class="anchor" id="_todo000007"></a>Member <a class="el" href="group___instrumentation__interface.html#gaab002d7cc2c095aafe0f65243ae922e3">PSI_server</a>  </dt>
<dd>This is currently a global variable, which is handy when compiling instrumented code that is bundled with the server. When dynamic plugin are truly supported, this variable will need to be replaced by a macro, so that each XYZ plugin can have it's own xyz_psi_server variable, obtained from <a class="el" href="struct_p_s_i__bootstrap.html#abc01e3871b57a4386f81f0b6d9dce1c2">PSI_bootstrap::get_interface()</a> with the version used at compile time for plugin XYZ.  </dd>
<dt><a class="anchor" id="_todo000060"></a>Member <a class="el" href="class_query__log__event.html#ace9dae10ee6c2c11ef34d678baa594d5">Query_log_event::print_query_header</a>  (IO_CACHE *file, PRINT_EVENT_INFO *print_event_info)</dt>
<dd>print the catalog ??  </dd>
<dt><a class="anchor" id="_todo000059"></a>Member <a class="el" href="class_query__log__event.html#a8eeda6f83d6ed20343be666af286032b">Query_log_event::Query_log_event</a>  (const char *buf, uint event_len, const <a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *description_event, Log_event_type event_type)</dt>
<dd>we should clean up and do only copy_str_and_move; it works for both cases. Then we can remove the catalog_nz flag. /sven  </dd>
<dt><a class="anchor" id="_todo000107"></a>Member <a class="el" href="sql__prepare_8cc.html#ac923efcc818c95eeb45ebc9ac085f081">reinit_stmt_before_use</a>  (THD *thd, LEX *lex)</dt>
<dd>When the new table structure is ready, then have a status bit to indicate the table is altered, and re-do the setup_* and open the tables back.  </dd>
<dt><a class="anchor" id="_todo000074"></a>Member <a class="el" href="class_relay__log__info.html#ab4299015e0504c30685b2e3b3e093d27">Relay_log_info::flush_info</a>  (bool force=FALSE)</dt>
<dd>Change the log file information to a binary format to avoid calling longlong2str. </dd>
<dt><a class="anchor" id="_todo000073"></a>Member <a class="el" href="class_relay__log__info.html#a7bfd2c28d4caabdc57c35793bde91d18">Relay_log_info::init_relay_log_pos</a>  (const char *log, ulonglong pos, bool need_data_lock, const char **errmsg, bool look_for_description_event)</dt>
<dd>check proper initialization of group_master_log_name/group_master_log_pos. /alfranio </dd>
<dt><a class="anchor" id="_todo000114"></a>Member <a class="el" href="group___query___resolver.html#ga62cce1652d3ee4d87cdc71ff4edb9a9f">resolve_subquery</a>  (THD *thd, <a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</dt>
<dd>for PS, make the whole block execute only on the first execution </dd>
<dt><a class="anchor" id="_todo000104"></a>Member <a class="el" href="sql__prepare_8cc.html#a4c6425fa85557ca8f86b27049e5dfba4">send_prep_stmt</a>  (<a class="el" href="class_prepared__statement.html">Prepared_statement</a> *stmt, uint columns)</dt>
<dd>Fix this nasty upcast from List&lt;Item_param&gt; to <a class="el" href="class_list.html">List&lt;Item&gt;</a> </dd>
<dt><a class="anchor" id="_todo000105"></a>Member <a class="el" href="sql__prepare_8cc.html#aaec3d94c06c8c8f5009bd6dd1fcc5f7b">set_param_time</a>  (<a class="el" href="class_item__param.html">Item_param</a> *param, uchar **pos, ulong len)</dt>
<dd>Add warning 'Data truncated' here  </dd>
<dt><a class="anchor" id="_todo000091"></a>Member <a class="el" href="group___query___executor.html#gabf6f9870d5d7d18698a9fed0295393f4">setup_copy_fields</a>  (THD *thd, TMP_TABLE_PARAM *param, Ref_ptr_array ref_pointer_array, <a class="el" href="class_list.html">List&lt; Item &gt;</a> &amp;res_selected_fields, <a class="el" href="class_list.html">List&lt; Item &gt;</a> &amp;res_all_fields, uint elements, <a class="el" href="class_list.html">List&lt; Item &gt;</a> &amp;all_fields)</dt>
<dd>In most cases this result will be sent to the user. This should be changed to use copy_int or copy_real depending on how the value is to be used: In some cases this may be an argument in a group function, like: IF(ISNULL(col),0,COUNT(*)) </dd>
<dt><a class="anchor" id="_todo000115"></a>Member <a class="el" href="group___query___resolver.html#gaf206c0aa90dedda87347e653c8a9d5d0">setup_group</a>  (THD *thd, Ref_ptr_array ref_pointer_array, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *tables, <a class="el" href="class_list.html">List&lt; Item &gt;</a> &amp;fields, <a class="el" href="class_list.html">List&lt; Item &gt;</a> &amp;all_fields, ORDER *order)</dt>
<dd>change ER_WRONG_FIELD_WITH_GROUP to more detailed ER_NON_GROUPING_FIELD_USED </dd>
<dt><a class="anchor" id="_todo000119"></a>Member <a class="el" href="group___query___optimizer.html#ga1510993d68f776aedbd40bc732b94fa6">setup_join_buffering</a>  (JOIN_TAB *tab, <a class="el" href="class_j_o_i_n.html">JOIN</a> *join, ulonglong options, uint no_jbuf_after, bool *icp_other_tables_ok)</dt>
<dd><p class="startdd">Long-term it is the goal that join buffering strategy is decided when the plan is selected.</p>
<pre class="fragment">Support BKA inside SJ-Materialization nests. When doing this, we'll need
to only store sj-inner tables in the join buffer.
</pre><p> #if 0 JOIN_TAB *first_tab= join-&gt;join_tab+join-&gt;const_tables; uint n_tables= i-join-&gt;const_tables; / * We normally put all preceding tables into the join buffer, except for the constant tables. If we're inside a semi-join materialization nest, e.g. </p>
</dd>
<dt><a class="anchor" id="_todo000117"></a>Member <a class="el" href="group___query___optimizer.html#gadd6d91b682441f4991964f9b3ef828c9">setup_semijoin_dups_elimination</a>  (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, ulonglong options, uint no_jbuf_after)</dt>
<dd>: merge <a class="el" href="group___query___optimizer.html#ga77fc941f20e42c089b99ab1641646828">make_join_readinfo()</a> and <a class="el" href="group___query___optimizer.html#gadd6d91b682441f4991964f9b3ef828c9">setup_semijoin_dups_elimination()</a> loops and change the following 'if' to </dd>
<dt><a class="anchor" id="_todo000082"></a>Member <a class="el" href="classsp__head.html#a42a692195fb3636528697c091f4578e0">sp_head::execute</a>  (THD *thd, bool merge_da_on_success)</dt>
<dd><ul>
<li>Will write this SP statement into binlog separately (TODO: consider changing the condition to "not inside event union") </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000079"></a>Member <a class="el" href="classsp__head.html#a1c125eeeef415da5d45fdf16de43ecb7">sp_head::execute_function</a>  (THD *thd, <a class="el" href="class_item.html">Item</a> **args, uint argcount, <a class="el" href="class_field.html">Field</a> *return_fld)</dt>
<dd><p class="startdd">We should create <a class="el" href="classsp__rcontext.html">sp_rcontext</a> once per command and reuse it on subsequent executions of a function/trigger.</p>
<p class="enddd">In future we should associate call arena/mem_root with <a class="el" href="classsp__rcontext.html">sp_rcontext</a> and allocate all these objects (and <a class="el" href="classsp__rcontext.html">sp_rcontext</a> itself) on it directly rather than juggle with arenas. </p>
</dd>
<dt><a class="anchor" id="_todo000078"></a>Member <a class="el" href="classsp__head.html#ac113041f45cd9bef83a5c53431e2b860">sp_head::execute_trigger</a>  (THD *thd, const LEX_STRING *db_name, const LEX_STRING *table_name, GRANT_INFO *grant_info)</dt>
<dd><ul>
<li>TODO: we should create <a class="el" href="classsp__rcontext.html">sp_rcontext</a> once per command and reuse it on subsequent executions of a trigger. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000081"></a>Member <a class="el" href="classsp__head.html#afe7c4aad6b9627d1f38b569b39f66419">sp_head::set_security_ctx</a>  (THD *thd, Security_context **save_ctx)</dt>
<dd>Cache if the definer has the rights to use the object on the first usage and reset the cache only if someone does a GRANT statement that 'may' affect this. </dd>
<dt><a class="anchor" id="_todo000083"></a>Class <a class="el" href="classsp__instr__jump.html">sp_instr_jump</a>  </dt>
<dd>later we will consider introducing a new class, which will be the base for <a class="el" href="classsp__instr__jump.html">sp_instr_jump</a>, <a class="el" href="classsp__instr__set__case__expr.html">sp_instr_set_case_expr</a> and <a class="el" href="classsp__instr__jump__case__when.html">sp_instr_jump_case_when</a>. Something like sp_regular_branch_instr (similar to <a class="el" href="classsp__lex__branch__instr.html">sp_lex_branch_instr</a>).  </dd>
<dt><a class="anchor" id="_todo000077"></a>Member <a class="el" href="classsp__parser__data.html#af658fd5aa0ce26b21268b34be0fd2c29">sp_parser_data::new_cont_backpatch</a>  ()</dt>
<dd>These functions should probably be declared in a separate interface class, but currently we try to minimize the <a class="el" href="classsp__instr.html">sp_instr</a> hierarchy. </dd>
<dt><a class="anchor" id="_todo000085"></a>Class <a class="el" href="class_sql__cmd__alter__table.html">Sql_cmd_alter_table</a>  </dt>
<dd>move <a class="el" href="class_alter__info.html">Alter_info</a> and other ALTER specific structures from Lex here.  </dd>
<dt><a class="anchor" id="_todo000084"></a>Class <a class="el" href="class_sql__cmd__common__alter__table.html">Sql_cmd_common_alter_table</a>  </dt>
<dd>move <a class="el" href="class_alter__info.html">Alter_info</a> and other ALTER generic structures from Lex here.  </dd>
<dt><a class="anchor" id="_todo000061"></a>Member <a class="el" href="structsql__ex__info.html#a90e3b19d97cb512779dd0bf6112d4fd0">sql_ex_info::write_data</a>  (IO_CACHE *file)</dt>
<dd>This is sensitive to field padding. We should write a char[7], not an <a class="el" href="structold__sql__ex.html">old_sql_ex</a>. /sven  </dd>
<dt><a class="anchor" id="_todo000123"></a>Member <a class="el" href="structst__join__table.html#a29fd946570ed7369a98edd0e5747c710">st_join_table::st_join_table</a>  ()</dt>
<dd>Add constructor to <a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a>. All users do init_read_record(), which does memset(), rather than invoking a constructor.  </dd>
<dt><a class="anchor" id="_todo000049"></a>Member <a class="el" href="classsubselect__single__select__engine.html#abea1c2122554f643c8b82b648f63ba39">subselect_single_select_engine::prepare</a>  ()</dt>
<dd>Re-check what properties of 'join' are needed during prepare, and see if we can avoid creating a <a class="el" href="class_j_o_i_n.html">JOIN</a> during <a class="el" href="group___query___resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a> of the outer join. </dd>
<dt><a class="anchor" id="_todo000134"></a>Member <a class="el" href="sys__vars_8cc.html#a4d3300d6e0443d21e8587c1405659a4a">Sys_date_format</a>  ("date_format", "The DATE format (ignored)", READ_ONLY GLOBAL_VAR(global_date_format.format.str), <a class="el" href="struct_c_m_d___l_i_n_e.html">CMD_LINE(REQUIRED_ARG)</a>, IN_SYSTEM_CHARSET, DEFAULT(known_date_time_formats[ISO_FORMAT].date_format), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(""))</dt>
<dd>make them NO_CMD_LINE ?  </dd>
<dt><a class="anchor" id="_todo000131"></a>Member <a class="el" href="sys__vars_8cc.html#a5b6eb5927443202f47bc2775a88726d8">Sys_ft_boolean_syntax</a>  ("ft_boolean_syntax", "List of operators for " "MATCH ... AGAINST ( ... IN BOOLEAN MODE)", GLOBAL_VAR(ft_boolean_syntax), <a class="el" href="struct_c_m_d___l_i_n_e.html">CMD_LINE(REQUIRED_ARG)</a>, IN_SYSTEM_CHARSET, DEFAULT(DEFAULT_FTB_SYNTAX), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_ftb_syntax), ON_UPDATE(query_cache_flush))</dt>
<dd>make SESSION_VAR (usability enhancement and a fix for a race condition)  </dd>
<dt><a class="anchor" id="_todo000132"></a>Member <a class="el" href="sys__vars_8cc.html#ab934b147dd95166f680d7bfcd7b0636a">Sys_ft_query_expansion_limit</a>  ("ft_query_expansion_limit", "Number of best matches to use for query expansion", READ_ONLY GLOBAL_VAR(ft_query_expansion_limit), <a class="el" href="struct_c_m_d___l_i_n_e.html">CMD_LINE(REQUIRED_ARG)</a>, VALID_RANGE(0, 1000), DEFAULT(20), BLOCK_SIZE(1))</dt>
<dd>make it an updatable SESSION_VAR  </dd>
<dt><a class="anchor" id="_todo000133"></a>Member <a class="el" href="sys__vars_8cc.html#ad154f050a27a260047dd25ccc3884ded">Sys_optimizer_prune_level</a>  ("optimizer_prune_level", "Controls the heuristic(s) applied during query optimization to prune " "less-promising partial plans from the optimizer search space. " "Meaning: 0 - do not apply any heuristic, thus perform exhaustive " "search; 1 - prune plans based on number of retrieved rows", SESSION_VAR(optimizer_prune_level), <a class="el" href="struct_c_m_d___l_i_n_e.html">CMD_LINE(REQUIRED_ARG)</a>, VALID_RANGE(0, 1), DEFAULT(1), BLOCK_SIZE(1))</dt>
<dd>change to enum  </dd>
<dt><a class="anchor" id="_todo000135"></a>Member <a class="el" href="class_sys__var__keycache.html#a7775f6e9ee55bb58461d6556f053075f">Sys_var_keycache::global_update</a>  (THD *thd, <a class="el" href="classset__var.html">set_var</a> *var)</dt>
<dd>This should be changed so that we wait until the previous assignment is done and then do the new assign  </dd>
<dt><a class="anchor" id="_todo000137"></a>Member <a class="el" href="struct_t_a_b_l_e.html#aa76fd5e13a8b5101a247413701978730">TABLE::mem_root</a>  </dt>
<dd>This member should not be declared in-line. That makes it impossible for any function that does memory allocation to take a const reference to a <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object.  </dd>
<dt><a class="anchor" id="_todo000138"></a>Member <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html#ad2814dff1dc9df41c607fdb66e2abbc1">TABLE_LIST::context_of_embedding</a>  </dt>
<dd>When name resolution contexts are created after parsing, we should be able to store this in the embedding join nest instead.  </dd>
<dt><a class="anchor" id="_todo000136"></a>Member <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html#ad3a3e3e4c725c1814866341fd65002bf">TABLE_SHARE::get_table_ref_type</a>  () const</dt>
<dd>perhaps we need to have a member instead of a function.  </dd>
<dt><a class="anchor" id="_todo000127"></a>Member <a class="el" href="class_table__triggers__list.html#ac2d1d5b25d9bb266b0ee2c060561caf4">Table_triggers_list::check_n_load</a>  (THD *thd, const char *db, const char *table_name, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table, bool names_only)</dt>
<dd><p class="startdd">A lot of things to do here e.g. how about other funcs and being more paranoical ?</p>
<p class="enddd">This could be avoided if there is no triggers for UPDATE and DELETE. </p>
</dd>
<dt><a class="anchor" id="_todo000126"></a>Member <a class="el" href="class_table__triggers__list.html#a5dd5facac52475db6b2e850519377271">Table_triggers_list::drop_trigger</a>  (THD *thd, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table, <a class="el" href="class_string.html">String</a> *stmt_query)</dt>
<dd>Probably instead of removing .TRG file we should move to archive directory but this should be done as part of <a class="el" href="parse__file_8cc.html" title="Text .frm files management routines. ">parse_file.cc</a> functionality (because we will need it elsewhere). </dd>
<dt><a class="anchor" id="_todo000057"></a>Member <a class="el" href="class_t_c___l_o_g___m_m_a_p.html#a880876be78bf7c3a8924af841220aafe">TC_LOG_MMAP::get_active_from_pool</a>  ()</dt>
<dd>TODO page merging. try to allocate adjacent page first, so that they can be flushed both in one sync  </dd>
<dt><a class="anchor" id="_todo000058"></a>Member <a class="el" href="class_t_c___l_o_g___m_m_a_p.html#af0e7ae806c38e2855e25fdadc54112f8">TC_LOG_MMAP::overflow</a>  ()</dt>
<dd>perhaps, increase log size ?  </dd>
<dt><a class="anchor" id="_todo000086"></a>Member <a class="el" href="group___data___dictionary.html#ga97a6db70d8b4bedd682115942e96b09e">tdc_open_view</a>  (THD *thd, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *table_list, const char *alias, const char *cache_key, uint cache_key_length, uint flags)</dt>
<dd>This function is needed for special handling of views under LOCK TABLES. We probably should get rid of it in long term. </dd>
<dt><a class="anchor" id="_todo000122"></a>Member <a class="el" href="group___query___optimizer.html#ga14a304484212b5489e8e995539493dd0">test_if_skip_sort_order</a>  (JOIN_TAB *tab, ORDER *order, ha_rows select_limit, const bool no_changes, const key_map *map, const char *clause_type)</dt>
<dd><ul>
<li>sergeyp: Results of all index merge selects actually are ordered by clustered PK values. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000089"></a>Member <a class="el" href="class_warning__info.html#aafc6f8bbd766711d7eaf266972dda165">Warning_info::opt_clear</a>  (ulonglong query_id)</dt>
<dd>: This is a sign of sloppy coding. Instead we need to designate one place in a statement life cycle where we call <a class="el" href="class_warning__info.html#acffa9ea0ca9bfe10a1046c9a3201aa36">Warning_info::clear()</a>. </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="group___binary___log.html#ga3d85906608487be3c3ee20ae8bb0f9e3">write_empty_groups_to_cache</a>  (THD *thd, <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *cache_data)</dt>
<dd>Move this function into the cache class? </dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="group___binary___log.html#gaa2545b9865ecf8c97d82d10e7ea857d1">write_one_empty_group_to_cache</a>  (THD *thd, <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *cache_data, <a class="el" href="struct_gtid.html">Gtid</a> gtid)</dt>
<dd>Move this function into the cache class?</dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

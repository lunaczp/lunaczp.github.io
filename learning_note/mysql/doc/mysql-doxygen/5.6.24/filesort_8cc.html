<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: sql/filesort.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_5bd71961b401a432086d0fb290a87f3f.html">sql</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">filesort.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sorts a database.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="sql__priv_8h_source.html">sql_priv.h</a>&quot;</code><br />
<code>#include &quot;filesort.h&quot;</code><br />
<code>#include &quot;unireg.h&quot;</code><br />
<code>#include &lt;m_ctype.h&gt;</code><br />
<code>#include &quot;sql_sort.h&quot;</code><br />
<code>#include &quot;probes_mysql.h&quot;</code><br />
<code>#include &quot;opt_range.h&quot;</code><br />
<code>#include &quot;bounded_queue.h&quot;</code><br />
<code>#include &quot;filesort_utils.h&quot;</code><br />
<code>#include &quot;<a class="el" href="sql__select_8h_source.html">sql_select.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="debug__sync_8h_source.html">debug_sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="opt__trace_8h_source.html">opt_trace.h</a>&quot;</code><br />
<code>#include &quot;sql_optimizer.h&quot;</code><br />
<code>#include &quot;sql_base.h&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a33b28daf02d239e17b4db5fe528e7623"><td class="memItemLeft" align="right" valign="top"><a id="a33b28daf02d239e17b4db5fe528e7623"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DBL_EXP_DIG</b>&#160;&#160;&#160;(sizeof(double)*8-DBL_MANT_DIG)</td></tr>
<tr class="separator:a33b28daf02d239e17b4db5fe528e7623"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae114f71faca21ece19b6ff87897486ad"><td class="memItemLeft" align="right" valign="top">static uchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#ae114f71faca21ece19b6ff87897486ad">read_buffpek_from_file</a> (<a class="el" href="structst__io__cache.html">IO_CACHE</a> *buffer_file, uint count, uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ae114f71faca21ece19b6ff87897486ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffd67ceec3537588a44009e780d9fa6"><td class="memItemLeft" align="right" valign="top">static ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a9ffd67ceec3537588a44009e780d9fa6">find_all_keys</a> (<a class="el" href="class_sort__param.html">Sort_param</a> *param, <a class="el" href="class_s_q_l___s_e_l_e_c_t.html">SQL_SELECT</a> *select, <a class="el" href="class_filesort__info.html">Filesort_info</a> *fs_info, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *buffer_file, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *tempfile, <a class="el" href="class_bounded__queue.html">Bounded_queue</a>&lt; uchar, uchar &gt; *pq, ha_rows *found_rows)</td></tr>
<tr class="separator:a9ffd67ceec3537588a44009e780d9fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770e104aff3bcac61b4928c65ea003fa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a770e104aff3bcac61b4928c65ea003fa">write_keys</a> (<a class="el" href="class_sort__param.html">Sort_param</a> *param, <a class="el" href="class_filesort__info.html">Filesort_info</a> *fs_info, uint count, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *buffer_file, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *tempfile)</td></tr>
<tr class="separator:a770e104aff3bcac61b4928c65ea003fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1373c36276e7352cb20de0f0b115470"><td class="memItemLeft" align="right" valign="top"><a id="ab1373c36276e7352cb20de0f0b115470"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>register_used_fields</b> (<a class="el" href="class_sort__param.html">Sort_param</a> *param)</td></tr>
<tr class="separator:ab1373c36276e7352cb20de0f0b115470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa057aea58ec00ad1f1f4b49d2e540ec7"><td class="memItemLeft" align="right" valign="top"><a id="aa057aea58ec00ad1f1f4b49d2e540ec7"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>merge_index</b> (<a class="el" href="class_sort__param.html">Sort_param</a> *param, uchar *sort_buffer, <a class="el" href="structst__buffpek.html">BUFFPEK</a> *buffpek, uint maxbuffer, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *tempfile, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *outfile)</td></tr>
<tr class="separator:aa057aea58ec00ad1f1f4b49d2e540ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eab5dedf8c40572eff58b61b644d166"><td class="memItemLeft" align="right" valign="top"><a id="a4eab5dedf8c40572eff58b61b644d166"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>save_index</b> (<a class="el" href="class_sort__param.html">Sort_param</a> *param, uint count, <a class="el" href="class_filesort__info.html">Filesort_info</a> *table_sort)</td></tr>
<tr class="separator:a4eab5dedf8c40572eff58b61b644d166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be55d3a4df274b922ed899ae5250dc4"><td class="memItemLeft" align="right" valign="top"><a id="a3be55d3a4df274b922ed899ae5250dc4"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>suffix_length</b> (ulong string_length)</td></tr>
<tr class="separator:a3be55d3a4df274b922ed899ae5250dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97da3c6958a95e1aa8d10e3721cdb786"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structst__sort__addon__field.html">SORT_ADDON_FIELD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a97da3c6958a95e1aa8d10e3721cdb786">get_addon_fields</a> (ulong max_length_for_sort_data, <a class="el" href="class_field.html">Field</a> **ptabfield, uint <a class="el" href="filesort_8cc.html#aee9ef85cf7266b0311b955d543c5c7ca">sortlength</a>, uint *plength)</td></tr>
<tr class="separator:a97da3c6958a95e1aa8d10e3721cdb786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a25ad9079af72180d1c48d4aa4a120"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a00a25ad9079af72180d1c48d4aa4a120">unpack_addon_fields</a> (struct <a class="el" href="structst__sort__addon__field.html">st_sort_addon_field</a> *addon_field, uchar *buff)</td></tr>
<tr class="separator:a00a25ad9079af72180d1c48d4aa4a120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f56645cb3c7199757d5e2581c9189"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a8e6f56645cb3c7199757d5e2581c9189">check_if_pq_applicable</a> (<a class="el" href="class_opt__trace__context.html">Opt_trace_context</a> *trace, <a class="el" href="class_sort__param.html">Sort_param</a> *param, <a class="el" href="class_filesort__info.html">Filesort_info</a> *info, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ha_rows records, ulong memory_available)</td></tr>
<tr class="separator:a8e6f56645cb3c7199757d5e2581c9189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d974061bb79f82d21e8608cdfac8b"><td class="memItemLeft" align="right" valign="top"><a id="a4c6d974061bb79f82d21e8608cdfac8b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>trace_filesort_information</b> (<a class="el" href="class_opt__trace__context.html">Opt_trace_context</a> *trace, const SORT_FIELD *sortorder, uint s_length)</td></tr>
<tr class="separator:a4c6d974061bb79f82d21e8608cdfac8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49e409cfaa25a9f5381ca371a2bf7e9"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#aa49e409cfaa25a9f5381ca371a2bf7e9">filesort</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="class_filesort.html">Filesort</a> *filesort, bool sort_positions, ha_rows *examined_rows, ha_rows *found_rows)</td></tr>
<tr class="separator:aa49e409cfaa25a9f5381ca371a2bf7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c16f18403365ecce656d4ac4b36bb47"><td class="memItemLeft" align="right" valign="top"><a id="a1c16f18403365ecce656d4ac4b36bb47"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>filesort_free_buffers</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, bool full)</td></tr>
<tr class="separator:a1c16f18403365ecce656d4ac4b36bb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd77004040983e42e5bf49ece1b236b"><td class="memItemLeft" align="right" valign="top"><a id="abfd77004040983e42e5bf49ece1b236b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>dbug_print_record</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, bool print_rowid)</td></tr>
<tr class="separator:abfd77004040983e42e5bf49ece1b236b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a468feece5a14884ba740b5164d62e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a14a468feece5a14884ba740b5164d62e">store_length</a> (uchar *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>, uint length, uint pack_length)</td></tr>
<tr class="separator:a14a468feece5a14884ba740b5164d62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bccc2cbf9a654f4a79c2b0e8f1cd2a"><td class="memItemLeft" align="right" valign="top"><a id="a03bccc2cbf9a654f4a79c2b0e8f1cd2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_native_longlong</b> (uchar *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>, int to_length, longlong val, bool is_unsigned)</td></tr>
<tr class="separator:a03bccc2cbf9a654f4a79c2b0e8f1cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa076b4c7728d69f242da234f6925de69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#aa076b4c7728d69f242da234f6925de69">make_sortkey</a> (<a class="el" href="class_sort__param.html">Sort_param</a> *param, uchar *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>, uchar *ref_pos)</td></tr>
<tr class="memdesc:aa076b4c7728d69f242da234f6925de69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declared here so we can unit test it.  <a href="#aa076b4c7728d69f242da234f6925de69">More...</a><br /></td></tr>
<tr class="separator:aa076b4c7728d69f242da234f6925de69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2563f03528f6a04002b65d06894ce6af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a2563f03528f6a04002b65d06894ce6af">merge_many_buff</a> (<a class="el" href="class_sort__param.html">Sort_param</a> *param, uchar *sort_buffer, <a class="el" href="structst__buffpek.html">BUFFPEK</a> *buffpek, uint *maxbuffer, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *t_file)</td></tr>
<tr class="separator:a2563f03528f6a04002b65d06894ce6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5c345a1e6aee816848c54085da17e7"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a3a5c345a1e6aee816848c54085da17e7">read_to_buffer</a> (<a class="el" href="structst__io__cache.html">IO_CACHE</a> *fromfile, <a class="el" href="structst__buffpek.html">BUFFPEK</a> *buffpek, uint rec_length)</td></tr>
<tr class="separator:a3a5c345a1e6aee816848c54085da17e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7a48f5cdb2b2251bd9056174ea6f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a2b7a48f5cdb2b2251bd9056174ea6f49">reuse_freed_buff</a> (<a class="el" href="structst__queue.html">QUEUE</a> *queue, <a class="el" href="structst__buffpek.html">BUFFPEK</a> *reuse, uint key_length)</td></tr>
<tr class="separator:a2b7a48f5cdb2b2251bd9056174ea6f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4c17524797303a41ab6c1ec2b99696"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#a2c4c17524797303a41ab6c1ec2b99696">merge_buffers</a> (<a class="el" href="class_sort__param.html">Sort_param</a> *param, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *from_file, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *to_file, uchar *sort_buffer, <a class="el" href="structst__buffpek.html">BUFFPEK</a> *lastbuff, <a class="el" href="structst__buffpek.html">BUFFPEK</a> *Fb, <a class="el" href="structst__buffpek.html">BUFFPEK</a> *Tb, int flag)</td></tr>
<tr class="separator:a2c4c17524797303a41ab6c1ec2b99696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9ef85cf7266b0311b955d543c5c7ca"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="filesort_8cc.html#aee9ef85cf7266b0311b955d543c5c7ca">sortlength</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, SORT_FIELD *sortorder, uint s_length, bool *multi_byte_charset)</td></tr>
<tr class="memdesc:aee9ef85cf7266b0311b955d543c5c7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declared here so we can unit test it.  <a href="#aee9ef85cf7266b0311b955d543c5c7ca">More...</a><br /></td></tr>
<tr class="separator:aee9ef85cf7266b0311b955d543c5c7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb1b25a65dbec9e84d8e50a44a28d9e"><td class="memItemLeft" align="right" valign="top"><a id="a7cb1b25a65dbec9e84d8e50a44a28d9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>change_double_for_sort</b> (double nr, uchar *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>)</td></tr>
<tr class="separator:a7cb1b25a65dbec9e84d8e50a44a28d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad0ae996e21449739b6c47071a9d58042"><td class="memItemLeft" align="right" valign="top"><a id="ad0ae996e21449739b6c47071a9d58042"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>Is_big_endian</b> = false</td></tr>
<tr class="separator:ad0ae996e21449739b6c47071a9d58042"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Sorts a database. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8e6f56645cb3c7199757d5e2581c9189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6f56645cb3c7199757d5e2581c9189">&#9670;&nbsp;</a></span>check_if_pq_applicable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool check_if_pq_applicable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_opt__trace__context.html">Opt_trace_context</a> *&#160;</td>
          <td class="paramname"><em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sort__param.html">Sort_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_filesort__info.html">Filesort_info</a> *&#160;</td>
          <td class="paramname"><em>filesort_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>memory_available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether priority queue is worth using to get top elements of an ordered result set. If it is, then allocates buffer for required amount of records</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>Current trace context. </td></tr>
    <tr><td class="paramname">param</td><td>Sort parameters. </td></tr>
    <tr><td class="paramname">filesort_info</td><td><a class="el" href="class_filesort.html">Filesort</a> information. </td></tr>
    <tr><td class="paramname">table</td><td>Table to sort. </td></tr>
    <tr><td class="paramname">num_rows</td><td>Estimate of number of rows in source record set. </td></tr>
    <tr><td class="paramname">memory_available</td><td>Memory available for sorting.</td></tr>
  </table>
  </dd>
</dl>
<p>DESCRIPTION Given a query like this: SELECT ... FROM t ORDER BY a1,...,an LIMIT max_rows; This function tests whether a priority queue should be used to keep the result. Necessary conditions are:</p><ul>
<li>estimate that it is actually cheaper than merge-sort</li>
<li>enough memory to store the &lt;max_rows&gt; records.</li>
</ul>
<p>If we don't have space for &lt;max_rows&gt; records, but we <em>do</em> have space for &lt;max_rows&gt; keys, we may rewrite 'table' to sort with references to records instead of additional data. (again, based on estimates that it will actually be cheaper).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- if it's ok to use PQ false - PQ will be slower than merge-sort, or there is not enough memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa49e409cfaa25a9f5381ca371a2bf7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49e409cfaa25a9f5381ca371a2bf7e9">&#9670;&nbsp;</a></span>filesort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows filesort </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_filesort.html">Filesort</a> *&#160;</td>
          <td class="paramname"><em>filesort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows *&#160;</td>
          <td class="paramname"><em>examined_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows *&#160;</td>
          <td class="paramname"><em>found_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort a table. Creates a set of pointers that can be used to read the rows in sorted order. This should be done with the functions in <a class="el" href="records_8cc.html" title="Functions for easy reading of records, possible through a cache. ">records.cc</a>.</p>
<p>Before calling filesort, one must have done table-&gt;file-&gt;info(HA_STATUS_VARIABLE)</p>
<p>The result set is stored in table-&gt;io_cache or table-&gt;record_pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Current thread </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table to sort </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filesort</td><td>How to sort the table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sort_positions</td><td>Set to TRUE if we want to force sorting by position (Needed by UPDATE/INSERT or ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> or when rowids are required by executor) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">examined_rows</td><td>Store number of examined rows here This is the number of found rows before applying WHERE condition. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found_rows</td><td>Store the number of found rows here. This is the number of found rows after applying WHERE condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If we sort by position (like if sort_positions is 1) <a class="el" href="filesort_8cc.html#aa49e409cfaa25a9f5381ca371a2bf7e9">filesort()</a> will call table-&gt;prepare_for_position().</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_POS_ERROR</td><td>Error </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ffd67ceec3537588a44009e780d9fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffd67ceec3537588a44009e780d9fa6">&#9670;&nbsp;</a></span>find_all_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ha_rows find_all_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sort__param.html">Sort_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_q_l___s_e_l_e_c_t.html">SQL_SELECT</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_filesort__info.html">Filesort_info</a> *&#160;</td>
          <td class="paramname"><em>fs_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>buffpek_pointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>tempfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounded__queue.html">Bounded_queue</a>&lt; uchar, uchar &gt; *&#160;</td>
          <td class="paramname"><em>pq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows *&#160;</td>
          <td class="paramname"><em>found_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search after sort_keys, and write them into tempfile (if we run out of space in the sort_keys buffer). All produced sequences are guaranteed to be non-empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">param</td><td>Sorting parameter </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select</td><td>Use this to get source data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sort_keys</td><td>Array of pointers to sort key + addon buffers. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffpek_pointers</td><td>File to write BUFFPEKs describing sorted segments in tempfile. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tempfile</td><td>File to write sorted sequences of sortkeys to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pq</td><td>If !NULL, use it for keeping top N elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found_rows</td><td>The number of FOUND_ROWS(). For a query with LIMIT, this value will typically be larger than the function return value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Basic idea: <pre class="fragment">   while (get_next_sortkey())
   {
     if (using priority queue)
       push sort key into queue
     else
     {
       if (no free space in sort_keys buffers)
       {
         sort sort_keys buffer;
         dump sorted sequence to 'tempfile';
         dump BUFFPEK describing sequence location into 'buffpek_pointers';
       }
       put sort key into 'sort_keys';
     }
   }
   if (sort_keys has some elements &amp;&amp; dumped at least once)
     sort-dump-dump as above;
   else
     don't sort, leave sort_keys array to be sorted by caller.
</pre></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Number</td><td>of records written on success. </td></tr>
    <tr><td class="paramname">HA_POS_ERROR</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97da3c6958a95e1aa8d10e3721cdb786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97da3c6958a95e1aa8d10e3721cdb786">&#9670;&nbsp;</a></span>get_addon_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structst__sort__addon__field.html">SORT_ADDON_FIELD</a> * get_addon_fields </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>max_length_for_sort_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> **&#160;</td>
          <td class="paramname"><em>ptabfield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>sortlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>plength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get descriptors of fields appended to sorted fields and calculate its total length.</p>
<p>The function first finds out what fields are used in the result set. Then it calculates the length of the buffer to store the values of these fields together with the value of sort values. If the calculated length is not greater than max_length_for_sort_data the function allocates memory for an array of descriptors containing layouts for the values of the non-sorted fields in the buffer and fills them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Current thread </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ptabfield</td><td>Array of references to the table fields </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sortlength</td><td>Total length of sorted fields </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plength</td><td>Total length of appended fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The null bits for the appended values are supposed to be put together and stored the buffer just ahead of the value of the first field.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the layout descriptors for the appended fields, if any </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if we do not store field values with sort data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa076b4c7728d69f242da234f6925de69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa076b4c7728d69f242da234f6925de69">&#9670;&nbsp;</a></span>make_sortkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make_sortkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sort__param.html">Sort_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>ref_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declared here so we can unit test it. </p>
<p>Make a sort-key from record. </p>

</div>
</div>
<a id="a2c4c17524797303a41ab6c1ec2b99696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4c17524797303a41ab6c1ec2b99696">&#9670;&nbsp;</a></span>merge_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int merge_buffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sort__param.html">Sort_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>from_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>to_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>sort_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__buffpek.html">BUFFPEK</a> *&#160;</td>
          <td class="paramname"><em>lastbuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__buffpek.html">BUFFPEK</a> *&#160;</td>
          <td class="paramname"><em>Fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__buffpek.html">BUFFPEK</a> *&#160;</td>
          <td class="paramname"><em>Tb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge buffers to one buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Sort parameter </td></tr>
    <tr><td class="paramname">from_file</td><td>File with source data (BUFFPEKs point to this file) </td></tr>
    <tr><td class="paramname">to_file</td><td>File to write the sorted result data. </td></tr>
    <tr><td class="paramname">sort_buffer</td><td>Buffer for data to store up to MERGEBUFF2 sort keys. </td></tr>
    <tr><td class="paramname">lastbuff</td><td>OUT Store here BUFFPEK describing data written to to_file </td></tr>
    <tr><td class="paramname">Fb</td><td>First element in source BUFFPEKs array </td></tr>
    <tr><td class="paramname">Tb</td><td>Last element in source BUFFPEKs array </td></tr>
    <tr><td class="paramname">flag</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">other</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2563f03528f6a04002b65d06894ce6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2563f03528f6a04002b65d06894ce6af">&#9670;&nbsp;</a></span>merge_many_buff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int merge_many_buff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sort__param.html">Sort_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>sort_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__buffpek.html">BUFFPEK</a> *&#160;</td>
          <td class="paramname"><em>buffpek</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>maxbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>t_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge buffers to make &lt; MERGEBUFF2 buffers. </p>

</div>
</div>
<a id="ae114f71faca21ece19b6ff87897486ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae114f71faca21ece19b6ff87897486ad">&#9670;&nbsp;</a></span>read_buffpek_from_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uchar * read_buffpek_from_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>buffpek_pointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes an array of string pointers for info-&gt;sort_keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td><a class="el" href="class_filesort__info.html">Filesort_info</a> struct owning the allocated array. </td></tr>
    <tr><td class="paramname">num_records</td><td>Number of records. </td></tr>
    <tr><td class="paramname">length</td><td>Length of each record.Read 'count' number of buffer pointers into memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a5c345a1e6aee816848c54085da17e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5c345a1e6aee816848c54085da17e7">&#9670;&nbsp;</a></span>read_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint read_to_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>fromfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__buffpek.html">BUFFPEK</a> *&#160;</td>
          <td class="paramname"><em>buffpek</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>rec_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data to buffer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">(uint)-1</td><td>if something goes wrong </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b7a48f5cdb2b2251bd9056174ea6f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7a48f5cdb2b2251bd9056174ea6f49">&#9670;&nbsp;</a></span>reuse_freed_buff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reuse_freed_buff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__queue.html">QUEUE</a> *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__buffpek.html">BUFFPEK</a> *&#160;</td>
          <td class="paramname"><em>reuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Put all room used by freed buffer to use in adjacent buffer.</p>
<p>Note, that we can't simply distribute memory evenly between all buffers, because new areas must not overlap with old ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>list of non-empty buffers, without freed buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reuse</td><td>empty buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_length</td><td>key length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee9ef85cf7266b0311b955d543c5c7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9ef85cf7266b0311b955d543c5c7ca">&#9670;&nbsp;</a></span>sortlength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint sortlength </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SORT_FIELD *&#160;</td>
          <td class="paramname"><em>sortorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>s_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>multi_byte_charset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declared here so we can unit test it. </p>
<p>Calculate length of sort key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sortorder</td><td>Order of items to sort </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">s_length</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">multi_byte_charset</td><td>Set to 1 if we are using multi-byte charset (In which case we have to use strxnfrm())</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>sortorder-&gt;length is updated for each sort item. <br />
 sortorder-&gt;need_strxnfrm is set 1 if we have to use strxnfrm</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Total length of sort buffer in bytes </dd></dl>

</div>
</div>
<a id="a14a468feece5a14884ba740b5164d62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a468feece5a14884ba740b5164d62e">&#9670;&nbsp;</a></span>store_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void store_length </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pack_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store length as suffix in high-byte-first order. </p>

</div>
</div>
<a id="a00a25ad9079af72180d1c48d4aa4a120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a25ad9079af72180d1c48d4aa4a120">&#9670;&nbsp;</a></span>unpack_addon_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void unpack_addon_fields </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structst__sort__addon__field.html">st_sort_addon_field</a> *&#160;</td>
          <td class="paramname"><em>addon_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy (unpack) values appended to sorted fields from a buffer back to their regular positions specified by the Field::ptr pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addon_field</td><td>Array of descriptors for appended fields </td></tr>
    <tr><td class="paramname">buff</td><td>Buffer which to unpack the value from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function is supposed to be used only as a callback function when getting field values for the sorted result set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void. </dd></dl>

</div>
</div>
<a id="a770e104aff3bcac61b4928c65ea003fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770e104aff3bcac61b4928c65ea003fa">&#9670;&nbsp;</a></span>write_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int write_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sort__param.html">Sort_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_filesort__info.html">Filesort_info</a> *&#160;</td>
          <td class="paramname"><em>fs_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>buffpek_pointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>tempfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sort the buffer and write:</p><ol type="1">
<li>the sorted sequence to tempfile</li>
<li><p class="startli">a BUFFPEK describing the sorted sequence position to buffpek_pointers</p>
<p class="startli">(was: Skriver en buffert med nycklar till filen)</p>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Sort parameters </td></tr>
    <tr><td class="paramname">sort_keys</td><td>Array of pointers to keys to sort </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements in sort_keys array </td></tr>
    <tr><td class="paramname">buffpek_pointers</td><td>One 'BUFFPEK' struct will be written into this file. The BUFFPEK::{file_pos, count} will indicate where the sorted data was stored. </td></tr>
    <tr><td class="paramname">tempfile</td><td>The sorted sequence will be written into this file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

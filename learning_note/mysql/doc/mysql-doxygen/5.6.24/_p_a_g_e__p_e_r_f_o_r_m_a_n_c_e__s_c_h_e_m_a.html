<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: The Performance Schema main page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The Performance Schema main page </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>MySQL PERFORMANCE_SCHEMA implementation.</p>
<h1><a class="anchor" id="INTRO"></a>
Introduction</h1>
<p>The PERFORMANCE_SCHEMA is a way to introspect the internal execution of the server at runtime. The performance schema focuses primarily on performance data, as opposed to the INFORMATION_SCHEMA whose purpose is to inspect metadata.</p>
<p>From a user point of view, the performance schema consists of:</p><ul>
<li>a dedicated database schema, named PERFORMANCE_SCHEMA,</li>
<li>SQL tables, used to query the server internal state or change configuration settings.</li>
</ul>
<p>From an implementation point of view, the performance schema is a dedicated Storage Engine which exposes data collected by 'Instrumentation Points' placed in the server code.</p>
<h1><a class="anchor" id="INTERFACES"></a>
Multiple interfaces</h1>
<p>The performance schema exposes many different interfaces, for different components, and for different purposes.</p>
<h2><a class="anchor" id="INT_INSTRUMENTING"></a>
Instrumenting interface</h2>
<p>All the data representing the server internal state exposed in the performance schema must be first collected: this is the role of the instrumenting interface. The instrumenting interface is a coding interface provided by implementors (of the performance schema) to implementors (of the server or server components).</p>
<p>This interface is available to:</p><ul>
<li>C implementations</li>
<li>C++ implementations</li>
<li>the core SQL layer (/sql)</li>
<li>the mysys library (/mysys)</li>
<li>MySQL plugins, including storage engines,</li>
<li>third party plugins, including third party storage engines.</li>
</ul>
<p>For details, see the <a class="el" href="_p_a_g_e__i_n_s_t_r_u_m_e_n_t_a_t_i_o_n__i_n_t_e_r_f_a_c_e.html">instrumentation interface page</a>.</p>
<h2><a class="anchor" id="INT_COMPILING"></a>
Compiling interface</h2>
<p>The implementation of the performance schema can be enabled or disabled at build time, when building MySQL from the source code.</p>
<p>When building with the performance schema code, some compilation flags are available to change the default values used in the code, if required.</p>
<p>For more details, see: </p><pre class="fragment">./configure --help </pre><p>To compile with the performance schema: </p><pre class="fragment">./configure --with-perfschema </pre><p>The implementation of all the compiling options is located in </p><pre class="fragment">./storage/perfschema/plug.in </pre><h2><a class="anchor" id="INT_STARTUP"></a>
Server startup interface</h2>
<p>The server startup interface consists of the "./mysqld ..." command line used to start the server. When the performance schema is compiled in the server binary, extra command line options are available.</p>
<p>These extra start options allow the DBA to:</p><ul>
<li>enable or disable the performance schema</li>
<li>specify some sizing parameters.</li>
</ul>
<p>To see help for the performance schema startup options, see: </p><pre class="fragment">./sql/mysqld --verbose --help  </pre><p>The implementation of all the startup options is located in </p><pre class="fragment">./sql/mysqld.cc, my_long_options[] </pre><h2><a class="anchor" id="INT_BOOTSTRAP"></a>
Server bootstrap interface</h2>
<p>The bootstrap interface is a private interface exposed by the performance schema, and used by the SQL layer. Its role is to advertise all the SQL tables natively supported by the performance schema to the SQL server. The code consists of creating MySQL tables for the performance schema itself, and is used in './mysql &ndash;bootstrap' mode when a server is installed.</p>
<p>The implementation of the database creation script is located in </p><pre class="fragment">./scripts/mysql_system_tables.sql </pre><h2><a class="anchor" id="INT_CONFIG"></a>
Runtime configuration interface</h2>
<p>When the performance schema is used at runtime, various configuration parameters can be used to specify what kind of data is collected, what kind of aggregations are computed, what kind of timers are used, what events are timed, etc.</p>
<p>For all these capabilities, not a single statement or special syntax was introduced in the parser. Instead of new SQL statements, the interface consists of DML (SELECT, INSERT, UPDATE, DELETE) against special "SETUP" tables.</p>
<p>For example: </p><pre class="fragment">mysql&gt; update performance_schema.SETUP_INSTRUMENTS
  set ENABLED='YES', TIMED='YES';
Query OK, 234 rows affected (0.00 sec)
Rows matched: 234  Changed: 234  Warnings: 0 </pre><h2><a class="anchor" id="INT_STATUS"></a>
Internal audit interface</h2>
<p>The internal audit interface is provided to the DBA to inspect if the performance schema code itself is functioning properly. This interface is necessary because a failure caused while instrumenting code in the server should not cause failures in the MySQL server itself, so that the performance schema implementation never raises errors during runtime execution.</p>
<p>This auditing interface consists of: </p><pre class="fragment">SHOW ENGINE PERFORMANCE_SCHEMA STATUS; </pre><p> It displays data related to the memory usage of the performance schema, as well as statistics about lost events, if any.</p>
<p>The SHOW STATUS command is implemented in </p><pre class="fragment">./storage/perfschema/pfs_engine_table.cc </pre><h2><a class="anchor" id="INT_QUERY"></a>
Query interface</h2>
<p>The query interface is used to query the internal state of a running server. It is provided as SQL tables.</p>
<p>For example: </p><pre class="fragment">mysql&gt; select * from performance_schema.EVENTS_WAITS_CURRENT;
</pre><h1><a class="anchor" id="DESIGN_PRINCIPLES"></a>
Design principles</h1>
<h2><a class="anchor" id="PRINCIPLE_BEHAVIOR"></a>
No behavior changes</h2>
<p>The primary goal of the performance schema is to measure (instrument) the execution of the server. A good measure should not cause any change in behavior.</p>
<p>To achieve this, the overall design of the performance schema complies with the following very severe design constraints:</p>
<p>The parser is unchanged. There are no new keywords, no new statements. This guarantees that existing applications will run the same way with or without the performance schema.</p>
<p>All the instrumentation points return "void", there are no error codes. Even if the performance schema internally fails, execution of the server code will proceed.</p>
<p>None of the instrumentation points allocate memory. All the memory used by the performance schema is pre-allocated at startup, and is considered "static" during the server life time.</p>
<p>None of the instrumentation points use any pthread_mutex, pthread_rwlock, or pthread_cond (or platform equivalents). Executing the instrumentation point should not cause thread scheduling to change in the server.</p>
<p>In other words, the implementation of the instrumentation points, including all the code called by the instrumentation points, is:</p><ul>
<li>malloc free</li>
<li>mutex free</li>
<li>rwlock free</li>
</ul>
<p>TODO: All the code located in storage/perfschema is malloc free, but unfortunately the usage of <a class="el" href="struct_l_f___h_a_s_h.html">LF_HASH</a> introduces some memory allocation. This should be revised if possible, to use a lock-free, malloc-free hash code table.</p>
<h2><a class="anchor" id="PRINCIPLE_PERFORMANCE"></a>
No performance hit</h2>
<p>The instrumentation of the server should be as fast as possible. In cases when there are choices between:</p><ul>
<li>doing some processing when recording the performance data in the instrumentation,</li>
<li>doing some processing when retrieving the performance data,</li>
</ul>
<p>priority is given in the design to make the instrumentation faster, pushing some complexity to data retrieval.</p>
<p>As a result, some parts of the design, related to:</p><ul>
<li>the setup code path,</li>
<li>the query code path,</li>
</ul>
<p>might appear to be sub-optimal.</p>
<p>The criterion used here is to optimize primarily the critical path (data collection), possibly at the expense of non-critical code paths.</p>
<h2><a class="anchor" id="PRINCIPLE_NOT_INTRUSIVE"></a>
Unintrusive instrumentation</h2>
<p>For the performance schema in general to be successful, the barrier of entry for a developer should be low, so it's easy to instrument code.</p>
<p>In particular, the instrumentation interface:</p><ul>
<li>is available for C and C++ code (so it's a C interface),</li>
<li>does not require parameters that the calling code can't easily provide,</li>
<li>supports partial instrumentation (for example, instrumenting mutexes does not require that every mutex is instrumented)</li>
</ul>
<h2><a class="anchor" id="PRINCIPLE_EXTENDABLE"></a>
Extendable instrumentation</h2>
<p>As the content of the performance schema improves, with more tables exposed and more data collected, the instrumentation interface will also be augmented to support instrumenting new concepts. Existing instrumentations should not be affected when additional instrumentation is made available, and making a new instrumentation available should not require existing instrumented code to support it.</p>
<h2><a class="anchor" id="PRINCIPLE_VERSIONED"></a>
Versioned instrumentation</h2>
<p>Given that the instrumentation offered by the performance schema will be augmented with time, when more features are implemented, the interface itself should be versioned, to keep compatibility with previous instrumented code.</p>
<p>For example, after both plugin-A and plugin-B have been instrumented for mutexes, read write locks and conditions, using the instrumentation interface, we can anticipate that the instrumentation interface is expanded to support file based operations.</p>
<p>Plugin-A, a file based storage engine, will most likely use the expanded interface and instrument its file usage, using the version 2 interface, while Plugin-B, a network based storage engine, will not change its code and not release a new binary.</p>
<p>When later the instrumentation interface is expanded to support network based operations (which will define interface version 3), the Plugin-B code can then be changed to make use of it.</p>
<p>Note, this is just an example to illustrate the design concept here. Both mutexes and file instrumentation are already available since version 1 of the instrumentation interface.</p>
<h2><a class="anchor" id="PRINCIPLE_DEPLOYMENT"></a>
Easy deployment</h2>
<p>Internally, we might want every plugin implementation to upgrade the instrumented code to the latest available, but this will cause additional work and this is not practical if the code change is monolithic.</p>
<p>Externally, for third party plugin implementors, asking implementors to always stay aligned to the latest instrumentation and make new releases, even when the change does not provide new functionality for them, is a bad idea.</p>
<p>For example, requiring a network based engine to re-release because the instrumentation interface changed for file based operations, will create too many deployment issues.</p>
<p>So, the performance schema implementation must support concurrently, in the same deployment, multiple versions of the instrumentation interface, and ensure binary compatibility with each version.</p>
<p>In addition to this, the performance schema can be included or excluded from the server binary, using build time configuration options.</p>
<p>Regardless, the following types of deployment are valid:</p><ul>
<li>a server supporting the performance schema + a storage engine that is not instrumented</li>
<li>a server not supporting the performance schema + a storage engine that is instrumented </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

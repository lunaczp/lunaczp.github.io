<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/trx/trx0i_s.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_7d6b8692e14baa729600e27a3e4f8b7c.html">trx</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">trx0i_s.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &lt;mysql/plugin.h&gt;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha0storage_8h_source.html">ha0storage.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0iter_8h_source.html">lock0iter.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0rec_8h_source.html">rem0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0row_8h_source.html">row0row.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0rw_8h_source.html">sync0rw.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0types_8h_source.html">sync0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0i__s_8h_source.html">trx0i_s.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0sys_8h_source.html">trx0sys.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0ut_8h_source.html">ut0ut.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi__s__mem__chunk__t.html">i_s_mem_chunk_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a01f0f3f3d1bf9116a90f06be4a55c646"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a01f0f3f3d1bf9116a90f06be4a55c646">TABLE_CACHE_INITIAL_ROWSNUM</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a01f0f3f3d1bf9116a90f06be4a55c646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0cca06ba6aeaeb82876fd21a0331f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aee0cca06ba6aeaeb82876fd21a0331f4">MEM_CHUNKS_IN_TABLE_CACHE</a>&#160;&#160;&#160;39</td></tr>
<tr class="memdesc:aee0cca06ba6aeaeb82876fd21a0331f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of chunks to allocate for a table cache.  <a href="#aee0cca06ba6aeaeb82876fd21a0331f4">More...</a><br /></td></tr>
<tr class="separator:aee0cca06ba6aeaeb82876fd21a0331f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36763bce6a91af48841bee6df67ef7d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a36763bce6a91af48841bee6df67ef7d6">MAX_ALLOWED_FOR_STORAGE</a>(cache)</td></tr>
<tr class="separator:a36763bce6a91af48841bee6df67ef7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99e0c0334d3e63e23d35f654079ccb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ac99e0c0334d3e63e23d35f654079ccb4">MAX_ALLOWED_FOR_ALLOC</a>(cache)</td></tr>
<tr class="separator:ac99e0c0334d3e63e23d35f654079ccb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b57e256193b9d5aced6f200585d82a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a5b57e256193b9d5aced6f200585d82a2">LOCKS_HASH_CELLS_NUM</a>&#160;&#160;&#160;10000</td></tr>
<tr class="separator:a5b57e256193b9d5aced6f200585d82a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa858fa143a71f61e3096fe65a429a0fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aa858fa143a71f61e3096fe65a429a0fe">CACHE_STORAGE_INITIAL_SIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:aa858fa143a71f61e3096fe65a429a0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b3957e13b039b02e104799cdf71292"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a52b3957e13b039b02e104799cdf71292">CACHE_STORAGE_HASH_CELLS</a>&#160;&#160;&#160;2048</td></tr>
<tr class="separator:a52b3957e13b039b02e104799cdf71292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c06168ee6b384103efe5ef9968a4e15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a2c06168ee6b384103efe5ef9968a4e15">CACHE_MIN_IDLE_TIME_US</a>&#160;&#160;&#160;100000 /* 0.1 sec */</td></tr>
<tr class="separator:a2c06168ee6b384103efe5ef9968a4e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae6eaaebecf6b68bdbafcff69320d95f5"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ae6eaaebecf6b68bdbafcff69320d95f5">wait_lock_get_heap_no</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ae6eaaebecf6b68bdbafcff69320d95f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf61aa32949295fdd25b9d69964f83d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a0cf61aa32949295fdd25b9d69964f83d">table_cache_init</a> (<a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *table_cache, size_t row_size)</td></tr>
<tr class="separator:a0cf61aa32949295fdd25b9d69964f83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692c274041f49e80c3e170b240ab30cf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a692c274041f49e80c3e170b240ab30cf">table_cache_free</a> (<a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *table_cache)</td></tr>
<tr class="separator:a692c274041f49e80c3e170b240ab30cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1d6a8d0d3e571fcfc7c405b2458cb8"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a7a1d6a8d0d3e571fcfc7c405b2458cb8">table_cache_create_empty_row</a> (<a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *table_cache, <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a7a1d6a8d0d3e571fcfc7c405b2458cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e1b41c44dd1f948c6475758192de28"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ab2e1b41c44dd1f948c6475758192de28">fill_trx_row</a> (<a class="el" href="structi__s__trx__row__t.html">i_s_trx_row_t</a> *<a class="el" href="row0log_8cc.html#ad42e2d1ad172100a2cd1338656cf0425">row</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *requested_lock_row, <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:ab2e1b41c44dd1f948c6475758192de28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea746ef8e0aa961a089254b7b83d65b9"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aea746ef8e0aa961a089254b7b83d65b9">put_nth_field</a> (char *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0merge_8cc.html#a4454283b5709de09b07c6d13c63c3927">buf_size</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:aea746ef8e0aa961a089254b7b83d65b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dde11fc97ca3c1462f443cddd3b186"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a37dde11fc97ca3c1462f443cddd3b186">fill_lock_data</a> (const char **lock_data, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no, <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a37dde11fc97ca3c1462f443cddd3b186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bc57517404e484f5daee0b044dfc0b"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ac5bc57517404e484f5daee0b044dfc0b">fill_locks_row</a> (<a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *<a class="el" href="row0log_8cc.html#ad42e2d1ad172100a2cd1338656cf0425">row</a>, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no, <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:ac5bc57517404e484f5daee0b044dfc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf0a9c1fbfb882a623b7bb9da194082"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structi__s__lock__waits__row__t.html">i_s_lock_waits_row_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#acdf0a9c1fbfb882a623b7bb9da194082">fill_lock_waits_row</a> (<a class="el" href="structi__s__lock__waits__row__t.html">i_s_lock_waits_row_t</a> *<a class="el" href="row0log_8cc.html#ad42e2d1ad172100a2cd1338656cf0425">row</a>, const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *requested_lock_row, const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *blocking_lock_row)</td></tr>
<tr class="separator:acdf0a9c1fbfb882a623b7bb9da194082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae850561d98192693cd4061393372ceaa"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ae850561d98192693cd4061393372ceaa">fold_lock</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="separator:ae850561d98192693cd4061393372ceaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968cb44ac25300f07654fe9867b6ff79"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a968cb44ac25300f07654fe9867b6ff79">locks_row_eq_lock</a> (const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *<a class="el" href="row0log_8cc.html#ad42e2d1ad172100a2cd1338656cf0425">row</a>, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="separator:a968cb44ac25300f07654fe9867b6ff79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cfd7901d4c5680423c0daf1b981dd0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a07cfd7901d4c5680423c0daf1b981dd0">search_innodb_locks</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="separator:a07cfd7901d4c5680423c0daf1b981dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf7fe2d991779bb79eb9bf85e307bd2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aadf7fe2d991779bb79eb9bf85e307bd2">add_lock_to_cache</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="separator:aadf7fe2d991779bb79eb9bf85e307bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90ac303a1d34193825ef57a71c72fd2"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ae90ac303a1d34193825ef57a71c72fd2">add_lock_wait_to_cache</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *requested_lock_row, const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *blocking_lock_row)</td></tr>
<tr class="separator:ae90ac303a1d34193825ef57a71c72fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fe829b4dd47e1cf2e897769c0482e6"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a80fe829b4dd47e1cf2e897769c0482e6">add_trx_relevant_locks_to_cache</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> **requested_lock_row)</td></tr>
<tr class="separator:a80fe829b4dd47e1cf2e897769c0482e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ebecc6d9f2669b9384f6f256fe1478"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a94ebecc6d9f2669b9384f6f256fe1478">can_cache_be_updated</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a94ebecc6d9f2669b9384f6f256fe1478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b73d6eb69e73c6558f8ee97e21e097d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a6b73d6eb69e73c6558f8ee97e21e097d">trx_i_s_cache_clear</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a6b73d6eb69e73c6558f8ee97e21e097d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fc53aaeadb3e3cc6cfafc9bd3586e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a76fc53aaeadb3e3cc6cfafc9bd3586e5">fetch_data_into_cache_low</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, ibool only_ac_nl, trx_list_t *trx_list)</td></tr>
<tr class="separator:a76fc53aaeadb3e3cc6cfafc9bd3586e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c73dfc1d549e29a263af5e11909bdf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a93c73dfc1d549e29a263af5e11909bdf">fetch_data_into_cache</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a93c73dfc1d549e29a263af5e11909bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1630cdc1f5268e69c45ce54b9d89950b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a1630cdc1f5268e69c45ce54b9d89950b">trx_i_s_possibly_fetch_data_into_cache</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a1630cdc1f5268e69c45ce54b9d89950b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc20b3ba22ba224ba5224a595edd9cb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a8cc20b3ba22ba224ba5224a595edd9cb">trx_i_s_cache_is_truncated</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a8cc20b3ba22ba224ba5224a595edd9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd3e1ba86fdc2cc24166e8104d3e821"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#abbd3e1ba86fdc2cc24166e8104d3e821">trx_i_s_cache_init</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:abbd3e1ba86fdc2cc24166e8104d3e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0f496c35385e46418b0b9d72c98884"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a8a0f496c35385e46418b0b9d72c98884">trx_i_s_cache_free</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a8a0f496c35385e46418b0b9d72c98884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4684a66f93bc0d4f2c402bdd81c20788"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a4684a66f93bc0d4f2c402bdd81c20788">trx_i_s_cache_start_read</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a4684a66f93bc0d4f2c402bdd81c20788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48357e2a54ac29ebcf53242d18822f1a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a48357e2a54ac29ebcf53242d18822f1a">trx_i_s_cache_end_read</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a48357e2a54ac29ebcf53242d18822f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6d77c6f2ea6ffdda2f779d7e7b21f1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a2e6d77c6f2ea6ffdda2f779d7e7b21f1">trx_i_s_cache_start_write</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a2e6d77c6f2ea6ffdda2f779d7e7b21f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884ff76fcec6dbfd070d3324809df7b8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a884ff76fcec6dbfd070d3324809df7b8">trx_i_s_cache_end_write</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache)</td></tr>
<tr class="separator:a884ff76fcec6dbfd070d3324809df7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117cfd2ddf19d1f50f8e7593e712a048"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#a117cfd2ddf19d1f50f8e7593e712a048">cache_select_table</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a> <a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a117cfd2ddf19d1f50f8e7593e712a048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf415a479c5343d86a46aea8c42577a5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#acf415a479c5343d86a46aea8c42577a5">trx_i_s_cache_get_rows_used</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a> <a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:acf415a479c5343d86a46aea8c42577a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced2b6642b7cdbe0b4a8718676f89ab8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#aced2b6642b7cdbe0b4a8718676f89ab8">trx_i_s_cache_get_nth_row</a> (<a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *cache, enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a> <a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:aced2b6642b7cdbe0b4a8718676f89ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade85acfa41299e10e4d0633c708935e6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#ade85acfa41299e10e4d0633c708935e6">trx_i_s_create_lock_id</a> (const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *<a class="el" href="row0log_8cc.html#ad42e2d1ad172100a2cd1338656cf0425">row</a>, char *lock_id, ulint lock_id_size)</td></tr>
<tr class="separator:ade85acfa41299e10e4d0633c708935e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:addf3c2fcb0413ec13456ef23a7ceb374"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#addf3c2fcb0413ec13456ef23a7ceb374">trx_i_s_cache_static</a></td></tr>
<tr class="separator:addf3c2fcb0413ec13456ef23a7ceb374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af642f64c1e8d6a0501d2ba654541de3e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="trx0i__s_8cc.html#af642f64c1e8d6a0501d2ba654541de3e">trx_i_s_cache</a> = &amp;<a class="el" href="trx0i__s_8cc.html#addf3c2fcb0413ec13456ef23a7ceb374">trx_i_s_cache_static</a></td></tr>
<tr class="separator:af642f64c1e8d6a0501d2ba654541de3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>INFORMATION SCHEMA innodb_trx, innodb_locks and innodb_lock_waits tables fetch code.</p>
<p>The code below fetches information needed to fill those 3 dynamic tables and uploads it into a "transactions
table cache" for later retrieval.</p>
<p>Created July 17, 2007 Vasil Dimov </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2c06168ee6b384103efe5ef9968a4e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c06168ee6b384103efe5ef9968a4e15">&#9670;&nbsp;</a></span>CACHE_MIN_IDLE_TIME_US</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_MIN_IDLE_TIME_US&#160;&#160;&#160;100000 /* 0.1 sec */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The minimum time that a cache must not be updated after it has been read for the last time; measured in microseconds. We use this technique to ensure that SELECTs which join several INFORMATION SCHEMA tables read the same version of the cache. </p>

</div>
</div>
<a id="a52b3957e13b039b02e104799cdf71292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b3957e13b039b02e104799cdf71292">&#9670;&nbsp;</a></span>CACHE_STORAGE_HASH_CELLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_STORAGE_HASH_CELLS&#160;&#160;&#160;2048</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of hash cells in the cache storage </p>

</div>
</div>
<a id="aa858fa143a71f61e3096fe65a429a0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa858fa143a71f61e3096fe65a429a0fe">&#9670;&nbsp;</a></span>CACHE_STORAGE_INITIAL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CACHE_STORAGE_INITIAL_SIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initial size of the cache storage </p>

</div>
</div>
<a id="a5b57e256193b9d5aced6f200585d82a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b57e256193b9d5aced6f200585d82a2">&#9670;&nbsp;</a></span>LOCKS_HASH_CELLS_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCKS_HASH_CELLS_NUM&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the hash table size is LOCKS_HASH_CELLS_NUM * sizeof(void*) bytes </p>

</div>
</div>
<a id="ac99e0c0334d3e63e23d35f654079ccb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99e0c0334d3e63e23d35f654079ccb4">&#9670;&nbsp;</a></span>MAX_ALLOWED_FOR_ALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_ALLOWED_FOR_ALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cache</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="trx0i__s_8h.html#a35fce873dd0c620970148a47b1131924">TRX_I_S_MEM_LIMIT</a>                      \</div><div class="line">         - (cache)-&gt;mem_allocd                  \</div><div class="line">         - <a class="code" href="ha0storage_8h.html#a525903647192e960bac5334b4374f263">ha_storage_get_size</a>((cache)-&gt;storage))</div><div class="ttc" id="trx0i__s_8h_html_a35fce873dd0c620970148a47b1131924"><div class="ttname"><a href="trx0i__s_8h.html#a35fce873dd0c620970148a47b1131924">TRX_I_S_MEM_LIMIT</a></div><div class="ttdeci">#define TRX_I_S_MEM_LIMIT</div><div class="ttdef"><b>Definition:</b> trx0i_s.h:38</div></div>
<div class="ttc" id="ha0storage_8h_html_a525903647192e960bac5334b4374f263"><div class="ttname"><a href="ha0storage_8h.html#a525903647192e960bac5334b4374f263">ha_storage_get_size</a></div><div class="ttdeci">UNIV_INLINE ulint ha_storage_get_size(const ha_storage_t *storage)</div></div>
</div><!-- fragment --><p>Memory limit in <a class="el" href="trx0i__s_8cc.html#a7a1d6a8d0d3e571fcfc7c405b2458cb8">table_cache_create_empty_row()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>hash storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum allowed allocation size </dd></dl>

</div>
</div>
<a id="a36763bce6a91af48841bee6df67ef7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36763bce6a91af48841bee6df67ef7d6">&#9670;&nbsp;</a></span>MAX_ALLOWED_FOR_STORAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_ALLOWED_FOR_STORAGE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cache</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="trx0i__s_8h.html#a35fce873dd0c620970148a47b1131924">TRX_I_S_MEM_LIMIT</a>                      \</div><div class="line">         - (cache)-&gt;mem_allocd)</div><div class="ttc" id="trx0i__s_8h_html_a35fce873dd0c620970148a47b1131924"><div class="ttname"><a href="trx0i__s_8h.html#a35fce873dd0c620970148a47b1131924">TRX_I_S_MEM_LIMIT</a></div><div class="ttdeci">#define TRX_I_S_MEM_LIMIT</div><div class="ttdef"><b>Definition:</b> trx0i_s.h:38</div></div>
</div><!-- fragment --><p>The following are some testing auxiliary macros. Do not enable them in a production environment. Memory limit passed to <a class="el" href="ha0storage_8cc.html#a5b5c7d979ca0d2c056e60a391df21dd1">ha_storage_put_memlim()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>hash storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum allowed allocation size </dd></dl>

</div>
</div>
<a id="aee0cca06ba6aeaeb82876fd21a0331f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0cca06ba6aeaeb82876fd21a0331f4">&#9670;&nbsp;</a></span>MEM_CHUNKS_IN_TABLE_CACHE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_CHUNKS_IN_TABLE_CACHE&#160;&#160;&#160;39</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of chunks to allocate for a table cache. </p>
<p>The rows of a table cache are stored in a set of chunks. When a new row is added a new chunk is allocated if necessary. Assuming that the first one is 1024 rows (TABLE_CACHE_INITIAL_ROWSNUM) and each subsequent is N/2 where N is the number of rows we have allocated till now, then 39th chunk would accommodate 1677416425 rows and all chunks would accommodate 3354832851 rows. </p>

</div>
</div>
<a id="a01f0f3f3d1bf9116a90f06be4a55c646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f0f3f3d1bf9116a90f06be4a55c646">&#9670;&nbsp;</a></span>TABLE_CACHE_INITIAL_ROWSNUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TABLE_CACHE_INITIAL_ROWSNUM&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initial number of rows in the table cache </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aadf7fe2d991779bb79eb9bf85e307bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf7fe2d991779bb79eb9bf85e307bd2">&#9670;&nbsp;</a></span>add_lock_to_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a>* add_lock_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds new element to the locks cache, enlarging it if necessary. Returns a pointer to the added row. If the row is already present then no row is added and a pointer to the existing row is returned. If row can not be allocated then NULL is returned. </p><dl class="section return"><dt>Returns</dt><dd>row </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
    <tr><td class="paramname">lock</td><td>in: the element to add </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: lock's record number or ULINT_UNDEFINED if the lock is a table lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae90ac303a1d34193825ef57a71c72fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90ac303a1d34193825ef57a71c72fd2">&#9670;&nbsp;</a></span>add_lock_wait_to_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool add_lock_wait_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>requested_lock_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>blocking_lock_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds new pair of locks to the lock waits cache. If memory can not be allocated then FALSE is returned. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if allocation fails </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
    <tr><td class="paramname">requested_lock_row</td><td>in: pointer to the relevant requested lock row in innodb_locks </td></tr>
    <tr><td class="paramname">blocking_lock_row</td><td>in: pointer to the relevant blocking lock row in innodb_locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80fe829b4dd47e1cf2e897769c0482e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fe829b4dd47e1cf2e897769c0482e6">&#9670;&nbsp;</a></span>add_trx_relevant_locks_to_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool add_trx_relevant_locks_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> **&#160;</td>
          <td class="paramname"><em>requested_lock_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds transaction's relevant (important) locks to cache. If the transaction is waiting, then the wait lock is added to innodb_locks and a pointer to the added row is returned in requested_lock_row, otherwise requested_lock_row is set to NULL. If rows can not be allocated then FALSE is returned and the value of requested_lock_row is undefined. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if allocation fails </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">requested_lock_row</td><td>out: pointer to the requested lock row, or NULL or undefined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a117cfd2ddf19d1f50f8e7593e712a048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117cfd2ddf19d1f50f8e7593e712a048">&#9670;&nbsp;</a></span>cache_select_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a>* cache_select_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a>&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Selects a INFORMATION SCHEMA table cache from the whole cache. </p><dl class="section return"><dt>Returns</dt><dd>table cache </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: whole cache </td></tr>
    <tr><td class="paramname">table</td><td>in: which table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94ebecc6d9f2669b9384f6f256fe1478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ebecc6d9f2669b9384f6f256fe1478">&#9670;&nbsp;</a></span>can_cache_be_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool can_cache_be_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the cache can safely be updated. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if can be updated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93c73dfc1d549e29a263af5e11909bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c73dfc1d549e29a263af5e11909bdf">&#9670;&nbsp;</a></span>fetch_data_into_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fetch_data_into_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fetches the data needed to fill the 3 INFORMATION SCHEMA tables into the table cache buffer. Cache must be locked for write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76fc53aaeadb3e3cc6cfafc9bd3586e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fc53aaeadb3e3cc6cfafc9bd3586e5">&#9670;&nbsp;</a></span>fetch_data_into_cache_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fetch_data_into_cache_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>only_ac_nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">trx_list_t *&#160;</td>
          <td class="paramname"><em>trx_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fetches the data needed to fill the 3 INFORMATION SCHEMA tables into the table cache buffer. Cache must be locked for write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
    <tr><td class="paramname">only_ac_nl</td><td>in: only select non-locking autocommit transactions </td></tr>
    <tr><td class="paramname">trx_list</td><td>in: trx list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37dde11fc97ca3c1462f443cddd3b186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dde11fc97ca3c1462f443cddd3b186">&#9670;&nbsp;</a></span>fill_lock_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fill_lock_data </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>lock_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the "lock_data" member of <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> object. If memory can not be allocated then FALSE is returned. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if allocation fails </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_data</td><td>out: "lock_data" to fill </td></tr>
    <tr><td class="paramname">lock</td><td>in: lock used to find the data </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: rec num used to find the data </td></tr>
    <tr><td class="paramname">cache</td><td>in/out: cache where to store volatile data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdf0a9c1fbfb882a623b7bb9da194082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf0a9c1fbfb882a623b7bb9da194082">&#9670;&nbsp;</a></span>fill_lock_waits_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structi__s__lock__waits__row__t.html">i_s_lock_waits_row_t</a>* fill_lock_waits_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__lock__waits__row__t.html">i_s_lock_waits_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>requested_lock_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>blocking_lock_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills <a class="el" href="structi__s__lock__waits__row__t.html">i_s_lock_waits_row_t</a> object. Returns its first argument. </p><dl class="section return"><dt>Returns</dt><dd>result object that's filled </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>out: result object that's filled </td></tr>
    <tr><td class="paramname">requested_lock_row</td><td>in: pointer to the relevant requested lock row in innodb_locks </td></tr>
    <tr><td class="paramname">blocking_lock_row</td><td>in: pointer to the relevant blocking lock row in innodb_locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5bc57517404e484f5daee0b044dfc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bc57517404e484f5daee0b044dfc0b">&#9670;&nbsp;</a></span>fill_locks_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fill_locks_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> object. Returns its first argument. If memory can not be allocated then FALSE is returned. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if allocation fails </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>out: result object that's filled </td></tr>
    <tr><td class="paramname">lock</td><td>in: lock to get data from </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: lock's record number or ULINT_UNDEFINED if the lock is a table lock </td></tr>
    <tr><td class="paramname">cache</td><td>in/out: cache into which to copy volatile strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2e1b41c44dd1f948c6475758192de28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e1b41c44dd1f948c6475758192de28">&#9670;&nbsp;</a></span>fill_trx_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fill_trx_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__trx__row__t.html">i_s_trx_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>requested_lock_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills <a class="el" href="structi__s__trx__row__t.html">i_s_trx_row_t</a> object. If memory can not be allocated then FALSE is returned. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if allocation fails </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>out: result object that's filled </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction to get data from </td></tr>
    <tr><td class="paramname">requested_lock_row</td><td>in: pointer to the corresponding row in innodb_locks if trx is waiting or NULL if trx is not waiting </td></tr>
    <tr><td class="paramname">cache</td><td>in/out: cache into which to copy volatile strings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae850561d98192693cd4061393372ceaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae850561d98192693cd4061393372ceaa">&#9670;&nbsp;</a></span>fold_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint fold_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a hash fold for a lock. For a record lock the fold is calculated from 4 elements, which uniquely identify a lock at a given point in time: transaction id, space id, page number, record number. For a table lock the fold is table's id. </p><dl class="section return"><dt>Returns</dt><dd>fold </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock object to fold </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: lock's record number or ULINT_UNDEFINED if the lock is a table lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a968cb44ac25300f07654fe9867b6ff79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968cb44ac25300f07654fe9867b6ff79">&#9670;&nbsp;</a></span>locks_row_eq_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool locks_row_eq_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> object represents a <a class="el" href="structlock__t.html">lock_t</a> object. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if they match </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>in: innodb_locks row </td></tr>
    <tr><td class="paramname">lock</td><td>in: lock object </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: lock's record number or ULINT_UNDEFINED if the lock is a table lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea746ef8e0aa961a089254b7b83d65b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea746ef8e0aa961a089254b7b83d65b9">&#9670;&nbsp;</a></span>put_nth_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint put_nth_field </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Format the nth field of "rec" and put it in "buf". The result is always NUL-terminated. Returns the number of bytes that were written to "buf" (including the terminating NUL). </p><dl class="section return"><dt>Returns</dt><dd>end of the result </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: buffer </td></tr>
    <tr><td class="paramname">buf_size</td><td>in: buffer size in bytes </td></tr>
    <tr><td class="paramname">n</td><td>in: number of field </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: record offsets, returned by rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07cfd7901d4c5680423c0daf1b981dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cfd7901d4c5680423c0daf1b981dd0">&#9670;&nbsp;</a></span>search_innodb_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a>* search_innodb_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for a row in the innodb_locks cache that has a specified id. This happens in O(1) time since a hash table is used. Returns pointer to the row or NULL if none is found. </p><dl class="section return"><dt>Returns</dt><dd>row or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
    <tr><td class="paramname">lock</td><td>in: lock to search for </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: lock's record number or ULINT_UNDEFINED if the lock is a table lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a1d6a8d0d3e571fcfc7c405b2458cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1d6a8d0d3e571fcfc7c405b2458cb8">&#9670;&nbsp;</a></span>table_cache_create_empty_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* table_cache_create_empty_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *&#160;</td>
          <td class="paramname"><em>table_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an empty row from a table cache. The row is allocated if no more empty rows are available. The number of used rows is incremented. If the memory limit is hit then NULL is returned and nothing is allocated. </p><dl class="section return"><dt>Returns</dt><dd>empty row, or NULL if out of memory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_cache</td><td>in/out: table cache </td></tr>
    <tr><td class="paramname">cache</td><td>in/out: cache to record how many bytes are allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a692c274041f49e80c3e170b240ab30cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692c274041f49e80c3e170b240ab30cf">&#9670;&nbsp;</a></span>table_cache_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void table_cache_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *&#160;</td>
          <td class="paramname"><em>table_cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a table cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_cache</td><td>in/out: table cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cf61aa32949295fdd25b9d69964f83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf61aa32949295fdd25b9d69964f83d">&#9670;&nbsp;</a></span>table_cache_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void table_cache_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi__s__table__cache__t.html">i_s_table_cache_t</a> *&#160;</td>
          <td class="paramname"><em>table_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the members of a table cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_cache</td><td>out: table cache </td></tr>
    <tr><td class="paramname">row_size</td><td>in: the size of a row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b73d6eb69e73c6558f8ee97e21e097d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b73d6eb69e73c6558f8ee97e21e097d">&#9670;&nbsp;</a></span>trx_i_s_cache_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trx_i_s_cache_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare a cache empty, preparing it to be filled up. Not all resources are freed because they can be reused. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>out: cache to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48357e2a54ac29ebcf53242d18822f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48357e2a54ac29ebcf53242d18822f1a">&#9670;&nbsp;</a></span>trx_i_s_cache_end_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void trx_i_s_cache_end_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a shared/read lock on the tables cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a884ff76fcec6dbfd070d3324809df7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884ff76fcec6dbfd070d3324809df7b8">&#9670;&nbsp;</a></span>trx_i_s_cache_end_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void trx_i_s_cache_end_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release an exclusive/write lock on the tables cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a0f496c35385e46418b0b9d72c98884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0f496c35385e46418b0b9d72c98884">&#9670;&nbsp;</a></span>trx_i_s_cache_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void trx_i_s_cache_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the INFORMATION SCHEMA trx related cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in, own: cache to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aced2b6642b7cdbe0b4a8718676f89ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced2b6642b7cdbe0b4a8718676f89ab8">&#9670;&nbsp;</a></span>trx_i_s_cache_get_nth_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void* trx_i_s_cache_get_nth_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a>&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the nth row (zero-based) in the cache for a given INFORMATION SCHEMA table. </p><dl class="section return"><dt>Returns</dt><dd>row </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
    <tr><td class="paramname">table</td><td>in: which table </td></tr>
    <tr><td class="paramname">n</td><td>in: row number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf415a479c5343d86a46aea8c42577a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf415a479c5343d86a46aea8c42577a5">&#9670;&nbsp;</a></span>trx_i_s_cache_get_rows_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint trx_i_s_cache_get_rows_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0i__s_8h.html#ae2302b72d893f3a895d5cac10337f99e">i_s_table</a>&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the number of used rows in the cache for a given INFORMATION SCHEMA table. </p><dl class="section return"><dt>Returns</dt><dd>number of rows </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
    <tr><td class="paramname">table</td><td>in: which table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbd3e1ba86fdc2cc24166e8104d3e821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd3e1ba86fdc2cc24166e8104d3e821">&#9670;&nbsp;</a></span>trx_i_s_cache_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void trx_i_s_cache_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize INFORMATION SCHEMA trx related cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>out: cache to init </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cc20b3ba22ba224ba5224a595edd9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc20b3ba22ba224ba5224a595edd9cb">&#9670;&nbsp;</a></span>trx_i_s_cache_is_truncated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool trx_i_s_cache_is_truncated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the data in the cache is truncated due to the memory limit posed by TRX_I_S_MEM_LIMIT. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if truncated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4684a66f93bc0d4f2c402bdd81c20788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4684a66f93bc0d4f2c402bdd81c20788">&#9670;&nbsp;</a></span>trx_i_s_cache_start_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void trx_i_s_cache_start_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue a shared/read lock on the tables cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e6d77c6f2ea6ffdda2f779d7e7b21f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6d77c6f2ea6ffdda2f779d7e7b21f1">&#9670;&nbsp;</a></span>trx_i_s_cache_start_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void trx_i_s_cache_start_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue an exclusive/write lock on the tables cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade85acfa41299e10e4d0633c708935e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade85acfa41299e10e4d0633c708935e6">&#9670;&nbsp;</a></span>trx_i_s_create_lock_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* trx_i_s_create_lock_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>lock_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_id_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Crafts a lock id string from a <a class="el" href="structi__s__locks__row__t.html">i_s_locks_row_t</a> object. Returns its second argument. This function aborts if there is not enough space in lock_id. Be sure to provide at least TRX_I_S_LOCK_ID_MAX_LEN + 1 if you want to be 100% sure that it will not abort. </p><dl class="section return"><dt>Returns</dt><dd>resulting lock id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>in: innodb_locks row </td></tr>
    <tr><td class="paramname">lock_id</td><td>out: resulting lock_id </td></tr>
    <tr><td class="paramname">lock_id_size</td><td>in: size of the lock id buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1630cdc1f5268e69c45ce54b9d89950b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1630cdc1f5268e69c45ce54b9d89950b">&#9670;&nbsp;</a></span>trx_i_s_possibly_fetch_data_into_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int trx_i_s_possibly_fetch_data_into_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the transactions cache if it has not been read for some time. Called from <a class="el" href="i__s_8cc.html">handler/i_s.cc</a>. </p><dl class="section return"><dt>Returns</dt><dd>0 - fetched, 1 - not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>in/out: cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6eaaebecf6b68bdbafcff69320d95f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eaaebecf6b68bdbafcff69320d95f5">&#9670;&nbsp;</a></span>wait_lock_get_heap_no()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint wait_lock_get_heap_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For a record lock that is in waiting state retrieves the only bit that is set, for a table lock returns ULINT_UNDEFINED. </p><dl class="section return"><dt>Returns</dt><dd>record number within the heap </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af642f64c1e8d6a0501d2ba654541de3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af642f64c1e8d6a0501d2ba654541de3e">&#9670;&nbsp;</a></span>trx_i_s_cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a>* trx_i_s_cache = &amp;<a class="el" href="trx0i__s_8cc.html#addf3c2fcb0413ec13456ef23a7ceb374">trx_i_s_cache_static</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the intermediate buffer where data needed to fill the INFORMATION SCHEMA tables is fetched and later retrieved by the C++ code in <a class="el" href="i__s_8cc.html">handler/i_s.cc</a>. </p>

</div>
</div>
<a id="addf3c2fcb0413ec13456ef23a7ceb374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf3c2fcb0413ec13456ef23a7ceb374">&#9670;&nbsp;</a></span>trx_i_s_cache_static</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtrx__i__s__cache__t.html">trx_i_s_cache_t</a> trx_i_s_cache_static</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the intermediate buffer where data needed to fill the INFORMATION SCHEMA tables is fetched and later retrieved by the C++ code in <a class="el" href="i__s_8cc.html">handler/i_s.cc</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

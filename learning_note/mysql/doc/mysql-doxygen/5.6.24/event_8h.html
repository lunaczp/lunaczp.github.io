<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: libevent/event.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_e0cb8418b6001d8d6e6585f045be2b6d.html">libevent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">event.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;config.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;<a class="el" href="evutil_8h_source.html">evutil.h</a>&gt;</code><br />
</div>
<p><a href="event_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent.html">event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevkeyval.html">evkeyval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevbuffer.html">evbuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent__watermark.html">event_watermark</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbufferevent.html">bufferevent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afd2b522123bb498e82f0cba3154c96bf"><td class="memItemLeft" align="right" valign="top"><a id="afd2b522123bb498e82f0cba3154c96bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVLIST_TIMEOUT</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:afd2b522123bb498e82f0cba3154c96bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4e9dd49bfbb4cccc279d653263bf0d"><td class="memItemLeft" align="right" valign="top"><a id="a1e4e9dd49bfbb4cccc279d653263bf0d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVLIST_INSERTED</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a1e4e9dd49bfbb4cccc279d653263bf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105489ac55c9ced60e0ce20af2024f2a"><td class="memItemLeft" align="right" valign="top"><a id="a105489ac55c9ced60e0ce20af2024f2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVLIST_SIGNAL</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a105489ac55c9ced60e0ce20af2024f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaf2fdd81437ac1daebde3c023cbd62"><td class="memItemLeft" align="right" valign="top"><a id="aceaf2fdd81437ac1daebde3c023cbd62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVLIST_ACTIVE</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:aceaf2fdd81437ac1daebde3c023cbd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a22542705d3dd63e32d5681da2bfb3"><td class="memItemLeft" align="right" valign="top"><a id="a27a22542705d3dd63e32d5681da2bfb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVLIST_INTERNAL</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a27a22542705d3dd63e32d5681da2bfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6bac1f3d7c88dae44e82ff987729a9"><td class="memItemLeft" align="right" valign="top"><a id="aed6bac1f3d7c88dae44e82ff987729a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVLIST_INIT</b>&#160;&#160;&#160;0x80</td></tr>
<tr class="separator:aed6bac1f3d7c88dae44e82ff987729a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1322cc51314cd035cfae7e568d7214e5"><td class="memItemLeft" align="right" valign="top"><a id="a1322cc51314cd035cfae7e568d7214e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVLIST_ALL</b>&#160;&#160;&#160;(0xf000 | 0x9f)</td></tr>
<tr class="separator:a1322cc51314cd035cfae7e568d7214e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ef4b6056484f5580f7d72fcf46fccf"><td class="memItemLeft" align="right" valign="top"><a id="a37ef4b6056484f5580f7d72fcf46fccf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_TIMEOUT</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a37ef4b6056484f5580f7d72fcf46fccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bbaf2d529670cc0ab793497b41700f"><td class="memItemLeft" align="right" valign="top"><a id="a74bbaf2d529670cc0ab793497b41700f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_READ</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a74bbaf2d529670cc0ab793497b41700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a31813fa3b26bf2d150512cbbf893f7"><td class="memItemLeft" align="right" valign="top"><a id="a2a31813fa3b26bf2d150512cbbf893f7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_WRITE</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a2a31813fa3b26bf2d150512cbbf893f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b7e95284ac1a197969d42ee9441ece"><td class="memItemLeft" align="right" valign="top"><a id="a59b7e95284ac1a197969d42ee9441ece"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_SIGNAL</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:a59b7e95284ac1a197969d42ee9441ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4947a60eb6d09327c61f89135f9f37"><td class="memItemLeft" align="right" valign="top"><a id="a3c4947a60eb6d09327c61f89135f9f37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_PERSIST</b>&#160;&#160;&#160;0x10	/* Persistant event */</td></tr>
<tr class="separator:a3c4947a60eb6d09327c61f89135f9f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5d5563dbaafdae9e5337ce227beb71"><td class="memItemLeft" align="right" valign="top"><a id="a1c5d5563dbaafdae9e5337ce227beb71"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_EVENT_DEFINED_TQENTRY</b></td></tr>
<tr class="separator:a1c5d5563dbaafdae9e5337ce227beb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71bfd90dc9d00fb03545fe66c67d673"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAILQ_ENTRY</b>(<a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:af71bfd90dc9d00fb03545fe66c67d673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899cb8dd0c2bf1289c0069e4649326ad"><td class="memItemLeft" align="right" valign="top"><a id="a899cb8dd0c2bf1289c0069e4649326ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVENT_SIGNAL</b>(ev)&#160;&#160;&#160;(int)(ev)-&gt;ev_fd</td></tr>
<tr class="separator:a899cb8dd0c2bf1289c0069e4649326ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1c2a40ad619b9c3ca2cb82a126e2e4"><td class="memItemLeft" align="right" valign="top"><a id="a2b1c2a40ad619b9c3ca2cb82a126e2e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVENT_FD</b>(ev)&#160;&#160;&#160;(int)(ev)-&gt;ev_fd</td></tr>
<tr class="separator:a2b1c2a40ad619b9c3ca2cb82a126e2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964443418439acdd775129ae260b21bb"><td class="memItemLeft" align="right" valign="top"><a id="a964443418439acdd775129ae260b21bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_DEBUG</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a964443418439acdd775129ae260b21bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d898badc07a518c29ecb0129cc77188"><td class="memItemLeft" align="right" valign="top"><a id="a6d898badc07a518c29ecb0129cc77188"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_MSG</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a6d898badc07a518c29ecb0129cc77188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ba4ffdc827c139311654c41cfddd1d"><td class="memItemLeft" align="right" valign="top"><a id="aa8ba4ffdc827c139311654c41cfddd1d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_WARN</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:aa8ba4ffdc827c139311654c41cfddd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829eede32e73952922a35e42b510bfe9"><td class="memItemLeft" align="right" valign="top"><a id="a829eede32e73952922a35e42b510bfe9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_EVENT_LOG_ERR</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a829eede32e73952922a35e42b510bfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea3ca87057c66fd9f5a9fda9b911f8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a6ea3ca87057c66fd9f5a9fda9b911f8b">evtimer_add</a>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add</a>(ev, tv)</td></tr>
<tr class="separator:a6ea3ca87057c66fd9f5a9fda9b911f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5d72155d72931332ed0656fc8fb0a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#afa5d72155d72931332ed0656fc8fb0a1">evtimer_set</a>(ev,  cb,  arg)&#160;&#160;&#160;<a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set</a>(ev, -1, 0, cb, arg)</td></tr>
<tr class="separator:afa5d72155d72931332ed0656fc8fb0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f7e7b422e9098d9362626d47b77525"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a22f7e7b422e9098d9362626d47b77525">evtimer_del</a>(ev)&#160;&#160;&#160;<a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del</a>(ev)</td></tr>
<tr class="separator:a22f7e7b422e9098d9362626d47b77525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7037bae3f2fb09eb2752e8252b63a5a6"><td class="memItemLeft" align="right" valign="top"><a id="a7037bae3f2fb09eb2752e8252b63a5a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evtimer_pending</b>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event_8h.html#abf39a907d20c1612adc310c123648b63">event_pending</a>(ev, EV_TIMEOUT, tv)</td></tr>
<tr class="separator:a7037bae3f2fb09eb2752e8252b63a5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765c62ada275b4114ca0494e9d1f0047"><td class="memItemLeft" align="right" valign="top"><a id="a765c62ada275b4114ca0494e9d1f0047"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evtimer_initialized</b>(ev)&#160;&#160;&#160;((ev)-&gt;ev_flags &amp; EVLIST_INIT)</td></tr>
<tr class="separator:a765c62ada275b4114ca0494e9d1f0047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf6ea49aab66ec47acd9f5b629bfe5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#afaf6ea49aab66ec47acd9f5b629bfe5e">timeout_add</a>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add</a>(ev, tv)</td></tr>
<tr class="separator:afaf6ea49aab66ec47acd9f5b629bfe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e9253a4d75703692dd912be4a87aab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a85e9253a4d75703692dd912be4a87aab">timeout_set</a>(ev,  cb,  arg)&#160;&#160;&#160;<a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set</a>(ev, -1, 0, cb, arg)</td></tr>
<tr class="separator:a85e9253a4d75703692dd912be4a87aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8febdc39e7def3c49deb1e9faa7fc537"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a8febdc39e7def3c49deb1e9faa7fc537">timeout_del</a>(ev)&#160;&#160;&#160;<a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del</a>(ev)</td></tr>
<tr class="separator:a8febdc39e7def3c49deb1e9faa7fc537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221671efe98942558743d1a66669b494"><td class="memItemLeft" align="right" valign="top"><a id="a221671efe98942558743d1a66669b494"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>timeout_pending</b>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event_8h.html#abf39a907d20c1612adc310c123648b63">event_pending</a>(ev, EV_TIMEOUT, tv)</td></tr>
<tr class="separator:a221671efe98942558743d1a66669b494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960c63760b26a73350a2bd3618fe4d66"><td class="memItemLeft" align="right" valign="top"><a id="a960c63760b26a73350a2bd3618fe4d66"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>timeout_initialized</b>(ev)&#160;&#160;&#160;((ev)-&gt;ev_flags &amp; EVLIST_INIT)</td></tr>
<tr class="separator:a960c63760b26a73350a2bd3618fe4d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26a36d05805ed2fadc7b2dcbf881020"><td class="memItemLeft" align="right" valign="top"><a id="ac26a36d05805ed2fadc7b2dcbf881020"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>signal_add</b>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add</a>(ev, tv)</td></tr>
<tr class="separator:ac26a36d05805ed2fadc7b2dcbf881020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e620dc98462b393821cf84cb02c7e5c"><td class="memItemLeft" align="right" valign="top"><a id="a1e620dc98462b393821cf84cb02c7e5c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>signal_set</b>(ev,  x,  cb,  arg)&#160;&#160;&#160;<a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set</a>(ev, x, EV_SIGNAL|EV_PERSIST, cb, arg)</td></tr>
<tr class="separator:a1e620dc98462b393821cf84cb02c7e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fc0b01f4acf885075e9720faf91906"><td class="memItemLeft" align="right" valign="top"><a id="a77fc0b01f4acf885075e9720faf91906"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>signal_del</b>(ev)&#160;&#160;&#160;<a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del</a>(ev)</td></tr>
<tr class="separator:a77fc0b01f4acf885075e9720faf91906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07458695d3403c8c0bcec356a9d243c7"><td class="memItemLeft" align="right" valign="top"><a id="a07458695d3403c8c0bcec356a9d243c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>signal_pending</b>(ev,  tv)&#160;&#160;&#160;<a class="el" href="event_8h.html#abf39a907d20c1612adc310c123648b63">event_pending</a>(ev, EV_SIGNAL, tv)</td></tr>
<tr class="separator:a07458695d3403c8c0bcec356a9d243c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049ba1588cd2d372b2617f1ff336282b"><td class="memItemLeft" align="right" valign="top"><a id="a049ba1588cd2d372b2617f1ff336282b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>signal_initialized</b>(ev)&#160;&#160;&#160;((ev)-&gt;ev_flags &amp; EVLIST_INIT)</td></tr>
<tr class="separator:a049ba1588cd2d372b2617f1ff336282b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc20b949f93daebf2acb5bd81be24fff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#afc20b949f93daebf2acb5bd81be24fff">event_initialized</a>(ev)&#160;&#160;&#160;((ev)-&gt;ev_flags &amp; EVLIST_INIT)</td></tr>
<tr class="separator:afc20b949f93daebf2acb5bd81be24fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf503b22891daa1b18d6efc9de02d61"><td class="memItemLeft" align="right" valign="top"><a id="afcf503b22891daa1b18d6efc9de02d61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVBUFFER_READ</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:afcf503b22891daa1b18d6efc9de02d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da7a6da254f89c736148285cab7b8d8"><td class="memItemLeft" align="right" valign="top"><a id="a8da7a6da254f89c736148285cab7b8d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVBUFFER_WRITE</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a8da7a6da254f89c736148285cab7b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedf9edc6f996732b04bcd059dc83a23"><td class="memItemLeft" align="right" valign="top"><a id="afedf9edc6f996732b04bcd059dc83a23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVBUFFER_EOF</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:afedf9edc6f996732b04bcd059dc83a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6271abfaba605b8eed08ac2f3b0c45"><td class="memItemLeft" align="right" valign="top"><a id="ace6271abfaba605b8eed08ac2f3b0c45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVBUFFER_ERROR</b>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:ace6271abfaba605b8eed08ac2f3b0c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2fb0bad27c0c012c281799355c9462"><td class="memItemLeft" align="right" valign="top"><a id="acb2fb0bad27c0c012c281799355c9462"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVBUFFER_TIMEOUT</b>&#160;&#160;&#160;0x40</td></tr>
<tr class="separator:acb2fb0bad27c0c012c281799355c9462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d9564980e380cf1887f2be70f687ad"><td class="memItemLeft" align="right" valign="top"><a id="ab8d9564980e380cf1887f2be70f687ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVBUFFER_LENGTH</b>(x)&#160;&#160;&#160;(x)-&gt;off</td></tr>
<tr class="separator:ab8d9564980e380cf1887f2be70f687ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c57a451c56dc1483a1c8aaeb9b92cc6"><td class="memItemLeft" align="right" valign="top"><a id="a1c57a451c56dc1483a1c8aaeb9b92cc6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVBUFFER_DATA</b>(x)&#160;&#160;&#160;(x)-&gt;buffer</td></tr>
<tr class="separator:a1c57a451c56dc1483a1c8aaeb9b92cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189bf30c83f32cffebdc0dcb65f41350"><td class="memItemLeft" align="right" valign="top"><a id="a189bf30c83f32cffebdc0dcb65f41350"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVBUFFER_INPUT</b>(x)&#160;&#160;&#160;(x)-&gt;input</td></tr>
<tr class="separator:a189bf30c83f32cffebdc0dcb65f41350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7bfa5494417540589e9ae582a2bccd"><td class="memItemLeft" align="right" valign="top"><a id="a6e7bfa5494417540589e9ae582a2bccd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVBUFFER_OUTPUT</b>(x)&#160;&#160;&#160;(x)-&gt;output</td></tr>
<tr class="separator:a6e7bfa5494417540589e9ae582a2bccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afab575b1e867dde13a2c7f2f967e0e4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#afab575b1e867dde13a2c7f2f967e0e4e">EVLOOP_ONCE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:afab575b1e867dde13a2c7f2f967e0e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b9c102337d0ece8607c9c01bc4f7c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a10b9c102337d0ece8607c9c01bc4f7c8">EVLOOP_NONBLOCK</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a10b9c102337d0ece8607c9c01bc4f7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a185f44c610d7ee21ecba720561b2e09c"><td class="memItemLeft" align="right" valign="top"><a id="a185f44c610d7ee21ecba720561b2e09c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>event_log_cb</b>) (int severity, const char *<a class="el" href="structmsg.html">msg</a>)</td></tr>
<tr class="separator:a185f44c610d7ee21ecba720561b2e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0846106f1f04dd81a32322e17e1e84fc"><td class="memItemLeft" align="right" valign="top"><a id="a0846106f1f04dd81a32322e17e1e84fc"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>evbuffercb</b>) (struct <a class="el" href="structbufferevent.html">bufferevent</a> *, void *)</td></tr>
<tr class="separator:a0846106f1f04dd81a32322e17e1e84fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d861c5d6442d672012a4f0ee279224"><td class="memItemLeft" align="right" valign="top"><a id="a06d861c5d6442d672012a4f0ee279224"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>everrorcb</b>) (struct <a class="el" href="structbufferevent.html">bufferevent</a> *, short what, void *)</td></tr>
<tr class="separator:a06d861c5d6442d672012a4f0ee279224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c16f1203aebc67f94791ae0240b7353"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353">event_base_new</a> (void)</td></tr>
<tr class="separator:a4c16f1203aebc67f94791ae0240b7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf74386dd3725e1538fed2d70c1c113"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init</a> (void)</td></tr>
<tr class="separator:a1bf74386dd3725e1538fed2d70c1c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7409499a79a59842955928af446fe03d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a7409499a79a59842955928af446fe03d">event_reinit</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
<tr class="separator:a7409499a79a59842955928af446fe03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4991bceb8aaf33545d1fc857230b51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a1f4991bceb8aaf33545d1fc857230b51">event_dispatch</a> (void)</td></tr>
<tr class="separator:a1f4991bceb8aaf33545d1fc857230b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e457364ed5216a8c7bc219033b946f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a01e457364ed5216a8c7bc219033b946f">event_base_dispatch</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a01e457364ed5216a8c7bc219033b946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba9db037ed6bb6f13d16d1720ac6d4a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#aeba9db037ed6bb6f13d16d1720ac6d4a">event_base_get_method</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:aeba9db037ed6bb6f13d16d1720ac6d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9827de8c3014417b11b48f2fe688ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a6e9827de8c3014417b11b48f2fe688ae">event_base_free</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a6e9827de8c3014417b11b48f2fe688ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e59ed1dd711ced2b2a1314d3e3c1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a87e59ed1dd711ced2b2a1314d3e3c1c7">event_set_log_callback</a> (event_log_cb cb)</td></tr>
<tr class="separator:a87e59ed1dd711ced2b2a1314d3e3c1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efd0ac7e54428d1941f212bc16ed9ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a2efd0ac7e54428d1941f212bc16ed9ce">event_base_set</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr class="separator:a2efd0ac7e54428d1941f212bc16ed9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765c1875642fc730addf04e9433f6448"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a765c1875642fc730addf04e9433f6448">event_loop</a> (int)</td></tr>
<tr class="separator:a765c1875642fc730addf04e9433f6448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad712706e6a763b6662f0eb03b3d8cd80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, int)</td></tr>
<tr class="separator:ad712706e6a763b6662f0eb03b3d8cd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3d894ac7986bb4967ebfe67a2d9977"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a2e3d894ac7986bb4967ebfe67a2d9977">event_loopexit</a> (const struct <a class="el" href="structtimeval.html">timeval</a> *)</td></tr>
<tr class="separator:a2e3d894ac7986bb4967ebfe67a2d9977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c66174ee5f10df65b9a9b62fca7dd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ac2c66174ee5f10df65b9a9b62fca7dd9">event_base_loopexit</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, const struct <a class="el" href="structtimeval.html">timeval</a> *)</td></tr>
<tr class="separator:ac2c66174ee5f10df65b9a9b62fca7dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5c57caea1d97160f6990b3deeb6961"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a3a5c57caea1d97160f6990b3deeb6961">event_loopbreak</a> (void)</td></tr>
<tr class="separator:a3a5c57caea1d97160f6990b3deeb6961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a7599e478e4031fa8cf52e26d8aa1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e">event_base_loopbreak</a> (struct <a class="el" href="structevent__base.html">event_base</a> *)</td></tr>
<tr class="separator:a07a7599e478e4031fa8cf52e26d8aa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24235e12d151db1782f792e14c83cf82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set</a> (struct <a class="el" href="structevent.html">event</a> *, int, short, void(*)(int, short, void *), void *)</td></tr>
<tr class="separator:a24235e12d151db1782f792e14c83cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450e7c610ac0e321168f036350c36d54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a450e7c610ac0e321168f036350c36d54">event_once</a> (int, short, void(*)(int, short, void *), void *, const struct <a class="el" href="structtimeval.html">timeval</a> *)</td></tr>
<tr class="separator:a450e7c610ac0e321168f036350c36d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10a8706318c18a2c014f1faa3fae852"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ab10a8706318c18a2c014f1faa3fae852">event_base_once</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, int <a class="el" href="row0merge_8cc.html#a2ba07eb1dd7b9899cf7b132635a757e8">fd</a>, short events, void(*callback)(int, short, void *), void *arg, const struct <a class="el" href="structtimeval.html">timeval</a> *timeout)</td></tr>
<tr class="separator:ab10a8706318c18a2c014f1faa3fae852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44df7b40859b56f2c866adb02dabdd9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add</a> (struct <a class="el" href="structevent.html">event</a> *ev, const struct <a class="el" href="structtimeval.html">timeval</a> *timeout)</td></tr>
<tr class="separator:a44df7b40859b56f2c866adb02dabdd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a8cb96af49d18388f64de73a2d4258"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del</a> (struct <a class="el" href="structevent.html">event</a> *)</td></tr>
<tr class="separator:a30a8cb96af49d18388f64de73a2d4258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b20816d7d8f1144977b66b1d62c50"><td class="memItemLeft" align="right" valign="top"><a id="a504b20816d7d8f1144977b66b1d62c50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>event_active</b> (struct <a class="el" href="structevent.html">event</a> *, int, short)</td></tr>
<tr class="separator:a504b20816d7d8f1144977b66b1d62c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf39a907d20c1612adc310c123648b63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#abf39a907d20c1612adc310c123648b63">event_pending</a> (struct <a class="el" href="structevent.html">event</a> *ev, short <a class="el" href="structevent.html">event</a>, struct <a class="el" href="structtimeval.html">timeval</a> *tv)</td></tr>
<tr class="separator:abf39a907d20c1612adc310c123648b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d7feed94477cf0a7e3e062cc17b7e1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a43d7feed94477cf0a7e3e062cc17b7e1">event_get_version</a> (void)</td></tr>
<tr class="separator:a43d7feed94477cf0a7e3e062cc17b7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a03c9175e0578017a384b4c039b090f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a8a03c9175e0578017a384b4c039b090f">event_get_method</a> (void)</td></tr>
<tr class="separator:a8a03c9175e0578017a384b4c039b090f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98d83bce2fe3e97ac655329fb30fccb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ac98d83bce2fe3e97ac655329fb30fccb">event_priority_init</a> (int)</td></tr>
<tr class="separator:ac98d83bce2fe3e97ac655329fb30fccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67067fe995561cd36a7f34ef19e030e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a67067fe995561cd36a7f34ef19e030e8">event_base_priority_init</a> (struct <a class="el" href="structevent__base.html">event_base</a> *, int)</td></tr>
<tr class="separator:a67067fe995561cd36a7f34ef19e030e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9984a63f2edcc72bef96a188f569b367"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a9984a63f2edcc72bef96a188f569b367">event_priority_set</a> (struct <a class="el" href="structevent.html">event</a> *, int)</td></tr>
<tr class="separator:a9984a63f2edcc72bef96a188f569b367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3110aae725315e58a1fe0c667efe7619"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a3110aae725315e58a1fe0c667efe7619">bufferevent_new</a> (int <a class="el" href="row0merge_8cc.html#a2ba07eb1dd7b9899cf7b132635a757e8">fd</a>, evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg)</td></tr>
<tr class="separator:a3110aae725315e58a1fe0c667efe7619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0697dabdb9b4057ae71b40a2f0e45fed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a0697dabdb9b4057ae71b40a2f0e45fed">bufferevent_base_set</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr class="separator:a0697dabdb9b4057ae71b40a2f0e45fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e1daaa7c4d52c95b16c9944fa62e90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a73e1daaa7c4d52c95b16c9944fa62e90">bufferevent_priority_set</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, int pri)</td></tr>
<tr class="separator:a73e1daaa7c4d52c95b16c9944fa62e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474a4cef8fd80bea09a636b5f3055bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a474a4cef8fd80bea09a636b5f3055bec">bufferevent_free</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr class="separator:a474a4cef8fd80bea09a636b5f3055bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b950fe07eae442b2ca4f4ff4a677253"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a0b950fe07eae442b2ca4f4ff4a677253">bufferevent_setcb</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg)</td></tr>
<tr class="separator:a0b950fe07eae442b2ca4f4ff4a677253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a989ad7a7d595ac0ce3a6cd65b8a76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a91a989ad7a7d595ac0ce3a6cd65b8a76">bufferevent_setfd</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, int <a class="el" href="row0merge_8cc.html#a2ba07eb1dd7b9899cf7b132635a757e8">fd</a>)</td></tr>
<tr class="separator:a91a989ad7a7d595ac0ce3a6cd65b8a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc606695cd6bb2e3f25c4330d0c9e3ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab">bufferevent_write</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, const void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:abc606695cd6bb2e3f25c4330d0c9e3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b140a32a4d16c402433130dc8c3bde4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a3b140a32a4d16c402433130dc8c3bde4">bufferevent_write_buffer</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, struct <a class="el" href="structevbuffer.html">evbuffer</a> *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a3b140a32a4d16c402433130dc8c3bde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd435529e20a39b24fead9ddcd966ba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a6bd435529e20a39b24fead9ddcd966ba">bufferevent_read</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a6bd435529e20a39b24fead9ddcd966ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9a3412e8c8e122c745b33d46b9643e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a1b9a3412e8c8e122c745b33d46b9643e">bufferevent_enable</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short <a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="separator:a1b9a3412e8c8e122c745b33d46b9643e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15582fe250247aa98d4897527215727"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#aa15582fe250247aa98d4897527215727">bufferevent_disable</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short <a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="separator:aa15582fe250247aa98d4897527215727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8236a058cbf059c2f2e3b10063c872b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#aa8236a058cbf059c2f2e3b10063c872b">bufferevent_settimeout</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, int timeout_read, int timeout_write)</td></tr>
<tr class="separator:aa8236a058cbf059c2f2e3b10063c872b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e3835e99f8eb73bb1cd7afa7427049"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a74e3835e99f8eb73bb1cd7afa7427049">bufferevent_setwatermark</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short events, size_t lowmark, size_t highmark)</td></tr>
<tr class="separator:a74e3835e99f8eb73bb1cd7afa7427049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebe44bfccd1d245cae17b1b7586092a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a8ebe44bfccd1d245cae17b1b7586092a">evbuffer_new</a> (void)</td></tr>
<tr class="separator:a8ebe44bfccd1d245cae17b1b7586092a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec1775b6bf61a6141c0a6843b8650d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a6ec1775b6bf61a6141c0a6843b8650d0">evbuffer_free</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *)</td></tr>
<tr class="separator:a6ec1775b6bf61a6141c0a6843b8650d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ab9ddfa6e5c44a995fdc7a3d1d9ab2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a78ab9ddfa6e5c44a995fdc7a3d1d9ab2">evbuffer_expand</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, size_t)</td></tr>
<tr class="separator:a78ab9ddfa6e5c44a995fdc7a3d1d9ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab652a2f82d23509713258a6e44697164"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ab652a2f82d23509713258a6e44697164">evbuffer_add</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, const void *, size_t)</td></tr>
<tr class="separator:ab652a2f82d23509713258a6e44697164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7fa5b23dee300713dd01bef841c6ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a7e7fa5b23dee300713dd01bef841c6ce">evbuffer_remove</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, void *, size_t)</td></tr>
<tr class="separator:a7e7fa5b23dee300713dd01bef841c6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcf61e69e7db74c29c8cdb7257ba0a0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a8fcf61e69e7db74c29c8cdb7257ba0a0">evbuffer_readline</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *)</td></tr>
<tr class="separator:a8fcf61e69e7db74c29c8cdb7257ba0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a295123af3ad09b6533cad34a67451"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a51a295123af3ad09b6533cad34a67451">evbuffer_add_buffer</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, struct <a class="el" href="structevbuffer.html">evbuffer</a> *)</td></tr>
<tr class="separator:a51a295123af3ad09b6533cad34a67451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9792469bec6ed712235c41a7c17637db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a9792469bec6ed712235c41a7c17637db">evbuffer_add_printf</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, const char *<a class="el" href="buf0dump_8cc.html#ad6ac843c40bd8448f37e3e704916e1f9">fmt</a>,...)</td></tr>
<tr class="separator:a9792469bec6ed712235c41a7c17637db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce39338da9b6cf8ecf1ef11eb898e41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#acce39338da9b6cf8ecf1ef11eb898e41">evbuffer_add_vprintf</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, const char *<a class="el" href="buf0dump_8cc.html#ad6ac843c40bd8448f37e3e704916e1f9">fmt</a>, va_list ap)</td></tr>
<tr class="separator:acce39338da9b6cf8ecf1ef11eb898e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2826b8da4931161cfcde35bf31b1bf5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a2826b8da4931161cfcde35bf31b1bf5f">evbuffer_drain</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, size_t)</td></tr>
<tr class="separator:a2826b8da4931161cfcde35bf31b1bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb1eb9fc521a1e10a01a365d6f74598"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#acbb1eb9fc521a1e10a01a365d6f74598">evbuffer_write</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, int)</td></tr>
<tr class="separator:acbb1eb9fc521a1e10a01a365d6f74598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d332b143e1654a1883c4b64de7fb11f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a7d332b143e1654a1883c4b64de7fb11f">evbuffer_read</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, int, int)</td></tr>
<tr class="separator:a7d332b143e1654a1883c4b64de7fb11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ad6c2569cf07b137f5d580f988fff4"><td class="memItemLeft" align="right" valign="top">u_char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a91ad6c2569cf07b137f5d580f988fff4">evbuffer_find</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, const u_char *, size_t)</td></tr>
<tr class="separator:a91ad6c2569cf07b137f5d580f988fff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dec925580c5c61cf3eaeb6323958680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#a7dec925580c5c61cf3eaeb6323958680">evbuffer_setcb</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *, void(*)(struct <a class="el" href="structevbuffer.html">evbuffer</a> *, size_t, size_t, void *), void *)</td></tr>
<tr class="separator:a7dec925580c5c61cf3eaeb6323958680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42029fb85fd8bdbd3d4b0d4fb07eedb1"><td class="memItemLeft" align="right" valign="top"><a id="a42029fb85fd8bdbd3d4b0d4fb07eedb1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_init</b> (void)</td></tr>
<tr class="separator:a42029fb85fd8bdbd3d4b0d4fb07eedb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323ba1fdf6f2a12f2d0bfbef75d0b2a0"><td class="memItemLeft" align="right" valign="top"><a id="a323ba1fdf6f2a12f2d0bfbef75d0b2a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_marshal</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t tag, const void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ev_uint32_t <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:a323ba1fdf6f2a12f2d0bfbef75d0b2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab447883b5f97b7820e7396f9478a3ef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_8h.html#ab447883b5f97b7820e7396f9478a3ef8">encode_int</a> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t number)</td></tr>
<tr class="separator:ab447883b5f97b7820e7396f9478a3ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21924dfc97056a88e97221b08e77de4"><td class="memItemLeft" align="right" valign="top"><a id="af21924dfc97056a88e97221b08e77de4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_marshal_int</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t tag, ev_uint32_t integer)</td></tr>
<tr class="separator:af21924dfc97056a88e97221b08e77de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8db60a9c4cd8ad2b0edc8faec1daf06"><td class="memItemLeft" align="right" valign="top"><a id="ad8db60a9c4cd8ad2b0edc8faec1daf06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_marshal_string</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ev_uint32_t tag, const char *string)</td></tr>
<tr class="separator:ad8db60a9c4cd8ad2b0edc8faec1daf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1663e1370fab412dc4cb6287e717af9f"><td class="memItemLeft" align="right" valign="top"><a id="a1663e1370fab412dc4cb6287e717af9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_marshal_timeval</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t tag, struct <a class="el" href="structtimeval.html">timeval</a> *tv)</td></tr>
<tr class="separator:a1663e1370fab412dc4cb6287e717af9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7344d5755e9125d565dcfd87381f87d9"><td class="memItemLeft" align="right" valign="top"><a id="a7344d5755e9125d565dcfd87381f87d9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_unmarshal</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *src, ev_uint32_t *ptag, struct <a class="el" href="structevbuffer.html">evbuffer</a> *dst)</td></tr>
<tr class="separator:a7344d5755e9125d565dcfd87381f87d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28430d262e4289fdb1c445e3ceb6f286"><td class="memItemLeft" align="right" valign="top"><a id="a28430d262e4289fdb1c445e3ceb6f286"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_peek</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t *ptag)</td></tr>
<tr class="separator:a28430d262e4289fdb1c445e3ceb6f286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca004e71e3217bf406be3fd75525caf"><td class="memItemLeft" align="right" valign="top"><a id="a8ca004e71e3217bf406be3fd75525caf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_peek_length</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t *plength)</td></tr>
<tr class="separator:a8ca004e71e3217bf406be3fd75525caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d569ee176b7c225f28ec611254c9da"><td class="memItemLeft" align="right" valign="top"><a id="a76d569ee176b7c225f28ec611254c9da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_payload_length</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t *plength)</td></tr>
<tr class="separator:a76d569ee176b7c225f28ec611254c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c7bbbd8e129138d9f0ef122fae90f2"><td class="memItemLeft" align="right" valign="top"><a id="a10c7bbbd8e129138d9f0ef122fae90f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_consume</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf)</td></tr>
<tr class="separator:a10c7bbbd8e129138d9f0ef122fae90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73031a48498064b6e64c66495768d86"><td class="memItemLeft" align="right" valign="top"><a id="aa73031a48498064b6e64c66495768d86"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_unmarshal_int</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t need_tag, ev_uint32_t *pinteger)</td></tr>
<tr class="separator:aa73031a48498064b6e64c66495768d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7c2d090a5b77291645e39d8f30df2a"><td class="memItemLeft" align="right" valign="top"><a id="a3f7c2d090a5b77291645e39d8f30df2a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_unmarshal_fixed</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *src, ev_uint32_t need_tag, void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, size_t <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:a3f7c2d090a5b77291645e39d8f30df2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d99d6b1369ce129ce12542228ab98f"><td class="memItemLeft" align="right" valign="top"><a id="a54d99d6b1369ce129ce12542228ab98f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_unmarshal_string</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t need_tag, char **pstring)</td></tr>
<tr class="separator:a54d99d6b1369ce129ce12542228ab98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154e7516c3eefa5e88014c26b863d00e"><td class="memItemLeft" align="right" valign="top"><a id="a154e7516c3eefa5e88014c26b863d00e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>evtag_unmarshal_timeval</b> (struct <a class="el" href="structevbuffer.html">evbuffer</a> *evbuf, ev_uint32_t need_tag, struct <a class="el" href="structtimeval.html">timeval</a> *ptv)</td></tr>
<tr class="separator:a154e7516c3eefa5e88014c26b863d00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A library for writing event-driven network servers </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afc20b949f93daebf2acb5bd81be24fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc20b949f93daebf2acb5bd81be24fff">&#9670;&nbsp;</a></span>event_initialized</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define event_initialized</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ev</td><td>)</td>
          <td>&#160;&#160;&#160;((ev)-&gt;ev_flags &amp; EVLIST_INIT)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if an event structure has been initialized.</p>
<p>The <a class="el" href="event_8h.html#afc20b949f93daebf2acb5bd81be24fff">event_initialized()</a> macro can be used to check if an event has been initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event structure to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the structure has been initialized, or 0 if it has not been initialized </dd></dl>

</div>
</div>
<a id="a10b9c102337d0ece8607c9c01bc4f7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b9c102337d0ece8607c9c01bc4f7c8">&#9670;&nbsp;</a></span>EVLOOP_NONBLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVLOOP_NONBLOCK&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not block. </p>

</div>
</div>
<a id="afab575b1e867dde13a2c7f2f967e0e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab575b1e867dde13a2c7f2f967e0e4e">&#9670;&nbsp;</a></span>EVLOOP_ONCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVLOOP_ONCE&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="event_8h.html#a765c1875642fc730addf04e9433f6448">event_loop()</a> flagsBlock at most once. </p>

</div>
</div>
<a id="a6ea3ca87057c66fd9f5a9fda9b911f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea3ca87057c66fd9f5a9fda9b911f8b">&#9670;&nbsp;</a></span>evtimer_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evtimer_add</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tv&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add</a>(ev, tv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a timer event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>the event struct </td></tr>
    <tr><td class="paramname">tv</td><td>timeval struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22f7e7b422e9098d9362626d47b77525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f7e7b422e9098d9362626d47b77525">&#9670;&nbsp;</a></span>evtimer_del</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evtimer_del</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ev</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del</a>(ev)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a timer event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>the event struct to be disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa5d72155d72931332ed0656fc8fb0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5d72155d72931332ed0656fc8fb0a1">&#9670;&nbsp;</a></span>evtimer_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evtimer_set</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set</a>(ev, -1, 0, cb, arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a timer event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>event struct to be modified </td></tr>
    <tr><td class="paramname">cb</td><td>callback function </td></tr>
    <tr><td class="paramname">arg</td><td>argument that will be passed to the callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af71bfd90dc9d00fb03545fe66c67d673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71bfd90dc9d00fb03545fe66c67d673">&#9670;&nbsp;</a></span>TAILQ_ENTRY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TAILQ_ENTRY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>{                                                                \</div><div class="line">        struct <a class="code" href="dict0load_8cc.html#ad30f5b5c3041ca36c76f4b062df095b4">type</a> *tqe_next;  <span class="comment">/* next element */</span>                      \</div><div class="line">        struct <a class="code" href="dict0load_8cc.html#ad30f5b5c3041ca36c76f4b062df095b4">type</a> **tqe_prev; <span class="comment">/* address of previous next element */</span>  \</div><div class="line">}</div><div class="ttc" id="dict0load_8cc_html_ad30f5b5c3041ca36c76f4b062df095b4"><div class="ttname"><a href="dict0load_8cc.html#ad30f5b5c3041ca36c76f4b062df095b4">type</a></div><div class="ttdeci">foreign type</div><div class="ttdef"><b>Definition:</b> dict0load.cc:2897</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afaf6ea49aab66ec47acd9f5b629bfe5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf6ea49aab66ec47acd9f5b629bfe5e">&#9670;&nbsp;</a></span>timeout_add</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define timeout_add</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tv&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add</a>(ev, tv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a timeout event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>the event struct to be disabled </td></tr>
    <tr><td class="paramname">tv</td><td>the timeout value, in seconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8febdc39e7def3c49deb1e9faa7fc537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8febdc39e7def3c49deb1e9faa7fc537">&#9670;&nbsp;</a></span>timeout_del</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define timeout_del</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ev</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del</a>(ev)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable a timeout event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>the timeout event to be disabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85e9253a4d75703692dd912be4a87aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e9253a4d75703692dd912be4a87aab">&#9670;&nbsp;</a></span>timeout_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define timeout_set</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set</a>(ev, -1, 0, cb, arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a timeout event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>the event struct to be defined </td></tr>
    <tr><td class="paramname">cb</td><td>the callback to be invoked when the timeout expires </td></tr>
    <tr><td class="paramname">arg</td><td>the argument to be passed to the callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0697dabdb9b4057ae71b40a2f0e45fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0697dabdb9b4057ae71b40a2f0e45fed">&#9670;&nbsp;</a></span>bufferevent_base_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_base_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign a bufferevent to a specific <a class="el" href="structevent__base.html">event_base</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>an <a class="el" href="structevent__base.html">event_base</a> returned by <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </td></tr>
    <tr><td class="paramname">bufev</td><td>a bufferevent struct returned by <a class="el" href="event_8h.html#a3110aae725315e58a1fe0c667efe7619">bufferevent_new()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a3110aae725315e58a1fe0c667efe7619">bufferevent_new()</a> </dd></dl>

</div>
</div>
<a id="aa15582fe250247aa98d4897527215727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15582fe250247aa98d4897527215727">&#9670;&nbsp;</a></span>bufferevent_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_disable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable a bufferevent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be disabled </td></tr>
    <tr><td class="paramname">event</td><td>any combination of EV_READ | EV_WRITE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a1b9a3412e8c8e122c745b33d46b9643e">bufferevent_enable()</a> </dd></dl>

</div>
</div>
<a id="a1b9a3412e8c8e122c745b33d46b9643e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9a3412e8c8e122c745b33d46b9643e">&#9670;&nbsp;</a></span>bufferevent_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable a bufferevent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be enabled </td></tr>
    <tr><td class="paramname">event</td><td>any combination of EV_READ | EV_WRITE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#aa15582fe250247aa98d4897527215727">bufferevent_disable()</a> </dd></dl>

</div>
</div>
<a id="a474a4cef8fd80bea09a636b5f3055bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474a4cef8fd80bea09a636b5f3055bec">&#9670;&nbsp;</a></span>bufferevent_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate the storage associated with a bufferevent structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent structure to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3110aae725315e58a1fe0c667efe7619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3110aae725315e58a1fe0c667efe7619">&#9670;&nbsp;</a></span>bufferevent_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbufferevent.html">bufferevent</a>* bufferevent_new </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evbuffercb&#160;</td>
          <td class="paramname"><em>readcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evbuffercb&#160;</td>
          <td class="paramname"><em>writecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">everrorcb&#160;</td>
          <td class="paramname"><em>errorcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cbarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new bufferevent.</p>
<p>libevent provides an abstraction on top of the regular event callbacks. This abstraction is called a buffered event. A buffered event provides input and output buffers that get filled and drained automatically. The user of a buffered event no longer deals directly with the I/O, but instead is reading from input and writing to output buffers.</p>
<p>Once initialized, the bufferevent structure can be used repeatedly with <a class="el" href="event_8h.html#a1b9a3412e8c8e122c745b33d46b9643e">bufferevent_enable()</a> and <a class="el" href="event_8h.html#aa15582fe250247aa98d4897527215727">bufferevent_disable()</a>.</p>
<p>When read enabled the bufferevent will try to read from the file descriptor and call the read callback. The write callback is executed whenever the output buffer is drained below the write low watermark, which is 0 by default.</p>
<p>If multiple bases are in use, <a class="el" href="event_8h.html#a0697dabdb9b4057ae71b40a2f0e45fed">bufferevent_base_set()</a> must be called before enabling the bufferevent for the first time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>the file descriptor from which data is read and written to. This file descriptor is not allowed to be a pipe(2). </td></tr>
    <tr><td class="paramname">readcb</td><td>callback to invoke when there is data to be read, or NULL if no callback is desired </td></tr>
    <tr><td class="paramname">writecb</td><td>callback to invoke when the file descriptor is ready for writing, or NULL if no callback is desired </td></tr>
    <tr><td class="paramname">errorcb</td><td>callback to invoke when there is an error on the file descriptor </td></tr>
    <tr><td class="paramname">cbarg</td><td>an argument that will be supplied to each of the callbacks (readcb, writecb, and errorcb) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly allocated bufferevent struct, or NULL if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a0697dabdb9b4057ae71b40a2f0e45fed">bufferevent_base_set()</a>, <a class="el" href="event_8h.html#a474a4cef8fd80bea09a636b5f3055bec">bufferevent_free()</a> </dd></dl>

</div>
</div>
<a id="a73e1daaa7c4d52c95b16c9944fa62e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e1daaa7c4d52c95b16c9944fa62e90">&#9670;&nbsp;</a></span>bufferevent_priority_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_priority_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign a priority to a bufferevent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>a bufferevent struct </td></tr>
    <tr><td class="paramname">pri</td><td>the priority to be assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a id="a6bd435529e20a39b24fead9ddcd966ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd435529e20a39b24fead9ddcd966ba">&#9670;&nbsp;</a></span>bufferevent_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t bufferevent_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from a bufferevent buffer.</p>
<p>The <a class="el" href="event_8h.html#a6bd435529e20a39b24fead9ddcd966ba">bufferevent_read()</a> function is used to read data from the input buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be read from </td></tr>
    <tr><td class="paramname">data</td><td>pointer to a buffer that will store the data </td></tr>
    <tr><td class="paramname">size</td><td>the size of the data buffer, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amount of data read, in bytes. </dd></dl>

</div>
</div>
<a id="a0b950fe07eae442b2ca4f4ff4a677253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b950fe07eae442b2ca4f4ff4a677253">&#9670;&nbsp;</a></span>bufferevent_setcb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_setcb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evbuffercb&#160;</td>
          <td class="paramname"><em>readcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evbuffercb&#160;</td>
          <td class="paramname"><em>writecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">everrorcb&#160;</td>
          <td class="paramname"><em>errorcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cbarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the callbacks for a bufferevent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent object for which to change callbacks </td></tr>
    <tr><td class="paramname">readcb</td><td>callback to invoke when there is data to be read, or NULL if no callback is desired </td></tr>
    <tr><td class="paramname">writecb</td><td>callback to invoke when the file descriptor is ready for writing, or NULL if no callback is desired </td></tr>
    <tr><td class="paramname">errorcb</td><td>callback to invoke when there is an error on the file descriptor </td></tr>
    <tr><td class="paramname">cbarg</td><td>an argument that will be supplied to each of the callbacks (readcb, writecb, and errorcb) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a3110aae725315e58a1fe0c667efe7619">bufferevent_new()</a> </dd></dl>

</div>
</div>
<a id="a91a989ad7a7d595ac0ce3a6cd65b8a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a989ad7a7d595ac0ce3a6cd65b8a76">&#9670;&nbsp;</a></span>bufferevent_setfd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_setfd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the file descriptor on which the bufferevent operates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent object for which to change the file descriptor </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor to operate on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8236a058cbf059c2f2e3b10063c872b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8236a058cbf059c2f2e3b10063c872b">&#9670;&nbsp;</a></span>bufferevent_settimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_settimeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the read and write timeout for a buffered event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be modified </td></tr>
    <tr><td class="paramname">timeout_read</td><td>the read timeout </td></tr>
    <tr><td class="paramname">timeout_write</td><td>the write timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74e3835e99f8eb73bb1cd7afa7427049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e3835e99f8eb73bb1cd7afa7427049">&#9670;&nbsp;</a></span>bufferevent_setwatermark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufferevent_setwatermark </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lowmark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>highmark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the watermarks for read and write events.</p>
<p>On input, a bufferevent does not invoke the user read callback unless there is at least low watermark data in the buffer. If the read buffer is beyond the high watermark, the buffevent stops reading from the network.</p>
<p>On output, the user write callback is invoked whenever the buffered data falls below the low watermark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be modified </td></tr>
    <tr><td class="paramname">events</td><td>EV_READ, EV_WRITE or both </td></tr>
    <tr><td class="paramname">lowmark</td><td>the lower watermark to set </td></tr>
    <tr><td class="paramname">highmark</td><td>the high watermark to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc606695cd6bb2e3f25c4330d0c9e3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc606695cd6bb2e3f25c4330d0c9e3ab">&#9670;&nbsp;</a></span>bufferevent_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data to a bufferevent buffer.</p>
<p>The <a class="el" href="event_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab">bufferevent_write()</a> function can be used to write data to the file descriptor. The data is appended to the output buffer and written to the descriptor automatically as it becomes available for writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be written to </td></tr>
    <tr><td class="paramname">data</td><td>a pointer to the data to be written </td></tr>
    <tr><td class="paramname">size</td><td>the length of the data, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a3b140a32a4d16c402433130dc8c3bde4">bufferevent_write_buffer()</a> </dd></dl>

</div>
</div>
<a id="a3b140a32a4d16c402433130dc8c3bde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b140a32a4d16c402433130dc8c3bde4">&#9670;&nbsp;</a></span>bufferevent_write_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bufferevent_write_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data from an evbuffer to a bufferevent buffer. The evbuffer is being drained as a result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be written to </td></tr>
    <tr><td class="paramname">buf</td><td>the evbuffer to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab">bufferevent_write()</a> </dd></dl>

</div>
</div>
<a id="ab447883b5f97b7820e7396f9478a3ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab447883b5f97b7820e7396f9478a3ef8">&#9670;&nbsp;</a></span>encode_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_int </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>evbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint32_t&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encode an integer and store it in an evbuffer.</p>
<p>We encode integer's by nibbles; the first nibble contains the number of significant nibbles - 1; this allows us to encode up to 64-bit integers. This function is byte-order independent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evbuf</td><td>evbuffer to store the encoded number </td></tr>
    <tr><td class="paramname">number</td><td>a 32-bit integer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab652a2f82d23509713258a6e44697164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab652a2f82d23509713258a6e44697164">&#9670;&nbsp;</a></span>evbuffer_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append data to the end of an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the event buffer to be appended to </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the beginning of the data buffer </td></tr>
    <tr><td class="paramname">datlen</td><td>the number of bytes to be copied from the data buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51a295123af3ad09b6533cad34a67451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a295123af3ad09b6533cad34a67451">&#9670;&nbsp;</a></span>evbuffer_add_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add_buffer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move data from one evbuffer into another evbuffer.</p>
<p>This is a destructive add. The data from one buffer moves into the other buffer. The destination buffer is expanded as needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outbuf</td><td>the output buffer </td></tr>
    <tr><td class="paramname">inbuf</td><td>the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a id="a9792469bec6ed712235c41a7c17637db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9792469bec6ed712235c41a7c17637db">&#9670;&nbsp;</a></span>evbuffer_add_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add_printf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a formatted string to the end of an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer that will be appended to </td></tr>
    <tr><td class="paramname">fmt</td><td>a format string </td></tr>
    <tr><td class="paramname">...</td><td>arguments that will be passed to printf(3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes added if successful, or -1 if an error occurred. </dd></dl>

</div>
</div>
<a id="acce39338da9b6cf8ecf1ef11eb898e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce39338da9b6cf8ecf1ef11eb898e41">&#9670;&nbsp;</a></span>evbuffer_add_vprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_add_vprintf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a va_list formatted string to the end of an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer that will be appended to </td></tr>
    <tr><td class="paramname">fmt</td><td>a format string </td></tr>
    <tr><td class="paramname">ap</td><td>a varargs va_list argument array that will be passed to vprintf(3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes added if successful, or -1 if an error occurred. </dd></dl>

</div>
</div>
<a id="a2826b8da4931161cfcde35bf31b1bf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2826b8da4931161cfcde35bf31b1bf5f">&#9670;&nbsp;</a></span>evbuffer_drain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evbuffer_drain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a specified number of bytes data from the beginning of an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to be drained </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes to drain from the beginning of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78ab9ddfa6e5c44a995fdc7a3d1d9ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ab9ddfa6e5c44a995fdc7a3d1d9ab2">&#9670;&nbsp;</a></span>evbuffer_expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_expand </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expands the available space in an event buffer.</p>
<p>Expands the available space in the event buffer to at least datlen</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the event buffer to be expanded </td></tr>
    <tr><td class="paramname">datlen</td><td>the new minimum length requirement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a id="a91ad6c2569cf07b137f5d580f988fff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ad6c2569cf07b137f5d580f988fff4">&#9670;&nbsp;</a></span>evbuffer_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_char* evbuffer_find </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u_char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a string within an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be searched </td></tr>
    <tr><td class="paramname">what</td><td>the string to be searched for </td></tr>
    <tr><td class="paramname">len</td><td>the length of the search string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the beginning of the search string, or NULL if the search failed. </dd></dl>

</div>
</div>
<a id="a6ec1775b6bf61a6141c0a6843b8650d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec1775b6bf61a6141c0a6843b8650d0">&#9670;&nbsp;</a></span>evbuffer_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evbuffer_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate storage for an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>to the evbuffer to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ebe44bfccd1d245cae17b1b7586092a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebe44bfccd1d245cae17b1b7586092a">&#9670;&nbsp;</a></span>evbuffer_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer.html">evbuffer</a>* evbuffer_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate storage for a new evbuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a newly allocated evbuffer struct, or NULL if an error occurred </dd></dl>

</div>
</div>
<a id="a7d332b143e1654a1883c4b64de7fb11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d332b143e1654a1883c4b64de7fb11f">&#9670;&nbsp;</a></span>evbuffer_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read from a file descriptor and store the result in an evbuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the evbuffer to store the result </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor to read from </td></tr>
    <tr><td class="paramname">howmuch</td><td>the number of bytes to be read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#acbb1eb9fc521a1e10a01a365d6f74598">evbuffer_write()</a> </dd></dl>

</div>
</div>
<a id="a8fcf61e69e7db74c29c8cdb7257ba0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcf61e69e7db74c29c8cdb7257ba0a0">&#9670;&nbsp;</a></span>evbuffer_readline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* evbuffer_readline </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a single line from an event buffer.</p>
<p>Reads a line terminated by either '<br />
', '<br />
' or '' or '<br />
'. The returned buffer needs to be freed by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a single line, or NULL if an error occurred </dd></dl>

</div>
</div>
<a id="a7e7fa5b23dee300713dd01bef841c6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7fa5b23dee300713dd01bef841c6ce">&#9670;&nbsp;</a></span>evbuffer_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from an event buffer and drain the bytes read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the event buffer to be read from </td></tr>
    <tr><td class="paramname">data</td><td>the destination buffer to store the result </td></tr>
    <tr><td class="paramname">datlen</td><td>the maximum size of the destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read </dd></dl>

</div>
</div>
<a id="a7dec925580c5c61cf3eaeb6323958680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dec925580c5c61cf3eaeb6323958680">&#9670;&nbsp;</a></span>evbuffer_setcb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void evbuffer_setcb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct <a class="el" href="structevbuffer.html">evbuffer</a> *, size_t, size_t, void *)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a callback to invoke when the evbuffer is modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be monitored </td></tr>
    <tr><td class="paramname">cb</td><td>the callback function to invoke when the evbuffer is modified </td></tr>
    <tr><td class="paramname">cbarg</td><td>an argument to be provided to the callback function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbb1eb9fc521a1e10a01a365d6f74598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb1eb9fc521a1e10a01a365d6f74598">&#9670;&nbsp;</a></span>evbuffer_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int evbuffer_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the contents of an evbuffer to a file descriptor.</p>
<p>The evbuffer will be drained after the bytes have been successfully written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the evbuffer to be written and drained </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor to be written to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a7d332b143e1654a1883c4b64de7fb11f">evbuffer_read()</a> </dd></dl>

</div>
</div>
<a id="a44df7b40859b56f2c866adb02dabdd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44df7b40859b56f2c866adb02dabdd9e">&#9670;&nbsp;</a></span>event_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtimeval.html">timeval</a> *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an event to the set of monitored events.</p>
<p>The function <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add()</a> schedules the execution of the ev event when the event specified in <a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set()</a> occurs or in at least the time specified in the tv. If tv is NULL, no timeout occurs and the function will only be called if a matching event occurs on the file descriptor. The event in the ev argument must be already initialized by <a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set()</a> and may not be used in calls to <a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set()</a> until it has timed out or been removed with <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del()</a>. If the event in the ev argument already has a scheduled timeout, the old timeout will be replaced by the new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct initialized via <a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set()</a> </td></tr>
    <tr><td class="paramname">timeout</td><td>the maximum amount of time to wait for the event, or NULL to wait forever </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del()</a>, <a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set()</a> </dd></dl>

</div>
</div>
<a id="a01e457364ed5216a8c7bc219033b946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e457364ed5216a8c7bc219033b946f">&#9670;&nbsp;</a></span>event_base_dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_dispatch </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Threadsafe event dispatching loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a>, <a class="el" href="event_8h.html#a1f4991bceb8aaf33545d1fc857230b51">event_dispatch()</a> </dd></dl>

</div>
</div>
<a id="a6e9827de8c3014417b11b48f2fe688ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9827de8c3014417b11b48f2fe688ae">&#9670;&nbsp;</a></span>event_base_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_base_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate all memory associated with an <a class="el" href="structevent__base.html">event_base</a>, and free the base.</p>
<p>Note that this function will not close any fds or free any memory passed to event_set as the argument to callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>an <a class="el" href="structevent__base.html">event_base</a> to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeba9db037ed6bb6f13d16d1720ac6d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba9db037ed6bb6f13d16d1720ac6d4a">&#9670;&nbsp;</a></span>event_base_get_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* event_base_get_method </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the kernel event notification mechanism used by libevent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353">event_base_new()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string identifying the kernel event mechanism (kqueue, epoll, etc.) </dd></dl>

</div>
</div>
<a id="ad712706e6a763b6662f0eb03b3d8cd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad712706e6a763b6662f0eb03b3d8cd80">&#9670;&nbsp;</a></span>event_base_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_loop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle events (threadsafe version).</p>
<p>This is a more flexible version of <a class="el" href="event_8h.html#a01e457364ed5216a8c7bc219033b946f">event_base_dispatch()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </td></tr>
    <tr><td class="paramname">flags</td><td>any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if an error occurred, or 1 if no events were registered. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a2e3d894ac7986bb4967ebfe67a2d9977">event_loopexit()</a>, <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop()</a> </dd></dl>

</div>
</div>
<a id="a07a7599e478e4031fa8cf52e26d8aa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a7599e478e4031fa8cf52e26d8aa1e">&#9670;&nbsp;</a></span>event_base_loopbreak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_loopbreak </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abort the active <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop()</a> immediately.</p>
<p><a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop()</a> will abort the loop after the next event is completed; <a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e">event_base_loopbreak()</a> is typically invoked from this event's callback. This behavior is analogous to the "break;" statement.</p>
<p>Subsequent invocations of <a class="el" href="event_8h.html#a765c1875642fc730addf04e9433f6448">event_loop()</a> will proceed normally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#ac2c66174ee5f10df65b9a9b62fca7dd9">event_base_loopexit</a> </dd></dl>

</div>
</div>
<a id="ac2c66174ee5f10df65b9a9b62fca7dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c66174ee5f10df65b9a9b62fca7dd9">&#9670;&nbsp;</a></span>event_base_loopexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_loopexit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtimeval.html">timeval</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exit the event loop after the specified time (threadsafe variant).</p>
<p>The next <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop()</a> iteration after the given timer expires will complete normally (handling all queued events) then exit without blocking for events again.</p>
<p>Subsequent invocations of <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop()</a> will proceed normally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </td></tr>
    <tr><td class="paramname">tv</td><td>the amount of time after which the loop should terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a2e3d894ac7986bb4967ebfe67a2d9977">event_loopexit()</a> </dd></dl>

</div>
</div>
<a id="a4c16f1203aebc67f94791ae0240b7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c16f1203aebc67f94791ae0240b7353">&#9670;&nbsp;</a></span>event_base_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevent__base.html">event_base</a>* event_base_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the event API.</p>
<p>Use <a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353">event_base_new()</a> to initialize a new event base, but does not set the current_base global. If using only <a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353">event_base_new()</a>, each event added must have an event base set with <a class="el" href="event_8h.html#a2efd0ac7e54428d1941f212bc16ed9ce">event_base_set()</a></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a2efd0ac7e54428d1941f212bc16ed9ce">event_base_set()</a>, <a class="el" href="event_8h.html#a6e9827de8c3014417b11b48f2fe688ae">event_base_free()</a>, <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </dd></dl>

</div>
</div>
<a id="ab10a8706318c18a2c014f1faa3fae852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10a8706318c18a2c014f1faa3fae852">&#9670;&nbsp;</a></span>event_base_once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_once </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, short, void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtimeval.html">timeval</a> *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a one-time event (threadsafe variant)</p>
<p>The function <a class="el" href="event_8h.html#ab10a8706318c18a2c014f1faa3fae852">event_base_once()</a> is similar to <a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set()</a>. However, it schedules a callback to be called exactly once and does not require the caller to prepare an event structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>an <a class="el" href="structevent__base.html">event_base</a> returned by <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </td></tr>
    <tr><td class="paramname">fd</td><td>a file descriptor to monitor </td></tr>
    <tr><td class="paramname">events</td><td><a class="el" href="structevent.html">event(s)</a> to monitor; can be any of EV_TIMEOUT | EV_READ | EV_WRITE </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked when the event occurs </td></tr>
    <tr><td class="paramname">arg</td><td>an argument to be passed to the callback function </td></tr>
    <tr><td class="paramname">timeout</td><td>the maximum amount of time to wait for the event, or NULL to wait forever </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a450e7c610ac0e321168f036350c36d54">event_once()</a> </dd></dl>

</div>
</div>
<a id="a67067fe995561cd36a7f34ef19e030e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67067fe995561cd36a7f34ef19e030e8">&#9670;&nbsp;</a></span>event_base_priority_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_priority_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number of different event priorities (threadsafe variant).</p>
<p>See the description of <a class="el" href="event_8h.html#ac98d83bce2fe3e97ac655329fb30fccb">event_priority_init()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the <a class="el" href="structevent__base.html">event_base</a> structure returned by <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </td></tr>
    <tr><td class="paramname">npriorities</td><td>the maximum number of priorities </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#ac98d83bce2fe3e97ac655329fb30fccb">event_priority_init()</a>, <a class="el" href="event_8h.html#a9984a63f2edcc72bef96a188f569b367">event_priority_set()</a> </dd></dl>

</div>
</div>
<a id="a2efd0ac7e54428d1941f212bc16ed9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efd0ac7e54428d1941f212bc16ed9ce">&#9670;&nbsp;</a></span>event_base_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_base_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associate a different event base with an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eb</td><td>the event base </td></tr>
    <tr><td class="paramname">ev</td><td>the event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30a8cb96af49d18388f64de73a2d4258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a8cb96af49d18388f64de73a2d4258">&#9670;&nbsp;</a></span>event_del()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_del </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an event from the set of monitored events.</p>
<p>The function <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del()</a> will cancel the event in the argument ev. If the event has already executed or has never been added the call will have no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct to be removed from the working set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add()</a> </dd></dl>

</div>
</div>
<a id="a1f4991bceb8aaf33545d1fc857230b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4991bceb8aaf33545d1fc857230b51">&#9670;&nbsp;</a></span>event_dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_dispatch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop to process events.</p>
<p>In order to process events, an application needs to call <a class="el" href="event_8h.html#a1f4991bceb8aaf33545d1fc857230b51">event_dispatch()</a>. This function only returns on error, and should replace the event core of the application program.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a01e457364ed5216a8c7bc219033b946f">event_base_dispatch()</a> </dd></dl>

</div>
</div>
<a id="a8a03c9175e0578017a384b4c039b090f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a03c9175e0578017a384b4c039b090f">&#9670;&nbsp;</a></span>event_get_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* event_get_method </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the kernel event notification mechanism used by libevent.</p>
<dl class="section return"><dt>Returns</dt><dd>a string identifying the kernel event mechanism (kqueue, epoll, etc.) </dd></dl>

</div>
</div>
<a id="a43d7feed94477cf0a7e3e062cc17b7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d7feed94477cf0a7e3e062cc17b7e1">&#9670;&nbsp;</a></span>event_get_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* event_get_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the libevent version number.</p>
<dl class="section return"><dt>Returns</dt><dd>a string containing the version number of libevent </dd></dl>

</div>
</div>
<a id="a1bf74386dd3725e1538fed2d70c1c113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf74386dd3725e1538fed2d70c1c113">&#9670;&nbsp;</a></span>event_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevent__base.html">event_base</a>* event_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the event API.</p>
<p>The event API needs to be initialized with <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> before it can be used. Sets the current_base global representing the default base for events that have no base associated with them.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a2efd0ac7e54428d1941f212bc16ed9ce">event_base_set()</a>, <a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353">event_base_new()</a> </dd></dl>

</div>
</div>
<a id="a765c1875642fc730addf04e9433f6448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765c1875642fc730addf04e9433f6448">&#9670;&nbsp;</a></span>event_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_loop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle events.</p>
<p>This is a more flexible version of <a class="el" href="event_8h.html#a1f4991bceb8aaf33545d1fc857230b51">event_dispatch()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 if an error occurred, or 1 if no events were registered. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a2e3d894ac7986bb4967ebfe67a2d9977">event_loopexit()</a>, <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop()</a> </dd></dl>

</div>
</div>
<a id="a3a5c57caea1d97160f6990b3deeb6961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5c57caea1d97160f6990b3deeb6961">&#9670;&nbsp;</a></span>event_loopbreak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_loopbreak </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abort the active <a class="el" href="event_8h.html#a765c1875642fc730addf04e9433f6448">event_loop()</a> immediately.</p>
<p><a class="el" href="event_8h.html#a765c1875642fc730addf04e9433f6448">event_loop()</a> will abort the loop after the next event is completed; <a class="el" href="event_8h.html#a3a5c57caea1d97160f6990b3deeb6961">event_loopbreak()</a> is typically invoked from this event's callback. This behavior is analogous to the "break;" statement.</p>
<p>Subsequent invocations of <a class="el" href="event_8h.html#a765c1875642fc730addf04e9433f6448">event_loop()</a> will proceed normally.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a07a7599e478e4031fa8cf52e26d8aa1e">event_base_loopbreak()</a>, <a class="el" href="event_8h.html#a2e3d894ac7986bb4967ebfe67a2d9977">event_loopexit()</a> </dd></dl>

</div>
</div>
<a id="a2e3d894ac7986bb4967ebfe67a2d9977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3d894ac7986bb4967ebfe67a2d9977">&#9670;&nbsp;</a></span>event_loopexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_loopexit </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtimeval.html">timeval</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exit the event loop after the specified time.</p>
<p>The next <a class="el" href="event_8h.html#a765c1875642fc730addf04e9433f6448">event_loop()</a> iteration after the given timer expires will complete normally (handling all queued events) then exit without blocking for events again.</p>
<p>Subsequent invocations of <a class="el" href="event_8h.html#a765c1875642fc730addf04e9433f6448">event_loop()</a> will proceed normally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tv</td><td>the amount of time after which the loop should terminate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a765c1875642fc730addf04e9433f6448">event_loop()</a>, <a class="el" href="event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop()</a>, <a class="el" href="event_8h.html#ac2c66174ee5f10df65b9a9b62fca7dd9">event_base_loopexit()</a> </dd></dl>

</div>
</div>
<a id="a450e7c610ac0e321168f036350c36d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450e7c610ac0e321168f036350c36d54">&#9670;&nbsp;</a></span>event_once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structevent__once.html">event_once</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, short, void *)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtimeval.html">timeval</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Schedule a one-time event to occur.</p>
<p>The function <a class="el" href="event_8h.html#a450e7c610ac0e321168f036350c36d54">event_once()</a> is similar to <a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set()</a>. However, it schedules a callback to be called exactly once and does not require the caller to prepare an event structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>a file descriptor to monitor </td></tr>
    <tr><td class="paramname">events</td><td><a class="el" href="structevent.html">event(s)</a> to monitor; can be any of EV_TIMEOUT | EV_READ | EV_WRITE </td></tr>
    <tr><td class="paramname">callback</td><td>callback function to be invoked when the event occurs </td></tr>
    <tr><td class="paramname">arg</td><td>an argument to be passed to the callback function </td></tr>
    <tr><td class="paramname">timeout</td><td>the maximum amount of time to wait for the event, or NULL to wait forever </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set()</a> </dd></dl>

</div>
</div>
<a id="abf39a907d20c1612adc310c123648b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf39a907d20c1612adc310c123648b63">&#9670;&nbsp;</a></span>event_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_pending </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structtimeval.html">timeval</a> *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a specific event is pending or scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct previously passed to <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add()</a> </td></tr>
    <tr><td class="paramname">event</td><td>the requested event type; any of EV_TIMEOUT|EV_READ| EV_WRITE|EV_SIGNAL </td></tr>
    <tr><td class="paramname">tv</td><td>an alternate timeout (FIXME - is this true?)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the event is pending, or 0 if the event has not occurred </dd></dl>

</div>
</div>
<a id="ac98d83bce2fe3e97ac655329fb30fccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98d83bce2fe3e97ac655329fb30fccb">&#9670;&nbsp;</a></span>event_priority_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_priority_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number of different event priorities.</p>
<p>By default libevent schedules all active events with the same priority. However, some time it is desirable to process some events with a higher priority than others. For that reason, libevent supports strict priority queues. Active events with a lower priority are always processed before events with a higher priority.</p>
<p>The number of different priorities can be set initially with the <a class="el" href="event_8h.html#ac98d83bce2fe3e97ac655329fb30fccb">event_priority_init()</a> function. This function should be called before the first call to <a class="el" href="event_8h.html#a1f4991bceb8aaf33545d1fc857230b51">event_dispatch()</a>. The <a class="el" href="event_8h.html#a9984a63f2edcc72bef96a188f569b367">event_priority_set()</a> function can be used to assign a priority to an event. By default, libevent assigns the middle priority to all events unless their priority is explicitly set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">npriorities</td><td>the maximum number of priorities </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a67067fe995561cd36a7f34ef19e030e8">event_base_priority_init()</a>, <a class="el" href="event_8h.html#a9984a63f2edcc72bef96a188f569b367">event_priority_set()</a> </dd></dl>

</div>
</div>
<a id="a9984a63f2edcc72bef96a188f569b367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9984a63f2edcc72bef96a188f569b367">&#9670;&nbsp;</a></span>event_priority_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_priority_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign a priority to an event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct </td></tr>
    <tr><td class="paramname">priority</td><td>the new priority to be assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#ac98d83bce2fe3e97ac655329fb30fccb">event_priority_init()</a> </dd></dl>

</div>
</div>
<a id="a7409499a79a59842955928af446fe03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7409499a79a59842955928af446fe03d">&#9670;&nbsp;</a></span>event_reinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int event_reinit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialized the event base after a fork</p>
<p>Some event mechanisms do not survive across fork. The event base needs to be reinitialized with the <a class="el" href="event_8h.html#a7409499a79a59842955928af446fe03d">event_reinit()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the event base that needs to be re-initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if some events could not be re-added. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a4c16f1203aebc67f94791ae0240b7353">event_base_new()</a>, <a class="el" href="event_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </dd></dl>

</div>
</div>
<a id="a24235e12d151db1782f792e14c83cf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24235e12d151db1782f792e14c83cf82">&#9670;&nbsp;</a></span>event_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent.html">event</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int, short, void *)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare an event structure to be added.</p>
<p>The function <a class="el" href="event_8h.html#a24235e12d151db1782f792e14c83cf82">event_set()</a> prepares the event structure ev to be used in future calls to <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add()</a> and <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del()</a>. The event will be prepared to call the function specified by the fn argument with an int argument indicating the file descriptor, a short argument indicating the type of event, and a void * argument given in the arg argument. The fd indicates the file descriptor that should be monitored for events. The events can be either EV_READ, EV_WRITE, or both. Indicating that an application can read or write from the file descriptor respectively without blocking.</p>
<p>The function fn will be called with the file descriptor that triggered the event and the type of event which will be either EV_TIMEOUT, EV_SIGNAL, EV_READ, or EV_WRITE. The additional flag EV_PERSIST makes an <a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add()</a> persistent until <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del()</a> has been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>an event struct to be modified </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor to be monitored </td></tr>
    <tr><td class="paramname">event</td><td>desired events to monitor; can be EV_READ and/or EV_WRITE </td></tr>
    <tr><td class="paramname">fn</td><td>callback function to be invoked when the event occurs </td></tr>
    <tr><td class="paramname">arg</td><td>an argument to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add()</a>, <a class="el" href="event_8h.html#a30a8cb96af49d18388f64de73a2d4258">event_del()</a>, <a class="el" href="event_8h.html#a450e7c610ac0e321168f036350c36d54">event_once()</a> </dd></dl>

</div>
</div>
<a id="a87e59ed1dd711ced2b2a1314d3e3c1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e59ed1dd711ced2b2a1314d3e3c1c7">&#9670;&nbsp;</a></span>event_set_log_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void event_set_log_callback </td>
          <td>(</td>
          <td class="paramtype">event_log_cb&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Redirect libevent's log messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>a function taking two arguments: an integer severity between _EVENT_LOG_DEBUG and _EVENT_LOG_ERR, and a string. If cb is NULL, then the default log is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/btr/btr0sea.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_f48f5f24c3af6e5b48618127168756b9.html">btr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">btr0sea.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0cur_8h_source.html">page0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0pcur_8h_source.html">btr0pcur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha0ha_8h_source.html">ha0ha.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0fd390dc9999c8e5cb9a1c8aad8a82bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a0fd390dc9999c8e5cb9a1c8aad8a82bd">BTR_SEARCH_PAGE_BUILD_LIMIT</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a0fd390dc9999c8e5cb9a1c8aad8a82bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215610cf6902258f236d650e3a1d5799"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a215610cf6902258f236d650e3a1d5799">BTR_SEARCH_BUILD_LIMIT</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:a215610cf6902258f236d650e3a1d5799"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa2706205f14a999f2e1c72c9c4fbfca7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#aa2706205f14a999f2e1c72c9c4fbfca7">btr_search_build_page_hash_index</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint <a class="el" href="row0merge_8cc.html#ac496ec05ddad9f1550478aec28d4dff0">n_fields</a>, ulint n_bytes, ibool left_side)</td></tr>
<tr class="separator:aa2706205f14a999f2e1c72c9c4fbfca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dfd4dd81154625505d48774e845020"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a97dfd4dd81154625505d48774e845020">btr_search_check_free_space_in_heap</a> (void)</td></tr>
<tr class="separator:a97dfd4dd81154625505d48774e845020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac539344c8c4a918f2461b7e2ea374"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#af1ac539344c8c4a918f2461b7e2ea374">btr_search_sys_create</a> (ulint hash_size)</td></tr>
<tr class="separator:af1ac539344c8c4a918f2461b7e2ea374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79ad1bd64e5cb2586daced8398c8779"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ad79ad1bd64e5cb2586daced8398c8779">btr_search_sys_free</a> (void)</td></tr>
<tr class="separator:ad79ad1bd64e5cb2586daced8398c8779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad123c65cc521709b8de09e84cead6951"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ad123c65cc521709b8de09e84cead6951">btr_search_disable_ref_count</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ad123c65cc521709b8de09e84cead6951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90851ab21895f360e3417e6208d4f559"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a90851ab21895f360e3417e6208d4f559">btr_search_disable</a> (void)</td></tr>
<tr class="separator:a90851ab21895f360e3417e6208d4f559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ffffd2a89c8d7ce0afcbf0f920fd6d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a05ffffd2a89c8d7ce0afcbf0f920fd6d">btr_search_enable</a> (void)</td></tr>
<tr class="separator:a05ffffd2a89c8d7ce0afcbf0f920fd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72c58cd4b8267eb55d3b5b61979ec13"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbtr__search__t.html">btr_search_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ab72c58cd4b8267eb55d3b5b61979ec13">btr_search_info_create</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:ab72c58cd4b8267eb55d3b5b61979ec13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dea0b428b64f76d6660e0aa9ea4ba4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ad6dea0b428b64f76d6660e0aa9ea4ba4">btr_search_info_get_ref_count</a> (<a class="el" href="structbtr__search__t.html">btr_search_t</a> *info)</td></tr>
<tr class="separator:ad6dea0b428b64f76d6660e0aa9ea4ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb49172aedff1ca4fd17223e40d826c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#aecb49172aedff1ca4fd17223e40d826c">btr_search_info_update_hash</a> (<a class="el" href="structbtr__search__t.html">btr_search_t</a> *info, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:aecb49172aedff1ca4fd17223e40d826c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97428cdc2320a6a02ed1f17e0803dd8"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ae97428cdc2320a6a02ed1f17e0803dd8">btr_search_update_block_hash_info</a> (<a class="el" href="structbtr__search__t.html">btr_search_t</a> *info, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a> <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:ae97428cdc2320a6a02ed1f17e0803dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78243fd0783f8dc787a0faaf8e10d13"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ae78243fd0783f8dc787a0faaf8e10d13">btr_search_update_hash_ref</a> (<a class="el" href="structbtr__search__t.html">btr_search_t</a> *info, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:ae78243fd0783f8dc787a0faaf8e10d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06803eb8ce2e5c5d3ac9d43e35806c67"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a06803eb8ce2e5c5d3ac9d43e35806c67">btr_search_info_update_slow</a> (<a class="el" href="structbtr__search__t.html">btr_search_t</a> *info, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:a06803eb8ce2e5c5d3ac9d43e35806c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54cfcece5869be6970336ef92db976b"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ad54cfcece5869be6970336ef92db976b">btr_search_check_guess</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ibool can_only_compare_to_cursor_rec, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ad54cfcece5869be6970336ef92db976b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430af82452b499cc4e0d7e3b1106497d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a430af82452b499cc4e0d7e3b1106497d">btr_search_guess_on_hash</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbtr__search__t.html">btr_search_t</a> *info, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint has_search_latch, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a430af82452b499cc4e0d7e3b1106497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac860ed78065384d4b1ed1a5d809d221b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ac860ed78065384d4b1ed1a5d809d221b">btr_search_drop_page_hash_index</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:ac860ed78065384d4b1ed1a5d809d221b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85d744ff9b2734301f4520444d83dfb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ae85d744ff9b2734301f4520444d83dfb">btr_search_drop_page_hash_when_freed</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:ae85d744ff9b2734301f4520444d83dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56191500ebb8904c374acb24cb4a7ad4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a56191500ebb8904c374acb24cb4a7ad4">btr_search_move_or_delete_hash_entries</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a56191500ebb8904c374acb24cb4a7ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ddf874784308ed5686772520f4a66b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a16ddf874784308ed5686772520f4a66b">btr_search_update_hash_on_delete</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:a16ddf874784308ed5686772520f4a66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55c90528e334c64e4b9601a6ff80a2b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ae55c90528e334c64e4b9601a6ff80a2b">btr_search_update_hash_node_on_insert</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:ae55c90528e334c64e4b9601a6ff80a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7c0fc33675fd37d80ef83a9250c3aa"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#aab7c0fc33675fd37d80ef83a9250c3aa">btr_search_update_hash_on_insert</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:aab7c0fc33675fd37d80ef83a9250c3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a412890df17baaf7d4031de605112c07b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a412890df17baaf7d4031de605112c07b">btr_search_enabled</a> = TRUE</td></tr>
<tr class="separator:a412890df17baaf7d4031de605112c07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f627e5c5abcdebc34c594a857253efa"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a9f627e5c5abcdebc34c594a857253efa">btr_search_this_is_zero</a> = 0</td></tr>
<tr class="separator:a9f627e5c5abcdebc34c594a857253efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30a9bfc2f4aa40cfbd1c733ea6ab22a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#ae30a9bfc2f4aa40cfbd1c733ea6ab22a">btr_sea_pad1</a> [64]</td></tr>
<tr class="separator:ae30a9bfc2f4aa40cfbd1c733ea6ab22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a0a39dca149a08db76ba4074b4a7bf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a17a0a39dca149a08db76ba4074b4a7bf">btr_search_latch_temp</a></td></tr>
<tr class="memdesc:a17a0a39dca149a08db76ba4074b4a7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The latch protecting the adaptive search system.  <a href="#a17a0a39dca149a08db76ba4074b4a7bf">More...</a><br /></td></tr>
<tr class="separator:a17a0a39dca149a08db76ba4074b4a7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb27b41b19a0956ca08c97c0f1c4dbd9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#adb27b41b19a0956ca08c97c0f1c4dbd9">btr_sea_pad2</a> [64]</td></tr>
<tr class="separator:adb27b41b19a0956ca08c97c0f1c4dbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e8f9dac27cb74e6d21d1dfe27c4a20"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbtr__search__sys__t.html">btr_search_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0sea_8cc.html#a53e8f9dac27cb74e6d21d1dfe27c4a20">btr_search_sys</a></td></tr>
<tr class="separator:a53e8f9dac27cb74e6d21d1dfe27c4a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The index tree adaptive search</p>
<p>Created 2/17/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a215610cf6902258f236d650e3a1d5799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215610cf6902258f236d650e3a1d5799">&#9670;&nbsp;</a></span>BTR_SEARCH_BUILD_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_SEARCH_BUILD_LIMIT&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The global limit for consecutive potentially successful hash searches, before hash index building is started </p>

</div>
</div>
<a id="a0fd390dc9999c8e5cb9a1c8aad8a82bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd390dc9999c8e5cb9a1c8aad8a82bd">&#9670;&nbsp;</a></span>BTR_SEARCH_PAGE_BUILD_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_SEARCH_PAGE_BUILD_LIMIT&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the number of records on the page divided by this parameter would have been successfully accessed using a hash index, the index is then built on the page, assuming the global limit has been reached </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa2706205f14a999f2e1c72c9c4fbfca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2706205f14a999f2e1c72c9c4fbfca7">&#9670;&nbsp;</a></span>btr_search_build_page_hash_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_search_build_page_hash_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>left_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds a hash index on a page with the given parameters. If the page already has a hash index with different parameters, the old hash index is removed. If index is non-NULL, this function checks if n_fields and n_bytes are sensible values, and does not build a hash index if not. in: hash for searches from left side?</p>
<p>Builds a hash index on a page with the given parameters. If the page already has a hash index with different parameters, the old hash index is removed. If index is non-NULL, this function checks if n_fields and n_bytes are sensible values, and does not build a hash index if not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index for which to build, or NULL if not known </td></tr>
    <tr><td class="paramname">block</td><td>in: index page, s- or x-latched </td></tr>
    <tr><td class="paramname">n_fields</td><td>in: hash this many full fields </td></tr>
    <tr><td class="paramname">n_bytes</td><td>in: hash this many bytes from the next field </td></tr>
    <tr><td class="paramname">left_side</td><td>in: hash for searches from left side? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97dfd4dd81154625505d48774e845020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97dfd4dd81154625505d48774e845020">&#9670;&nbsp;</a></span>btr_search_check_free_space_in_heap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_search_check_free_space_in_heap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function should be called before reserving any btr search mutex, if the intended operation might add nodes to the search system hash table. Because of the latching order, once we have reserved the btr search system latch, we cannot allocate a free frame from the buffer pool. Checks that there is a free buffer frame allocated for hash table heap in the btr search system. If not, allocates a free frames for the heap. This check makes it probable that, when have reserved the btr search system latch and we need to allocate a new node to the hash table, it will succeed. However, the check will not guarantee success. </p>

</div>
</div>
<a id="ad54cfcece5869be6970336ef92db976b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54cfcece5869be6970336ef92db976b">&#9670;&nbsp;</a></span>btr_search_check_guess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool btr_search_check_guess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>can_only_compare_to_cursor_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a guessed position for a tree cursor is right. Note that if mode is PAGE_CUR_LE, which is used in inserts, and the function returns TRUE, then cursor-&gt;up_match and cursor-&gt;low_match both have sensible values. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: guessed cursor position </td></tr>
    <tr><td class="paramname">can_only_compare_to_cursor_rec</td><td>in: if we do not have a latch on the page of cursor, but only a latch on btr_search_latch, then ONLY the columns of the record UNDER the cursor are protected, not the next or previous record in the chain: we cannot look at the next or previous record to check our guess! </td></tr>
    <tr><td class="paramname">tuple</td><td>in: data tuple </td></tr>
    <tr><td class="paramname">mode</td><td>in: PAGE_CUR_L, PAGE_CUR_LE, PAGE_CUR_G, or PAGE_CUR_GE </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90851ab21895f360e3417e6208d4f559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90851ab21895f360e3417e6208d4f559">&#9670;&nbsp;</a></span>btr_search_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable the adaptive hash search system and empty the index. </p>

</div>
</div>
<a id="ad123c65cc521709b8de09e84cead6951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad123c65cc521709b8de09e84cead6951">&#9670;&nbsp;</a></span>btr_search_disable_ref_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_search_disable_ref_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set index-&gt;ref_count = 0 on all indexes of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac860ed78065384d4b1ed1a5d809d221b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac860ed78065384d4b1ed1a5d809d221b">&#9670;&nbsp;</a></span>btr_search_drop_page_hash_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_drop_page_hash_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drops a page hash index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block containing index page, s- or x-latched, or an index page for which we know that block-&gt;buf_fix_count == 0 or it is an index page which has already been removed from the buf_pool-&gt;page_hash i.e.: it is in state BUF_BLOCK_REMOVE_HASH </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae85d744ff9b2734301f4520444d83dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85d744ff9b2734301f4520444d83dfb">&#9670;&nbsp;</a></span>btr_search_drop_page_hash_when_freed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_drop_page_hash_when_freed </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drops a possible page hash index when a page is evicted from the buffer pool or freed in a file segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05ffffd2a89c8d7ce0afcbf0f920fd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ffffd2a89c8d7ce0afcbf0f920fd6d">&#9670;&nbsp;</a></span>btr_search_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable the adaptive hash search system. </p>

</div>
</div>
<a id="a430af82452b499cc4e0d7e3b1106497d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430af82452b499cc4e0d7e3b1106497d">&#9670;&nbsp;</a></span>btr_search_guess_on_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_search_guess_on_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__search__t.html">btr_search_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>has_search_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to guess the right search position based on the hash search info of the index. Note that if mode is PAGE_CUR_LE, which is used in inserts, and the function returns TRUE, then cursor-&gt;up_match and cursor-&gt;low_match both have sensible values. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if succeeded </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">info</td><td>in: index search info </td></tr>
    <tr><td class="paramname">tuple</td><td>in: logical record </td></tr>
    <tr><td class="paramname">mode</td><td>in: PAGE_CUR_L, ... </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ...; NOTE that only if has_search_latch is 0, we will have a latch set on the cursor page, otherwise we assume the caller uses his search latch to protect the record! </td></tr>
    <tr><td class="paramname">cursor</td><td>out: tree cursor </td></tr>
    <tr><td class="paramname">has_search_latch</td><td>in: latch mode the caller currently has on btr_search_latch: RW_S_LATCH, RW_X_LATCH, or 0 </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab72c58cd4b8267eb55d3b5b61979ec13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72c58cd4b8267eb55d3b5b61979ec13">&#9670;&nbsp;</a></span>btr_search_info_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbtr__search__t.html">btr_search_t</a>* btr_search_info_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and initializes a search info struct. </p><dl class="section return"><dt>Returns</dt><dd>own: search info struct </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: heap where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6dea0b428b64f76d6660e0aa9ea4ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dea0b428b64f76d6660e0aa9ea4ba4">&#9670;&nbsp;</a></span>btr_search_info_get_ref_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_search_info_get_ref_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__search__t.html">btr_search_t</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of ref_count. The value is protected by btr_search_latch. </p><dl class="section return"><dt>Returns</dt><dd>ref_count value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: search info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecb49172aedff1ca4fd17223e40d826c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb49172aedff1ca4fd17223e40d826c">&#9670;&nbsp;</a></span>btr_search_info_update_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_search_info_update_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__search__t.html">btr_search_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the search info of an index about hash successes. NOTE that info is NOT protected by any semaphore, to save CPU time! Do not assume its fields are consistent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in/out: search info </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor which was just positioned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06803eb8ce2e5c5d3ac9d43e35806c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06803eb8ce2e5c5d3ac9d43e35806c67">&#9670;&nbsp;</a></span>btr_search_info_update_slow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_info_update_slow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__search__t.html">btr_search_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the search info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in/out: search info </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor which was just positioned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56191500ebb8904c374acb24cb4a7ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56191500ebb8904c374acb24cb4a7ad4">&#9670;&nbsp;</a></span>btr_search_move_or_delete_hash_entries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_move_or_delete_hash_entries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves or deletes hash entries for moved records. If new_page is already hashed, then the hash index for page, if any, is dropped. If new_page is not hashed, and page is hashed, then a new hash index is built to new_page with the same parameters as page (this often happens when a page is split). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: records are copied to this page </td></tr>
    <tr><td class="paramname">block</td><td>in: index page from which records were copied, and the copied records will be deleted from this page </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1ac539344c8c4a918f2461b7e2ea374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ac539344c8c4a918f2461b7e2ea374">&#9670;&nbsp;</a></span>btr_search_sys_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_sys_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hash_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and initializes the adaptive search system at a database start. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_size</td><td>in: hash index hash table size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad79ad1bd64e5cb2586daced8398c8779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79ad1bd64e5cb2586daced8398c8779">&#9670;&nbsp;</a></span>btr_search_sys_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_sys_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the adaptive search system at a database shutdown. </p>

</div>
</div>
<a id="ae97428cdc2320a6a02ed1f17e0803dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97428cdc2320a6a02ed1f17e0803dd8">&#9670;&nbsp;</a></span>btr_search_update_block_hash_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool btr_search_update_block_hash_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__search__t.html">btr_search_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a> &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the block search info on hash successes. NOTE that info and block-&gt;n_hash_helps, n_fields, n_bytes, side are NOT protected by any semaphore, to save CPU time! Do not assume the fields are consistent. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if building a (new) hash index on the block is recommended </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: search info </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in: cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae55c90528e334c64e4b9601a6ff80a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55c90528e334c64e4b9601a6ff80a2b">&#9670;&nbsp;</a></span>btr_search_update_hash_node_on_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_update_hash_node_on_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the page hash index when a single record is inserted on a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor which was positioned to the place to insert using btr_cur_search_..., and the new record has been inserted next to the cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16ddf874784308ed5686772520f4a66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ddf874784308ed5686772520f4a66b">&#9670;&nbsp;</a></span>btr_search_update_hash_on_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_update_hash_on_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the page hash index when a single record is deleted from a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor which was positioned on the record to delete using btr_cur_search_..., the record is not yet deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab7c0fc33675fd37d80ef83a9250c3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7c0fc33675fd37d80ef83a9250c3aa">&#9670;&nbsp;</a></span>btr_search_update_hash_on_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_search_update_hash_on_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the page hash index when a single record is inserted on a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor which was positioned to the place to insert using btr_cur_search_..., and the new record has been inserted next to the cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae78243fd0783f8dc787a0faaf8e10d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78243fd0783f8dc787a0faaf8e10d13">&#9670;&nbsp;</a></span>btr_search_update_hash_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_search_update_hash_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__search__t.html">btr_search_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates a hash node reference when it has been unsuccessfully used in a search which could have succeeded with the used hash parameters. This can happen because when building a hash index for a page, we do not check what happens at page boundaries, and therefore there can be misleading hash nodes. Also, collisions in the fold value can lead to misleading references. This function lazily fixes these imperfections in the hash index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: search info </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block where cursor positioned </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae30a9bfc2f4aa40cfbd1c733ea6ab22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30a9bfc2f4aa40cfbd1c733ea6ab22a">&#9670;&nbsp;</a></span>btr_sea_pad1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte btr_sea_pad1[64]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>padding to prevent other memory update hotspots from residing on the same memory cache line as btr_search_latch </p>

</div>
</div>
<a id="adb27b41b19a0956ca08c97c0f1c4dbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb27b41b19a0956ca08c97c0f1c4dbd9">&#9670;&nbsp;</a></span>btr_sea_pad2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte btr_sea_pad2[64]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>padding to prevent other memory update hotspots from residing on the same memory cache line </p>

</div>
</div>
<a id="a412890df17baaf7d4031de605112c07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412890df17baaf7d4031de605112c07b">&#9670;&nbsp;</a></span>btr_search_enabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char btr_search_enabled = TRUE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag: has the search system been enabled? Protected by btr_search_latch. </p>

</div>
</div>
<a id="a17a0a39dca149a08db76ba4074b4a7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a0a39dca149a08db76ba4074b4a7bf">&#9670;&nbsp;</a></span>btr_search_latch_temp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structrw__lock__t.html">rw_lock_t</a>* btr_search_latch_temp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The latch protecting the adaptive search system. </p>
<p>The latch protecting the adaptive search system: this latch protects the (1) positions of records on those pages where a hash index has been built. NOTE: It does not protect values of non-ordering fields within a record from being updated in-place! We can use fact (1) to perform unique searches to indexes. </p>

</div>
</div>
<a id="a53e8f9dac27cb74e6d21d1dfe27c4a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e8f9dac27cb74e6d21d1dfe27c4a20">&#9670;&nbsp;</a></span>btr_search_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbtr__search__sys__t.html">btr_search_sys_t</a>* btr_search_sys</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The adaptive hash index </p>

</div>
</div>
<a id="a9f627e5c5abcdebc34c594a857253efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f627e5c5abcdebc34c594a857253efa">&#9670;&nbsp;</a></span>btr_search_this_is_zero</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_search_this_is_zero = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A dummy variable to fool the compiler </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Gtid_set Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_gtid__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Gtid_set Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="rpl__gtid_8h_source.html">rpl_gtid.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set_1_1_gtid__iterator.html">Gtid_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_gtid__set_1_1_interval__chunk.html">Interval_chunk</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set_1_1_interval__iterator.html">Interval_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set_1_1_interval__iterator__base.html">Interval_iterator_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a048d3934c095e4afed99055334367047"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a048d3934c095e4afed99055334367047">Gtid_set</a> (<a class="el" href="class_sid__map.html">Sid_map</a> *<a class="el" href="class_gtid__set.html#a1ed15c63da105506bb57cab3cd07f12a">sid_map</a>, <a class="el" href="class_checkable__rwlock.html">Checkable_rwlock</a> *<a class="el" href="class_gtid__set.html#a235c417ccc71af6d15f629ac7e786db3">sid_lock</a>=NULL)</td></tr>
<tr class="separator:a048d3934c095e4afed99055334367047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f441c71a9465b3e03fc2d8a68a04315"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a3f441c71a9465b3e03fc2d8a68a04315">Gtid_set</a> (<a class="el" href="class_sid__map.html">Sid_map</a> *<a class="el" href="class_gtid__set.html#a1ed15c63da105506bb57cab3cd07f12a">sid_map</a>, const char *text, enum_return_status *<a class="el" href="rem0rec_8cc.html#ad891b6122c6331f9c438fda0302a8d5e">status</a>, <a class="el" href="class_checkable__rwlock.html">Checkable_rwlock</a> *<a class="el" href="class_gtid__set.html#a235c417ccc71af6d15f629ac7e786db3">sid_lock</a>=NULL)</td></tr>
<tr class="separator:a3f441c71a9465b3e03fc2d8a68a04315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad214bab2852c98a3b0ce39bb305f720f"><td class="memItemLeft" align="right" valign="top"><a id="ad214bab2852c98a3b0ce39bb305f720f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#ad214bab2852c98a3b0ce39bb305f720f">~Gtid_set</a> ()</td></tr>
<tr class="memdesc:ad214bab2852c98a3b0ce39bb305f720f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy this <a class="el" href="class_gtid__set.html">Gtid_set</a>. <br /></td></tr>
<tr class="separator:ad214bab2852c98a3b0ce39bb305f720f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8130a7559cfd7b940f42e66c9b171a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a8d8130a7559cfd7b940f42e66c9b171a">clear</a> ()</td></tr>
<tr class="separator:a8d8130a7559cfd7b940f42e66c9b171a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac457d510c14ce9d834ce85268f62f6fe"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#ac457d510c14ce9d834ce85268f62f6fe">_add_gtid</a> (rpl_sidno sidno, rpl_gno gno)</td></tr>
<tr class="separator:ac457d510c14ce9d834ce85268f62f6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6298a4686b2856153efb1678ef326ce"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#ae6298a4686b2856153efb1678ef326ce">_remove_gtid</a> (rpl_sidno sidno, rpl_gno gno)</td></tr>
<tr class="separator:ae6298a4686b2856153efb1678ef326ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0378bb6823f52a48455328515b62c684"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a0378bb6823f52a48455328515b62c684">_add_gtid</a> (const <a class="el" href="struct_gtid.html">Gtid</a> &amp;gtid)</td></tr>
<tr class="separator:a0378bb6823f52a48455328515b62c684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020ff727cab9d32ce695233376a5383e"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a020ff727cab9d32ce695233376a5383e">_remove_gtid</a> (const <a class="el" href="struct_gtid.html">Gtid</a> &amp;gtid)</td></tr>
<tr class="separator:a020ff727cab9d32ce695233376a5383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a76ae688b1286b8bc51b02619174892"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set</a> (const <a class="el" href="class_gtid__set.html">Gtid_set</a> *other)</td></tr>
<tr class="separator:a5a76ae688b1286b8bc51b02619174892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0a5e109f9b6f5d1fdec79462468340"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#afc0a5e109f9b6f5d1fdec79462468340">remove_gtid_set</a> (const <a class="el" href="class_gtid__set.html">Gtid_set</a> *other)</td></tr>
<tr class="separator:afc0a5e109f9b6f5d1fdec79462468340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae854e77cbadfd86cf28b61d5a8e228b9"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#ae854e77cbadfd86cf28b61d5a8e228b9">add_gtid_text</a> (const char *text, bool *anonymous=NULL)</td></tr>
<tr class="separator:ae854e77cbadfd86cf28b61d5a8e228b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f1bc4e5fa45a2902ff562df316cf1b"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#ae5f1bc4e5fa45a2902ff562df316cf1b">add_gtid_encoding</a> (const uchar *encoded, size_t length, size_t *actual_length=NULL)</td></tr>
<tr class="separator:ae5f1bc4e5fa45a2902ff562df316cf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e68bd7787bfa962c687120e171eae73"><td class="memItemLeft" align="right" valign="top"><a id="a4e68bd7787bfa962c687120e171eae73"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a4e68bd7787bfa962c687120e171eae73">contains_gtid</a> (rpl_sidno sidno, rpl_gno gno) const</td></tr>
<tr class="memdesc:a4e68bd7787bfa962c687120e171eae73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the given GTID exists in this set. <br /></td></tr>
<tr class="separator:a4e68bd7787bfa962c687120e171eae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5f701799a0101c55a594a39969ef20"><td class="memItemLeft" align="right" valign="top"><a id="a5c5f701799a0101c55a594a39969ef20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a5c5f701799a0101c55a594a39969ef20">contains_gtid</a> (const <a class="el" href="struct_gtid.html">Gtid</a> &amp;gtid) const</td></tr>
<tr class="memdesc:a5c5f701799a0101c55a594a39969ef20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the given GTID exists in this set. <br /></td></tr>
<tr class="separator:a5c5f701799a0101c55a594a39969ef20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc3a046cf55b71db3a2def3b4a01ecb"><td class="memItemLeft" align="right" valign="top"><a id="afcc3a046cf55b71db3a2def3b4a01ecb"></a>
rpl_sidno&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#afcc3a046cf55b71db3a2def3b4a01ecb">get_max_sidno</a> () const</td></tr>
<tr class="memdesc:afcc3a046cf55b71db3a2def3b4a01ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximal sidno that this <a class="el" href="class_gtid__set.html">Gtid_set</a> currently has space for. <br /></td></tr>
<tr class="separator:afcc3a046cf55b71db3a2def3b4a01ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f026631d33627a5c273bdc35dcc03ef"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a4f026631d33627a5c273bdc35dcc03ef">ensure_sidno</a> (rpl_sidno sidno)</td></tr>
<tr class="separator:a4f026631d33627a5c273bdc35dcc03ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe2143cf922ad18d4d92853d439796b"><td class="memItemLeft" align="right" valign="top"><a id="a0fe2143cf922ad18d4d92853d439796b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a0fe2143cf922ad18d4d92853d439796b">is_subset</a> (const <a class="el" href="class_gtid__set.html">Gtid_set</a> *super) const</td></tr>
<tr class="memdesc:a0fe2143cf922ad18d4d92853d439796b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="class_gtid__set.html">Gtid_set</a> is a subset of the other <a class="el" href="class_gtid__set.html">Gtid_set</a>. <br /></td></tr>
<tr class="separator:a0fe2143cf922ad18d4d92853d439796b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75513b924941cde711e91e8c0f9275a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a75513b924941cde711e91e8c0f9275a0">is_subset_for_sid</a> (const <a class="el" href="class_gtid__set.html">Gtid_set</a> *super, rpl_sidno superset_sidno, rpl_sidno subset_sidno) const</td></tr>
<tr class="separator:a75513b924941cde711e91e8c0f9275a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f59bb7b9cd3a32b54bb5f8128aa5ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a09f59bb7b9cd3a32b54bb5f8128aa5ca">is_intersection_nonempty</a> (const <a class="el" href="class_gtid__set.html">Gtid_set</a> *other) const</td></tr>
<tr class="separator:a09f59bb7b9cd3a32b54bb5f8128aa5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a384be7c735d018d5fc0c8c0c64344e"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a9a384be7c735d018d5fc0c8c0c64344e">intersection</a> (const <a class="el" href="class_gtid__set.html">Gtid_set</a> *other, <a class="el" href="class_gtid__set.html">Gtid_set</a> *result)</td></tr>
<tr class="separator:a9a384be7c735d018d5fc0c8c0c64344e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba037b0972b58d2be314c76cffef66d"><td class="memItemLeft" align="right" valign="top"><a id="abba037b0972b58d2be314c76cffef66d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#abba037b0972b58d2be314c76cffef66d">is_empty</a> () const</td></tr>
<tr class="memdesc:abba037b0972b58d2be314c76cffef66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="class_gtid__set.html">Gtid_set</a> is empty. <br /></td></tr>
<tr class="separator:abba037b0972b58d2be314c76cffef66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129894d15720c07d707ca29a426cbe47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a129894d15720c07d707ca29a426cbe47">contains_sidno</a> (rpl_sidno sidno) const</td></tr>
<tr class="separator:a129894d15720c07d707ca29a426cbe47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edf398794ea7e5b50fd2f1f03039f92"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a6edf398794ea7e5b50fd2f1f03039f92">to_string</a> () const</td></tr>
<tr class="separator:a6edf398794ea7e5b50fd2f1f03039f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38edaa055dbb42de1bcd0443f0e24239"><td class="memItemLeft" align="right" valign="top"><a id="a38edaa055dbb42de1bcd0443f0e24239"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a38edaa055dbb42de1bcd0443f0e24239">print</a> () const</td></tr>
<tr class="memdesc:a38edaa055dbb42de1bcd0443f0e24239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug only: Print this <a class="el" href="class_gtid__set.html">Gtid_set</a> to stdout. <br /></td></tr>
<tr class="separator:a38edaa055dbb42de1bcd0443f0e24239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3faa91a817bda42cf81081ae580327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#adc3faa91a817bda42cf81081ae580327">dbug_print</a> (const char *text=&quot;&quot;) const</td></tr>
<tr class="separator:adc3faa91a817bda42cf81081ae580327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95788d41ef65127f643bf7c7b65a4e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#af95788d41ef65127f643bf7c7b65a4e2">get_string_length</a> (const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> *string_format=NULL) const</td></tr>
<tr class="separator:af95788d41ef65127f643bf7c7b65a4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dae3fbe653bdb6dc5e59cc292111b3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a4dae3fbe653bdb6dc5e59cc292111b3f">to_string</a> (char *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> *string_format=NULL) const</td></tr>
<tr class="separator:a4dae3fbe653bdb6dc5e59cc292111b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3372b93fff473d081e5bd110210b9386"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a3372b93fff473d081e5bd110210b9386">to_string</a> (char **<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> *string_format=NULL) const</td></tr>
<tr class="separator:a3372b93fff473d081e5bd110210b9386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcb30d3c0809db3baa3bce6a813332b"><td class="memItemLeft" align="right" valign="top"><a id="a1dcb30d3c0809db3baa3bce6a813332b"></a>
<a class="el" href="class_sid__map.html">Sid_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a1dcb30d3c0809db3baa3bce6a813332b">get_sid_map</a> () const</td></tr>
<tr class="memdesc:a1dcb30d3c0809db3baa3bce6a813332b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_sid__map.html">Sid_map</a> associated with this <a class="el" href="class_gtid__set.html">Gtid_set</a>. <br /></td></tr>
<tr class="separator:a1dcb30d3c0809db3baa3bce6a813332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11541c02363dc7a2877a5a0282d679ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a11541c02363dc7a2877a5a0282d679ab">add_interval_memory</a> (int n_intervals, <a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> *intervals_param)</td></tr>
<tr class="separator:a11541c02363dc7a2877a5a0282d679ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036d17fc704667febec3777422f164cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a036d17fc704667febec3777422f164cd">encode</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>) const</td></tr>
<tr class="separator:a036d17fc704667febec3777422f164cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92c3495294a8533401fe17ea6e250f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#ac92c3495294a8533401fe17ea6e250f4">get_encoded_length</a> () const</td></tr>
<tr class="separator:ac92c3495294a8533401fe17ea6e250f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8a10c1dfb57ac995cbf14b51f83f8e68"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a8a10c1dfb57ac995cbf14b51f83f8e68">is_valid</a> (const char *text)</td></tr>
<tr class="separator:a8a10c1dfb57ac995cbf14b51f83f8e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a65b9f6c31cfc7d5ca7b1564411c2a416"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a65b9f6c31cfc7d5ca7b1564411c2a416">default_string_format</a></td></tr>
<tr class="separator:a65b9f6c31cfc7d5ca7b1564411c2a416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefb12fa60900cd38a8abe959b774f54"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#abefb12fa60900cd38a8abe959b774f54">sql_string_format</a></td></tr>
<tr class="separator:abefb12fa60900cd38a8abe959b774f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba668b76ba3d4a4d96a91389dc31817"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a4ba668b76ba3d4a4d96a91389dc31817">commented_string_format</a></td></tr>
<tr class="separator:a4ba668b76ba3d4a4d96a91389dc31817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a38bc9f586ff50d8298b7f8369c31b7b5"><td class="memItemLeft" align="right" valign="top"><a id="a38bc9f586ff50d8298b7f8369c31b7b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a38bc9f586ff50d8298b7f8369c31b7b5">init</a> ()</td></tr>
<tr class="memdesc:a38bc9f586ff50d8298b7f8369c31b7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker for the constructor. <br /></td></tr>
<tr class="separator:a38bc9f586ff50d8298b7f8369c31b7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54269e96b253223e09febe574b9ed742"><td class="memItemLeft" align="right" valign="top"><a id="a54269e96b253223e09febe574b9ed742"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a54269e96b253223e09febe574b9ed742">get_n_intervals</a> (rpl_sidno sidno) const</td></tr>
<tr class="memdesc:a54269e96b253223e09febe574b9ed742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of intervals for the given sidno. <br /></td></tr>
<tr class="separator:a54269e96b253223e09febe574b9ed742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1993d9eb1d4276690534173fc21afa66"><td class="memItemLeft" align="right" valign="top"><a id="a1993d9eb1d4276690534173fc21afa66"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a1993d9eb1d4276690534173fc21afa66">get_n_intervals</a> () const</td></tr>
<tr class="memdesc:a1993d9eb1d4276690534173fc21afa66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of intervals in this <a class="el" href="class_gtid__set.html">Gtid_set</a>. <br /></td></tr>
<tr class="separator:a1993d9eb1d4276690534173fc21afa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ef434a8ec957298f0d1ba546465972"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a91ef434a8ec957298f0d1ba546465972">create_new_chunk</a> (int <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a91ef434a8ec957298f0d1ba546465972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee334bbf87b4974bf7162ca4b8f3817c"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#aee334bbf87b4974bf7162ca4b8f3817c">get_free_interval</a> (<a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> **out)</td></tr>
<tr class="separator:aee334bbf87b4974bf7162ca4b8f3817c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0469b6a65245c7d163e4f668b6a035df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a0469b6a65245c7d163e4f668b6a035df">put_free_interval</a> (<a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> *iv)</td></tr>
<tr class="separator:a0469b6a65245c7d163e4f668b6a035df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69751d98a68b54cf39ed80a911ab37da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a69751d98a68b54cf39ed80a911ab37da">add_interval_memory_lock_taken</a> (int n_ivs, <a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> *ivs)</td></tr>
<tr class="separator:a69751d98a68b54cf39ed80a911ab37da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd693a6a053229a889ef275df590aa03"><td class="memItemLeft" align="right" valign="top"><a id="afd693a6a053229a889ef275df590aa03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assert_free_intervals_locked</b> ()</td></tr>
<tr class="separator:afd693a6a053229a889ef275df590aa03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631a429070b1828cff450a493fe913aa"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a631a429070b1828cff450a493fe913aa">add_gno_interval</a> (<a class="el" href="class_gtid__set_1_1_interval__iterator.html">Interval_iterator</a> *ivitp, rpl_gno start, rpl_gno end, <a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a> *lock)</td></tr>
<tr class="separator:a631a429070b1828cff450a493fe913aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4542c0d0fbc95557d3c80264d3fcc24"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#ab4542c0d0fbc95557d3c80264d3fcc24">remove_gno_interval</a> (<a class="el" href="class_gtid__set_1_1_interval__iterator.html">Interval_iterator</a> *ivitp, rpl_gno start, rpl_gno end, <a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a> *lock)</td></tr>
<tr class="separator:ab4542c0d0fbc95557d3c80264d3fcc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11af43449e8b947836b22632f8ce9147"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a11af43449e8b947836b22632f8ce9147">add_gno_intervals</a> (rpl_sidno sidno, <a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a> ivit, <a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a> *lock)</td></tr>
<tr class="separator:a11af43449e8b947836b22632f8ce9147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82a55e8ed6521c0d23eaf0bc3bfd497"><td class="memItemLeft" align="right" valign="top">enum_return_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#af82a55e8ed6521c0d23eaf0bc3bfd497">remove_gno_intervals</a> (rpl_sidno sidno, <a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a> ivit, <a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a> *lock)</td></tr>
<tr class="separator:af82a55e8ed6521c0d23eaf0bc3bfd497"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a312e5a07220196998a2cbac8d95e1fcf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a312e5a07220196998a2cbac8d95e1fcf">is_interval_subset</a> (<a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a> *sub, <a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a> *super)</td></tr>
<tr class="separator:a312e5a07220196998a2cbac8d95e1fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eaae5cc56a6423f72980810b4cd8b4"><td class="memItemLeft" align="right" valign="top"><a id="a91eaae5cc56a6423f72980810b4cd8b4"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a91eaae5cc56a6423f72980810b4cd8b4">is_interval_intersection_nonempty</a> (<a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a> *ivit1, <a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a> *ivit2)</td></tr>
<tr class="memdesc:a91eaae5cc56a6423f72980810b4cd8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if at least one sidno in ivit1 is also in ivit2. <br /></td></tr>
<tr class="separator:a91eaae5cc56a6423f72980810b4cd8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a235c417ccc71af6d15f629ac7e786db3"><td class="memItemLeft" align="right" valign="top"><a id="a235c417ccc71af6d15f629ac7e786db3"></a>
<a class="el" href="class_checkable__rwlock.html">Checkable_rwlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a235c417ccc71af6d15f629ac7e786db3">sid_lock</a></td></tr>
<tr class="memdesc:a235c417ccc71af6d15f629ac7e786db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write lock that protects updates to the number of SIDs. <br /></td></tr>
<tr class="separator:a235c417ccc71af6d15f629ac7e786db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741234c5a03195365346ad888bbeca81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a741234c5a03195365346ad888bbeca81">free_intervals_mutex</a></td></tr>
<tr class="separator:a741234c5a03195365346ad888bbeca81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed15c63da105506bb57cab3cd07f12a"><td class="memItemLeft" align="right" valign="top"><a id="a1ed15c63da105506bb57cab3cd07f12a"></a>
<a class="el" href="class_sid__map.html">Sid_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a1ed15c63da105506bb57cab3cd07f12a">sid_map</a></td></tr>
<tr class="memdesc:a1ed15c63da105506bb57cab3cd07f12a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_sid__map.html">Sid_map</a> associated with this <a class="el" href="class_gtid__set.html">Gtid_set</a>. <br /></td></tr>
<tr class="separator:a1ed15c63da105506bb57cab3cd07f12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b610d998116151a6c58cc0a743046ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__dynamic__array.html">DYNAMIC_ARRAY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a5b610d998116151a6c58cc0a743046ec">intervals</a></td></tr>
<tr class="separator:a5b610d998116151a6c58cc0a743046ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b17991d3ebfb38fb697bf640148b9f1"><td class="memItemLeft" align="right" valign="top"><a id="a5b17991d3ebfb38fb697bf640148b9f1"></a>
<a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a5b17991d3ebfb38fb697bf640148b9f1">free_intervals</a></td></tr>
<tr class="memdesc:a5b17991d3ebfb38fb697bf640148b9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of free intervals. <br /></td></tr>
<tr class="separator:a5b17991d3ebfb38fb697bf640148b9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab2254b708f076cca14781060b99ea2"><td class="memItemLeft" align="right" valign="top"><a id="a4ab2254b708f076cca14781060b99ea2"></a>
<a class="el" href="struct_gtid__set_1_1_interval__chunk.html">Interval_chunk</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a4ab2254b708f076cca14781060b99ea2">chunks</a></td></tr>
<tr class="memdesc:a4ab2254b708f076cca14781060b99ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked list of chunks. <br /></td></tr>
<tr class="separator:a4ab2254b708f076cca14781060b99ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfa3daf2442d3b5ac21ad93d88c9040"><td class="memItemLeft" align="right" valign="top"><a id="a4dfa3daf2442d3b5ac21ad93d88c9040"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a4dfa3daf2442d3b5ac21ad93d88c9040">cached_string_length</a></td></tr>
<tr class="memdesc:a4dfa3daf2442d3b5ac21ad93d88c9040"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string length. <br /></td></tr>
<tr class="separator:a4dfa3daf2442d3b5ac21ad93d88c9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f1e5d87f80ff7d54681c633b3405d"><td class="memItemLeft" align="right" valign="top"><a id="ad78f1e5d87f80ff7d54681c633b3405d"></a>
const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#ad78f1e5d87f80ff7d54681c633b3405d">cached_string_format</a></td></tr>
<tr class="memdesc:ad78f1e5d87f80ff7d54681c633b3405d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> that was used when cached_string_length was computed. <br /></td></tr>
<tr class="separator:ad78f1e5d87f80ff7d54681c633b3405d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84014647fe8f9773957a399da6a195a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a84014647fe8f9773957a399da6a195a4">n_chunks</a></td></tr>
<tr class="separator:a84014647fe8f9773957a399da6a195a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a3cac4397e001272fe224571ec2955cf7"><td class="memItemLeft" align="right" valign="top"><a id="a3cac4397e001272fe224571ec2955cf7"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a3cac4397e001272fe224571ec2955cf7">CHUNK_GROW_SIZE</a> = 8</td></tr>
<tr class="memdesc:a3cac4397e001272fe224571ec2955cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default number of intervals in an <a class="el" href="struct_gtid__set_1_1_interval__chunk.html">Interval_chunk</a>. <br /></td></tr>
<tr class="separator:a3cac4397e001272fe224571ec2955cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a59860055a243825524c47d9adc494250"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gtid__set.html#a59860055a243825524c47d9adc494250">Gtid_set::Free_intervals_lock</a></td></tr>
<tr class="memdesc:a59860055a243825524c47d9adc494250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by unit tests that need to access private members.  <a href="#a59860055a243825524c47d9adc494250">More...</a><br /></td></tr>
<tr class="separator:a59860055a243825524c47d9adc494250"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a set of GTIDs.</p>
<p>This is structured as an array, indexed by SIDNO, where each element contains a linked list of intervals.</p>
<p>This data structure OPTIONALLY knows of a <a class="el" href="class_sid__map.html">Sid_map</a> that gives a correspondence between SIDNO and SID. If the <a class="el" href="class_sid__map.html">Sid_map</a> is NULL, then operations that require a <a class="el" href="class_sid__map.html">Sid_map</a> - printing and parsing - raise an assertion.</p>
<p>This data structure OPTIONALLY knows of a read-write lock that protects the number of SIDNOs. The lock is provided by the invoker of the constructor and it is generally the caller's responsibility to acquire the read lock. If the lock is not NULL, access methods assert that the caller already holds the read (or write) lock. If the lock is not NULL and a method of this class grows the number of SIDNOs, then the method temporarily upgrades this lock to a write lock and then degrades it to a read lock again; there will be a short period when the lock is not held at all. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a048d3934c095e4afed99055334367047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048d3934c095e4afed99055334367047">&#9670;&nbsp;</a></span>Gtid_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtid_set::Gtid_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sid__map.html">Sid_map</a> *&#160;</td>
          <td class="paramname"><em>sid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_checkable__rwlock.html">Checkable_rwlock</a> *&#160;</td>
          <td class="paramname"><em>sid_lock</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new, empty <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid_map</td><td>The <a class="el" href="class_sid__map.html">Sid_map</a> to use, or NULL if this <a class="el" href="class_gtid__set.html">Gtid_set</a> should not have a <a class="el" href="class_sid__map.html">Sid_map</a>. </td></tr>
    <tr><td class="paramname">sid_lock</td><td>Read-write lock that protects updates to the number of SIDs. This may be NULL if such changes do not need to be protected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f441c71a9465b3e03fc2d8a68a04315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f441c71a9465b3e03fc2d8a68a04315">&#9670;&nbsp;</a></span>Gtid_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtid_set::Gtid_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sid__map.html">Sid_map</a> *&#160;</td>
          <td class="paramname"><em>sid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_return_status *&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_checkable__rwlock.html">Checkable_rwlock</a> *&#160;</td>
          <td class="paramname"><em>sid_lock</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new <a class="el" href="class_gtid__set.html">Gtid_set</a> that contains the groups in the given string, in the same format as add_gtid_text(char *).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sid_map</td><td>The <a class="el" href="class_sid__map.html">Sid_map</a> to use for SIDs. </td></tr>
    <tr><td class="paramname">text</td><td>The text to parse. </td></tr>
    <tr><td class="paramname">status</td><td>Will be set GS_SUCCESS or GS_ERROR_PARSE or GS_ERROR_OUT_OF_MEMORY. </td></tr>
    <tr><td class="paramname">sid_lock</td><td>Read/write lock to protect changes in the number of SIDs with. This may be NULL if such changes do not need to be protected.</td></tr>
  </table>
  </dd>
</dl>
<p>If sid_lock != NULL, then the read lock on sid_lock must be held before calling this function. If the array is grown, sid_lock is temporarily upgraded to a write lock and then degraded again; there will be a short period when the lock is not held at all. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac457d510c14ce9d834ce85268f62f6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac457d510c14ce9d834ce85268f62f6fe">&#9670;&nbsp;</a></span>_add_gtid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::_add_gtid </td>
          <td>(</td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>sidno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rpl_gno&#160;</td>
          <td class="paramname"><em>gno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the given GTID to this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<p>The SIDNO must exist in the <a class="el" href="class_gtid__set.html">Gtid_set</a> before this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>SIDNO of the group to add. </td></tr>
    <tr><td class="paramname">gno</td><td>GNO of the group to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a0378bb6823f52a48455328515b62c684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0378bb6823f52a48455328515b62c684">&#9670;&nbsp;</a></span>_add_gtid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::_add_gtid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_gtid.html">Gtid</a> &amp;&#160;</td>
          <td class="paramname"><em>gtid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the given GTID to this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<p>The SIDNO must exist in the <a class="el" href="class_gtid__set.html">Gtid_set</a> before this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gtid</td><td><a class="el" href="struct_gtid.html">Gtid</a> to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="ae6298a4686b2856153efb1678ef326ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6298a4686b2856153efb1678ef326ce">&#9670;&nbsp;</a></span>_remove_gtid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::_remove_gtid </td>
          <td>(</td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>sidno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rpl_gno&#160;</td>
          <td class="paramname"><em>gno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the given GTID from this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>SIDNO of the group to remove. </td></tr>
    <tr><td class="paramname">gno</td><td>GNO of the group to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a020ff727cab9d32ce695233376a5383e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020ff727cab9d32ce695233376a5383e">&#9670;&nbsp;</a></span>_remove_gtid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::_remove_gtid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_gtid.html">Gtid</a> &amp;&#160;</td>
          <td class="paramname"><em>gtid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the given GTID from this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gtid</td><td><a class="el" href="struct_gtid.html">Gtid</a> to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a631a429070b1828cff450a493fe913aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631a429070b1828cff450a493fe913aa">&#9670;&nbsp;</a></span>add_gno_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::add_gno_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_interval__iterator.html">Interval_iterator</a> *&#160;</td>
          <td class="paramname"><em>ivitp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rpl_gno&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rpl_gno&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the interval (start, end) to the given <a class="el" href="class_gtid__set_1_1_interval__iterator.html">Interval_iterator</a>.</p>
<p>This is the lowest-level function that adds groups; this is where <a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> objects are added, grown, or merged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ivitp</td><td>Pointer to iterator. After this function returns, the current_element of the iterator will be the interval that contains start and end. </td></tr>
    <tr><td class="paramname">start</td><td>The first GNO in the interval. </td></tr>
    <tr><td class="paramname">end</td><td>The first GNO after the interval. </td></tr>
    <tr><td class="paramname">lock</td><td>If this function has to add or remove an interval, then this lock will be taken unless it is already taken. This mechanism means that the lock will be taken lazily by e.g. <a class="el" href="class_gtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set()</a> the first time that the list of free intervals is accessed, and automatically released when <a class="el" href="class_gtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set()</a> returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a11af43449e8b947836b22632f8ce9147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11af43449e8b947836b22632f8ce9147">&#9670;&nbsp;</a></span>add_gno_intervals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::add_gno_intervals </td>
          <td>(</td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>sidno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a>&#160;</td>
          <td class="paramname"><em>ivit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a list of intervals to the given SIDNO.</p>
<p>The SIDNO must exist in the <a class="el" href="class_gtid__set.html">Gtid_set</a> before this function is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>The SIDNO to which intervals will be added. </td></tr>
    <tr><td class="paramname">ivit</td><td>Iterator over the intervals to add. This is typically an iterator over some other <a class="el" href="class_gtid__set.html">Gtid_set</a>. </td></tr>
    <tr><td class="paramname">lock</td><td>If this function has to add or remove an interval, then this lock will be taken unless it is already taken. This mechanism means that the lock will be taken lazily by e.g. <a class="el" href="class_gtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set()</a> the first time that the list of free intervals is accessed, and automatically released when <a class="el" href="class_gtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set()</a> returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="ae5f1bc4e5fa45a2902ff562df316cf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f1bc4e5fa45a2902ff562df316cf1b">&#9670;&nbsp;</a></span>add_gtid_encoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::add_gtid_encoding </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>actual_length</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes a <a class="el" href="class_gtid__set.html">Gtid_set</a> from the given string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes. </td></tr>
    <tr><td class="paramname">actual_length</td><td>If this is not NULL, it is set to the number of bytes used by the encoding (which may be less than 'length'). If this is NULL, an error is generated if the encoding is shorter than the given 'length'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GS_SUCCESS or GS_ERROR_PARSE or GS_ERROR_OUT_OF_MEMORY </dd></dl>

</div>
</div>
<a id="a5a76ae688b1286b8bc51b02619174892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a76ae688b1286b8bc51b02619174892">&#9670;&nbsp;</a></span>add_gtid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::add_gtid_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds all groups from the given <a class="el" href="class_gtid__set.html">Gtid_set</a> to this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<p>If sid_lock != NULL, then the read lock must be held before calling this function. If a new sidno is added so that the array of lists of intervals is grown, sid_lock is temporarily upgraded to a write lock and then degraded again; there will be a short period when the lock is not held at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="class_gtid__set.html">Gtid_set</a> to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="ae854e77cbadfd86cf28b61d5a8e228b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae854e77cbadfd86cf28b61d5a8e228b9">&#9670;&nbsp;</a></span>add_gtid_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::add_gtid_text </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>anonymous</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the set of GTIDs represented by the given string to this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<p>The string must have the format of a comma-separated list of zero or more of the following:</p>
<p>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX(:NUMBER+(-NUMBER)?)* | ANONYMOUS</p>
<p>Each X is a hexadecimal digit (upper- or lowercase). NUMBER is a decimal, 0xhex, or 0oct number.</p>
<p>The start of an interval must be greater than 0. The end of an interval may be 0, but any interval that has an endpoint that is smaller than the start is discarded.</p>
<p>If sid_lock != NULL, then the read lock on sid_lock must be held before calling this function. If a new sidno is added so that the array of lists of intervals is grown, sid_lock is temporarily upgraded to a write lock and then degraded again; there will be a short period when the lock is not held at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">anonymous[in,out]</td><td>If this is NULL, ANONYMOUS is not allowed. If this is not NULL, it will be set to true if the anonymous group was found; false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a11541c02363dc7a2877a5a0282d679ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11541c02363dc7a2877a5a0282d679ab">&#9670;&nbsp;</a></span>add_interval_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_set::add_interval_memory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_intervals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> *&#160;</td>
          <td class="paramname"><em>intervals_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provides an array of Intervals that this <a class="el" href="class_gtid__set.html">Gtid_set</a> can use when groups are subsequently added. This can be used as an optimization, to reduce allocation for sets that have a known number of intervals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_intervals</td><td>The number of intervals to add. </td></tr>
    <tr><td class="paramname">intervals</td><td>Array of n_intervals intervals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69751d98a68b54cf39ed80a911ab37da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69751d98a68b54cf39ed80a911ab37da">&#9670;&nbsp;</a></span>add_interval_memory_lock_taken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_set::add_interval_memory_lock_taken </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> *&#160;</td>
          <td class="paramname"><em>ivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like add_interval_memory, but does not acquire free_intervals_mutex. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_gtid__set.html#a11541c02363dc7a2877a5a0282d679ab">Gtid_set::add_interval_memory</a> </dd></dl>

</div>
</div>
<a id="a8d8130a7559cfd7b940f42e66c9b171a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8130a7559cfd7b940f42e66c9b171a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_set::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all groups from this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<p>This does not deallocate anything: if groups are added later, existing allocated memory will be re-used. </p>

</div>
</div>
<a id="a129894d15720c07d707ca29a426cbe47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129894d15720c07d707ca29a426cbe47">&#9670;&nbsp;</a></span>contains_sidno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtid_set::contains_sidno </td>
          <td>(</td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="class_gtid__set.html">Gtid_set</a> contains at least one GTID with the given SIDNO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>The SIDNO to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The SIDNO is less than or equal to the max SIDNO, and there is at least one group with this SIDNO. </td></tr>
    <tr><td class="paramname">false</td><td>The SIDNO is greater than the max SIDNO, or there is no group with this SIDNO. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91ef434a8ec957298f0d1ba546465972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ef434a8ec957298f0d1ba546465972">&#9670;&nbsp;</a></span>create_new_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::create_new_chunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new chunk of Intervals and adds them to the list of unused intervals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of intervals in this chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="adc3faa91a817bda42cf81081ae580327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3faa91a817bda42cf81081ae580327">&#9670;&nbsp;</a></span>dbug_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_set::dbug_print </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print this <a class="el" href="class_gtid__set.html">Gtid_set</a> to the trace file if debug is enabled; no-op otherwise. </p>

</div>
</div>
<a id="a036d17fc704667febec3777422f164cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036d17fc704667febec3777422f164cd">&#9670;&nbsp;</a></span>encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_set::encode </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes this <a class="el" href="class_gtid__set.html">Gtid_set</a> as a binary string. </p>

</div>
</div>
<a id="a4f026631d33627a5c273bdc35dcc03ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f026631d33627a5c273bdc35dcc03ef">&#9670;&nbsp;</a></span>ensure_sidno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::ensure_sidno </td>
          <td>(</td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>sidno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates space for all sidnos up to the given sidno in the array of intervals. The sidno must exist in the <a class="el" href="class_sid__map.html">Sid_map</a> associated with this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<p>If sid_lock != NULL, then the read lock on sid_lock must be held before calling this function. If the array is grown, sid_lock is temporarily upgraded to a write lock and then degraded again; there will be a short period when the lock is not held at all.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>The SIDNO. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="ac92c3495294a8533401fe17ea6e250f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92c3495294a8533401fe17ea6e250f4">&#9670;&nbsp;</a></span>get_encoded_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Gtid_set::get_encoded_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of this <a class="el" href="class_gtid__set.html">Gtid_set</a> when encoded using the <a class="el" href="class_gtid__set.html#a036d17fc704667febec3777422f164cd">encode()</a> function. </p>

</div>
</div>
<a id="aee334bbf87b4974bf7162ca4b8f3817c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee334bbf87b4974bf7162ca4b8f3817c">&#9670;&nbsp;</a></span>get_free_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::get_free_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> **&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a fresh new <a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> object.</p>
<p>This usually does not require any real allocation, it only pops the first interval from the list of free intervals. If there are no free intervals, it calls create_new_chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The resulting Interval* will be stored here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="af95788d41ef65127f643bf7c7b65a4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95788d41ef65127f643bf7c7b65a4e2">&#9670;&nbsp;</a></span>get_string_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_set::get_string_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> *&#160;</td>
          <td class="paramname"><em>string_format</em> = <code>NULL</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the output from to_string.</p>
<dl class="section warning"><dt>Warning</dt><dd>This does not include the trailing '\0', so your buffer needs space for <a class="el" href="class_gtid__set.html#af95788d41ef65127f643bf7c7b65a4e2">get_string_length()</a> + 1 characters.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_format</td><td><a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> object that specifies separators in the resulting text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length. </dd></dl>

</div>
</div>
<a id="a9a384be7c735d018d5fc0c8c0c64344e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a384be7c735d018d5fc0c8c0c64344e">&#9670;&nbsp;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the intersection of this <a class="el" href="class_gtid__set.html">Gtid_set</a> and the other <a class="el" href="class_gtid__set.html">Gtid_set</a> to result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="class_gtid__set.html">Gtid_set</a> to intersect with this <a class="el" href="class_gtid__set.html">Gtid_set</a> </td></tr>
    <tr><td class="paramname">result</td><td><a class="el" href="class_gtid__set.html">Gtid_set</a> where the result will be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000068">Todo:</a></b></dt><dd>: This algorithm is simple, a little bit slower than necessary. It would be more efficient to iterate over intervals of 'this' and 'other' similar to <a class="el" href="class_gtid__set.html#a631a429070b1828cff450a493fe913aa">add_gno_interval()</a>. At the moment the performance of this is not super-important. /Sven </dd></dl>

</div>
</div>
<a id="a09f59bb7b9cd3a32b54bb5f8128aa5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f59bb7b9cd3a32b54bb5f8128aa5ca">&#9670;&nbsp;</a></span>is_intersection_nonempty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtid_set::is_intersection_nonempty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if there is a least one element of this <a class="el" href="class_gtid__set.html">Gtid_set</a> in the other <a class="el" href="class_gtid__set.html">Gtid_set</a>. </p>

</div>
</div>
<a id="a312e5a07220196998a2cbac8d95e1fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312e5a07220196998a2cbac8d95e1fcf">&#9670;&nbsp;</a></span>is_interval_subset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtid_set::is_interval_subset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a> *&#160;</td>
          <td class="paramname"><em>sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a> *&#160;</td>
          <td class="paramname"><em>super</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if every interval of sub is a subset of some interval of super. </p>

</div>
</div>
<a id="a75513b924941cde711e91e8c0f9275a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75513b924941cde711e91e8c0f9275a0">&#9670;&nbsp;</a></span>is_subset_for_sid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtid_set::is_subset_for_sid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>super</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>superset_sidno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>subset_sidno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="class_gtid__set.html">Gtid_set</a> is a subset of the given gtid_set on the given superset_sidno and subset_sidno.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">super</td><td><a class="el" href="class_gtid__set.html">Gtid_set</a> with which 'this'::gtid_set needs to be compared </td></tr>
    <tr><td class="paramname">superset_sidno</td><td>The sidno that will be compared, relative to super-&gt;sid_map. </td></tr>
    <tr><td class="paramname">subset_sidno</td><td>The sidno that will be compared, relative to this-&gt;sid_map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If 'this' <a class="el" href="class_gtid__set.html">Gtid_set</a> is subset of given 'super' <a class="el" href="class_gtid__set.html">Gtid_set</a>. false If 'this' <a class="el" href="class_gtid__set.html">Gtid_set</a> is <em>not</em> subset of given 'super' <a class="el" href="class_gtid__set.html">Gtid_set</a>. </dd></dl>

</div>
</div>
<a id="a8a10c1dfb57ac995cbf14b51f83f8e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a10c1dfb57ac995cbf14b51f83f8e68">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtid_set::is_valid </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given string is a valid specification of a <a class="el" href="class_gtid__set.html">Gtid_set</a>, false otherwise. </p>

</div>
</div>
<a id="a0469b6a65245c7d163e4f668b6a035df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0469b6a65245c7d163e4f668b6a035df">&#9670;&nbsp;</a></span>put_free_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Gtid_set::put_free_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> *&#160;</td>
          <td class="paramname"><em>iv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts the given interval in the list of free intervals. Does not unlink it from its place in any other list. </p>

</div>
</div>
<a id="ab4542c0d0fbc95557d3c80264d3fcc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4542c0d0fbc95557d3c80264d3fcc24">&#9670;&nbsp;</a></span>remove_gno_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::remove_gno_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_interval__iterator.html">Interval_iterator</a> *&#160;</td>
          <td class="paramname"><em>ivitp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rpl_gno&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rpl_gno&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the interval (start, end) from the given <a class="el" href="class_gtid__set_1_1_interval__iterator.html">Interval_iterator</a>. This is the lowest-level function that removes groups; this is where <a class="el" href="struct_gtid__set_1_1_interval.html">Interval</a> objects are removed, truncated, or split.</p>
<p>It is not required that the groups in the interval exist in this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ivitp</td><td>Pointer to iterator. After this function returns, the current_element of the iterator will be the next interval after end. </td></tr>
    <tr><td class="paramname">start</td><td>The first GNO in the interval. </td></tr>
    <tr><td class="paramname">end</td><td>The first GNO after the interval. </td></tr>
    <tr><td class="paramname">lock</td><td>If this function has to add or remove an interval, then this lock will be taken unless it is already taken. This mechanism means that the lock will be taken lazily by e.g. <a class="el" href="class_gtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set()</a> the first time that the list of free intervals is accessed, and automatically released when <a class="el" href="class_gtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set()</a> returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="af82a55e8ed6521c0d23eaf0bc3bfd497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82a55e8ed6521c0d23eaf0bc3bfd497">&#9670;&nbsp;</a></span>remove_gno_intervals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::remove_gno_intervals </td>
          <td>(</td>
          <td class="paramtype">rpl_sidno&#160;</td>
          <td class="paramname"><em>sidno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_const__interval__iterator.html">Const_interval_iterator</a>&#160;</td>
          <td class="paramname"><em>ivit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a list of intervals from the given SIDNO.</p>
<p>It is not required that the intervals exist in this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sidno</td><td>The SIDNO from which intervals will be removed. </td></tr>
    <tr><td class="paramname">ivit</td><td>Iterator over the intervals to remove. This is typically an iterator over some other <a class="el" href="class_gtid__set.html">Gtid_set</a>. </td></tr>
    <tr><td class="paramname">lock</td><td>If this function has to add or remove an interval, then this lock will be taken unless it is already taken. This mechanism means that the lock will be taken lazily by e.g. <a class="el" href="class_gtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set()</a> the first time that the list of free intervals is accessed, and automatically released when <a class="el" href="class_gtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set()</a> returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="afc0a5e109f9b6f5d1fdec79462468340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0a5e109f9b6f5d1fdec79462468340">&#9670;&nbsp;</a></span>remove_gtid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_return_status Gtid_set::remove_gtid_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all groups in the given <a class="el" href="class_gtid__set.html">Gtid_set</a> from this <a class="el" href="class_gtid__set.html">Gtid_set</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="class_gtid__set.html">Gtid_set</a> to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RETURN_STATUS_OK or RETURN_STATUS_REPORTED_ERROR. </dd></dl>

</div>
</div>
<a id="a6edf398794ea7e5b50fd2f1f03039f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edf398794ea7e5b50fd2f1f03039f92">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* Gtid_set::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a newly allocated string containing this <a class="el" href="class_gtid__set.html">Gtid_set</a>, or NULL on out of memory. </p>

</div>
</div>
<a id="a4dae3fbe653bdb6dc5e59cc292111b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dae3fbe653bdb6dc5e59cc292111b3f">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_set::to_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> *&#160;</td>
          <td class="paramname"><em>string_format</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Formats this <a class="el" href="class_gtid__set.html">Gtid_set</a> as a string and saves in a given buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to the buffer where the string should be stored. This should have size at least <a class="el" href="class_gtid__set.html#af95788d41ef65127f643bf7c7b65a4e2">get_string_length()</a>+1. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">string_format</td><td><a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> object that specifies separators in the resulting text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the generated string. </dd></dl>

</div>
</div>
<a id="a3372b93fff473d081e5bd110210b9386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3372b93fff473d081e5bd110210b9386">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_set::to_string </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> *&#160;</td>
          <td class="paramname"><em>string_format</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Formats a <a class="el" href="class_gtid__set.html">Gtid_set</a> as a string and saves in a newly allocated buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Pointer to pointer to string. The function will set it to point to the newly allocated buffer, or NULL on out of memory. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">string_format</td><td>Specifies how to format the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Length</td><td>of the generated string, or -1 on out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a59860055a243825524c47d9adc494250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59860055a243825524c47d9adc494250">&#9670;&nbsp;</a></span>Gtid_set::Free_intervals_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Gtid_set::Free_intervals_lock</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by unit tests that need to access private members. </p>
<p>Only <a class="el" href="class_gtid__set_1_1_free__intervals__lock.html">Free_intervals_lock</a> is allowed to access free_intervals_mutex. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4ba668b76ba3d4a4d96a91389dc31817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba668b76ba3d4a4d96a91389dc31817">&#9670;&nbsp;</a></span>commented_string_format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_gtid__set_1_1_string__format.html">Gtid_set::String_format</a> Gtid_set::commented_string_format</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">  <span class="stringliteral">&quot;# &quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;:&quot;</span>, <span class="stringliteral">&quot;-&quot;</span>, <span class="stringliteral">&quot;:&quot;</span>, <span class="stringliteral">&quot;,\n# &quot;</span>, <span class="stringliteral">&quot;# [empty]&quot;</span>,</div><div class="line">  2, 0, 1, 1, 1, 4, 9</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> for printing the <a class="el" href="class_gtid__set.html">Gtid_set</a> commented: the string is not quote-wrapped, and every SID is on a new line with a leading '# '. </p>

</div>
</div>
<a id="a65b9f6c31cfc7d5ca7b1564411c2a416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b9f6c31cfc7d5ca7b1564411c2a416">&#9670;&nbsp;</a></span>default_string_format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_gtid__set_1_1_string__format.html">Gtid_set::String_format</a> Gtid_set::default_string_format</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">  <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;:&quot;</span>, <span class="stringliteral">&quot;-&quot;</span>, <span class="stringliteral">&quot;:&quot;</span>, <span class="stringliteral">&quot;,\n&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">  0, 0, 1, 1, 1, 2, 0</div><div class="line">}</div></div><!-- fragment --><p>The default <a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a>: the format understood by add_gtid_text(const char *). </p>

</div>
</div>
<a id="a741234c5a03195365346ad888bbeca81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741234c5a03195365346ad888bbeca81">&#9670;&nbsp;</a></span>free_intervals_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> Gtid_set::free_intervals_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lock protecting the list of free intervals. This lock is only used if sid_lock is not NULL. </p>

</div>
</div>
<a id="a5b610d998116151a6c58cc0a743046ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b610d998116151a6c58cc0a743046ec">&#9670;&nbsp;</a></span>intervals</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__dynamic__array.html">DYNAMIC_ARRAY</a> Gtid_set::intervals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array where the N'th element contains the head pointer to the intervals of SIDNO N+1. </p>

</div>
</div>
<a id="a84014647fe8f9773957a399da6a195a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84014647fe8f9773957a399da6a195a4">&#9670;&nbsp;</a></span>n_chunks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Gtid_set::n_chunks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of chunks. Used only to check some invariants when DBUG is on. </p>

</div>
</div>
<a id="abefb12fa60900cd38a8abe959b774f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefb12fa60900cd38a8abe959b774f54">&#9670;&nbsp;</a></span>sql_string_format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_gtid__set_1_1_string__format.html">Gtid_set::String_format</a> Gtid_set::sql_string_format</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">  <span class="stringliteral">&quot;&#39;&quot;</span>, <span class="stringliteral">&quot;&#39;&quot;</span>, <span class="stringliteral">&quot;:&quot;</span>, <span class="stringliteral">&quot;-&quot;</span>, <span class="stringliteral">&quot;:&quot;</span>, <span class="stringliteral">&quot;&#39;,\n&#39;&quot;</span>, <span class="stringliteral">&quot;&#39;&#39;&quot;</span>,</div><div class="line">  1, 1, 1, 1, 1, 4, 2</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="struct_gtid__set_1_1_string__format.html">String_format</a> useful to generate an SQL string: the string is wrapped in single quotes and there is a newline between SIDs. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="rpl__gtid_8h_source.html">rpl_gtid.h</a></li>
<li>sql/rpl_gtid_set.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

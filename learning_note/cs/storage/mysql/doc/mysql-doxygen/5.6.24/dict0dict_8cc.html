<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/dict/dict0dict.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_c831b130efbf9169b51e663499b9ee52.html">dict</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dict0dict.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fts0fts_8h_source.html">fts0fts.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="data0type_8h_source.html">data0type.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mach0data_8h_source.html">mach0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0crea_8h_source.html">dict0crea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0stats_8h_source.html">dict0stats.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0undo_8h_source.html">trx0undo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0once_8h_source.html">os0once.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0pars_8h_source.html">pars0pars.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0sym_8h_source.html">pars0sym.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fts0types_8h_source.html">fts0types.h</a>&quot;</code><br />
<code>#include &quot;m_ctype.h&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0priv_8h_source.html">dict0priv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0merge_8h_source.html">row0merge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0log_8h_source.html">row0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0ut_8h_source.html">ut0ut.h</a>&quot;</code><br />
<code>#include &quot;m_string.h&quot;</code><br />
<code>#include &quot;my_sys.h&quot;</code><br />
<code>#include &quot;mysqld.h&quot;</code><br />
<code>#include &quot;strfunc.h&quot;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__foreign__remove__partial.html">dict_foreign_remove_partial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a618168d3c16fcf6d9174b43907d1492c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a618168d3c16fcf6d9174b43907d1492c">DICT_HEAP_SIZE</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:a618168d3c16fcf6d9174b43907d1492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea1569f42e51c51330bdebec2f972b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#acea1569f42e51c51330bdebec2f972b5">DICT_POOL_PER_TABLE_HASH</a>&#160;&#160;&#160;512</td></tr>
<tr class="separator:acea1569f42e51c51330bdebec2f972b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac94c53a8fcfa0e0b8544d8a5f9a8b90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#aac94c53a8fcfa0e0b8544d8a5f9a8b90">DICT_POOL_PER_VARYING</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:aac94c53a8fcfa0e0b8544d8a5f9a8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7227a5ba3c90ba9ca2bcb0dbbc7c66"><td class="memItemLeft" align="right" valign="top"><a id="a5f7227a5ba3c90ba9ca2bcb0dbbc7c66"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIG_ROW_SIZE</b>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a5f7227a5ba3c90ba9ca2bcb0dbbc7c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4819fbf6292a3c6aedcdb3c33ef64d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a6e4819fbf6292a3c6aedcdb3c33ef64d">CREATE_TYPES_NAMES</a>()</td></tr>
<tr class="separator:a6e4819fbf6292a3c6aedcdb3c33ef64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aad343b0f78eedbe080ea4fe9e3aec477"><td class="memItemLeft" align="right" valign="top"><a id="aad343b0f78eedbe080ea4fe9e3aec477"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ib_warn_row_too_big</b> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:aad343b0f78eedbe080ea4fe9e3aec477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52b4d3b4a72eddf228fc06f88970792"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ab52b4d3b4a72eddf228fc06f88970792">dict_index_find_cols</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:ab52b4d3b4a72eddf228fc06f88970792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ee385310dbca2e8319fa352a34506f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#af1ee385310dbca2e8319fa352a34506f">dict_index_build_internal_clust</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:af1ee385310dbca2e8319fa352a34506f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8515b8e426ebe53bed93c8d7f58533a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a8515b8e426ebe53bed93c8d7f58533a0">dict_index_build_internal_non_clust</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a8515b8e426ebe53bed93c8d7f58533a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603240b6157bd9efa7e144045b5f29a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a603240b6157bd9efa7e144045b5f29a4">dict_index_build_internal_fts</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a603240b6157bd9efa7e144045b5f29a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d3a49d3c91e1b27addcdf0706f52a3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a58d3a49d3c91e1b27addcdf0706f52a3">dict_col_print_low</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const <a class="el" href="structdict__col__t.html">dict_col_t</a> *col)</td></tr>
<tr class="separator:a58d3a49d3c91e1b27addcdf0706f52a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ab2b572550ca88a5470aee059e8e1f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a30ab2b572550ca88a5470aee059e8e1f">dict_index_print_low</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a30ab2b572550ca88a5470aee059e8e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5eaa09ea7061883a8535c34c06d95f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a2c5eaa09ea7061883a8535c34c06d95f">dict_field_print_low</a> (const <a class="el" href="structdict__field__t.html">dict_field_t</a> *field)</td></tr>
<tr class="separator:a2c5eaa09ea7061883a8535c34c06d95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc121dcf8cebc138fb8c59efd2b9f33e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#adc121dcf8cebc138fb8c59efd2b9f33e">dict_index_remove_from_cache_low</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ibool lru_evict)</td></tr>
<tr class="separator:adc121dcf8cebc138fb8c59efd2b9f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0ae4cc9073c6791525d75b40553092"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#aca0ae4cc9073c6791525d75b40553092">dict_table_remove_from_cache_low</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ibool lru_evict)</td></tr>
<tr class="separator:aca0ae4cc9073c6791525d75b40553092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd71a18450a9e4c1aa70ed826442bcf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a5fd71a18450a9e4c1aa70ed826442bcf">dict_casedn_str</a> (char *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>)</td></tr>
<tr class="separator:a5fd71a18450a9e4c1aa70ed826442bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c9f33ad07e2661ef5c92a3bc58853e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a17c9f33ad07e2661ef5c92a3bc58853e">dict_tables_have_same_db</a> (const char *name1, const char *name2)</td></tr>
<tr class="separator:a17c9f33ad07e2661ef5c92a3bc58853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d13cf57d6cba918de841e4e08da5d56"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a0d13cf57d6cba918de841e4e08da5d56">dict_remove_db_name</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a0d13cf57d6cba918de841e4e08da5d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bec6f2c328f76fbfd23bc1af57c6aff"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a7bec6f2c328f76fbfd23bc1af57c6aff">dict_get_db_name_len</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a7bec6f2c328f76fbfd23bc1af57c6aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25862c97598776f8d56dea98879d76f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ae25862c97598776f8d56dea98879d76f">dict_mutex_enter_for_mysql</a> (void)</td></tr>
<tr class="separator:ae25862c97598776f8d56dea98879d76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea51b53d906e17ac34c888ab43ac895"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#acea51b53d906e17ac34c888ab43ac895">dict_mutex_exit_for_mysql</a> (void)</td></tr>
<tr class="separator:acea51b53d906e17ac34c888ab43ac895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc9845ed994d238ea786a7e18824bb7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#abfc9845ed994d238ea786a7e18824bb7">dict_table_stats_latch_alloc</a> (void *table_void)</td></tr>
<tr class="separator:abfc9845ed994d238ea786a7e18824bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eca5100b6f672eda7a3d37e58aba89"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a41eca5100b6f672eda7a3d37e58aba89">dict_table_stats_latch_free</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a41eca5100b6f672eda7a3d37e58aba89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fea7e3f600763f1ec8ada4c88f7a806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a7fea7e3f600763f1ec8ada4c88f7a806">dict_table_stats_latch_create</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, bool enabled)</td></tr>
<tr class="separator:a7fea7e3f600763f1ec8ada4c88f7a806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428c4723fd38a1e83223604d42b7b8ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a428c4723fd38a1e83223604d42b7b8ab">dict_table_stats_latch_destroy</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a428c4723fd38a1e83223604d42b7b8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80a681b70c81ca0ea43f44a5c18cac5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#af80a681b70c81ca0ea43f44a5c18cac5">dict_table_stats_lock</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint latch_mode)</td></tr>
<tr class="separator:af80a681b70c81ca0ea43f44a5c18cac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04604c3e7b339ea5e3c8abd28b090d3c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a04604c3e7b339ea5e3c8abd28b090d3c">dict_table_stats_unlock</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint latch_mode)</td></tr>
<tr class="separator:a04604c3e7b339ea5e3c8abd28b090d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6632f5f8cdd777607282722acbfbb455"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a6632f5f8cdd777607282722acbfbb455">dict_table_try_drop_aborted</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, table_id_t table_id, ulint ref_count)</td></tr>
<tr class="separator:a6632f5f8cdd777607282722acbfbb455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1989e2ada49c84e0e347071346946759"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a1989e2ada49c84e0e347071346946759">dict_table_try_drop_aborted_and_mutex_exit</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ibool try_drop)</td></tr>
<tr class="separator:a1989e2ada49c84e0e347071346946759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3820be766c877566c3e6b4a84e2cc12"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ab3820be766c877566c3e6b4a84e2cc12">dict_table_close</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ibool <a class="el" href="row0umod_8cc.html#a9a21208d7771d5950d52e7c903e9b017">dict_locked</a>, ibool try_drop)</td></tr>
<tr class="separator:ab3820be766c877566c3e6b4a84e2cc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0b313d8dee1744af43e55fce6dcf08"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a9b0b313d8dee1744af43e55fce6dcf08">dict_table_get_col_name</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint col_nr)</td></tr>
<tr class="separator:a9b0b313d8dee1744af43e55fce6dcf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e2ec99166cb4864aaff087ed0a65ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a46e2ec99166cb4864aaff087ed0a65ef">dict_table_autoinc_alloc</a> (void *table_void)</td></tr>
<tr class="separator:a46e2ec99166cb4864aaff087ed0a65ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2de3c437c5839848217de0a6154c1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#aaf2de3c437c5839848217de0a6154c1e">dict_index_zip_pad_alloc</a> (void *index_void)</td></tr>
<tr class="separator:aaf2de3c437c5839848217de0a6154c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49bfaa0816cb22789040f3bb6452801"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ab49bfaa0816cb22789040f3bb6452801">dict_table_autoinc_lock</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ab49bfaa0816cb22789040f3bb6452801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c78faad46732bf93f171537a22d6097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a2c78faad46732bf93f171537a22d6097">dict_index_zip_pad_lock</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a2c78faad46732bf93f171537a22d6097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb30464c14647e66de656bfeafe4ff74"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#acb30464c14647e66de656bfeafe4ff74">dict_table_autoinc_initialize</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ib_uint64_t value)</td></tr>
<tr class="separator:acb30464c14647e66de656bfeafe4ff74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9ad841f816713f946e02065c3fea10"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#aeb9ad841f816713f946e02065c3fea10">dict_table_get_all_fts_indexes</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structib__vector__t.html">ib_vector_t</a> *indexes)</td></tr>
<tr class="separator:aeb9ad841f816713f946e02065c3fea10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53afacec0c25e52b28facfe8f88897cf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a53afacec0c25e52b28facfe8f88897cf">dict_table_autoinc_read</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a53afacec0c25e52b28facfe8f88897cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af842ce585a97426002ec4989065efa1f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#af842ce585a97426002ec4989065efa1f">dict_table_autoinc_update_if_greater</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ib_uint64_t value)</td></tr>
<tr class="separator:af842ce585a97426002ec4989065efa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723afb57a4938d2c27f79040748c1378"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a723afb57a4938d2c27f79040748c1378">dict_table_autoinc_unlock</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a723afb57a4938d2c27f79040748c1378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1724dd9eb3aee41e4f8a9cd5b12cfa02"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a1724dd9eb3aee41e4f8a9cd5b12cfa02">dict_index_get_nth_col_or_prefix_pos</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, ibool inc_prefix)</td></tr>
<tr class="separator:a1724dd9eb3aee41e4f8a9cd5b12cfa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1b96ff14be9ff80dc62bfd2a96d61a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a8d1b96ff14be9ff80dc62bfd2a96d61a">dict_index_contains_col_or_prefix</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a8d1b96ff14be9ff80dc62bfd2a96d61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dec2cadd776cf77d54bfd170f5aad37"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a7dec2cadd776cf77d54bfd170f5aad37">dict_index_get_nth_field_pos</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *index2, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a7dec2cadd776cf77d54bfd170f5aad37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fc5eb076cc17572bf406ee7ab1f9e8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a16fc5eb076cc17572bf406ee7ab1f9e8">dict_table_open_on_id</a> (table_id_t table_id, ibool <a class="el" href="row0umod_8cc.html#a9a21208d7771d5950d52e7c903e9b017">dict_locked</a>, <a class="el" href="dict0dict_8h.html#ad37e188831074bcf7fdae6bd963a1599">dict_table_op_t</a> table_op)</td></tr>
<tr class="separator:a16fc5eb076cc17572bf406ee7ab1f9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9720be12ef6d46a9bf22a94c5598f16"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ae9720be12ef6d46a9bf22a94c5598f16">dict_table_get_nth_col_pos</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:ae9720be12ef6d46a9bf22a94c5598f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9a972080b4db2d95e84201c8424562"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a0d9a972080b4db2d95e84201c8424562">dict_table_col_in_clustered_key</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a0d9a972080b4db2d95e84201c8424562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef812c49166835cf66a42dd3efab45c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a6ef812c49166835cf66a42dd3efab45c">dict_init</a> (void)</td></tr>
<tr class="separator:a6ef812c49166835cf66a42dd3efab45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c7671ff3615631489ab3455ddeed99"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ab7c7671ff3615631489ab3455ddeed99">dict_move_to_mru</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ab7c7671ff3615631489ab3455ddeed99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173c1301f343e7d305785c556ba35b82"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a173c1301f343e7d305785c556ba35b82">dict_table_open_on_name</a> (const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, ibool <a class="el" href="row0umod_8cc.html#a9a21208d7771d5950d52e7c903e9b017">dict_locked</a>, ibool try_drop, <a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a> <a class="el" href="dict0load_8cc.html#a9a28d171c183917206e81f1571dc72df">ignore_err</a>)</td></tr>
<tr class="separator:a173c1301f343e7d305785c556ba35b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f828e344beff1a10211d307682e1c8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a94f828e344beff1a10211d307682e1c8">dict_table_add_system_columns</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a94f828e344beff1a10211d307682e1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a19f9aaf680e7d1433d5400a4e04e37"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a4a19f9aaf680e7d1433d5400a4e04e37">dict_table_add_to_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ibool can_be_evicted, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a4a19f9aaf680e7d1433d5400a4e04e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ac61f025d283937e11565796f8ac27"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ac8ac61f025d283937e11565796f8ac27">dict_table_can_be_evicted</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ac8ac61f025d283937e11565796f8ac27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397377fd297fc5dbaf4f22476b91b2c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a397377fd297fc5dbaf4f22476b91b2c0">dict_make_room_in_cache</a> (ulint max_tables, ulint pct_check)</td></tr>
<tr class="separator:a397377fd297fc5dbaf4f22476b91b2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa626c8b9d58aacb01e9de5e5685ce5e4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#aa626c8b9d58aacb01e9de5e5685ce5e4">dict_table_move_from_lru_to_non_lru</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:aa626c8b9d58aacb01e9de5e5685ce5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8bbe5ea4c31fdd32c64cf76dda9407"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a5a8bbe5ea4c31fdd32c64cf76dda9407">dict_table_move_from_non_lru_to_lru</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a5a8bbe5ea4c31fdd32c64cf76dda9407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80be4fb9c73cd15f56b734980f0620d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#af80be4fb9c73cd15f56b734980f0620d">dict_table_find_index_on_id</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, index_id_t <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:af80be4fb9c73cd15f56b734980f0620d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bf7f6dba8d9868a3fbc3ac1aa43d4d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a63bf7f6dba8d9868a3fbc3ac1aa43d4d">dict_index_find_on_id_low</a> (index_id_t <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a63bf7f6dba8d9868a3fbc3ac1aa43d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4931cb7447a3b6276d9e628fc0f75d8f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a4931cb7447a3b6276d9e628fc0f75d8f">dict_table_rename_in_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char *new_name, ibool rename_also_foreigns)</td></tr>
<tr class="separator:a4931cb7447a3b6276d9e628fc0f75d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b20d19158e7bef1ca59d308c8745727"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a4b20d19158e7bef1ca59d308c8745727">dict_table_change_id_in_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, table_id_t new_id)</td></tr>
<tr class="separator:a4b20d19158e7bef1ca59d308c8745727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce9c12df7e6ff2de04d27f9fa47624f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a5ce9c12df7e6ff2de04d27f9fa47624f">dict_table_remove_from_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a5ce9c12df7e6ff2de04d27f9fa47624f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b04fc5a43c0fbee742975b9becea2b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ae9b04fc5a43c0fbee742975b9becea2b">dict_col_name_is_reserved</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ae9b04fc5a43c0fbee742975b9becea2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed9eaa6639867e07011bc5632a75d3b"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#afed9eaa6639867e07011bc5632a75d3b">dict_index_too_big_for_undo</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *new_index)</td></tr>
<tr class="separator:afed9eaa6639867e07011bc5632a75d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64a07f4809b51bf88c408e0b7f384cb"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#af64a07f4809b51bf88c408e0b7f384cb">dict_index_too_big_for_tree</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *new_index)</td></tr>
<tr class="separator:af64a07f4809b51bf88c408e0b7f384cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f650ba48d7d2278b644875875a6f85b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a7f650ba48d7d2278b644875875a6f85b">dict_index_add_to_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, ibool strict)</td></tr>
<tr class="separator:a7f650ba48d7d2278b644875875a6f85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e217b3ee2c2aa4bb7e292e21f3c9a2e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a8e217b3ee2c2aa4bb7e292e21f3c9a2e">dict_index_remove_from_cache</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a8e217b3ee2c2aa4bb7e292e21f3c9a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf92c2e4e73403931a16cf49e2ddf9a3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#adf92c2e4e73403931a16cf49e2ddf9a3">dict_index_add_col</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__col__t.html">dict_col_t</a> *col, ulint prefix_len)</td></tr>
<tr class="separator:adf92c2e4e73403931a16cf49e2ddf9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42a84e4b90fcbce8ae15dfe3cf747a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ac42a84e4b90fcbce8ae15dfe3cf747a8">dict_index_copy</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index1, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index2, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint start, ulint end)</td></tr>
<tr class="separator:ac42a84e4b90fcbce8ae15dfe3cf747a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca6181f0a8abde62fe5cbafc56d494b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#afca6181f0a8abde62fe5cbafc56d494b">dict_index_copy_types</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="row0merge_8cc.html#ac496ec05ddad9f1550478aec28d4dff0">n_fields</a>)</td></tr>
<tr class="separator:afca6181f0a8abde62fe5cbafc56d494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bc055c2cfd705fdf7c8e398052d04b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#af9bc055c2cfd705fdf7c8e398052d04b">dict_table_copy_types</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:af9bc055c2cfd705fdf7c8e398052d04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f94dee0afa880f6289b231748ac7ea"><td class="memItemLeft" align="right" valign="top"><a id="ac4f94dee0afa880f6289b231748ac7ea"></a>
UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>dict_table_wait_for_bg_threads_to_exit</b> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint delay)</td></tr>
<tr class="separator:ac4f94dee0afa880f6289b231748ac7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad161e2bebda3505b1126f6d3086b23"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a6ad161e2bebda3505b1126f6d3086b23">dict_table_is_referenced_by_foreign_key</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a6ad161e2bebda3505b1126f6d3086b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c737c0acb031f95387bede1f043843c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a3c737c0acb031f95387bede1f043843c">dict_table_get_referenced_constraint</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a3c737c0acb031f95387bede1f043843c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5f2c20a9921fde2364cadf5c1617bf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a8e5f2c20a9921fde2364cadf5c1617bf">dict_table_get_foreign_constraint</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a8e5f2c20a9921fde2364cadf5c1617bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f346477aa6b5b307e3dc28a6bc1a3d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a67f346477aa6b5b307e3dc28a6bc1a3d">dict_foreign_remove_from_cache</a> (<a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *<a class="el" href="row0ins_8cc.html#a1362873f2d7bb1bfd79ca409ddbb674a">foreign</a>)</td></tr>
<tr class="separator:a67f346477aa6b5b307e3dc28a6bc1a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee7cee267a03b49d497799c70b98e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a24ee7cee267a03b49d497799c70b98e6">dict_foreign_find</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *<a class="el" href="row0ins_8cc.html#a1362873f2d7bb1bfd79ca409ddbb674a">foreign</a>)</td></tr>
<tr class="separator:a24ee7cee267a03b49d497799c70b98e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9509b816d6e6cd3549e27c6b30427a48"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a9509b816d6e6cd3549e27c6b30427a48">dict_foreign_find_index</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char **<a class="el" href="dict0load_8cc.html#a3e7bc9f4cd7bbfa8a51a407837f72b55">col_names</a>, const char **columns, ulint n_cols, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *types_idx, bool <a class="el" href="dict0load_8cc.html#a3fac4efac7823b3e26c17321965b0abe">check_charsets</a>, ulint check_null)</td></tr>
<tr class="separator:a9509b816d6e6cd3549e27c6b30427a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41bc842c3bc63a1a110cd29f9b427da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#af41bc842c3bc63a1a110cd29f9b427da">dict_foreign_error_report_low</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:af41bc842c3bc63a1a110cd29f9b427da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5ff794b470852ef356c27a5ee84afc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#afa5ff794b470852ef356c27a5ee84afc">dict_foreign_error_report</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *fk, const char *<a class="el" href="structmsg.html">msg</a>)</td></tr>
<tr class="separator:afa5ff794b470852ef356c27a5ee84afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b7666d847e3d9e79eb322ff08db31c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a61b7666d847e3d9e79eb322ff08db31c">dict_foreign_add_to_cache</a> (<a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *<a class="el" href="row0ins_8cc.html#a1362873f2d7bb1bfd79ca409ddbb674a">foreign</a>, const char **<a class="el" href="dict0load_8cc.html#a3e7bc9f4cd7bbfa8a51a407837f72b55">col_names</a>, bool <a class="el" href="dict0load_8cc.html#a3fac4efac7823b3e26c17321965b0abe">check_charsets</a>, <a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a> <a class="el" href="dict0load_8cc.html#a9a28d171c183917206e81f1571dc72df">ignore_err</a>)</td></tr>
<tr class="separator:a61b7666d847e3d9e79eb322ff08db31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb52e0452226d74bbc217d1ad0fd19e"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#afeb52e0452226d74bbc217d1ad0fd19e">dict_scan_to</a> (const char *ptr, const char *string)</td></tr>
<tr class="separator:afeb52e0452226d74bbc217d1ad0fd19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f1dd875af0565ed4b8da8cd9e6d25d"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#af7f1dd875af0565ed4b8da8cd9e6d25d">dict_accept</a> (struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *cs, const char *ptr, const char *string, ibool *success)</td></tr>
<tr class="separator:af7f1dd875af0565ed4b8da8cd9e6d25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3433393375c4b26ff4dad1ba7288a5ff"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a3433393375c4b26ff4dad1ba7288a5ff">dict_scan_id</a> (struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *cs, const char *ptr, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const char **<a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ibool table_id, ibool accept_also_dot)</td></tr>
<tr class="separator:a3433393375c4b26ff4dad1ba7288a5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95f6ee6ea989e2d6389040aa90fab02"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ae95f6ee6ea989e2d6389040aa90fab02">dict_scan_col</a> (struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *cs, const char *ptr, ibool *success, <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const <a class="el" href="structdict__col__t.html">dict_col_t</a> **column, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const char **<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ae95f6ee6ea989e2d6389040aa90fab02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7832690eefab0cd2f54e4ca1086e459e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a7832690eefab0cd2f54e4ca1086e459e">dict_get_referenced_table</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *<a class="el" href="row0mysql_8cc.html#a085345c23a5cb2745233c9924425af10">database_name</a>, ulint database_name_len, const char *<a class="el" href="ha__innodb_8cc.html#a0027708eb826fc9750cdd8953fded532">table_name</a>, ulint table_name_len, <a class="el" href="structdict__table__t.html">dict_table_t</a> **<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a7832690eefab0cd2f54e4ca1086e459e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e080a03465bbad28b15358e5534423e"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a7e080a03465bbad28b15358e5534423e">dict_scan_table_name</a> (struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *cs, const char *ptr, <a class="el" href="structdict__table__t.html">dict_table_t</a> **<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ibool *success, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const char **ref_name)</td></tr>
<tr class="separator:a7e080a03465bbad28b15358e5534423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3375ad03cf2893e0a4ebfe68c7f5ff94"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a3375ad03cf2893e0a4ebfe68c7f5ff94">dict_skip_word</a> (struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *cs, const char *ptr, ibool *success)</td></tr>
<tr class="separator:a3375ad03cf2893e0a4ebfe68c7f5ff94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0449774b838906b3e79242282848381"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ad0449774b838906b3e79242282848381">dict_strip_comments</a> (const char *sql_string, size_t sql_length)</td></tr>
<tr class="separator:ad0449774b838906b3e79242282848381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f3f547474e816ea33fea968dd71273"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ab5f3f547474e816ea33fea968dd71273">dict_table_get_highest_foreign_id</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ab5f3f547474e816ea33fea968dd71273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4469447426aac986ba56f6db5c9d34"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a9f4469447426aac986ba56f6db5c9d34">dict_foreign_report_syntax_err</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *start_of_latest_foreign, const char *ptr)</td></tr>
<tr class="separator:a9f4469447426aac986ba56f6db5c9d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae797a46733fef373c4f5ed82f580c0e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ae797a46733fef373c4f5ed82f580c0e4">dict_create_foreign_constraints_low</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *cs, const char *sql_string, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ibool reject_fks)</td></tr>
<tr class="separator:ae797a46733fef373c4f5ed82f580c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5befceecf543154dd5ef75ce8461528"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#af5befceecf543154dd5ef75ce8461528">dict_str_starts_with_keyword</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const char *str, const char *keyword)</td></tr>
<tr class="separator:af5befceecf543154dd5ef75ce8461528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c8291ce222ecab26b50a2883c9ce73"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a73c8291ce222ecab26b50a2883c9ce73">dict_create_foreign_constraints</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, const char *sql_string, size_t sql_length, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ibool reject_fks)</td></tr>
<tr class="separator:a73c8291ce222ecab26b50a2883c9ce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c06c9fc99dcaa57a13731ff001d94f2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a5c06c9fc99dcaa57a13731ff001d94f2">dict_foreign_parse_drop_constraints</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint *<a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, const char ***constraints_to_drop)</td></tr>
<tr class="separator:a5c06c9fc99dcaa57a13731ff001d94f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbb600cba0743d040dd0b21ac920454"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a7fbb600cba0743d040dd0b21ac920454">dict_index_get_if_in_cache_low</a> (index_id_t index_id)</td></tr>
<tr class="separator:a7fbb600cba0743d040dd0b21ac920454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894161e0d082b8e7376470ecab814016"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a894161e0d082b8e7376470ecab814016">dict_index_build_node_ptr</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>)</td></tr>
<tr class="separator:a894161e0d082b8e7376470ecab814016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab555cf7e9a92304e09d05db772b8dab1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ab555cf7e9a92304e09d05db772b8dab1">dict_index_copy_rec_order_prefix</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, ulint *<a class="el" href="row0merge_8cc.html#ac496ec05ddad9f1550478aec28d4dff0">n_fields</a>, byte **<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint *<a class="el" href="row0merge_8cc.html#a4454283b5709de09b07c6d13c63c3927">buf_size</a>)</td></tr>
<tr class="separator:ab555cf7e9a92304e09d05db772b8dab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ec3cce534686707f98abb61d3601a5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a46ec3cce534686707f98abb61d3601a5">dict_index_build_data_tuple</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, ulint <a class="el" href="row0merge_8cc.html#ac496ec05ddad9f1550478aec28d4dff0">n_fields</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a46ec3cce534686707f98abb61d3601a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceba24bdcaf09e09194645ca2ca62d1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a4ceba24bdcaf09e09194645ca2ca62d1">dict_index_calc_min_rec_len</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a4ceba24bdcaf09e09194645ca2ca62d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6bcf2106fd2ad52e1fd7292d66df19"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#aef6bcf2106fd2ad52e1fd7292d66df19">dict_foreign_print_low</a> (<a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *<a class="el" href="row0ins_8cc.html#a1362873f2d7bb1bfd79ca409ddbb674a">foreign</a>)</td></tr>
<tr class="separator:aef6bcf2106fd2ad52e1fd7292d66df19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6452a812364b1faf9aeda3f88e909e8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ab6452a812364b1faf9aeda3f88e909e8">dict_table_print</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:ab6452a812364b1faf9aeda3f88e909e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f25cfa132b5723cdb99992d733439f4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a9f25cfa132b5723cdb99992d733439f4">dict_print_info_on_foreign_key_in_create_format</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *<a class="el" href="row0ins_8cc.html#a1362873f2d7bb1bfd79ca409ddbb674a">foreign</a>, ibool add_newline)</td></tr>
<tr class="separator:a9f25cfa132b5723cdb99992d733439f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65969d432fe467c57380492067f7bd28"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a65969d432fe467c57380492067f7bd28">dict_print_info_on_foreign_keys</a> (ibool create_table_format, FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a65969d432fe467c57380492067f7bd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0c8e86a47c780f5b23f725b12ae21e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a5a0c8e86a47c780f5b23f725b12ae21e">dict_index_name_print</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a5a0c8e86a47c780f5b23f725b12ae21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952eb767919a99aa9993eb6c1933d2e3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a952eb767919a99aa9993eb6c1933d2e3">dict_find_table_by_space</a> (ulint space_id)</td></tr>
<tr class="separator:a952eb767919a99aa9993eb6c1933d2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab174f1dfadd6de621f5bded28c6c25de"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ab174f1dfadd6de621f5bded28c6c25de">dict_set_corrupted_by_space</a> (ulint space_id)</td></tr>
<tr class="separator:ab174f1dfadd6de621f5bded28c6c25de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0bc8ad9d8b97e93761f9150756273c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a6f0bc8ad9d8b97e93761f9150756273c">dict_set_corrupted</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, const char *ctx)</td></tr>
<tr class="separator:a6f0bc8ad9d8b97e93761f9150756273c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61812d7472f10e4f78660f75e001d8e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#aa61812d7472f10e4f78660f75e001d8e">dict_set_corrupted_index_cache_only</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:aa61812d7472f10e4f78660f75e001d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac625bf70b3857b1565a7b64f2b25ed93"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ac625bf70b3857b1565a7b64f2b25ed93">dict_ind_init</a> (void)</td></tr>
<tr class="separator:ac625bf70b3857b1565a7b64f2b25ed93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376976964bc0adea33b8792613f0688"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a2376976964bc0adea33b8792613f0688">dict_ind_free</a> (void)</td></tr>
<tr class="separator:a2376976964bc0adea33b8792613f0688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f034e55e1266359ab4c4c020d3812c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a85f034e55e1266359ab4c4c020d3812c">dict_table_get_index_on_name</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a85f034e55e1266359ab4c4c020d3812c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453e4327c7edfb630a64b1fb07885cdf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a453e4327c7edfb630a64b1fb07885cdf">dict_foreign_replace_index</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char **<a class="el" href="dict0load_8cc.html#a3e7bc9f4cd7bbfa8a51a407837f72b55">col_names</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a453e4327c7edfb630a64b1fb07885cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0c175b88bcb48aa6c09be3d0069027"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a4c0c175b88bcb48aa6c09be3d0069027">dict_table_get_index_on_name_and_min_id</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a4c0c175b88bcb48aa6c09be3d0069027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdeaa13251e2885436d83de4f271774"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a1bdeaa13251e2885436d83de4f271774">dict_fs2utf8</a> (const char *db_and_table, char *db_utf8, size_t db_utf8_size, char *table_utf8, size_t table_utf8_size)</td></tr>
<tr class="separator:a1bdeaa13251e2885436d83de4f271774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7e6b6ec30ca9eec9e6c2b154fe527a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#abb7e6b6ec30ca9eec9e6c2b154fe527a">dict_close</a> (void)</td></tr>
<tr class="separator:abb7e6b6ec30ca9eec9e6c2b154fe527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5687f15e99784a37a5480dcf6a0c3ad9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a5687f15e99784a37a5480dcf6a0c3ad9">dict_foreign_qualify_index</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const char **<a class="el" href="dict0load_8cc.html#a3e7bc9f4cd7bbfa8a51a407837f72b55">col_names</a>, const char **columns, ulint n_cols, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *types_idx, bool <a class="el" href="dict0load_8cc.html#a3fac4efac7823b3e26c17321965b0abe">check_charsets</a>, ulint check_null)</td></tr>
<tr class="separator:a5687f15e99784a37a5480dcf6a0c3ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b1dee0bf5873f1d1411b9a076ce6ac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a86b1dee0bf5873f1d1411b9a076ce6ac">dict_index_zip_pad_update</a> (<a class="el" href="structzip__pad__info__t.html">zip_pad_info_t</a> *info, ulint zip_threshold)</td></tr>
<tr class="separator:a86b1dee0bf5873f1d1411b9a076ce6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fb6150cc7e3da83b3e75335ef9cecb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a66fb6150cc7e3da83b3e75335ef9cecb">dict_index_zip_success</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a66fb6150cc7e3da83b3e75335ef9cecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63427d2546157136807fd3fd504342bc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a63427d2546157136807fd3fd504342bc">dict_index_zip_failure</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a63427d2546157136807fd3fd504342bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8427eee5255a741379de8195697bfe"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a6c8427eee5255a741379de8195697bfe">dict_index_zip_pad_optimal_page_size</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a6c8427eee5255a741379de8195697bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d042819b0b32cbddba3cf3ff03d24f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ad5d042819b0b32cbddba3cf3ff03d24f">dict_tf_to_row_format_string</a> (ulint table_flag)</td></tr>
<tr class="separator:ad5d042819b0b32cbddba3cf3ff03d24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4401bccbcb5e191cdd3d95728549747f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a4401bccbcb5e191cdd3d95728549747f">dict_table_schema_check</a> (<a class="el" href="structdict__table__schema__t.html">dict_table_schema_t</a> *req_schema, char *errstr, size_t errstr_sz)</td></tr>
<tr class="separator:a4401bccbcb5e191cdd3d95728549747f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a975706a18d0ba2e302f2c6e1cd905f59"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a975706a18d0ba2e302f2c6e1cd905f59">dict_ind_redundant</a></td></tr>
<tr class="separator:a975706a18d0ba2e302f2c6e1cd905f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f366968ef52576a00ba9d1c95ba372f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a2f366968ef52576a00ba9d1c95ba372f">dict_ind_compact</a></td></tr>
<tr class="separator:a2f366968ef52576a00ba9d1c95ba372f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8913b84084da00fa9870fbae64b75aa3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__sys__t.html">dict_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a8913b84084da00fa9870fbae64b75aa3">dict_sys</a> = NULL</td></tr>
<tr class="separator:a8913b84084da00fa9870fbae64b75aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac379b632e8479bbf0e33a5e0a3105368"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structrw__lock__t.html">rw_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ac379b632e8479bbf0e33a5e0a3105368">dict_operation_lock</a></td></tr>
<tr class="memdesc:ac379b632e8479bbf0e33a5e0a3105368"><td class="mdescLeft">&#160;</td><td class="mdescRight">the data dictionary rw-latch protecting dict_sys  <a href="#ac379b632e8479bbf0e33a5e0a3105368">More...</a><br /></td></tr>
<tr class="separator:ac379b632e8479bbf0e33a5e0a3105368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04860931b6c5270d0cb91ee34bea1a2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#ac04860931b6c5270d0cb91ee34bea1a2">zip_failure_threshold_pct</a> = 5</td></tr>
<tr class="separator:ac04860931b6c5270d0cb91ee34bea1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd0ad667c54fd1a585b5d1bb2d3f7c6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a7fd0ad667c54fd1a585b5d1bb2d3f7c6">zip_pad_max</a> = 50</td></tr>
<tr class="separator:a7fd0ad667c54fd1a585b5d1bb2d3f7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874357b82465503e7f7cdb187036df44"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0dict_8cc.html#a874357b82465503e7f7cdb187036df44">dict_ibfk</a> [] = &quot;_ibfk_&quot;</td></tr>
<tr class="separator:a874357b82465503e7f7cdb187036df44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06218747fef5a07bdb40b1862a489f76"><td class="memItemLeft" align="right" valign="top"><a id="a06218747fef5a07bdb40b1862a489f76"></a>
UNIV_INTERN FILE *&#160;</td><td class="memItemRight" valign="bottom"><b>dict_foreign_err_file</b> = NULL</td></tr>
<tr class="separator:a06218747fef5a07bdb40b1862a489f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1e3edd1bc11b52825041f73eaa4d82"><td class="memItemLeft" align="right" valign="top"><a id="a7f1e3edd1bc11b52825041f73eaa4d82"></a>
UNIV_INTERN <a class="el" href="structib__mutex__t.html">ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dict_foreign_err_mutex</b></td></tr>
<tr class="separator:a7f1e3edd1bc11b52825041f73eaa4d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data dictionary system</p>
<p>Created 1/8/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6e4819fbf6292a3c6aedcdb3c33ef64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4819fbf6292a3c6aedcdb3c33ef64d">&#9670;&nbsp;</a></span>CREATE_TYPES_NAMES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CREATE_TYPES_NAMES</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="data0type_8h.html#ac1b30320f80b2109cb46d6e23cc2a033">dtype_sql_name</a>((<span class="keywordtype">unsigned</span>) req_schema-&gt;columns[<a class="code" href="buf0buddy_8cc.html#a303adcc1d2d4784f47305cea9986649c">i</a>].mtype, \</div><div class="line">                       (<span class="keywordtype">unsigned</span>) req_schema-&gt;columns[i].prtype_mask, \</div><div class="line">                       (<span class="keywordtype">unsigned</span>) req_schema-&gt;columns[i].len, \</div><div class="line">                       req_type, <span class="keyword">sizeof</span>(req_type)); \</div><div class="line">        dtype_sql_name(<a class="code" href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a>-&gt;cols[j].mtype, \</div><div class="line">                       <a class="code" href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a>-&gt;cols[j].prtype, \</div><div class="line">                       <a class="code" href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a>-&gt;cols[j].len, \</div><div class="line">                       actual_type, <span class="keyword">sizeof</span>(actual_type))</div><div class="ttc" id="buf0buddy_8cc_html_a303adcc1d2d4784f47305cea9986649c"><div class="ttname"><a href="buf0buddy_8cc.html#a303adcc1d2d4784f47305cea9986649c">i</a></div><div class="ttdeci">static ulint i</div><div class="ttdef"><b>Definition:</b> buf0buddy.cc:235</div></div>
<div class="ttc" id="data0type_8h_html_ac1b30320f80b2109cb46d6e23cc2a033"><div class="ttname"><a href="data0type_8h.html#ac1b30320f80b2109cb46d6e23cc2a033">dtype_sql_name</a></div><div class="ttdeci">UNIV_INLINE char * dtype_sql_name(unsigned mtype, unsigned prtype, unsigned len, char *name, unsigned name_sz)</div></div>
<div class="ttc" id="dict0crea_8cc_html_a97b9c482d2e3a71e14565e116943095a"><div class="ttname"><a href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a></div><div class="ttdeci">table</div><div class="ttdef"><b>Definition:</b> dict0crea.cc:266</div></div>
</div><!-- fragment --><p>Auxiliary macro used inside <a class="el" href="dict0dict_8cc.html#a4401bccbcb5e191cdd3d95728549747f">dict_table_schema_check()</a>. </p>

</div>
</div>
<a id="a618168d3c16fcf6d9174b43907d1492c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618168d3c16fcf6d9174b43907d1492c">&#9670;&nbsp;</a></span>DICT_HEAP_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DICT_HEAP_SIZE&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>initial memory heap size when creating a table or index object </p>

</div>
</div>
<a id="acea1569f42e51c51330bdebec2f972b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea1569f42e51c51330bdebec2f972b5">&#9670;&nbsp;</a></span>DICT_POOL_PER_TABLE_HASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DICT_POOL_PER_TABLE_HASH&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>buffer pool max size per table hash table fixed size in bytes </p>

</div>
</div>
<a id="aac94c53a8fcfa0e0b8544d8a5f9a8b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac94c53a8fcfa0e0b8544d8a5f9a8b90">&#9670;&nbsp;</a></span>DICT_POOL_PER_VARYING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DICT_POOL_PER_VARYING&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>buffer pool max size per data dictionary varying size in bytes </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af7f1dd875af0565ed4b8da8cd9e6d25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f1dd875af0565ed4b8da8cd9e6d25d">&#9670;&nbsp;</a></span>dict_accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* dict_accept </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Accepts a specified string. Comparisons are case-insensitive. </p><dl class="section return"><dt>Returns</dt><dd>if string was accepted, the pointer is moved after that, else ptr is returned </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>in: the character set of ptr </td></tr>
    <tr><td class="paramname">ptr</td><td>in: scan from this </td></tr>
    <tr><td class="paramname">string</td><td>in: accept only this string as the next non-whitespace string </td></tr>
    <tr><td class="paramname">success</td><td>out: TRUE if accepted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fd71a18450a9e4c1aa70ed826442bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd71a18450a9e4c1aa70ed826442bcf">&#9670;&nbsp;</a></span>dict_casedn_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_casedn_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes all characters in a NUL-terminated UTF-8 string lower case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>in/out: string to put in lower case </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb7e6b6ec30ca9eec9e6c2b154fe527a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7e6b6ec30ca9eec9e6c2b154fe527a">&#9670;&nbsp;</a></span>dict_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the data dictionary module. </p>

</div>
</div>
<a id="ae9b04fc5a43c0fbee742975b9becea2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b04fc5a43c0fbee742975b9becea2b">&#9670;&nbsp;</a></span>dict_col_name_is_reserved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool dict_col_name_is_reserved </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the given column name is reserved for InnoDB system columns, return TRUE. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if name is reserved </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: column name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58d3a49d3c91e1b27addcdf0706f52a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d3a49d3c91e1b27addcdf0706f52a3">&#9670;&nbsp;</a></span>dict_col_print_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_col_print_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints a column data. in: column</p>
<p>Prints a column data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">col</td><td>in: column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73c8291ce222ecab26b50a2883c9ce73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c8291ce222ecab26b50a2883c9ce73">&#9670;&nbsp;</a></span>dict_create_foreign_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_create_foreign_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sql_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>reject_fks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans a table create SQL string and adds to the data dictionary the foreign key constraints declared in the string. This function should be called after the indexes for a table have been created. Each foreign key constraint must be accompanied with indexes in both participating tables. The indexes are allowed to contain more fields than mentioned in the constraint. </p><dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">sql_string</td><td>in: table create statement where foreign keys are declared like: FOREIGN KEY (a, b) REFERENCES table2(c, d), table2 can be written also with the database name before it: test.table2; the default database id the database of parameter name </td></tr>
    <tr><td class="paramname">sql_length</td><td>in: length of sql_string </td></tr>
    <tr><td class="paramname">name</td><td>in: table full name in the normalized form database_name/table_name </td></tr>
    <tr><td class="paramname">reject_fks</td><td>in: if TRUE, fail with error code DB_CANNOT_ADD_CONSTRAINT if any foreign keys are found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae797a46733fef373c4f5ed82f580c0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae797a46733fef373c4f5ed82f580c0e4">&#9670;&nbsp;</a></span>dict_create_foreign_constraints_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_create_foreign_constraints_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>reject_fks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scans a table create SQL string and adds to the data dictionary the foreign key constraints declared in the string. This function should be called after the indexes for a table have been created. Each foreign key constraint must be accompanied with indexes in both participating tables. The indexes are allowed to contain more fields than mentioned in the constraint. </p><dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
    <tr><td class="paramname">cs</td><td>in: the character set of sql_string </td></tr>
    <tr><td class="paramname">sql_string</td><td>in: CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> or ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> statement where foreign keys are declared like: FOREIGN KEY (a, b) REFERENCES table2(c, d), table2 can be written also with the database name before it: test.table2; the default database is the database of parameter name </td></tr>
    <tr><td class="paramname">name</td><td>in: table full name in the normalized form database_name/table_name </td></tr>
    <tr><td class="paramname">reject_fks</td><td>in: if TRUE, fail with error code DB_CANNOT_ADD_CONSTRAINT if any foreign keys are found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c5eaa09ea7061883a8535c34c06d95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5eaa09ea7061883a8535c34c06d95f">&#9670;&nbsp;</a></span>dict_field_print_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_field_print_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__field__t.html">dict_field_t</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints a field data. in: field</p>
<p>Prints a field data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>in: field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a952eb767919a99aa9993eb6c1933d2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952eb767919a99aa9993eb6c1933d2e3">&#9670;&nbsp;</a></span>dict_find_table_by_space()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__table__t.html">dict_table_t</a>* dict_find_table_by_space </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a table in dict_sys-&gt;table_LRU list with specified space id </p><dl class="section return"><dt>Returns</dt><dd>table if found, NULL if not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: space ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61b7666d847e3d9e79eb322ff08db31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b7666d847e3d9e79eb322ff08db31c">&#9670;&nbsp;</a></span>dict_foreign_add_to_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_foreign_add_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_charsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a>&#160;</td>
          <td class="paramname"><em>ignore_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a foreign key constraint object to the dictionary cache. May free the object if there already is an object with the same identifier in. At least one of the foreign table and the referenced table must already be in the dictionary cache! </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foreign</td><td>in, own: foreign key constraint </td></tr>
    <tr><td class="paramname">col_names</td><td>in: column names, or NULL to use foreign-&gt;foreign_table-&gt;col_names </td></tr>
    <tr><td class="paramname">check_charsets</td><td>in: whether to check charset compatibility </td></tr>
    <tr><td class="paramname">ignore_err</td><td>in: error to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa5ff794b470852ef356c27a5ee84afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5ff794b470852ef356c27a5ee84afc">&#9670;&nbsp;</a></span>dict_foreign_error_report()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_foreign_error_report </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>fk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Report an error in a foreign key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: output stream </td></tr>
    <tr><td class="paramname">fk</td><td>in: foreign key constraint </td></tr>
    <tr><td class="paramname">msg</td><td>in: the error message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af41bc842c3bc63a1a110cd29f9b427da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41bc842c3bc63a1a110cd29f9b427da">&#9670;&nbsp;</a></span>dict_foreign_error_report_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_foreign_error_report_low </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Report an error in a foreign key definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: output stream </td></tr>
    <tr><td class="paramname">name</td><td>in: table name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24ee7cee267a03b49d497799c70b98e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ee7cee267a03b49d497799c70b98e6">&#9670;&nbsp;</a></span>dict_foreign_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a>* dict_foreign_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the foreign constraint from the foreign and referenced lists of a table. </p><dl class="section return"><dt>Returns</dt><dd>foreign constraint </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table object </td></tr>
    <tr><td class="paramname">foreign</td><td>in: foreign constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9509b816d6e6cd3549e27c6b30427a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9509b816d6e6cd3549e27c6b30427a48">&#9670;&nbsp;</a></span>dict_foreign_find_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_foreign_find_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>types_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_charsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>check_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to find an index whose first fields are the columns in the array, in the same order and is not marked for deletion and is not the same as types_idx. </p><dl class="section return"><dt>Returns</dt><dd>matching index, NULL if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">col_names</td><td>in: column names, or NULL to use table-&gt;col_names </td></tr>
    <tr><td class="paramname">columns</td><td>in: array of column names </td></tr>
    <tr><td class="paramname">n_cols</td><td>in: number of columns </td></tr>
    <tr><td class="paramname">types_idx</td><td>in: NULL or an index whose types the column types must match </td></tr>
    <tr><td class="paramname">check_charsets</td><td>in: whether to check charsets. only has an effect if types_idx != NULL </td></tr>
    <tr><td class="paramname">check_null</td><td>in: nonzero if none of the columns must be declared NOT NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c06c9fc99dcaa57a13731ff001d94f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c06c9fc99dcaa57a13731ff001d94f2">&#9670;&nbsp;</a></span>dict_foreign_parse_drop_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_foreign_parse_drop_constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char ***&#160;</td>
          <td class="paramname"><em>constraints_to_drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the CONSTRAINT id's to be dropped in an ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> statement. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_CANNOT_DROP_CONSTRAINT if syntax error or the constraint id does not match </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: heap from which we can allocate memory </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">n</td><td>out: number of constraints to drop </td></tr>
    <tr><td class="paramname">constraints_to_drop</td><td>out: id's of the constraints to drop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef6bcf2106fd2ad52e1fd7292d66df19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6bcf2106fd2ad52e1fd7292d66df19">&#9670;&nbsp;</a></span>dict_foreign_print_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_foreign_print_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints info of a foreign key constraint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foreign</td><td>in: foreign key constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5687f15e99784a37a5480dcf6a0c3ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5687f15e99784a37a5480dcf6a0c3ad9">&#9670;&nbsp;</a></span>dict_foreign_qualify_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool dict_foreign_qualify_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>types_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_charsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>check_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> an index to see whether its first fields are the columns in the array, in the same order and is not marked for deletion and is not the same as types_idx. </p><dl class="section return"><dt>Returns</dt><dd>true if the index qualifies, otherwise false </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">col_names</td><td>in: column names, or NULL to use table-&gt;col_names </td></tr>
    <tr><td class="paramname">columns</td><td>in: array of column names </td></tr>
    <tr><td class="paramname">n_cols</td><td>in: number of columns </td></tr>
    <tr><td class="paramname">index</td><td>in: index to check </td></tr>
    <tr><td class="paramname">types_idx</td><td>in: NULL or an index whose types the column types must match </td></tr>
    <tr><td class="paramname">check_charsets</td><td>in: whether to check charsets. only has an effect if types_idx != NULL </td></tr>
    <tr><td class="paramname">check_null</td><td>in: nonzero if none of the columns must be declared NOT NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67f346477aa6b5b307e3dc28a6bc1a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f346477aa6b5b307e3dc28a6bc1a3d">&#9670;&nbsp;</a></span>dict_foreign_remove_from_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_foreign_remove_from_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a foreign constraint struct from the dictionary cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foreign</td><td>in, own: foreign constraint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a453e4327c7edfb630a64b1fb07885cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453e4327c7edfb630a64b1fb07885cdf">&#9670;&nbsp;</a></span>dict_foreign_replace_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool dict_foreign_replace_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the index passed in with another equivalent index in the foreign key lists of the table. </p><dl class="section return"><dt>Returns</dt><dd>whether all replacements were found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">col_names</td><td>in: column names, or NULL to use table-&gt;col_names </td></tr>
    <tr><td class="paramname">index</td><td>in: index to be replaced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f4469447426aac986ba56f6db5c9d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4469447426aac986ba56f6db5c9d34">&#9670;&nbsp;</a></span>dict_foreign_report_syntax_err()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_foreign_report_syntax_err </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>start_of_latest_foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reports a simple foreign key create clause syntax error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name </td></tr>
    <tr><td class="paramname">start_of_latest_foreign</td><td>in: start of the foreign key clause in the SQL string </td></tr>
    <tr><td class="paramname">ptr</td><td>in: place of the syntax error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bdeaa13251e2885436d83de4f271774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdeaa13251e2885436d83de4f271774">&#9670;&nbsp;</a></span>dict_fs2utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_fs2utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_and_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>db_utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>db_utf8_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>table_utf8_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a database and table name from filesystem encoding (e.g. d/a@1Kc, same format as used in <a class="el" href="structdict__table__t.html#ab075f273bdfd4c19af4622c4c635e386">dict_table_t::name</a>) in two strings in UTF8 encoding (e.g. dцb and aюbØc). The output buffers must be at least MAX_DB_UTF8_LEN and MAX_TABLE_UTF8_LEN bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db_and_table</td><td>in: database and table names, e.g. d/a@1Kc </td></tr>
    <tr><td class="paramname">db_utf8</td><td>out: database name, e.g. dцb </td></tr>
    <tr><td class="paramname">db_utf8_size</td><td>in: dbname_utf8 size </td></tr>
    <tr><td class="paramname">table_utf8</td><td>out: table name, e.g. aюbØc </td></tr>
    <tr><td class="paramname">table_utf8_size</td><td>in: table_utf8 size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bec6f2c328f76fbfd23bc1af57c6aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bec6f2c328f76fbfd23bc1af57c6aff">&#9670;&nbsp;</a></span>dict_get_db_name_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint dict_get_db_name_len </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the database name length in a table name. </p><dl class="section return"><dt>Returns</dt><dd>database name length </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name in the form dbname '/' tablename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7832690eefab0cd2f54e4ca1086e459e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7832690eefab0cd2f54e4ca1086e459e">&#9670;&nbsp;</a></span>dict_get_referenced_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* dict_get_referenced_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>database_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>database_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>table_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> **&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a table from its database and table name, this is currently used by foreign constraint parser to get the referenced table. </p><dl class="section return"><dt>Returns</dt><dd>complete table name with database and table name, allocated from heap memory passed in </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: foreign key table name </td></tr>
    <tr><td class="paramname">database_name</td><td>in: table db name </td></tr>
    <tr><td class="paramname">database_name_len</td><td>in: db name length </td></tr>
    <tr><td class="paramname">table_name</td><td>in: table name </td></tr>
    <tr><td class="paramname">table_name_len</td><td>in: table name length </td></tr>
    <tr><td class="paramname">table</td><td>out: table object or NULL </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: heap memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2376976964bc0adea33b8792613f0688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2376976964bc0adea33b8792613f0688">&#9670;&nbsp;</a></span>dict_ind_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_ind_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees dict_ind_redundant and dict_ind_compact. </p>

</div>
</div>
<a id="ac625bf70b3857b1565a7b64f2b25ed93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac625bf70b3857b1565a7b64f2b25ed93">&#9670;&nbsp;</a></span>dict_ind_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_ind_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inits dict_ind_redundant and dict_ind_compact. </p>

</div>
</div>
<a id="adf92c2e4e73403931a16cf49e2ddf9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf92c2e4e73403931a16cf49e2ddf9a3">&#9670;&nbsp;</a></span>dict_index_add_col()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_index_add_col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>prefix_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a column to index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in/out: index </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">col</td><td>in: column </td></tr>
    <tr><td class="paramname">prefix_len</td><td>in: column prefix length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f650ba48d7d2278b644875875a6f85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f650ba48d7d2278b644875875a6f85b">&#9670;&nbsp;</a></span>dict_index_add_to_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_index_add_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>strict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an index to the dictionary cache. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_TOO_BIG_RECORD, or DB_CORRUPTION </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table on which the index is </td></tr>
    <tr><td class="paramname">index</td><td>in, own: index; NOTE! The index memory object is freed in this function! </td></tr>
    <tr><td class="paramname">page_no</td><td>in: root page number of the index </td></tr>
    <tr><td class="paramname">strict</td><td>in: TRUE=refuse to create the index if records could be too big to fit in an B-tree page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46ec3cce534686707f98abb61d3601a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ec3cce534686707f98abb61d3601a5">&#9670;&nbsp;</a></span>dict_index_build_data_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdtuple__t.html">dtuple_t</a>* dict_index_build_data_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a typed data tuple out of a physical record. </p><dl class="section return"><dt>Returns</dt><dd>own: data tuple </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">rec</td><td>in: record for which to build data tuple </td></tr>
    <tr><td class="paramname">n_fields</td><td>in: number of data fields </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where tuple created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1ee385310dbca2e8319fa352a34506f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ee385310dbca2e8319fa352a34506f">&#9670;&nbsp;</a></span>dict_index_build_internal_clust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__index__t.html">dict_index_t</a> * dict_index_build_internal_clust </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds the internal dictionary cache representation for a clustered index, containing also system fields not defined by the user. </p><dl class="section return"><dt>Returns</dt><dd>own: the internal representation of the clustered index in: user representation of a clustered index</dd></dl>
<p>Builds the internal dictionary cache representation for a clustered index, containing also system fields not defined by the user. </p><dl class="section return"><dt>Returns</dt><dd>own: the internal representation of the clustered index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">index</td><td>in: user representation of a clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a603240b6157bd9efa7e144045b5f29a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603240b6157bd9efa7e144045b5f29a4">&#9670;&nbsp;</a></span>dict_index_build_internal_fts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__index__t.html">dict_index_t</a> * dict_index_build_internal_fts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds the internal dictionary cache representation for an FTS index. </p><dl class="section return"><dt>Returns</dt><dd>own: the internal representation of the FTS index in: user representation of an FTS index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">index</td><td>in: user representation of an FTS index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8515b8e426ebe53bed93c8d7f58533a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8515b8e426ebe53bed93c8d7f58533a0">&#9670;&nbsp;</a></span>dict_index_build_internal_non_clust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__index__t.html">dict_index_t</a> * dict_index_build_internal_non_clust </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds the internal dictionary cache representation for a non-clustered index, containing also system fields not defined by the user. </p><dl class="section return"><dt>Returns</dt><dd>own: the internal representation of the non-clustered index in: user representation of a non-clustered index</dd></dl>
<p>Builds the internal dictionary cache representation for a non-clustered index, containing also system fields not defined by the user. </p><dl class="section return"><dt>Returns</dt><dd>own: the internal representation of the non-clustered index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">index</td><td>in: user representation of a non-clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a894161e0d082b8e7376470ecab814016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894161e0d082b8e7376470ecab814016">&#9670;&nbsp;</a></span>dict_index_build_node_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdtuple__t.html">dtuple_t</a>* dict_index_build_node_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a node pointer out of a physical record and a page number. </p><dl class="section return"><dt>Returns</dt><dd>own: node pointer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">rec</td><td>in: record for which to build node pointer </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number to put in node pointer </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where pointer created </td></tr>
    <tr><td class="paramname">level</td><td>in: level of rec in tree: 0 means leaf level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ceba24bdcaf09e09194645ca2ca62d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceba24bdcaf09e09194645ca2ca62d1">&#9670;&nbsp;</a></span>dict_index_calc_min_rec_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint dict_index_calc_min_rec_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the minimum record length in an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d1b96ff14be9ff80dc62bfd2a96d61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1b96ff14be9ff80dc62bfd2a96d61a">&#9670;&nbsp;</a></span>dict_index_contains_col_or_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool dict_index_contains_col_or_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the index contains a column or a prefix of that column. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if contains the column or its prefix </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">n</td><td>in: column number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac42a84e4b90fcbce8ae15dfe3cf747a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42a84e4b90fcbce8ae15dfe3cf747a8">&#9670;&nbsp;</a></span>dict_index_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_index_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies fields contained in index2 to index1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index1</td><td>in: index to copy to </td></tr>
    <tr><td class="paramname">index2</td><td>in: index to copy from </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">start</td><td>in: first position to copy </td></tr>
    <tr><td class="paramname">end</td><td>in: last position to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab555cf7e9a92304e09d05db772b8dab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab555cf7e9a92304e09d05db772b8dab1">&#9670;&nbsp;</a></span>dict_index_copy_rec_order_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN rec_t* dict_index_copy_rec_order_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies an initial segment of a physical record, long enough to specify an index entry uniquely. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the prefix record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">rec</td><td>in: record for which to copy prefix </td></tr>
    <tr><td class="paramname">n_fields</td><td>out: number of fields copied </td></tr>
    <tr><td class="paramname">buf</td><td>in/out: memory buffer for the copied prefix, or NULL </td></tr>
    <tr><td class="paramname">buf_size</td><td>in/out: buffer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afca6181f0a8abde62fe5cbafc56d494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca6181f0a8abde62fe5cbafc56d494b">&#9670;&nbsp;</a></span>dict_index_copy_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_index_copy_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies types of fields contained in index to tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in/out: data tuple </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">n_fields</td><td>in: number of field types to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab52b4d3b4a72eddf228fc06f88970792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52b4d3b4a72eddf228fc06f88970792">&#9670;&nbsp;</a></span>dict_index_find_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool dict_index_find_cols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to find column names for the index and sets the col field of the index. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the column names were found in: index</dd></dl>
<p>Tries to find column names for the index and sets the col field of the index. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the column names were found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63bf7f6dba8d9868a3fbc3ac1aa43d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63bf7f6dba8d9868a3fbc3ac1aa43d4d">&#9670;&nbsp;</a></span>dict_index_find_on_id_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_index_find_on_id_low </td>
          <td>(</td>
          <td class="paramtype">index_id_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for an index with the given id. NOTE that we do not reserve the dictionary mutex: this function is for emergency purposes like printing info of a corrupt database page! </p><dl class="section return"><dt>Returns</dt><dd>index or NULL if not found in cache </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: index id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fbb600cba0743d040dd0b21ac920454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbb600cba0743d040dd0b21ac920454">&#9670;&nbsp;</a></span>dict_index_get_if_in_cache_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_index_get_if_in_cache_low </td>
          <td>(</td>
          <td class="paramtype">index_id_t&#160;</td>
          <td class="paramname"><em>index_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an index object if it is found in the dictionary cache. Assumes that dict_sys-&gt;mutex is already being held. </p><dl class="section return"><dt>Returns</dt><dd>index, NULL if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_id</td><td>in: index id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1724dd9eb3aee41e4f8a9cd5b12cfa02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1724dd9eb3aee41e4f8a9cd5b12cfa02">&#9670;&nbsp;</a></span>dict_index_get_nth_col_or_prefix_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint dict_index_get_nth_col_or_prefix_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>inc_prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for column n in an index. </p><dl class="section return"><dt>Returns</dt><dd>position in internal representation of the index; ULINT_UNDEFINED if not contained </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">n</td><td>in: column number </td></tr>
    <tr><td class="paramname">inc_prefix</td><td>in: TRUE=consider column prefixes too </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dec2cadd776cf77d54bfd170f5aad37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dec2cadd776cf77d54bfd170f5aad37">&#9670;&nbsp;</a></span>dict_index_get_nth_field_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint dict_index_get_nth_field_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a matching field in an index. The column has to be the same. The column in index must be complete, or must contain a prefix longer than the column in index2. That is, we must be able to construct the prefix in index2 from the prefix in index. </p><dl class="section return"><dt>Returns</dt><dd>position in internal representation of the index; ULINT_UNDEFINED if not contained </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index from which to search </td></tr>
    <tr><td class="paramname">index2</td><td>in: index </td></tr>
    <tr><td class="paramname">n</td><td>in: field number in index2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a0c8e86a47c780f5b23f725b12ae21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0c8e86a47c780f5b23f725b12ae21e">&#9670;&nbsp;</a></span>dict_index_name_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_index_name_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Displays the names of the index and the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: output stream </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">index</td><td>in: index to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30ab2b572550ca88a5470aee059e8e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ab2b572550ca88a5470aee059e8e1f">&#9670;&nbsp;</a></span>dict_index_print_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_index_print_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints an index data. in: index</p>
<p>Prints an index data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e217b3ee2c2aa4bb7e292e21f3c9a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e217b3ee2c2aa4bb7e292e21f3c9a2e">&#9670;&nbsp;</a></span>dict_index_remove_from_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_index_remove_from_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an index from the dictionary cache.</p>
<p>Removes an index from the cache </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">index</td><td>in, own: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc121dcf8cebc138fb8c59efd2b9f33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc121dcf8cebc138fb8c59efd2b9f33e">&#9670;&nbsp;</a></span>dict_index_remove_from_cache_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_index_remove_from_cache_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>lru_evict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes an index from the dictionary cache. in: TRUE if page being evicted to make room in the table LRU list</p>
<p>Removes an index from the dictionary cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">index</td><td>in, own: index </td></tr>
    <tr><td class="paramname">lru_evict</td><td>in: TRUE if index being evicted to make room in the table LRU list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af64a07f4809b51bf88c408e0b7f384cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64a07f4809b51bf88c408e0b7f384cb">&#9670;&nbsp;</a></span>dict_index_too_big_for_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool dict_index_too_big_for_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>new_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a record of this index might not fit on a single B-tree page, return TRUE. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the index record could become too big </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">new_index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afed9eaa6639867e07011bc5632a75d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed9eaa6639867e07011bc5632a75d3b">&#9670;&nbsp;</a></span>dict_index_too_big_for_undo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool dict_index_too_big_for_undo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>new_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If an undo log record for this table might not fit on a single page, return TRUE. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the undo log record could become too big </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">new_index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63427d2546157136807fd3fd504342bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63427d2546157136807fd3fd504342bc">&#9670;&nbsp;</a></span>dict_index_zip_failure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_index_zip_failure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called whenever a page compression attempt fails. Updates the compression padding information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in/out: index to be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf2de3c437c5839848217de0a6154c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2de3c437c5839848217de0a6154c1e">&#9670;&nbsp;</a></span>dict_index_zip_pad_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_index_zip_pad_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>index_void</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and init the zip_pad_mutex of a given index. This function must not be called concurrently on the same index object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index_void</td><td>index whose zip_pad_mutex to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c78faad46732bf93f171537a22d6097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c78faad46732bf93f171537a22d6097">&#9670;&nbsp;</a></span>dict_index_zip_pad_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_index_zip_pad_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire the zip_pad_mutex latch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>the index whose zip_pad_mutex to acquire. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c8427eee5255a741379de8195697bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8427eee5255a741379de8195697bfe">&#9670;&nbsp;</a></span>dict_index_zip_pad_optimal_page_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint dict_index_zip_pad_optimal_page_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the optimal page size, for which page will likely compress. </p><dl class="section return"><dt>Returns</dt><dd>page size beyond which page might not compress </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index for which page size is requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86b1dee0bf5873f1d1411b9a076ce6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b1dee0bf5873f1d1411b9a076ce6ac">&#9670;&nbsp;</a></span>dict_index_zip_pad_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_index_zip_pad_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structzip__pad__info__t.html">zip_pad_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the state of compression failure padding heuristics. This is called whenever a compression operation succeeds or fails. The caller must be holding info-&gt;mutex </p>

</div>
</div>
<a id="a66fb6150cc7e3da83b3e75335ef9cecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fb6150cc7e3da83b3e75335ef9cecb">&#9670;&nbsp;</a></span>dict_index_zip_success()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_index_zip_success </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called whenever a page is successfully compressed. Updates the compression padding information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in/out: index to be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ef812c49166835cf66a42dd3efab45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef812c49166835cf66a42dd3efab45c">&#9670;&nbsp;</a></span>dict_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inits the data dictionary module. </p>

</div>
</div>
<a id="a397377fd297fc5dbaf4f22476b91b2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397377fd297fc5dbaf4f22476b91b2c0">&#9670;&nbsp;</a></span>dict_make_room_in_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint dict_make_room_in_cache </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pct_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make room in the table cache by evicting an unused table. The unused table should not be part of FK relationship and currently not used in any user transaction. There is no guarantee that it will remove a table. </p><dl class="section return"><dt>Returns</dt><dd>number of tables evicted. If the number of tables in the dict_LRU is less than max_tables it will not do anything. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_tables</td><td>in: max tables allowed in cache </td></tr>
    <tr><td class="paramname">pct_check</td><td>in: max percent to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7c7671ff3615631489ab3455ddeed99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c7671ff3615631489ab3455ddeed99">&#9670;&nbsp;</a></span>dict_move_to_mru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_move_to_mru </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move to the most recently used segment of the LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to move to MRU </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae25862c97598776f8d56dea98879d76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25862c97598776f8d56dea98879d76f">&#9670;&nbsp;</a></span>dict_mutex_enter_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_mutex_enter_for_mysql </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves the dictionary system mutex for MySQL. </p>

</div>
</div>
<a id="acea51b53d906e17ac34c888ab43ac895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea51b53d906e17ac34c888ab43ac895">&#9670;&nbsp;</a></span>dict_mutex_exit_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_mutex_exit_for_mysql </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the dictionary system mutex for MySQL. </p>

</div>
</div>
<a id="a9f25cfa132b5723cdb99992d733439f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f25cfa132b5723cdb99992d733439f4">&#9670;&nbsp;</a></span>dict_print_info_on_foreign_key_in_create_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_print_info_on_foreign_key_in_create_format </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>add_newline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outputs info on a foreign key of a table in a format suitable for CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">foreign</td><td>in: foreign key constraint </td></tr>
    <tr><td class="paramname">add_newline</td><td>in: whether to add a newline </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65969d432fe467c57380492067f7bd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65969d432fe467c57380492067f7bd28">&#9670;&nbsp;</a></span>dict_print_info_on_foreign_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_print_info_on_foreign_keys </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>create_table_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outputs info on foreign keys of a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">create_table_format</td><td>in: if TRUE then print in a format suitable to be inserted into a CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a>, otherwise in the format of SHOW <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> STATUS </td></tr>
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d13cf57d6cba918de841e4e08da5d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d13cf57d6cba918de841e4e08da5d56">&#9670;&nbsp;</a></span>dict_remove_db_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_remove_db_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the end of table name where we have removed dbname and '/'. </p><dl class="section return"><dt>Returns</dt><dd>table name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name in the form dbname '/' tablename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae95f6ee6ea989e2d6389040aa90fab02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95f6ee6ea989e2d6389040aa90fab02">&#9670;&nbsp;</a></span>dict_scan_col()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* dict_scan_col </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> **&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to scan a column name. </p><dl class="section return"><dt>Returns</dt><dd>scanned to </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>in: the character set of ptr </td></tr>
    <tr><td class="paramname">ptr</td><td>in: scanned to </td></tr>
    <tr><td class="paramname">success</td><td>out: TRUE if success </td></tr>
    <tr><td class="paramname">table</td><td>in: table in which the column is </td></tr>
    <tr><td class="paramname">column</td><td>out: pointer to column if success </td></tr>
    <tr><td class="paramname">heap</td><td>in: heap where to allocate </td></tr>
    <tr><td class="paramname">name</td><td>out,own: the column name; NULL if no name was scannable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3433393375c4b26ff4dad1ba7288a5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3433393375c4b26ff4dad1ba7288a5ff">&#9670;&nbsp;</a></span>dict_scan_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* dict_scan_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>accept_also_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scans an id. For the lexical definition of an 'id', see the code below. Strips backquotes or double quotes from around the id. </p><dl class="section return"><dt>Returns</dt><dd>scanned to </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>in: the character set of ptr </td></tr>
    <tr><td class="paramname">ptr</td><td>in: scanned to </td></tr>
    <tr><td class="paramname">heap</td><td>in: heap where to allocate the id (NULL=id will not be allocated, but it will point to string near ptr) </td></tr>
    <tr><td class="paramname">id</td><td>out,own: the id; NULL if no id was scannable </td></tr>
    <tr><td class="paramname">table_id</td><td>in: TRUE=convert the allocated id as a table name; FALSE=convert to UTF-8 </td></tr>
    <tr><td class="paramname">accept_also_dot</td><td>in: TRUE if also a dot can appear in a non-quoted id; in a quoted id it can appear always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e080a03465bbad28b15358e5534423e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e080a03465bbad28b15358e5534423e">&#9670;&nbsp;</a></span>dict_scan_table_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* dict_scan_table_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> **&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ref_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scans a table name from an SQL string. </p><dl class="section return"><dt>Returns</dt><dd>scanned to </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>in: the character set of ptr </td></tr>
    <tr><td class="paramname">ptr</td><td>in: scanned to </td></tr>
    <tr><td class="paramname">table</td><td>out: table object or NULL </td></tr>
    <tr><td class="paramname">name</td><td>in: foreign key table name </td></tr>
    <tr><td class="paramname">success</td><td>out: TRUE if ok name found </td></tr>
    <tr><td class="paramname">heap</td><td>in: heap where to allocate the id </td></tr>
    <tr><td class="paramname">ref_name</td><td>out,own: the table name; NULL if no name was scannable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeb52e0452226d74bbc217d1ad0fd19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb52e0452226d74bbc217d1ad0fd19e">&#9670;&nbsp;</a></span>dict_scan_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* dict_scan_to </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scans from pointer onwards. Stops if is at the start of a copy of 'string' where characters are compared without case sensitivity, and only outside `` or "" quotes. Stops also at NUL. </p><dl class="section return"><dt>Returns</dt><dd>scanned up to this </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: scan from </td></tr>
    <tr><td class="paramname">string</td><td>in: look for this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f0bc8ad9d8b97e93761f9150756273c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0bc8ad9d8b97e93761f9150756273c">&#9670;&nbsp;</a></span>dict_set_corrupted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_set_corrupted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags an index corrupted both in the data dictionary cache and in the SYS_INDEXES </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in/out: index </td></tr>
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
    <tr><td class="paramname">ctx</td><td>in: context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab174f1dfadd6de621f5bded28c6c25de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab174f1dfadd6de621f5bded28c6c25de">&#9670;&nbsp;</a></span>dict_set_corrupted_by_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool dict_set_corrupted_by_space </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags a table with specified space_id corrupted in the data dictionary cache </p><dl class="section return"><dt>Returns</dt><dd>TRUE if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: space ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa61812d7472f10e4f78660f75e001d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61812d7472f10e4f78660f75e001d8e">&#9670;&nbsp;</a></span>dict_set_corrupted_index_cache_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_set_corrupted_index_cache_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags an index corrupted in the data dictionary cache only. This is used mostly to mark a corrupted index when index's own dictionary is corrupted, and we force to load such index for repair purpose </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in/out: index </td></tr>
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3375ad03cf2893e0a4ebfe68c7f5ff94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3375ad03cf2893e0a4ebfe68c7f5ff94">&#9670;&nbsp;</a></span>dict_skip_word()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* dict_skip_word </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcharset__info__st.html">charset_info_st</a> *&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Skips one id. The id is allowed to contain also '.'. </p><dl class="section return"><dt>Returns</dt><dd>scanned to </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>in: the character set of ptr </td></tr>
    <tr><td class="paramname">ptr</td><td>in: scanned to </td></tr>
    <tr><td class="paramname">success</td><td>out: TRUE if success, FALSE if just spaces left in string or a syntax error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5befceecf543154dd5ef75ce8461528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5befceecf543154dd5ef75ce8461528">&#9670;&nbsp;</a></span>dict_str_starts_with_keyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool dict_str_starts_with_keyword </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>in: MySQL thread handle </td></tr>
    <tr><td class="paramname">str</td><td>in: string to scan for keyword </td></tr>
    <tr><td class="paramname">keyword</td><td>in: keyword to look for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0449774b838906b3e79242282848381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0449774b838906b3e79242282848381">&#9670;&nbsp;</a></span>dict_strip_comments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* dict_strip_comments </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sql_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sql_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes MySQL comments from an SQL string. A comment is either (a) '#' to the end of the line, (b) '&ndash;[space]' to the end of the line, or (c) '[slash][asterisk]' till the next '[asterisk][slash]' (like the familiar C comment syntax). </p><dl class="section return"><dt>Returns</dt><dd>own: SQL string stripped from comments; the caller must free this with <a class="el" href="mem0mem_8h.html#a4cdeda261ea5f6db299898f33e6bbdbf">mem_free()</a>! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sql_string</td><td>in: SQL string </td></tr>
    <tr><td class="paramname">sql_length</td><td>in: length of sql_string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94f828e344beff1a10211d307682e1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f828e344beff1a10211d307682e1c8">&#9670;&nbsp;</a></span>dict_table_add_system_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_add_system_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds system columns to a table object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">heap</td><td>in: temporary heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a19f9aaf680e7d1433d5400a4e04e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a19f9aaf680e7d1433d5400a4e04e37">&#9670;&nbsp;</a></span>dict_table_add_to_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_add_to_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>can_be_evicted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a table object to the dictionary cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">can_be_evicted</td><td>in: TRUE if can be evicted </td></tr>
    <tr><td class="paramname">heap</td><td>in: temporary heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46e2ec99166cb4864aaff087ed0a65ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e2ec99166cb4864aaff087ed0a65ef">&#9670;&nbsp;</a></span>dict_table_autoinc_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_autoinc_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>table_void</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and init the autoinc latch of a given table. This function must not be called concurrently on the same table object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_void</td><td>table whose autoinc latch to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb30464c14647e66de656bfeafe4ff74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb30464c14647e66de656bfeafe4ff74">&#9670;&nbsp;</a></span>dict_table_autoinc_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_autoinc_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unconditionally set the autoinc counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">value</td><td>in: next value to assign to a row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab49bfaa0816cb22789040f3bb6452801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49bfaa0816cb22789040f3bb6452801">&#9670;&nbsp;</a></span>dict_table_autoinc_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_autoinc_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire the autoinc lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53afacec0c25e52b28facfe8f88897cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53afacec0c25e52b28facfe8f88897cf">&#9670;&nbsp;</a></span>dict_table_autoinc_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ib_uint64_t dict_table_autoinc_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the next autoinc value (== autoinc counter value), 0 if not yet initialized. </p><dl class="section return"><dt>Returns</dt><dd>value for a new row, or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a723afb57a4938d2c27f79040748c1378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723afb57a4938d2c27f79040748c1378">&#9670;&nbsp;</a></span>dict_table_autoinc_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_autoinc_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the autoinc lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af842ce585a97426002ec4989065efa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af842ce585a97426002ec4989065efa1f">&#9670;&nbsp;</a></span>dict_table_autoinc_update_if_greater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_autoinc_update_if_greater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the autoinc counter if the value supplied is greater than the current value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">value</td><td>in: value which was assigned to a row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8ac61f025d283937e11565796f8ac27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ac61f025d283937e11565796f8ac27">&#9670;&nbsp;</a></span>dict_table_can_be_evicted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool dict_table_can_be_evicted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether a table can be evicted from the LRU cache. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if table can be evicted. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to test </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b20d19158e7bef1ca59d308c8745727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b20d19158e7bef1ca59d308c8745727">&#9670;&nbsp;</a></span>dict_table_change_id_in_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_change_id_in_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_id_t&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the id of a table object in the dictionary cache. This is used in DISCARD TABLESPACE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table object already in cache </td></tr>
    <tr><td class="paramname">new_id</td><td>in: new id to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3820be766c877566c3e6b4a84e2cc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3820be766c877566c3e6b4a84e2cc12">&#9670;&nbsp;</a></span>dict_table_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>dict_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>try_drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrements the count of open handles to a table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">dict_locked</td><td>in: TRUE=data dictionary locked </td></tr>
    <tr><td class="paramname">try_drop</td><td>in: TRUE=try to drop any orphan indexes after an aborted online index creation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d9a972080b4db2d95e84201c8424562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9a972080b4db2d95e84201c8424562">&#9670;&nbsp;</a></span>dict_table_col_in_clustered_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool dict_table_col_in_clustered_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a column is in the ordering columns of the clustered index of a table. Column prefixes are treated like whole columns. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the column, or its prefix, is in the clustered key </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">n</td><td>in: column number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9bc055c2cfd705fdf7c8e398052d04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bc055c2cfd705fdf7c8e398052d04b">&#9670;&nbsp;</a></span>dict_table_copy_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_copy_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies types of columns contained in table to tuple and sets all fields of the tuple to the SQL NULL value. This function should be called right after <a class="el" href="data0data_8h.html#ab9dcb458e87ae5ded2aaff94f60fa8a3">dtuple_create()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in/out: data tuple </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af80be4fb9c73cd15f56b734980f0620d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80be4fb9c73cd15f56b734980f0620d">&#9670;&nbsp;</a></span>dict_table_find_index_on_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_table_find_index_on_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_id_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for an index with the given id given a table instance. </p><dl class="section return"><dt>Returns</dt><dd>index or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table instance </td></tr>
    <tr><td class="paramname">id</td><td>in: index id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb9ad841f816713f946e02065c3fea10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9ad841f816713f946e02065c3fea10">&#9670;&nbsp;</a></span>dict_table_get_all_fts_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint dict_table_get_all_fts_indexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__vector__t.html">ib_vector_t</a> *&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">indexes</td><td>out: all FTS indexes on this table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b0b313d8dee1744af43e55fce6dcf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0b313d8dee1744af43e55fce6dcf08">&#9670;&nbsp;</a></span>dict_table_get_col_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_table_get_col_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_nr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a column's name. </p><dl class="section return"><dt>Returns</dt><dd>column name. NOTE: not guaranteed to stay valid if table is modified in any way (columns added, etc.). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">col_nr</td><td>in: column number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e5f2c20a9921fde2364cadf5c1617bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5f2c20a9921fde2364cadf5c1617bf">&#9670;&nbsp;</a></span>dict_table_get_foreign_constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a>* dict_table_get_foreign_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a index is defined for a foreign key constraint. Index is a part of a foreign key constraint if the index is referenced by foreign key or index is a foreign key index. </p><dl class="section return"><dt>Returns</dt><dd>pointer to foreign key struct if index is defined for foreign key, otherwise NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: InnoDB table </td></tr>
    <tr><td class="paramname">index</td><td>in: InnoDB index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5f3f547474e816ea33fea968dd71273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f3f547474e816ea33fea968dd71273">&#9670;&nbsp;</a></span>dict_table_get_highest_foreign_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint dict_table_get_highest_foreign_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the highest [number] for foreign key constraints of the table. Looks only at the &gt;= 4.0.18-format id's, which are of the form databasename/tablename_ibfk_[number]. </p><dl class="section return"><dt>Returns</dt><dd>highest number, 0 if table has no new format foreign key constraints </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table in the dictionary memory cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85f034e55e1266359ab4c4c020d3812c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f034e55e1266359ab4c4c020d3812c">&#9670;&nbsp;</a></span>dict_table_get_index_on_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_table_get_index_on_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get index by name </p><dl class="section return"><dt>Returns</dt><dd>index, NULL if does not exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">name</td><td>in: name of the index to find </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c0c175b88bcb48aa6c09be3d0069027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0c175b88bcb48aa6c09be3d0069027">&#9670;&nbsp;</a></span>dict_table_get_index_on_name_and_min_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_table_get_index_on_name_and_min_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In case there is more than one index with the same name return the index with the min(id). </p><dl class="section return"><dt>Returns</dt><dd>index, NULL if does not exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">name</td><td>in: name of the index to find </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9720be12ef6d46a9bf22a94c5598f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9720be12ef6d46a9bf22a94c5598f16">&#9670;&nbsp;</a></span>dict_table_get_nth_col_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint dict_table_get_nth_col_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for column n position in the clustered index. </p><dl class="section return"><dt>Returns</dt><dd>position in internal representation of the clustered index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">n</td><td>in: column number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c737c0acb031f95387bede1f043843c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c737c0acb031f95387bede1f043843c">&#9670;&nbsp;</a></span>dict_table_get_referenced_constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a>* dict_table_get_referenced_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if the index is referenced by a foreign key, if TRUE return foreign else return NULL </p><dl class="section return"><dt>Returns</dt><dd>pointer to foreign key struct if index is defined for foreign key, otherwise NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: InnoDB table </td></tr>
    <tr><td class="paramname">index</td><td>in: InnoDB index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ad161e2bebda3505b1126f6d3086b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad161e2bebda3505b1126f6d3086b23">&#9670;&nbsp;</a></span>dict_table_is_referenced_by_foreign_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool dict_table_is_referenced_by_foreign_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a table is referenced by foreign keys. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if table is referenced by a foreign key </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: InnoDB table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa626c8b9d58aacb01e9de5e5685ce5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa626c8b9d58aacb01e9de5e5685ce5e4">&#9670;&nbsp;</a></span>dict_table_move_from_lru_to_non_lru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_move_from_lru_to_non_lru </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move a table to the non-LRU list from the LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to move from LRU to non-LRU </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a8bbe5ea4c31fdd32c64cf76dda9407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8bbe5ea4c31fdd32c64cf76dda9407">&#9670;&nbsp;</a></span>dict_table_move_from_non_lru_to_lru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_move_from_non_lru_to_lru </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move a table to the LRU list from the non-LRU list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to move from non-LRU to LRU </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16fc5eb076cc17572bf406ee7ab1f9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fc5eb076cc17572bf406ee7ab1f9e8">&#9670;&nbsp;</a></span>dict_table_open_on_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a>* dict_table_open_on_id </td>
          <td>(</td>
          <td class="paramtype">table_id_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>dict_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0dict_8h.html#ad37e188831074bcf7fdae6bd963a1599">dict_table_op_t</a>&#160;</td>
          <td class="paramname"><em>table_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a table object based on table id. </p><dl class="section return"><dt>Returns</dt><dd>table, NULL if does not exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_id</td><td>in: table id </td></tr>
    <tr><td class="paramname">dict_locked</td><td>in: TRUE=data dictionary locked </td></tr>
    <tr><td class="paramname">table_op</td><td>in: operation to perform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a173c1301f343e7d305785c556ba35b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173c1301f343e7d305785c556ba35b82">&#9670;&nbsp;</a></span>dict_table_open_on_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a>* dict_table_open_on_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>dict_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>try_drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a>&#160;</td>
          <td class="paramname"><em>ignore_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a table object and increment its open handle count. NOTE! This is a high-level function to be used mainly from outside the 'dict' module. Inside this directory dict_table_get_low is usually the appropriate function. </p><dl class="section return"><dt>Returns</dt><dd>table, NULL if does not exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_name</td><td>in: table name </td></tr>
    <tr><td class="paramname">dict_locked</td><td>in: TRUE=data dictionary locked </td></tr>
    <tr><td class="paramname">try_drop</td><td>in: TRUE=try to drop any orphan indexes after an aborted online index creation </td></tr>
    <tr><td class="paramname">ignore_err</td><td>in: error to be ignored when loading a table definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6452a812364b1faf9aeda3f88e909e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6452a812364b1faf9aeda3f88e909e8">&#9670;&nbsp;</a></span>dict_table_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a table data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ce9c12df7e6ff2de04d27f9fa47624f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce9c12df7e6ff2de04d27f9fa47624f">&#9670;&nbsp;</a></span>dict_table_remove_from_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_remove_from_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a table object from the dictionary cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in, own: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca0ae4cc9073c6791525d75b40553092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0ae4cc9073c6791525d75b40553092">&#9670;&nbsp;</a></span>dict_table_remove_from_cache_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_table_remove_from_cache_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>lru_evict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a table object from the dictionary cache. in: TRUE if evicting from LRU</p>
<p>Removes a table object from the dictionary cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in, own: table </td></tr>
    <tr><td class="paramname">lru_evict</td><td>in: TRUE if table being evicted to make room in the table LRU list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4931cb7447a3b6276d9e628fc0f75d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4931cb7447a3b6276d9e628fc0f75d8f">&#9670;&nbsp;</a></span>dict_table_rename_in_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_table_rename_in_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>rename_also_foreigns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renames a table object. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">new_name</td><td>in: new name </td></tr>
    <tr><td class="paramname">rename_also_foreigns</td><td>in: in ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> we want to preserve the original table name in constraints which reference it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4401bccbcb5e191cdd3d95728549747f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4401bccbcb5e191cdd3d95728549747f">&#9670;&nbsp;</a></span>dict_table_schema_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_table_schema_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__schema__t.html">dict_table_schema_t</a> *&#160;</td>
          <td class="paramname"><em>req_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>errstr_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a table exists and whether it has the given structure. The table must have the same number of columns with the same names and types. The order of the columns does not matter. The caller must own the dictionary mutex. <a class="el" href="dict0dict_8cc.html#a4401bccbcb5e191cdd3d95728549747f">dict_table_schema_check()</a> </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if the table exists and contains the necessary columns </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req_schema</td><td>in/out: required table schema </td></tr>
    <tr><td class="paramname">errstr</td><td>out: human readable error message if != DB_SUCCESS is returned </td></tr>
    <tr><td class="paramname">errstr_sz</td><td>in: errstr size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfc9845ed994d238ea786a7e18824bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc9845ed994d238ea786a7e18824bb7">&#9670;&nbsp;</a></span>dict_table_stats_latch_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_table_stats_latch_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>table_void</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate and init a <a class="el" href="structdict__table__t.html">dict_table_t</a>'s stats latch. This function must not be called concurrently on the same table object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table_void</td><td>table whose stats latch to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fea7e3f600763f1ec8ada4c88f7a806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fea7e3f600763f1ec8ada4c88f7a806">&#9670;&nbsp;</a></span>dict_table_stats_latch_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_stats_latch_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="structdict__table__t.html">dict_table_t</a>'s stats latch or delay for lazy creation. This function is only called from either single threaded environment or from a thread that has not shared the table object with other threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table whose stats latch to create </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>if false then the latch is disabled and <a class="el" href="dict0dict_8cc.html#af80a681b70c81ca0ea43f44a5c18cac5">dict_table_stats_lock()</a>/unlock() become noop on this table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a428c4723fd38a1e83223604d42b7b8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428c4723fd38a1e83223604d42b7b8ab">&#9670;&nbsp;</a></span>dict_table_stats_latch_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dict_table_stats_latch_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a <a class="el" href="structdict__table__t.html">dict_table_t</a>'s stats latch. This function is only called from either single threaded environment or from a thread that has not shared the table object with other threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table whose stats latch to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41eca5100b6f672eda7a3d37e58aba89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41eca5100b6f672eda7a3d37e58aba89">&#9670;&nbsp;</a></span>dict_table_stats_latch_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_table_stats_latch_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deinit and free a <a class="el" href="structdict__table__t.html">dict_table_t</a>'s stats latch. This function must not be called concurrently on the same table object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>table whose stats latch to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af80a681b70c81ca0ea43f44a5c18cac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80a681b70c81ca0ea43f44a5c18cac5">&#9670;&nbsp;</a></span>dict_table_stats_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_stats_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock the appropriate latch to protect a given table's statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: RW_S_LATCH or RW_X_LATCH </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04604c3e7b339ea5e3c8abd28b090d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04604c3e7b339ea5e3c8abd28b090d3c">&#9670;&nbsp;</a></span>dict_table_stats_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_table_stats_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlock the latch that has been locked by <a class="el" href="dict0dict_8cc.html#af80a681b70c81ca0ea43f44a5c18cac5">dict_table_stats_lock()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: RW_S_LATCH or RW_X_LATCH </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6632f5f8cdd777607282722acbfbb455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6632f5f8cdd777607282722acbfbb455">&#9670;&nbsp;</a></span>dict_table_try_drop_aborted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_table_try_drop_aborted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_id_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>ref_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to drop any indexes after an aborted index creation. This can also be after a server kill during DROP INDEX. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table, or NULL if it needs to be looked up again </td></tr>
    <tr><td class="paramname">table_id</td><td>in: table identifier </td></tr>
    <tr><td class="paramname">ref_count</td><td>in: expected table-&gt;n_ref_count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1989e2ada49c84e0e347071346946759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1989e2ada49c84e0e347071346946759">&#9670;&nbsp;</a></span>dict_table_try_drop_aborted_and_mutex_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void dict_table_try_drop_aborted_and_mutex_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>try_drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When opening a table, try to drop any indexes after an aborted index creation. Release the dict_sys-&gt;mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table (may be NULL) </td></tr>
    <tr><td class="paramname">try_drop</td><td>in: FALSE if should try to drop indexes whose online creation was aborted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17c9f33ad07e2661ef5c92a3bc58853e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c9f33ad07e2661ef5c92a3bc58853e">&#9670;&nbsp;</a></span>dict_tables_have_same_db()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool dict_tables_have_same_db </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the database name in two table names is the same. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if same db name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name1</td><td>in: table name in the form dbname '/' tablename </td></tr>
    <tr><td class="paramname">name2</td><td>in: table name in the form dbname '/' tablename </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5d042819b0b32cbddba3cf3ff03d24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d042819b0b32cbddba3cf3ff03d24f">&#9670;&nbsp;</a></span>dict_tf_to_row_format_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_tf_to_row_format_string </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>table_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert table flag to row format string. </p><dl class="section return"><dt>Returns</dt><dd>row format name. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_flag</td><td>in: row format setting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a874357b82465503e7f7cdb187036df44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874357b82465503e7f7cdb187036df44">&#9670;&nbsp;</a></span>dict_ibfk</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char dict_ibfk[] = &quot;_ibfk_&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Identifies generated InnoDB foreign key names </p>

</div>
</div>
<a id="a2f366968ef52576a00ba9d1c95ba372f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f366968ef52576a00ba9d1c95ba372f">&#9670;&nbsp;</a></span>dict_ind_compact</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_ind_compact</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dummy index for ROW_FORMAT=COMPACT supremum and infimum records </p>

</div>
</div>
<a id="a975706a18d0ba2e302f2c6e1cd905f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975706a18d0ba2e302f2c6e1cd905f59">&#9670;&nbsp;</a></span>dict_ind_redundant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__index__t.html">dict_index_t</a>* dict_ind_redundant</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dummy index for ROW_FORMAT=REDUNDANT supremum and infimum records </p>

</div>
</div>
<a id="ac379b632e8479bbf0e33a5e0a3105368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac379b632e8479bbf0e33a5e0a3105368">&#9670;&nbsp;</a></span>dict_operation_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structrw__lock__t.html">rw_lock_t</a> dict_operation_lock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the data dictionary rw-latch protecting dict_sys </p>
<p>table create, drop, etc. reserve this in X-mode; implicit or backround operations purge, rollback, foreign key checks reserve this in S-mode; we cannot trust that MySQL protects implicit or background operations a table drop since MySQL does not know of them; therefore we need this; NOTE: a transaction which reserves this must keep book on the mode in <a class="el" href="structtrx__t.html#a49a0c797290155d3ee11c2fb8f53b719">trx_t::dict_operation_lock_mode</a> </p>

</div>
</div>
<a id="a8913b84084da00fa9870fbae64b75aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8913b84084da00fa9870fbae64b75aa3">&#9670;&nbsp;</a></span>dict_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__sys__t.html">dict_sys_t</a>* dict_sys = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the dictionary system </p>

</div>
</div>
<a id="ac04860931b6c5270d0cb91ee34bea1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04860931b6c5270d0cb91ee34bea1a2">&#9670;&nbsp;</a></span>zip_failure_threshold_pct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulong zip_failure_threshold_pct = 5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Percentage of compression failures that are allowed in a single round </p>

</div>
</div>
<a id="a7fd0ad667c54fd1a585b5d1bb2d3f7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd0ad667c54fd1a585b5d1bb2d3f7c6">&#9670;&nbsp;</a></span>zip_pad_max</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulong zip_pad_max = 50</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum percentage of a page that can be allowed as a pad to avoid compression failures </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/page/page0zip.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_7bd8f96740b7dc138f256daa629f1e06.html">page</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">page0zip.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;my_config.h&quot;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0log_8h_source.html">mtr0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0sort_8h_source.html">ut0sort.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0types_8h_source.html">page0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0recv_8h_source.html">log0recv.h</a>&quot;</code><br />
<code>#include &quot;zlib.h&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0crc32_8h_source.html">ut0crc32.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a026ecb225c8ecf49f8a6075a7071a962"><td class="memItemLeft" align="right" valign="top"><a id="a026ecb225c8ecf49f8a6075a7071a962"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>THIS_MODULE</b></td></tr>
<tr class="separator:a026ecb225c8ecf49f8a6075a7071a962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8175d6be93b5fcbb87cea304a42b0255"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a8175d6be93b5fcbb87cea304a42b0255">ASSERT_ZERO</a>(<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>,  <a class="el" href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a>)&#160;&#160;&#160;<a class="el" href="ut0dbg_8h.html#a17113dab7f37e298e889ac8818ab13d0">ut_ad</a>(!memcmp(<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, <a class="el" href="btr0types_8h.html#acf93462cc7a2ace0e2399e07e85210fd">field_ref_zero</a>, <a class="el" href="ut0ut_8h.html#a2f6f88650823f4cddb49d2730934894e">ut_min</a>(<a class="el" href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a>, sizeof <a class="el" href="btr0types_8h.html#acf93462cc7a2ace0e2399e07e85210fd">field_ref_zero</a>)))</td></tr>
<tr class="separator:a8175d6be93b5fcbb87cea304a42b0255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad542e4e3584140b2d5004ef38d5cdb37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ad542e4e3584140b2d5004ef38d5cdb37">ASSERT_ZERO_BLOB</a>(<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>)&#160;&#160;&#160;<a class="el" href="ut0dbg_8h.html#a17113dab7f37e298e889ac8818ab13d0">ut_ad</a>(!memcmp(<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, <a class="el" href="btr0types_8h.html#acf93462cc7a2ace0e2399e07e85210fd">field_ref_zero</a>, sizeof <a class="el" href="btr0types_8h.html#acf93462cc7a2ace0e2399e07e85210fd">field_ref_zero</a>))</td></tr>
<tr class="separator:ad542e4e3584140b2d5004ef38d5cdb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c9b0ea6717204041761a33df32ae27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a44c9b0ea6717204041761a33df32ae27">page_zip_fail</a>(fmt_args)&#160;&#160;&#160;/* empty */</td></tr>
<tr class="separator:a44c9b0ea6717204041761a33df32ae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d4a274f3bd9d0059d94a4501b4afdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ab1d4a274f3bd9d0059d94a4501b4afdc">page_zip_dir_start_low</a>(page_zip,  n_dense)&#160;&#160;&#160;((page_zip)-&gt;<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a> + <a class="el" href="page0zip_8cc.html#a52da1b13195f94287e0ced0a6908009e">page_zip_dir_start_offs</a>(page_zip, n_dense))</td></tr>
<tr class="separator:ab1d4a274f3bd9d0059d94a4501b4afdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918934b4045dc229439a2112df64da19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a918934b4045dc229439a2112df64da19">page_zip_dir_start</a>(page_zip)&#160;&#160;&#160;<a class="el" href="page0zip_8cc.html#ab1d4a274f3bd9d0059d94a4501b4afdc">page_zip_dir_start_low</a>(page_zip, <a class="el" href="page0zip_8cc.html#a2d923417373ac2532f4bf14c4bdffc60">page_zip_dir_elems</a>(page_zip))</td></tr>
<tr class="separator:a918934b4045dc229439a2112df64da19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af676d90106c2910827562a313f5399d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#af676d90106c2910827562a313f5399d6">FILE_LOGFILE</a></td></tr>
<tr class="separator:af676d90106c2910827562a313f5399d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3fef197146b932f5ad01fce683a66b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a6d3fef197146b932f5ad01fce683a66b">LOGFILE</a></td></tr>
<tr class="separator:a6d3fef197146b932f5ad01fce683a66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6323fd4df02082f62a58c5dadd56653b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a6323fd4df02082f62a58c5dadd56653b">page_zip_empty_size</a> (ulint <a class="el" href="row0merge_8cc.html#ac496ec05ddad9f1550478aec28d4dff0">n_fields</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>)</td></tr>
<tr class="separator:a6323fd4df02082f62a58c5dadd56653b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d923417373ac2532f4bf14c4bdffc60"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a2d923417373ac2532f4bf14c4bdffc60">page_zip_dir_elems</a> (const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:a2d923417373ac2532f4bf14c4bdffc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fd665f7863e86b8275590af493bb53"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a87fd665f7863e86b8275590af493bb53">page_zip_dir_size</a> (const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:a87fd665f7863e86b8275590af493bb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52da1b13195f94287e0ced0a6908009e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a52da1b13195f94287e0ced0a6908009e">page_zip_dir_start_offs</a> (const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint n_dense)</td></tr>
<tr class="separator:a52da1b13195f94287e0ced0a6908009e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd34851618bc78f08c84f0cec2f14613"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#abd34851618bc78f08c84f0cec2f14613">page_zip_dir_user_size</a> (const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:abd34851618bc78f08c84f0cec2f14613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7890b8b80535de978eb30381e6a21165"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a7890b8b80535de978eb30381e6a21165">page_zip_dir_find_low</a> (byte *slot, byte *end, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a7890b8b80535de978eb30381e6a21165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb72db5004326fcf3006cfbef033aa88"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#acb72db5004326fcf3006cfbef033aa88">page_zip_dir_find</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:acb72db5004326fcf3006cfbef033aa88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf08eb25507b85f2f2ede4bf643599a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a0bf08eb25507b85f2f2ede4bf643599a">page_zip_dir_find_free</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a0bf08eb25507b85f2f2ede4bf643599a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7d94b79e63f0b8453a93be2b751dab"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a0c7d94b79e63f0b8453a93be2b751dab">page_zip_dir_get</a> (const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint slot)</td></tr>
<tr class="separator:a0c7d94b79e63f0b8453a93be2b751dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e2941b0cead612c7c549769f0013fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a93e2941b0cead612c7c549769f0013fd">page_zip_compress_write_log</a> (const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a93e2941b0cead612c7c549769f0013fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0fcd1993a033070fb0c85bdb182f37"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a4b0fcd1993a033070fb0c85bdb182f37">page_zip_get_n_prev_extern</a> (const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a4b0fcd1993a033070fb0c85bdb182f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d75b7122e5a2fe8579d3bb0680fc40"><td class="memItemLeft" align="right" valign="top">static byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#aa8d75b7122e5a2fe8579d3bb0680fc40">page_zip_fixed_field_encode</a> (byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint val)</td></tr>
<tr class="separator:aa8d75b7122e5a2fe8579d3bb0680fc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08adb0e64c645e7d35a235ac69547bae"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a08adb0e64c645e7d35a235ac69547bae">page_zip_fields_encode</a> (ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint trx_id_pos, byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a08adb0e64c645e7d35a235ac69547bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea9f986ad6a05b9847a02bd9e52e71d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a0ea9f986ad6a05b9847a02bd9e52e71d">page_zip_dir_encode</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const rec_t **recs)</td></tr>
<tr class="separator:a0ea9f986ad6a05b9847a02bd9e52e71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce4590300498ce5675d66b7c6a8d609"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#abce4590300498ce5675d66b7c6a8d609">page_zip_zalloc</a> (void *opaque, uInt <a class="el" href="structitems.html">items</a>, uInt <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:abce4590300498ce5675d66b7c6a8d609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e480c32976efd4355900e68df58b51"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a29e480c32976efd4355900e68df58b51">page_zip_free</a> (void *opaque <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)), void *address <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:a29e480c32976efd4355900e68df58b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949c4203a9504051bc97fd2873484bd1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a949c4203a9504051bc97fd2873484bd1">page_zip_set_alloc</a> (void *stream, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a949c4203a9504051bc97fd2873484bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664a4d99e0e58bc5f9b1c3e26b6a1cc3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a664a4d99e0e58bc5f9b1c3e26b6a1cc3">page_zip_compress_node_ptrs</a> (<a class="el" href="page0zip_8cc.html#af676d90106c2910827562a313f5399d6">FILE_LOGFILE</a> z_stream *c_stream, const rec_t **recs, ulint n_dense, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, byte *storage, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a664a4d99e0e58bc5f9b1c3e26b6a1cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8aad3d6235b73532aca4c57ea6bae22"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ac8aad3d6235b73532aca4c57ea6bae22">page_zip_compress_sec</a> (<a class="el" href="page0zip_8cc.html#af676d90106c2910827562a313f5399d6">FILE_LOGFILE</a> z_stream *c_stream, const rec_t **recs, ulint n_dense)</td></tr>
<tr class="separator:ac8aad3d6235b73532aca4c57ea6bae22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7a3796ac8d960fd1efe4ef97f0c06"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a5af7a3796ac8d960fd1efe4ef97f0c06">page_zip_compress_clust_ext</a> (<a class="el" href="page0zip_8cc.html#af676d90106c2910827562a313f5399d6">FILE_LOGFILE</a> z_stream *c_stream, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="row0log_8cc.html#ad5c629c97aa6f73adab320ccdebcd264">trx_id_col</a>, byte *deleted, byte *storage, byte **externs, ulint *n_blobs)</td></tr>
<tr class="separator:a5af7a3796ac8d960fd1efe4ef97f0c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5546de9c1e1c5331906db775c953dd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#add5546de9c1e1c5331906db775c953dd">page_zip_compress_clust</a> (<a class="el" href="page0zip_8cc.html#af676d90106c2910827562a313f5399d6">FILE_LOGFILE</a> z_stream *c_stream, const rec_t **recs, ulint n_dense, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint *n_blobs, ulint <a class="el" href="row0log_8cc.html#ad5c629c97aa6f73adab320ccdebcd264">trx_id_col</a>, byte *deleted, byte *storage, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:add5546de9c1e1c5331906db775c953dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59142b92980079a77ae603306e1858c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ab59142b92980079a77ae603306e1858c">page_zip_compress</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ab59142b92980079a77ae603306e1858c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303261bfc2e729ddb281c1e0d97d002e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a303261bfc2e729ddb281c1e0d97d002e">page_zip_dir_cmp</a> (const rec_t *rec1, const rec_t *<a class="el" href="rem0cmp_8cc.html#aa8e8b75d129ba2c89a078148118c155c">rec2</a>)</td></tr>
<tr class="separator:a303261bfc2e729ddb281c1e0d97d002e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e66d0d8f6e74ef6f5107ec575094fff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a2e66d0d8f6e74ef6f5107ec575094fff">page_zip_dir_sort</a> (rec_t **arr, rec_t **aux_arr, ulint <a class="el" href="row0merge_8cc.html#a3361ade50d313e8440af7c5b83c62c00">low</a>, ulint <a class="el" href="row0merge_8cc.html#a0e8bb13be82bff6124680e514b1b6bcc">high</a>)</td></tr>
<tr class="separator:a2e66d0d8f6e74ef6f5107ec575094fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518837648b773e4ea2e75ac92fac9244"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a518837648b773e4ea2e75ac92fac9244">page_zip_fields_free</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a518837648b773e4ea2e75ac92fac9244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815c0ffa129b3161e0115be0304cb42c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a815c0ffa129b3161e0115be0304cb42c">page_zip_fields_decode</a> (const byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const byte *end, ulint *<a class="el" href="row0log_8cc.html#ad5c629c97aa6f73adab320ccdebcd264">trx_id_col</a>)</td></tr>
<tr class="separator:a815c0ffa129b3161e0115be0304cb42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36903b307b5ad8288e776dab85e3fe3"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#aa36903b307b5ad8288e776dab85e3fe3">page_zip_dir_decode</a> (const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, rec_t **recs, rec_t **recs_aux, ulint n_dense)</td></tr>
<tr class="separator:aa36903b307b5ad8288e776dab85e3fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74b90a5a409cf83281b4765227dd52d"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ab74b90a5a409cf83281b4765227dd52d">page_zip_set_extra_bytes</a> (const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint info_bits)</td></tr>
<tr class="separator:ab74b90a5a409cf83281b4765227dd52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b1d5e516f406c0ed6c19f126b40c89"><td class="memItemLeft" align="right" valign="top">static const byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a17b1d5e516f406c0ed6c19f126b40c89">page_zip_apply_log_ext</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="row0log_8cc.html#ad5c629c97aa6f73adab320ccdebcd264">trx_id_col</a>, const byte *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, const byte *end)</td></tr>
<tr class="separator:a17b1d5e516f406c0ed6c19f126b40c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab785daade2504337d6613c89e744fd04"><td class="memItemLeft" align="right" valign="top">static const byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ab785daade2504337d6613c89e744fd04">page_zip_apply_log</a> (const byte *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, rec_t **recs, ulint n_dense, ulint <a class="el" href="row0log_8cc.html#ad5c629c97aa6f73adab320ccdebcd264">trx_id_col</a>, ulint heap_status, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:ab785daade2504337d6613c89e744fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0b074fa3c51f6a30982b38591fb200"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a1d0b074fa3c51f6a30982b38591fb200">page_zip_decompress_heap_no</a> (z_stream *d_stream, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, ulint &amp;heap_status)</td></tr>
<tr class="separator:a1d0b074fa3c51f6a30982b38591fb200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72693fd940a0fbb870ed9c378670ca64"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a72693fd940a0fbb870ed9c378670ca64">page_zip_decompress_node_ptrs</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, z_stream *d_stream, rec_t **recs, ulint n_dense, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a72693fd940a0fbb870ed9c378670ca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae523c6860aca3219bd23f6d9fba8157c"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ae523c6860aca3219bd23f6d9fba8157c">page_zip_decompress_sec</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, z_stream *d_stream, rec_t **recs, ulint n_dense, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:ae523c6860aca3219bd23f6d9fba8157c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ea69762980b9ac7c7d81f8f56918a9"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a31ea69762980b9ac7c7d81f8f56918a9">page_zip_decompress_clust_ext</a> (z_stream *d_stream, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="row0log_8cc.html#ad5c629c97aa6f73adab320ccdebcd264">trx_id_col</a>)</td></tr>
<tr class="separator:a31ea69762980b9ac7c7d81f8f56918a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ef0474117eb25efb88674036094aff"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#aa5ef0474117eb25efb88674036094aff">page_zip_decompress_clust</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, z_stream *d_stream, rec_t **recs, ulint n_dense, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="row0log_8cc.html#ad5c629c97aa6f73adab320ccdebcd264">trx_id_col</a>, ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:aa5ef0474117eb25efb88674036094aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcc4801686d9d7039ad22ce6e32d65a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#aebcc4801686d9d7039ad22ce6e32d65a">page_zip_decompress</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ibool all)</td></tr>
<tr class="separator:aebcc4801686d9d7039ad22ce6e32d65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45d948cef4d240a1afd6f038babe777"><td class="memItemLeft" align="right" valign="top">static byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ae45d948cef4d240a1afd6f038babe777">page_zip_write_rec_ext</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, const byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint create, ulint <a class="el" href="row0log_8cc.html#ad5c629c97aa6f73adab320ccdebcd264">trx_id_col</a>, ulint heap_no, byte *storage, byte *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>)</td></tr>
<tr class="separator:ae45d948cef4d240a1afd6f038babe777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8346763580134b237f46b41d815751ca"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a8346763580134b237f46b41d815751ca">page_zip_write_rec</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint create)</td></tr>
<tr class="separator:a8346763580134b237f46b41d815751ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec098830929e06efd9d166154b79b214"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#aec098830929e06efd9d166154b79b214">page_zip_parse_write_blob_ptr</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:aec098830929e06efd9d166154b79b214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d407139b38beac31773b1bfed92383"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a19d407139b38beac31773b1bfed92383">page_zip_write_blob_ptr</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a19d407139b38beac31773b1bfed92383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8181f139ad785ace74b3b40d758700"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a1c8181f139ad785ace74b3b40d758700">page_zip_parse_write_node_ptr</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:a1c8181f139ad785ace74b3b40d758700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d48f129f320c9af2a0bbf1b6ea3681b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a8d48f129f320c9af2a0bbf1b6ea3681b">page_zip_write_node_ptr</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, ulint ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a8d48f129f320c9af2a0bbf1b6ea3681b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f902e4fdd00ab61f13beb77ebc4800"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a27f902e4fdd00ab61f13beb77ebc4800">page_zip_write_trx_id_and_roll_ptr</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="row0log_8cc.html#ad5c629c97aa6f73adab320ccdebcd264">trx_id_col</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> <a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a>)</td></tr>
<tr class="separator:a27f902e4fdd00ab61f13beb77ebc4800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc510488025a7007e924e8dffcd53200"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#acc510488025a7007e924e8dffcd53200">page_zip_clear_rec</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:acc510488025a7007e924e8dffcd53200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82368a54bc478f459e74faac1c6b1727"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a82368a54bc478f459e74faac1c6b1727">page_zip_rec_set_deleted</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, ulint flag)</td></tr>
<tr class="separator:a82368a54bc478f459e74faac1c6b1727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f1ff6129a0d9784aa45fa54d7d6d70"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a70f1ff6129a0d9784aa45fa54d7d6d70">page_zip_rec_set_owned</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, ulint flag)</td></tr>
<tr class="separator:a70f1ff6129a0d9784aa45fa54d7d6d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35cae13d4039b0f1fa59d5272116a40"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ab35cae13d4039b0f1fa59d5272116a40">page_zip_dir_insert</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const byte *prev_rec, const byte *free_rec, byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:ab35cae13d4039b0f1fa59d5272116a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66a6a4eecbc701b7c95648e628567ca"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ad66a6a4eecbc701b7c95648e628567ca">page_zip_dir_delete</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, byte *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const byte *free)</td></tr>
<tr class="separator:ad66a6a4eecbc701b7c95648e628567ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5312abf062ee12e38214e6fe16b96255"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a5312abf062ee12e38214e6fe16b96255">page_zip_dir_add_slot</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint is_clustered)</td></tr>
<tr class="separator:a5312abf062ee12e38214e6fe16b96255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b122ccecd3470b90272ee6413ce1ca"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ab9b122ccecd3470b90272ee6413ce1ca">page_zip_parse_write_header</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:ab9b122ccecd3470b90272ee6413ce1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b27175a5d817c1cede6b71efe9f428"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a14b27175a5d817c1cede6b71efe9f428">page_zip_write_header_log</a> (const byte *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ulint length, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a14b27175a5d817c1cede6b71efe9f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863b6023c2351a464413ad6f2ac1468c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a863b6023c2351a464413ad6f2ac1468c">page_zip_reorganize</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a863b6023c2351a464413ad6f2ac1468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b557e225536933736a7409d0dc21cc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a76b557e225536933736a7409d0dc21cc">page_zip_copy_recs</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *src_zip, const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *src, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a76b557e225536933736a7409d0dc21cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5165b7896d4c22d8201e506ee823b22"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ab5165b7896d4c22d8201e506ee823b22">page_zip_parse_compress</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:ab5165b7896d4c22d8201e506ee823b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab945994317b9f99a3cd6fa7170c3729b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#ab945994317b9f99a3cd6fa7170c3729b">page_zip_calc_checksum</a> (const void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, <a class="el" href="buf0types_8h.html#acaf8bfcdca6f89c133a00e41f1596cdd">srv_checksum_algorithm_t</a> algo)</td></tr>
<tr class="separator:ab945994317b9f99a3cd6fa7170c3729b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28aba759751d57b23b9fd7fda06619c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a28aba759751d57b23b9fd7fda06619c0">page_zip_verify_checksum</a> (const void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a28aba759751d57b23b9fd7fda06619c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abe68f834a1051a123fa6dcd5f1858f24"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structpage__zip__stat__t.html">page_zip_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#abe68f834a1051a123fa6dcd5f1858f24">page_zip_stat</a> [<a class="el" href="page0types_8h.html#abafca45baefc76a04e46a3a12e243cc9">PAGE_ZIP_SSIZE_MAX</a>]</td></tr>
<tr class="separator:abe68f834a1051a123fa6dcd5f1858f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e2dda16ec1ab8b2c055164b541d123"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="page0types_8h.html#a2a70eec3d796d807a6fd8011490c573f">page_zip_stat_per_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a43e2dda16ec1ab8b2c055164b541d123">page_zip_stat_per_index</a></td></tr>
<tr class="separator:a43e2dda16ec1ab8b2c055164b541d123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d162c7c680b91441b5e75b004b7e02"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structib__mutex__t.html">ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#af8d162c7c680b91441b5e75b004b7e02">page_zip_stat_per_index_mutex</a></td></tr>
<tr class="separator:af8d162c7c680b91441b5e75b004b7e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ba1b82930f64abb674fc2485803bc4"><td class="memItemLeft" align="right" valign="top"><a id="a96ba1b82930f64abb674fc2485803bc4"></a>
UNIV_INTERN mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>page_zip_stat_per_index_mutex_key</b></td></tr>
<tr class="separator:a96ba1b82930f64abb674fc2485803bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c469ada1d234f062ec1bc8340c02de"><td class="memItemLeft" align="right" valign="top"><a id="aa5c469ada1d234f062ec1bc8340c02de"></a>
UNIV_INTERN uint&#160;</td><td class="memItemRight" valign="bottom"><b>page_zip_level</b> = DEFAULT_COMPRESSION_LEVEL</td></tr>
<tr class="separator:aa5c469ada1d234f062ec1bc8340c02de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3d8f9efdc91a3db3c5b5ee882a9130"><td class="memItemLeft" align="right" valign="top"><a id="a3e3d8f9efdc91a3db3c5b5ee882a9130"></a>
UNIV_INTERN my_bool&#160;</td><td class="memItemRight" valign="bottom"><b>page_zip_log_pages</b> = true</td></tr>
<tr class="separator:a3e3d8f9efdc91a3db3c5b5ee882a9130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f6454b70db57b32fbb62e6c708deab"><td class="memItemLeft" align="right" valign="top">static const byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a45f6454b70db57b32fbb62e6c708deab">infimum_extra</a> []</td></tr>
<tr class="separator:a45f6454b70db57b32fbb62e6c708deab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb3a28f26f09ddca40650276842bf5a"><td class="memItemLeft" align="right" valign="top">static const byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#abeb3a28f26f09ddca40650276842bf5a">infimum_data</a> []</td></tr>
<tr class="separator:abeb3a28f26f09ddca40650276842bf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088094b7e1b7b1a11f59eb92294be3e1"><td class="memItemLeft" align="right" valign="top">static const byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="page0zip_8cc.html#a088094b7e1b7b1a11f59eb92294be3e1">supremum_extra_data</a> []</td></tr>
<tr class="separator:a088094b7e1b7b1a11f59eb92294be3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Compressed page interface</p>
<p>Created June 2005 by Marko Makela </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8175d6be93b5fcbb87cea304a42b0255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8175d6be93b5fcbb87cea304a42b0255">&#9670;&nbsp;</a></span>ASSERT_ZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASSERT_ZERO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ut0dbg_8h.html#a17113dab7f37e298e889ac8818ab13d0">ut_ad</a>(!memcmp(<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, <a class="el" href="btr0types_8h.html#acf93462cc7a2ace0e2399e07e85210fd">field_ref_zero</a>, <a class="el" href="ut0ut_8h.html#a2f6f88650823f4cddb49d2730934894e">ut_min</a>(<a class="el" href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a>, sizeof <a class="el" href="btr0types_8h.html#acf93462cc7a2ace0e2399e07e85210fd">field_ref_zero</a>)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assert that a block of memory is filled with zero bytes. Compare at most sizeof(field_ref_zero) bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>in: memory block </td></tr>
    <tr><td class="paramname">s</td><td>in: size of the memory block, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad542e4e3584140b2d5004ef38d5cdb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad542e4e3584140b2d5004ef38d5cdb37">&#9670;&nbsp;</a></span>ASSERT_ZERO_BLOB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASSERT_ZERO_BLOB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ut0dbg_8h.html#a17113dab7f37e298e889ac8818ab13d0">ut_ad</a>(!memcmp(<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, <a class="el" href="btr0types_8h.html#acf93462cc7a2ace0e2399e07e85210fd">field_ref_zero</a>, sizeof <a class="el" href="btr0types_8h.html#acf93462cc7a2ace0e2399e07e85210fd">field_ref_zero</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assert that a BLOB pointer is filled with zero bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>in: BLOB pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af676d90106c2910827562a313f5399d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af676d90106c2910827562a313f5399d6">&#9670;&nbsp;</a></span>FILE_LOGFILE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FILE_LOGFILE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty declaration of the logfile parameter </p>

</div>
</div>
<a id="a6d3fef197146b932f5ad01fce683a66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3fef197146b932f5ad01fce683a66b">&#9670;&nbsp;</a></span>LOGFILE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOGFILE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Missing logfile parameter </p>

</div>
</div>
<a id="a918934b4045dc229439a2112df64da19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918934b4045dc229439a2112df64da19">&#9670;&nbsp;</a></span>page_zip_dir_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define page_zip_dir_start</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_zip</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="page0zip_8cc.html#ab1d4a274f3bd9d0059d94a4501b4afdc">page_zip_dir_start_low</a>(page_zip, <a class="el" href="page0zip_8cc.html#a2d923417373ac2532f4bf14c4bdffc60">page_zip_dir_elems</a>(page_zip))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a pointer to the compressed page trailer (the dense page directory), including deleted records (the free list). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_zip</td><td>compressed page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the dense page directory </dd></dl>

</div>
</div>
<a id="ab1d4a274f3bd9d0059d94a4501b4afdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d4a274f3bd9d0059d94a4501b4afdc">&#9670;&nbsp;</a></span>page_zip_dir_start_low</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define page_zip_dir_start_low</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_zip, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_dense&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((page_zip)-&gt;<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a> + <a class="el" href="page0zip_8cc.html#a52da1b13195f94287e0ced0a6908009e">page_zip_dir_start_offs</a>(page_zip, n_dense))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a pointer to the compressed page trailer (the dense page directory), including deleted records (the free list). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_zip</td><td>compressed page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_dense</td><td>number of entries in the directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the dense page directory </dd></dl>

</div>
</div>
<a id="a44c9b0ea6717204041761a33df32ae27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c9b0ea6717204041761a33df32ae27">&#9670;&nbsp;</a></span>page_zip_fail</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define page_zip_fail</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fmt_args</td><td>)</td>
          <td>&#160;&#160;&#160;/* empty */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dummy wrapper for page_zip_fail_func() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt_args</td><td>ignored: printf(3) format string and arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab785daade2504337d6613c89e744fd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab785daade2504337d6613c89e744fd04">&#9670;&nbsp;</a></span>page_zip_apply_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const byte* page_zip_apply_log </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>recs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>trx_id_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the modification log to an uncompressed page. Do not copy the fields that are stored separately. </p><dl class="section return"><dt>Returns</dt><dd>pointer to end of modification log, or NULL on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>in: modification log </td></tr>
    <tr><td class="paramname">size</td><td>in: maximum length of the log, in bytes </td></tr>
    <tr><td class="paramname">recs</td><td>in: dense page directory, sorted by address (indexed by heap_no - PAGE_HEAP_NO_USER_LOW) </td></tr>
    <tr><td class="paramname">n_dense</td><td>in: size of recs[] </td></tr>
    <tr><td class="paramname">trx_id_col</td><td>in: column number of trx_id in the index, or ULINT_UNDEFINED if none </td></tr>
    <tr><td class="paramname">heap_status</td><td>in: heap_no and status bits for the next record to uncompress </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the page </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: work area for <a class="el" href="rem0rec_8h.html#a872d3467fef6277df3779c3a58865b9f">rec_get_offsets_reverse()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17b1d5e516f406c0ed6c19f126b40c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b1d5e516f406c0ed6c19f126b40c89">&#9670;&nbsp;</a></span>page_zip_apply_log_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const byte* page_zip_apply_log_ext </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>trx_id_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the modification log to a record containing externally stored columns. Do not copy the fields that are stored separately. </p><dl class="section return"><dt>Returns</dt><dd>pointer to modification log, or NULL on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">trx_id_col</td><td>in: position of of DB_TRX_ID </td></tr>
    <tr><td class="paramname">data</td><td>in: modification log </td></tr>
    <tr><td class="paramname">end</td><td>in: end of modification log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab945994317b9f99a3cd6fa7170c3729b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab945994317b9f99a3cd6fa7170c3729b">&#9670;&nbsp;</a></span>page_zip_calc_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint page_zip_calc_checksum </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#acaf8bfcdca6f89c133a00e41f1596cdd">srv_checksum_algorithm_t</a>&#160;</td>
          <td class="paramname"><em>algo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the compressed page checksum. </p><dl class="section return"><dt>Returns</dt><dd>page checksum </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>in: compressed page </td></tr>
    <tr><td class="paramname">size</td><td>in: size of compressed page </td></tr>
    <tr><td class="paramname">algo</td><td>in: algorithm to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc510488025a7007e924e8dffcd53200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc510488025a7007e924e8dffcd53200">&#9670;&nbsp;</a></span>page_zip_clear_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void page_zip_clear_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear an area on the uncompressed and compressed page. Do not clear the data payload, as that would grow the modification log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">rec</td><td>in: record to clear </td></tr>
    <tr><td class="paramname">index</td><td>in: index of rec </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab59142b92980079a77ae603306e1858c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59142b92980079a77ae603306e1858c">&#9670;&nbsp;</a></span>page_zip_compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool page_zip_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compress a page. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure; page_zip will be left intact on failure. </dd></dl>
<p>&lt; index field information</p>
<p>&lt; compressed payload of the page</p>
<p>&lt; dense page directory, sorted by address </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: size; out: data, n_blobs, m_start, m_end, m_nonempty </td></tr>
    <tr><td class="paramname">page</td><td>in: uncompressed page </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the B-tree node </td></tr>
    <tr><td class="paramname">level</td><td>in: compression level </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add5546de9c1e1c5331906db775c953dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5546de9c1e1c5331906db775c953dd">&#9670;&nbsp;</a></span>page_zip_compress_clust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int page_zip_compress_clust </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0zip_8cc.html#af676d90106c2910827562a313f5399d6">FILE_LOGFILE</a> z_stream *&#160;</td>
          <td class="paramname"><em>c_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t **&#160;</td>
          <td class="paramname"><em>recs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>trx_id_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compress the records of a leaf node of a clustered index. </p><dl class="section return"><dt>Returns</dt><dd>Z_OK, or a zlib error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_stream</td><td>in/out: compressed page stream </td></tr>
    <tr><td class="paramname">recs</td><td>in: dense page directory sorted by address </td></tr>
    <tr><td class="paramname">n_dense</td><td>in: size of recs[] </td></tr>
    <tr><td class="paramname">index</td><td>in: the index of the page </td></tr>
    <tr><td class="paramname">n_blobs</td><td>in: 0; out: number of externally stored columns </td></tr>
    <tr><td class="paramname">trx_id_col</td><td>index of the trx_id column </td></tr>
    <tr><td class="paramname">deleted</td><td>in: dense directory entry pointing to the head of the free list </td></tr>
    <tr><td class="paramname">storage</td><td>in: end of dense page directory </td></tr>
    <tr><td class="paramname">heap</td><td>in: temporary memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7a3796ac8d960fd1efe4ef97f0c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7a3796ac8d960fd1efe4ef97f0c06">&#9670;&nbsp;</a></span>page_zip_compress_clust_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int page_zip_compress_clust_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0zip_8cc.html#af676d90106c2910827562a313f5399d6">FILE_LOGFILE</a> z_stream *&#160;</td>
          <td class="paramname"><em>c_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>trx_id_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>externs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_blobs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compress a record of a leaf node of a clustered index that contains externally stored columns. </p><dl class="section return"><dt>Returns</dt><dd>Z_OK, or a zlib error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_stream</td><td>in/out: compressed page stream </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">trx_id_col</td><td>in: position of of DB_TRX_ID </td></tr>
    <tr><td class="paramname">deleted</td><td>in: dense directory entry pointing to the head of the free list </td></tr>
    <tr><td class="paramname">storage</td><td>in: end of dense page directory </td></tr>
    <tr><td class="paramname">externs</td><td>in/out: pointer to the next available BLOB pointer </td></tr>
    <tr><td class="paramname">n_blobs</td><td>in/out: number of externally stored columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a664a4d99e0e58bc5f9b1c3e26b6a1cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664a4d99e0e58bc5f9b1c3e26b6a1cc3">&#9670;&nbsp;</a></span>page_zip_compress_node_ptrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int page_zip_compress_node_ptrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0zip_8cc.html#af676d90106c2910827562a313f5399d6">FILE_LOGFILE</a> z_stream *&#160;</td>
          <td class="paramname"><em>c_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t **&#160;</td>
          <td class="paramname"><em>recs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compress the records of a node pointer page. </p><dl class="section return"><dt>Returns</dt><dd>Z_OK, or a zlib error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_stream</td><td>in/out: compressed page stream </td></tr>
    <tr><td class="paramname">recs</td><td>in: dense page directory sorted by address </td></tr>
    <tr><td class="paramname">n_dense</td><td>in: size of recs[] </td></tr>
    <tr><td class="paramname">index</td><td>in: the index of the page </td></tr>
    <tr><td class="paramname">storage</td><td>in: end of dense page directory </td></tr>
    <tr><td class="paramname">heap</td><td>in: temporary memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8aad3d6235b73532aca4c57ea6bae22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8aad3d6235b73532aca4c57ea6bae22">&#9670;&nbsp;</a></span>page_zip_compress_sec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int page_zip_compress_sec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0zip_8cc.html#af676d90106c2910827562a313f5399d6">FILE_LOGFILE</a> z_stream *&#160;</td>
          <td class="paramname"><em>c_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t **&#160;</td>
          <td class="paramname"><em>recs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_dense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compress the records of a leaf node of a secondary index. </p><dl class="section return"><dt>Returns</dt><dd>Z_OK, or a zlib error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_stream</td><td>in/out: compressed page stream </td></tr>
    <tr><td class="paramname">recs</td><td>in: dense page directory sorted by address </td></tr>
    <tr><td class="paramname">n_dense</td><td>in: size of recs[] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93e2941b0cead612c7c549769f0013fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e2941b0cead612c7c549769f0013fd">&#9670;&nbsp;</a></span>page_zip_compress_write_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void page_zip_compress_write_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a log record of compressing an index page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: compressed page </td></tr>
    <tr><td class="paramname">page</td><td>in: uncompressed page </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the B-tree node </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76b557e225536933736a7409d0dc21cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b557e225536933736a7409d0dc21cc">&#9670;&nbsp;</a></span>page_zip_copy_recs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_copy_recs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>src_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the records of a page byte for byte. Do not copy the page header or trailer, except those B-tree header fields that are directly related to the storage of records. Also copy PAGE_MAX_TRX_ID. NOTE: The caller must update the lock table and the adaptive hash index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>out: copy of src_zip (n_blobs, m_start, m_end, m_nonempty, data[0..size-1]) </td></tr>
    <tr><td class="paramname">page</td><td>out: copy of src </td></tr>
    <tr><td class="paramname">src_zip</td><td>in: compressed page </td></tr>
    <tr><td class="paramname">src</td><td>in: page </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the B-tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebcc4801686d9d7039ad22ce6e32d65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcc4801686d9d7039ad22ce6e32d65a">&#9670;&nbsp;</a></span>page_zip_decompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool page_zip_decompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decompress a page. This function should tolerate errors on the compressed page. Instead of letting assertions fail, it will return FALSE if an inconsistency is detected. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure </dd></dl>
<p>&lt; dense page directory, sorted by address </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: data, ssize; out: m_start, m_end, m_nonempty, n_blobs </td></tr>
    <tr><td class="paramname">page</td><td>out: uncompressed page, may be trashed </td></tr>
    <tr><td class="paramname">all</td><td>in: TRUE=decompress the whole page; FALSE=verify but do not copy some page header fields that should not change after page creation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5ef0474117eb25efb88674036094aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ef0474117eb25efb88674036094aff">&#9670;&nbsp;</a></span>page_zip_decompress_clust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool page_zip_decompress_clust </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">z_stream *&#160;</td>
          <td class="paramname"><em>d_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>recs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>trx_id_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compress the records of a leaf node of a clustered index. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">d_stream</td><td>in/out: compressed page stream </td></tr>
    <tr><td class="paramname">recs</td><td>in: dense page directory sorted by address </td></tr>
    <tr><td class="paramname">n_dense</td><td>in: size of recs[] </td></tr>
    <tr><td class="paramname">index</td><td>in: the index of the page </td></tr>
    <tr><td class="paramname">trx_id_col</td><td>index of the trx_id column </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: temporary offsets </td></tr>
    <tr><td class="paramname">heap</td><td>in: temporary memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31ea69762980b9ac7c7d81f8f56918a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ea69762980b9ac7c7d81f8f56918a9">&#9670;&nbsp;</a></span>page_zip_decompress_clust_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool page_zip_decompress_clust_ext </td>
          <td>(</td>
          <td class="paramtype">z_stream *&#160;</td>
          <td class="paramname"><em>d_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>trx_id_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decompress a record of a leaf node of a clustered index that contains externally stored columns. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_stream</td><td>in/out: compressed page stream </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">trx_id_col</td><td>in: position of of DB_TRX_ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d0b074fa3c51f6a30982b38591fb200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0b074fa3c51f6a30982b38591fb200">&#9670;&nbsp;</a></span>page_zip_decompress_heap_no()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool page_zip_decompress_heap_no </td>
          <td>(</td>
          <td class="paramtype">z_stream *&#160;</td>
          <td class="paramname"><em>d_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint &amp;&#160;</td>
          <td class="paramname"><em>heap_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the heap_no in a record, and skip the fixed-size record header that is not included in the d_stream. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE if d_stream does not end at rec </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_stream</td><td>in/out: compressed page stream </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">heap_status</td><td>in/out: heap_no and status bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72693fd940a0fbb870ed9c378670ca64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72693fd940a0fbb870ed9c378670ca64">&#9670;&nbsp;</a></span>page_zip_decompress_node_ptrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool page_zip_decompress_node_ptrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">z_stream *&#160;</td>
          <td class="paramname"><em>d_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>recs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decompress the records of a node pointer page. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">d_stream</td><td>in/out: compressed page stream </td></tr>
    <tr><td class="paramname">recs</td><td>in: dense page directory sorted by address </td></tr>
    <tr><td class="paramname">n_dense</td><td>in: size of recs[] </td></tr>
    <tr><td class="paramname">index</td><td>in: the index of the page </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: temporary offsets </td></tr>
    <tr><td class="paramname">heap</td><td>in: temporary memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae523c6860aca3219bd23f6d9fba8157c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae523c6860aca3219bd23f6d9fba8157c">&#9670;&nbsp;</a></span>page_zip_decompress_sec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool page_zip_decompress_sec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">z_stream *&#160;</td>
          <td class="paramname"><em>d_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>recs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_dense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decompress the records of a leaf node of a secondary index. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">d_stream</td><td>in/out: compressed page stream </td></tr>
    <tr><td class="paramname">recs</td><td>in: dense page directory sorted by address </td></tr>
    <tr><td class="paramname">n_dense</td><td>in: size of recs[] </td></tr>
    <tr><td class="paramname">index</td><td>in: the index of the page </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: temporary offsets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5312abf062ee12e38214e6fe16b96255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5312abf062ee12e38214e6fe16b96255">&#9670;&nbsp;</a></span>page_zip_dir_add_slot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_dir_add_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>is_clustered</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a slot to the dense page directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">is_clustered</td><td>in: nonzero for clustered index, zero for others </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a303261bfc2e729ddb281c1e0d97d002e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303261bfc2e729ddb281c1e0d97d002e">&#9670;&nbsp;</a></span>page_zip_dir_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool page_zip_dir_cmp </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two page directory entries. </p><dl class="section return"><dt>Returns</dt><dd>positive if rec1 &gt; rec2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec1</td><td>in: rec1 </td></tr>
    <tr><td class="paramname">rec2</td><td>in: rec2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa36903b307b5ad8288e776dab85e3fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36903b307b5ad8288e776dab85e3fe3">&#9670;&nbsp;</a></span>page_zip_dir_decode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool page_zip_dir_decode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>recs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>recs_aux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_dense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate the sparse page directory from the dense directory. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: dense page directory on compressed page </td></tr>
    <tr><td class="paramname">page</td><td>in: compact page with valid header; out: trailer and sparse page directory filled in </td></tr>
    <tr><td class="paramname">recs</td><td>out: dense page directory sorted by ascending address (and heap_no) </td></tr>
    <tr><td class="paramname">recs_aux</td><td>in/out: scratch area </td></tr>
    <tr><td class="paramname">n_dense</td><td>in: number of user records, and size of recs[] and recs_aux[] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad66a6a4eecbc701b7c95648e628567ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66a6a4eecbc701b7c95648e628567ca">&#9670;&nbsp;</a></span>page_zip_dir_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_dir_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>free</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift the dense page directory and the array of BLOB pointers when a record is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">rec</td><td>in: deleted record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of rec </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">free</td><td>in: previous start of the free list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d923417373ac2532f4bf14c4bdffc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d923417373ac2532f4bf14c4bdffc60">&#9670;&nbsp;</a></span>page_zip_dir_elems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint page_zip_dir_elems </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of elements in the dense page directory, including deleted records (the free list). </p><dl class="section return"><dt>Returns</dt><dd>number of elements in the dense page directory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: compressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ea9f986ad6a05b9847a02bd9e52e71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea9f986ad6a05b9847a02bd9e52e71d">&#9670;&nbsp;</a></span>page_zip_dir_encode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void page_zip_dir_encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t **&#160;</td>
          <td class="paramname"><em>recs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populate the dense page directory from the sparse directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: compact page </td></tr>
    <tr><td class="paramname">buf</td><td>in: pointer to dense page directory[-1]; out: dense directory on compressed page </td></tr>
    <tr><td class="paramname">recs</td><td>in: pointer to an array of 0, or NULL; out: dense page directory sorted by ascending address (and heap_no) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb72db5004326fcf3006cfbef033aa88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb72db5004326fcf3006cfbef033aa88">&#9670;&nbsp;</a></span>page_zip_dir_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE byte* page_zip_dir_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the slot of the given non-free record in the dense page directory. </p><dl class="section return"><dt>Returns</dt><dd>dense directory slot, or NULL if record not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: compressed page </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset of user record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bf08eb25507b85f2f2ede4bf643599a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf08eb25507b85f2f2ede4bf643599a">&#9670;&nbsp;</a></span>page_zip_dir_find_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE byte* page_zip_dir_find_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the slot of the given free record in the dense page directory. </p><dl class="section return"><dt>Returns</dt><dd>dense directory slot, or NULL if record not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: compressed page </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset of user record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7890b8b80535de978eb30381e6a21165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7890b8b80535de978eb30381e6a21165">&#9670;&nbsp;</a></span>page_zip_dir_find_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE byte* page_zip_dir_find_low </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the slot of the given record in the dense page directory. </p><dl class="section return"><dt>Returns</dt><dd>dense directory slot, or NULL if record not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>in: start of records </td></tr>
    <tr><td class="paramname">end</td><td>in: end of records </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset of user record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c7d94b79e63f0b8453a93be2b751dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7d94b79e63f0b8453a93be2b751dab">&#9670;&nbsp;</a></span>page_zip_dir_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint page_zip_dir_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a given slot in the dense page directory. </p><dl class="section return"><dt>Returns</dt><dd>record offset on the uncompressed page, possibly ORed with PAGE_ZIP_DIR_SLOT_DEL or PAGE_ZIP_DIR_SLOT_OWNED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: compressed page </td></tr>
    <tr><td class="paramname">slot</td><td>in: slot (0=first user record) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab35cae13d4039b0f1fa59d5272116a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35cae13d4039b0f1fa59d5272116a40">&#9670;&nbsp;</a></span>page_zip_dir_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_dir_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>prev_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>free_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a record to the dense page directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">prev_rec</td><td>in: record after which to insert </td></tr>
    <tr><td class="paramname">free_rec</td><td>in: record from which rec was allocated, or NULL </td></tr>
    <tr><td class="paramname">rec</td><td>in: record to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87fd665f7863e86b8275590af493bb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fd665f7863e86b8275590af493bb53">&#9670;&nbsp;</a></span>page_zip_dir_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint page_zip_dir_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of the compressed page trailer (the dense page directory), including deleted records (the free list). </p><dl class="section return"><dt>Returns</dt><dd>length of dense page directory, in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: compressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e66d0d8f6e74ef6f5107ec575094fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e66d0d8f6e74ef6f5107ec575094fff">&#9670;&nbsp;</a></span>page_zip_dir_sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void page_zip_dir_sort </td>
          <td>(</td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>aux_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sort the dense page directory by address (heap_no). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in/out: dense page directory </td></tr>
    <tr><td class="paramname">aux_arr</td><td>in/out: work area </td></tr>
    <tr><td class="paramname">low</td><td>in: lower bound of the sorting area, inclusive </td></tr>
    <tr><td class="paramname">high</td><td>in: upper bound of the sorting area, exclusive </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52da1b13195f94287e0ced0a6908009e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52da1b13195f94287e0ced0a6908009e">&#9670;&nbsp;</a></span>page_zip_dir_start_offs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint page_zip_dir_start_offs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_dense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets an offset to the compressed page trailer (the dense page directory), including deleted records (the free list). </p><dl class="section return"><dt>Returns</dt><dd>offset of the dense page directory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: compressed page </td></tr>
    <tr><td class="paramname">n_dense</td><td>in: directory size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd34851618bc78f08c84f0cec2f14613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd34851618bc78f08c84f0cec2f14613">&#9670;&nbsp;</a></span>page_zip_dir_user_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint page_zip_dir_user_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of the compressed page trailer (the dense page directory), only including user records (excluding the free list). </p><dl class="section return"><dt>Returns</dt><dd>length of dense page directory comprising existing records, in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: compressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6323fd4df02082f62a58c5dadd56653b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6323fd4df02082f62a58c5dadd56653b">&#9670;&nbsp;</a></span>page_zip_empty_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint page_zip_empty_size </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the guaranteed free space on an empty page. </p><dl class="section return"><dt>Returns</dt><dd>minimum payload size on the page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_fields</td><td>in: number of columns in the index </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a815c0ffa129b3161e0115be0304cb42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815c0ffa129b3161e0115be0304cb42c">&#9670;&nbsp;</a></span>page_zip_fields_decode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__index__t.html">dict_index_t</a>* page_zip_fields_decode </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>trx_id_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the index information for the compressed page. </p><dl class="section return"><dt>Returns</dt><dd>own: dummy index describing the page, or NULL on error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in: index information </td></tr>
    <tr><td class="paramname">end</td><td>in: end of buf </td></tr>
    <tr><td class="paramname">trx_id_col</td><td>in: NULL for non-leaf pages; for leaf pages, pointer to where to store the position of the trx_id column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08adb0e64c645e7d35a235ac69547bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08adb0e64c645e7d35a235ac69547bae">&#9670;&nbsp;</a></span>page_zip_fields_encode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint page_zip_fields_encode </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>trx_id_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the index information for the compressed page. </p><dl class="section return"><dt>Returns</dt><dd>used size of buf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: number of fields to compress </td></tr>
    <tr><td class="paramname">index</td><td>in: index comprising at least n fields </td></tr>
    <tr><td class="paramname">trx_id_pos</td><td>in: position of the trx_id column in the index, or ULINT_UNDEFINED if this is a non-leaf page </td></tr>
    <tr><td class="paramname">buf</td><td>out: buffer of (n + 1) * 2 bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a518837648b773e4ea2e75ac92fac9244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518837648b773e4ea2e75ac92fac9244">&#9670;&nbsp;</a></span>page_zip_fields_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void page_zip_fields_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocate the index information initialized by <a class="el" href="page0zip_8cc.html#a815c0ffa129b3161e0115be0304cb42c">page_zip_fields_decode()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: dummy index to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8d75b7122e5a2fe8579d3bb0680fc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d75b7122e5a2fe8579d3bb0680fc40">&#9670;&nbsp;</a></span>page_zip_fixed_field_encode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static byte* page_zip_fixed_field_encode </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Encode the length of a fixed-length column. </p><dl class="section return"><dt>Returns</dt><dd>buf + length of encoded val </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in: pointer to buffer where to write </td></tr>
    <tr><td class="paramname">val</td><td>in: value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29e480c32976efd4355900e68df58b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e480c32976efd4355900e68df58b51">&#9670;&nbsp;</a></span>page_zip_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void page_zip_free </td>
          <td>(</td>
          <td class="paramtype">void *opaque &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *address &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocate memory for zlib. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__attribute__</td><td>in: memory heap </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in: object to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b0fcd1993a033070fb0c85bdb182f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0fcd1993a033070fb0c85bdb182f37">&#9670;&nbsp;</a></span>page_zip_get_n_prev_extern()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint page_zip_get_n_prev_extern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine how many externally stored columns are contained in existing records with smaller heap_no than rec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: dense page directory on compressed page </td></tr>
    <tr><td class="paramname">rec</td><td>in: compact physical record on a B-tree leaf page </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5165b7896d4c22d8201e506ee823b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5165b7896d4c22d8201e506ee823b22">&#9670;&nbsp;</a></span>page_zip_parse_compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* page_zip_parse_compress </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a log record of compressing an index page. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>out: uncompressed page </td></tr>
    <tr><td class="paramname">page_zip</td><td>out: compressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec098830929e06efd9d166154b79b214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec098830929e06efd9d166154b79b214">&#9670;&nbsp;</a></span>page_zip_parse_write_blob_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* page_zip_parse_write_blob_ptr </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a log record of writing a BLOB pointer of a record. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: redo log buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: redo log buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: uncompressed page </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9b122ccecd3470b90272ee6413ce1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b122ccecd3470b90272ee6413ce1ca">&#9670;&nbsp;</a></span>page_zip_parse_write_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* page_zip_parse_write_header </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a log record of writing to the header of a page. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: redo log buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: redo log buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: uncompressed page </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c8181f139ad785ace74b3b40d758700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8181f139ad785ace74b3b40d758700">&#9670;&nbsp;</a></span>page_zip_parse_write_node_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* page_zip_parse_write_node_ptr </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a log record of writing the node pointer of a record. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: redo log buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: redo log buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: uncompressed page </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82368a54bc478f459e74faac1c6b1727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82368a54bc478f459e74faac1c6b1727">&#9670;&nbsp;</a></span>page_zip_rec_set_deleted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_rec_set_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the "deleted" flag of a record on a compressed page. The flag must already have been written on the uncompressed page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">rec</td><td>in: record on the uncompressed page </td></tr>
    <tr><td class="paramname">flag</td><td>in: the deleted flag (nonzero=TRUE) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70f1ff6129a0d9784aa45fa54d7d6d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f1ff6129a0d9784aa45fa54d7d6d70">&#9670;&nbsp;</a></span>page_zip_rec_set_owned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_rec_set_owned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the "owned" flag of a record on a compressed page. The n_owned field must already have been written on the uncompressed page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">rec</td><td>in: record on the uncompressed page </td></tr>
    <tr><td class="paramname">flag</td><td>in: the owned flag (nonzero=TRUE) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a863b6023c2351a464413ad6f2ac1468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863b6023c2351a464413ad6f2ac1468c">&#9670;&nbsp;</a></span>page_zip_reorganize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool page_zip_reorganize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reorganize and compress a page. This is a low-level operation for compressed pages, to be used when <a class="el" href="page0zip_8cc.html#ab59142b92980079a77ae603306e1858c">page_zip_compress()</a> fails. On success, a redo log entry MLOG_ZIP_PAGE_COMPRESS will be written. The function <a class="el" href="btr0btr_8cc.html#a7153cd6fec3c5a1fdfc6b85c1beefe5a">btr_page_reorganize()</a> should be preferred whenever possible. IMPORTANT: if <a class="el" href="page0zip_8cc.html#a863b6023c2351a464413ad6f2ac1468c">page_zip_reorganize()</a> is invoked on a leaf page of a non-clustered index, the caller must update the insert buffer free bits in the same mini-transaction in such a way that the modification will be redo-logged. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure; page_zip will be left intact on failure, but page will be overwritten. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: page with compressed page; on the compressed page, in: size; out: data, n_blobs, m_start, m_end, m_nonempty </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the B-tree node </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a949c4203a9504051bc97fd2873484bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949c4203a9504051bc97fd2873484bd1">&#9670;&nbsp;</a></span>page_zip_set_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_set_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure the zlib allocator to use the given memory heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>in/out: zlib stream </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab74b90a5a409cf83281b4765227dd52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74b90a5a409cf83281b4765227dd52d">&#9670;&nbsp;</a></span>page_zip_set_extra_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool page_zip_set_extra_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>info_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the REC_N_NEW_EXTRA_BYTES of each record. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in: compressed page </td></tr>
    <tr><td class="paramname">page</td><td>in/out: uncompressed page </td></tr>
    <tr><td class="paramname">info_bits</td><td>in: REC_INFO_MIN_REC_FLAG or 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28aba759751d57b23b9fd7fda06619c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aba759751d57b23b9fd7fda06619c0">&#9670;&nbsp;</a></span>page_zip_verify_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool page_zip_verify_checksum </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify a compressed page's checksum. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the stored checksum is valid according to the value of innodb_checksum_algorithm </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>in: compressed page </td></tr>
    <tr><td class="paramname">size</td><td>in: size of compressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19d407139b38beac31773b1bfed92383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d407139b38beac31773b1bfed92383">&#9670;&nbsp;</a></span>page_zip_write_blob_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_write_blob_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a BLOB pointer of a record on the leaf page of a clustered index. The information must already have been updated on the uncompressed page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record whose data is being written </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the page </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">n</td><td>in: column index </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle, or NULL if no logging is needed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14b27175a5d817c1cede6b71efe9f428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b27175a5d817c1cede6b71efe9f428">&#9670;&nbsp;</a></span>page_zip_write_header_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_write_header_log </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a log record of writing to the uncompressed header portion of a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>in: data on the uncompressed page </td></tr>
    <tr><td class="paramname">length</td><td>in: length of the data </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d48f129f320c9af2a0bbf1b6ea3681b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d48f129f320c9af2a0bbf1b6ea3681b">&#9670;&nbsp;</a></span>page_zip_write_node_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_write_node_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the node pointer of a record on a non-leaf compressed page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">size</td><td>in: data size of rec </td></tr>
    <tr><td class="paramname">ptr</td><td>in: node pointer </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8346763580134b237f46b41d815751ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8346763580134b237f46b41d815751ca">&#9670;&nbsp;</a></span>page_zip_write_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_write_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>create</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write an entire record on the compressed page. The data must already have been written to the uncompressed page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">rec</td><td>in: record being written </td></tr>
    <tr><td class="paramname">index</td><td>in: the index the record belongs to </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">create</td><td>in: nonzero=insert, zero=update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae45d948cef4d240a1afd6f038babe777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45d948cef4d240a1afd6f038babe777">&#9670;&nbsp;</a></span>page_zip_write_rec_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static byte* page_zip_write_rec_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>trx_id_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a record on the compressed page that contains externally stored columns. The data must already have been written to the uncompressed page. </p><dl class="section return"><dt>Returns</dt><dd>end of modification log </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">page</td><td>in: page containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record being written </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">create</td><td>in: nonzero=insert, zero=update </td></tr>
    <tr><td class="paramname">trx_id_col</td><td>in: position of DB_TRX_ID </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of rec </td></tr>
    <tr><td class="paramname">storage</td><td>in: end of dense page directory </td></tr>
    <tr><td class="paramname">data</td><td>in: end of modification log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27f902e4fdd00ab61f13beb77ebc4800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f902e4fdd00ab61f13beb77ebc4800">&#9670;&nbsp;</a></span>page_zip_write_trx_id_and_roll_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void page_zip_write_trx_id_and_roll_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>trx_id_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the trx_id and roll_ptr of a record on a B-tree leaf node page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">trx_id_col</td><td>in: column number of TRX_ID in rec </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction identifier </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll_ptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abce4590300498ce5675d66b7c6a8d609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce4590300498ce5675d66b7c6a8d609">&#9670;&nbsp;</a></span>page_zip_zalloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* page_zip_zalloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uInt&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uInt&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate memory for zlib. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opaque</td><td>in/out: memory heap </td></tr>
    <tr><td class="paramname">items</td><td>in: number of items to allocate </td></tr>
    <tr><td class="paramname">size</td><td>in: size of an item in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abeb3a28f26f09ddca40650276842bf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb3a28f26f09ddca40650276842bf5a">&#9670;&nbsp;</a></span>infimum_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const byte infimum_data[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        0x69, 0x6e, 0x66, 0x69,</div><div class="line">        0x6d, 0x75, 0x6d, 0x00  </div><div class="line">}</div></div><!-- fragment --><p>Data bytes of an infimum record </p>

</div>
</div>
<a id="a45f6454b70db57b32fbb62e6c708deab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f6454b70db57b32fbb62e6c708deab">&#9670;&nbsp;</a></span>infimum_extra</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const byte infimum_extra[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        0x01,                   </div><div class="line">        0x00, 0x02              </div><div class="line">                        </div><div class="line">}</div></div><!-- fragment --><p>Extra bytes of an infimum record </p>

</div>
</div>
<a id="abe68f834a1051a123fa6dcd5f1858f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe68f834a1051a123fa6dcd5f1858f24">&#9670;&nbsp;</a></span>page_zip_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structpage__zip__stat__t.html">page_zip_stat_t</a> page_zip_stat[<a class="el" href="page0types_8h.html#abafca45baefc76a04e46a3a12e243cc9">PAGE_ZIP_SSIZE_MAX</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Statistics on compression, indexed by <a class="el" href="structpage__zip__des__t.html#a67685e94a6651cb5f3facba15dac1e3e">page_zip_des_t::ssize</a> - 1 </p>

</div>
</div>
<a id="a43e2dda16ec1ab8b2c055164b541d123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e2dda16ec1ab8b2c055164b541d123">&#9670;&nbsp;</a></span>page_zip_stat_per_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="page0types_8h.html#a2a70eec3d796d807a6fd8011490c573f">page_zip_stat_per_index_t</a> page_zip_stat_per_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Statistics on compression, indexed by index-&gt;id </p>

</div>
</div>
<a id="af8d162c7c680b91441b5e75b004b7e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d162c7c680b91441b5e75b004b7e02">&#9670;&nbsp;</a></span>page_zip_stat_per_index_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structib__mutex__t.html">ib_mutex_t</a> page_zip_stat_per_index_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mutex protecting page_zip_stat_per_index </p>

</div>
</div>
<a id="a088094b7e1b7b1a11f59eb92294be3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088094b7e1b7b1a11f59eb92294be3e1">&#9670;&nbsp;</a></span>supremum_extra_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const byte supremum_extra_data[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">                        </div><div class="line">        0x00, 0x0b,             </div><div class="line">        0x00, 0x00,             </div><div class="line">        0x73, 0x75, 0x70, 0x72,</div><div class="line">        0x65, 0x6d, 0x75, 0x6d  </div><div class="line">}</div></div><!-- fragment --><p>Extra bytes and data bytes of a supremum record </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/fil/fil0fil.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_e8020bb067c5bf46e03c97ffbe579728.html">fil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fil0fil.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &lt;<a class="el" href="debug__sync_8h_source.html">debug_sync.h</a>&gt;</code><br />
<code>#include &lt;my_dbug.h&gt;</code><br />
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0file_8h_source.html">os0file.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mach0data_8h_source.html">mach0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0flu_8h_source.html">buf0flu.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0recv_8h_source.html">log0recv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0fsp_8h_source.html">fsp0fsp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0mtr_8h_source.html">mtr0mtr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0log_8h_source.html">mtr0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0sys_8h_source.html">trx0sys.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0sync_8h_source.html">os0sync.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfil__node__t.html">fil_node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfil__space__t.html">fil_space_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfil__system__t.html">fil_system_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_check.html">Check</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfil__iterator__t.html">fil_iterator_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a32c8880b31da52b89328470e4d137c93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a32c8880b31da52b89328470e4d137c93">FIL_NODE_MAGIC_N</a>&#160;&#160;&#160;89389</td></tr>
<tr class="separator:a32c8880b31da52b89328470e4d137c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97767f7a305f12be3e2a360cfcdbf8fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a97767f7a305f12be3e2a360cfcdbf8fc">FIL_SPACE_MAGIC_N</a>&#160;&#160;&#160;89472</td></tr>
<tr class="separator:a97767f7a305f12be3e2a360cfcdbf8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab4fdf47dd5f793a95d0ea32958c9af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aaab4fdf47dd5f793a95d0ea32958c9af">fil_is_user_tablespace_id</a>(<a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>)&#160;&#160;&#160;((<a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>) &gt; <a class="el" href="srv0srv_8cc.html#a21a014089f3b6798290045b969bbb505">srv_undo_tablespaces_open</a>)</td></tr>
<tr class="separator:aaab4fdf47dd5f793a95d0ea32958c9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5193ba3b0717d5db0ee8f3a5049bd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#acf5193ba3b0717d5db0ee8f3a5049bd8">fil_buffering_disabled</a>(<a class="el" href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a>)</td></tr>
<tr class="separator:acf5193ba3b0717d5db0ee8f3a5049bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a61854371bfb59efabf6a63b95674f430"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a61854371bfb59efabf6a63b95674f430">fil_space_belongs_in_lru</a> (const <a class="el" href="structfil__space__t.html">fil_space_t</a> *<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>)</td></tr>
<tr class="separator:a61854371bfb59efabf6a63b95674f430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9bcc5f9f714ef9d439ca8e49f263ea"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a8c9bcc5f9f714ef9d439ca8e49f263ea">fil_node_prepare_for_io</a> (<a class="el" href="structfil__node__t.html">fil_node_t</a> *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>, <a class="el" href="structfil__system__t.html">fil_system_t</a> *system, <a class="el" href="structfil__space__t.html">fil_space_t</a> *<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>)</td></tr>
<tr class="separator:a8c9bcc5f9f714ef9d439ca8e49f263ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30abd8466829d2f311a9b791a13c26ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a30abd8466829d2f311a9b791a13c26ad">fil_node_complete_io</a> (<a class="el" href="structfil__node__t.html">fil_node_t</a> *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>, <a class="el" href="structfil__system__t.html">fil_system_t</a> *system, ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:a30abd8466829d2f311a9b791a13c26ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c2665967c66df9026dd02a78137843"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a68c2665967c66df9026dd02a78137843">fil_space_free</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ibool x_latched)</td></tr>
<tr class="separator:a68c2665967c66df9026dd02a78137843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ea12f88dede7e83bdf7f47febd3be2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a73ea12f88dede7e83bdf7f47febd3be2">fil_read</a> (bool <a class="el" href="ibuf0ibuf_8cc.html#a6265893dd43b2df4e241408f9e736f2e">sync</a>, ulint space_id, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint block_offset, ulint byte_offset, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, void *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, void *message)</td></tr>
<tr class="separator:a73ea12f88dede7e83bdf7f47febd3be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb3925ae6b3fa2868cea7ad5205fe7a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a5fb3925ae6b3fa2868cea7ad5205fe7a">fil_write</a> (bool <a class="el" href="ibuf0ibuf_8cc.html#a6265893dd43b2df4e241408f9e736f2e">sync</a>, ulint space_id, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint block_offset, ulint byte_offset, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, void *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, void *message)</td></tr>
<tr class="separator:a5fb3925ae6b3fa2868cea7ad5205fe7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05245f5807e7705f139809665cbff028"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a05245f5807e7705f139809665cbff028">fil_space_get_by_id</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a05245f5807e7705f139809665cbff028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92aad0f1d64b64c33c8e4db9689183eb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a92aad0f1d64b64c33c8e4db9689183eb">fil_space_get_by_name</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a92aad0f1d64b64c33c8e4db9689183eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8b48a141176a1f720eba4a41ad787e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ib_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a1d8b48a141176a1f720eba4a41ad787e">fil_space_get_version</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a1d8b48a141176a1f720eba4a41ad787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2b6eef6add57c6d75c8d1772401006"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a8a2b6eef6add57c6d75c8d1772401006">fil_space_get_latch</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ulint *<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:a8a2b6eef6add57c6d75c8d1772401006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb31919b213988278ef69c102f7c5c78"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#acb31919b213988278ef69c102f7c5c78">fil_space_get_type</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:acb31919b213988278ef69c102f7c5c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac993498b99dcc9981161a790b7d999f9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ac993498b99dcc9981161a790b7d999f9">fil_space_is_flushed</a> (<a class="el" href="structfil__space__t.html">fil_space_t</a> *<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>)</td></tr>
<tr class="separator:ac993498b99dcc9981161a790b7d999f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dcf2980d5a2cc899c18d5fe2d11265"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a10dcf2980d5a2cc899c18d5fe2d11265">fil_node_create</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ibool is_raw)</td></tr>
<tr class="separator:a10dcf2980d5a2cc899c18d5fe2d11265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88ed35568b0ded52a7a6b1249f38f37"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ad88ed35568b0ded52a7a6b1249f38f37">fil_node_open_file</a> (<a class="el" href="structfil__node__t.html">fil_node_t</a> *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>, <a class="el" href="structfil__system__t.html">fil_system_t</a> *system, <a class="el" href="structfil__space__t.html">fil_space_t</a> *<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>)</td></tr>
<tr class="separator:ad88ed35568b0ded52a7a6b1249f38f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7abe73431e6e669f40658a6565b9fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a2c7abe73431e6e669f40658a6565b9fb">fil_node_close_file</a> (<a class="el" href="structfil__node__t.html">fil_node_t</a> *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>, <a class="el" href="structfil__system__t.html">fil_system_t</a> *system)</td></tr>
<tr class="separator:a2c7abe73431e6e669f40658a6565b9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afdf4e32f4a8aedf3c8abe8b45a6dcf"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a2afdf4e32f4a8aedf3c8abe8b45a6dcf">fil_try_to_close_file_in_LRU</a> (ibool <a class="el" href="structprint__info.html">print_info</a>)</td></tr>
<tr class="separator:a2afdf4e32f4a8aedf3c8abe8b45a6dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baa65a9c9c95cbbfd0735a4da852f3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a1baa65a9c9c95cbbfd0735a4da852f3e">fil_mutex_enter_and_prepare_for_io</a> (ulint space_id)</td></tr>
<tr class="separator:a1baa65a9c9c95cbbfd0735a4da852f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcc72794b2954ec733806e1cd255603"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#acdcc72794b2954ec733806e1cd255603">fil_node_free</a> (<a class="el" href="structfil__node__t.html">fil_node_t</a> *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>, <a class="el" href="structfil__system__t.html">fil_system_t</a> *system, <a class="el" href="structfil__space__t.html">fil_space_t</a> *<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>)</td></tr>
<tr class="separator:acdcc72794b2954ec733806e1cd255603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8579f9c3d0bcffa49d572edbc8f8dc78"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a8579f9c3d0bcffa49d572edbc8f8dc78">fil_space_create</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, ulint purpose)</td></tr>
<tr class="separator:a8579f9c3d0bcffa49d572edbc8f8dc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bca8e593a99c8eead9bc19864ee2a2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ab2bca8e593a99c8eead9bc19864ee2a2">fil_assign_new_space_id</a> (ulint *space_id)</td></tr>
<tr class="separator:ab2bca8e593a99c8eead9bc19864ee2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb387f5155d53506cd2c42fde401d19"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#abeb387f5155d53506cd2c42fde401d19">fil_space_get_space</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:abeb387f5155d53506cd2c42fde401d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225b7a4c10101f39efa0b9b811172445"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a225b7a4c10101f39efa0b9b811172445">fil_space_get_first_path</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a225b7a4c10101f39efa0b9b811172445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad30cf3eec2fd6c3e4e3dbd34e3f8fcf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aad30cf3eec2fd6c3e4e3dbd34e3f8fcf">fil_space_get_size</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:aad30cf3eec2fd6c3e4e3dbd34e3f8fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4ed0e5ded56070991831d36ba28213"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a0b4ed0e5ded56070991831d36ba28213">fil_space_get_flags</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a0b4ed0e5ded56070991831d36ba28213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946871486b5f407a1f4ba064bddd8551"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a946871486b5f407a1f4ba064bddd8551">fil_space_get_zip_size</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a946871486b5f407a1f4ba064bddd8551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519ff40e8bee8e86d771331c911ed77f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a519ff40e8bee8e86d771331c911ed77f">fil_check_adress_in_tablespace</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a519ff40e8bee8e86d771331c911ed77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1176740e17691150bbbd166a07da13a5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a1176740e17691150bbbd166a07da13a5">fil_init</a> (ulint hash_size, ulint max_n_open)</td></tr>
<tr class="separator:a1176740e17691150bbbd166a07da13a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3879af28c90e280336d1943c7d65e07"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aa3879af28c90e280336d1943c7d65e07">fil_open_log_and_system_tablespace_files</a> (void)</td></tr>
<tr class="separator:aa3879af28c90e280336d1943c7d65e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e886ae4bd2457d8b200296c8b949c1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a91e886ae4bd2457d8b200296c8b949c1">fil_close_all_files</a> (void)</td></tr>
<tr class="separator:a91e886ae4bd2457d8b200296c8b949c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fe8af05ceecfd14174ee118fed2d4f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a12fe8af05ceecfd14174ee118fed2d4f">fil_close_log_files</a> (bool free)</td></tr>
<tr class="separator:a12fe8af05ceecfd14174ee118fed2d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa684ec2b3df65dbd5781785e443a4c21"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aa684ec2b3df65dbd5781785e443a4c21">fil_set_max_space_id_if_bigger</a> (ulint max_id)</td></tr>
<tr class="separator:aa684ec2b3df65dbd5781785e443a4c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b124024e55e226be9dd3de4da5e2aa"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a71b124024e55e226be9dd3de4da5e2aa">__attribute__</a> ((warn_unused_result)) <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_write_lsn_and_arch_no_to_file(ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a></td></tr>
<tr class="separator:a71b124024e55e226be9dd3de4da5e2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704a682f713e3e629b6cd0f013c0e665"><td class="memItemLeft" align="right" valign="top">static ulint lsn_t ulint arch_log_no&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a704a682f713e3e629b6cd0f013c0e665">__attribute__</a> ((unused)))</td></tr>
<tr class="separator:a704a682f713e3e629b6cd0f013c0e665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b6ca3b6843a7764ccce4b897f389b5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a04b6ca3b6843a7764ccce4b897f389b5">fil_write_flushed_lsn_to_data_files</a> (lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>, ulint arch_log_no)</td></tr>
<tr class="separator:a04b6ca3b6843a7764ccce4b897f389b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd40331d65268884f95dde9b230f167"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a3cd40331d65268884f95dde9b230f167">fil_read_first_page</a> (<a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> data_file, ibool one_read_already, ulint *<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, ulint *space_id, lsn_t *<a class="el" href="srv0start_8cc.html#a1d546c3fcf2f25749006e0d32da645f4">min_flushed_lsn</a>, lsn_t *<a class="el" href="srv0start_8cc.html#a451b129f36127c7dc27ad05fe897b792">max_flushed_lsn</a>)</td></tr>
<tr class="separator:a3cd40331d65268884f95dde9b230f167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa507b17351caa27faee60e20cba250"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#adfa507b17351caa27faee60e20cba250">fil_inc_pending_ops</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ibool print_err)</td></tr>
<tr class="separator:adfa507b17351caa27faee60e20cba250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8720a7a25993eec7148615034b6dcc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#acf8720a7a25993eec7148615034b6dcc">fil_decr_pending_ops</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:acf8720a7a25993eec7148615034b6dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc3b7648440e7e6298bc6d8074e80d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a63fc3b7648440e7e6298bc6d8074e80d">fil_create_directory_for_tablename</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a63fc3b7648440e7e6298bc6d8074e80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d1f90ff3554ae6ee3743e060c1f01e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a33d1f90ff3554ae6ee3743e060c1f01e">fil_op_write_log</a> (ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, ulint space_id, ulint log_flags, ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *new_name, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a33d1f90ff3554ae6ee3743e060c1f01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26747387fc164754ccb513d23565ba3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aa26747387fc164754ccb513d23565ba3">fil_op_log_parse_or_replay</a> (byte *ptr, byte *end_ptr, ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, ulint space_id, ulint log_flags)</td></tr>
<tr class="separator:aa26747387fc164754ccb513d23565ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada7d21afc2cdd69a53c4c1fa0997aae"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aada7d21afc2cdd69a53c4c1fa0997aae">fil_make_cfg_name</a> (const char *filepath)</td></tr>
<tr class="separator:aada7d21afc2cdd69a53c4c1fa0997aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b86443a27a1e344c45c064c69934f6"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ae2b86443a27a1e344c45c064c69934f6">fil_ibuf_check_pending_ops</a> (<a class="el" href="structfil__space__t.html">fil_space_t</a> *<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint count)</td></tr>
<tr class="separator:ae2b86443a27a1e344c45c064c69934f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10ab1175c4688dd6beddeb814488469"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#af10ab1175c4688dd6beddeb814488469">fil_check_pending_io</a> (<a class="el" href="structfil__space__t.html">fil_space_t</a> *<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="structfil__node__t.html">fil_node_t</a> **<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>, ulint count)</td></tr>
<tr class="separator:af10ab1175c4688dd6beddeb814488469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b1837c097f08281072e4256c90308b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a27b1837c097f08281072e4256c90308b">fil_check_pending_operations</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, <a class="el" href="structfil__space__t.html">fil_space_t</a> **<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, char **path)</td></tr>
<tr class="separator:a27b1837c097f08281072e4256c90308b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47781df16c9f20b3d05fa863d59e6557"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a47781df16c9f20b3d05fa863d59e6557">fil_close_tablespace</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a47781df16c9f20b3d05fa863d59e6557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb979fce49c0bd27d6371cee88b14df1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#acb979fce49c0bd27d6371cee88b14df1">fil_delete_tablespace</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, <a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a> <a class="el" href="buf0lru_8cc.html#a41c956bb7d3a54c280f72c674fa42b0d">buf_remove</a>)</td></tr>
<tr class="separator:acb979fce49c0bd27d6371cee88b14df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3b73168dc3e08f29d228d3f1d3f5da"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#add3b73168dc3e08f29d228d3f1d3f5da">fil_tablespace_is_being_deleted</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:add3b73168dc3e08f29d228d3f1d3f5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de06832778567dbe0ae14728d22af47"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a4de06832778567dbe0ae14728d22af47">fil_discard_tablespace</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a4de06832778567dbe0ae14728d22af47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a06ea6c5efd8e7bed4ddf07e9f71f7"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a94a06ea6c5efd8e7bed4ddf07e9f71f7">fil_rename_tablespace_in_mem</a> (<a class="el" href="structfil__space__t.html">fil_space_t</a> *<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="structfil__node__t.html">fil_node_t</a> *<a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a>, const char *new_name, const char *new_path)</td></tr>
<tr class="separator:a94a06ea6c5efd8e7bed4ddf07e9f71f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361c82b308c23fc7186ae38c55c9513a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a361c82b308c23fc7186ae38c55c9513a">fil_make_ibd_name</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, bool is_full_path)</td></tr>
<tr class="separator:a361c82b308c23fc7186ae38c55c9513a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c08abc73f26d23ecadf1714d8253afd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a3c08abc73f26d23ecadf1714d8253afd">fil_make_isl_name</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a3c08abc73f26d23ecadf1714d8253afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921aabc85334206af22b02b27762efd3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a921aabc85334206af22b02b27762efd3">fil_rename_tablespace</a> (const char *old_name_in, ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, const char *new_name, const char *new_path_in)</td></tr>
<tr class="separator:a921aabc85334206af22b02b27762efd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ce26a3a21ae46c81b30af49e22ef4c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ad3ce26a3a21ae46c81b30af49e22ef4c">fil_create_link_file</a> (const char *tablename, const char *filepath)</td></tr>
<tr class="separator:ad3ce26a3a21ae46c81b30af49e22ef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adf281c2c4b1bb23595a3f18ef61597"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a2adf281c2c4b1bb23595a3f18ef61597">fil_delete_link_file</a> (const char *tablename)</td></tr>
<tr class="separator:a2adf281c2c4b1bb23595a3f18ef61597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b9e2a6418bd07fc29f2b14e32e699a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ad0b9e2a6418bd07fc29f2b14e32e699a">fil_read_link_file</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ad0b9e2a6418bd07fc29f2b14e32e699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5312c685859f9961b0bd7226e99afb0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aa5312c685859f9961b0bd7226e99afb0">fil_open_linked_file</a> (const char *tablename, char **remote_filepath, <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> *remote_file)</td></tr>
<tr class="separator:aa5312c685859f9961b0bd7226e99afb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50407a4a49e6b4ca164d96d311269546"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a50407a4a49e6b4ca164d96d311269546">fil_create_new_single_table_tablespace</a> (ulint space_id, const char *tablename, const char *dir_path, ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, ulint <a class="el" href="ha__innodb_8cc.html#a3ca41e26d8b04a12445282fdce51338a">flags2</a>, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a50407a4a49e6b4ca164d96d311269546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050964df8fae71ea2abb7d2a2fd22f6f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a050964df8fae71ea2abb7d2a2fd22f6f">fil_report_bad_tablespace</a> (const char *filepath, const char *check_msg, ulint found_id, ulint found_flags, ulint expected_id, ulint expected_flags)</td></tr>
<tr class="separator:a050964df8fae71ea2abb7d2a2fd22f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c3703629a96f531192c0c2ae85977d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a97c3703629a96f531192c0c2ae85977d">fil_open_single_table_tablespace</a> (bool validate, bool fix_dict, ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const char *tablename, const char *path_in)</td></tr>
<tr class="separator:a97c3703629a96f531192c0c2ae85977d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba6fef965c5261b055a7a3813b3f5b0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a3ba6fef965c5261b055a7a3813b3f5b0">fil_user_tablespace_find_space_id</a> (<a class="el" href="structfsp__open__info.html">fsp_open_info</a> *fsp)</td></tr>
<tr class="separator:a3ba6fef965c5261b055a7a3813b3f5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067a1660fa770cf70ebacbda30df17ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a067a1660fa770cf70ebacbda30df17ef">fil_user_tablespace_restore_page</a> (<a class="el" href="structfsp__open__info.html">fsp_open_info</a> *fsp, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a067a1660fa770cf70ebacbda30df17ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc234e11550020cb31d9f9c356d6cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a97fc234e11550020cb31d9f9c356d6cd">fil_validate_single_table_tablespace</a> (const char *tablename, <a class="el" href="structfsp__open__info.html">fsp_open_info</a> *fsp)</td></tr>
<tr class="separator:a97fc234e11550020cb31d9f9c356d6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d87fc7382b6b95e25facdb502fddf6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a92d87fc7382b6b95e25facdb502fddf6">fil_load_single_table_tablespace</a> (const char *dbname, const char *filename)</td></tr>
<tr class="separator:a92d87fc7382b6b95e25facdb502fddf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406ddde700c2d397beae4fa8ee73ea7d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a406ddde700c2d397beae4fa8ee73ea7d">fil_file_readdir_next_file</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *<a class="el" href="row0import_8cc.html#a52482fdd3721e7db69dc740aefee8ad4">err</a>, const char *dirname, <a class="el" href="os0file_8h.html#a996944ca087e0aab572f2b5ea990a108">os_file_dir_t</a> dir, <a class="el" href="structos__file__stat__t.html">os_file_stat_t</a> *info)</td></tr>
<tr class="separator:a406ddde700c2d397beae4fa8ee73ea7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0288e7c7e88e282b6247cf2826920f0e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a0288e7c7e88e282b6247cf2826920f0e">fil_load_single_table_tablespaces</a> (void)</td></tr>
<tr class="separator:a0288e7c7e88e282b6247cf2826920f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ba86f6ec9233a99058d40a2ad07e7c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ad4ba86f6ec9233a99058d40a2ad07e7c">fil_tablespace_deleted_or_being_deleted_in_mem</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ib_int64_t version)</td></tr>
<tr class="separator:ad4ba86f6ec9233a99058d40a2ad07e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0533f2301d7ee226d088264de54a5c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a8d0533f2301d7ee226d088264de54a5c">fil_tablespace_exists_in_mem</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a8d0533f2301d7ee226d088264de54a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dbabe9a6c902c0f9b2d71ad2e58733"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ad7dbabe9a6c902c0f9b2d71ad2e58733">fil_report_missing_tablespace</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ulint space_id)</td></tr>
<tr class="separator:ad7dbabe9a6c902c0f9b2d71ad2e58733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519541e228b94b326d4b55edbda664c4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a519541e228b94b326d4b55edbda664c4">fil_space_for_table_exists_in_mem</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ibool mark_space, ibool print_error_if_does_not_exist, bool adjust_space, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, table_id_t table_id)</td></tr>
<tr class="separator:a519541e228b94b326d4b55edbda664c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438cca87418dbe8d3cdda93c455b2d47"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a438cca87418dbe8d3cdda93c455b2d47">fil_get_space_id_for_table</a> (const char *tablename)</td></tr>
<tr class="separator:a438cca87418dbe8d3cdda93c455b2d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f5de18476e82ce28875ce0a00dfca6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a77f5de18476e82ce28875ce0a00dfca6">fil_extend_space_to_desired_size</a> (ulint *actual_size, ulint space_id, ulint size_after_extend)</td></tr>
<tr class="separator:a77f5de18476e82ce28875ce0a00dfca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8b440963bc21f4366c8816f715b4dc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a7b8b440963bc21f4366c8816f715b4dc">fil_space_reserve_free_extents</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ulint n_free_now, ulint n_to_reserve)</td></tr>
<tr class="separator:a7b8b440963bc21f4366c8816f715b4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d88c959e7718f3503c2d1c78a9609c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ab7d88c959e7718f3503c2d1c78a9609c">fil_space_release_free_extents</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ulint n_reserved)</td></tr>
<tr class="separator:ab7d88c959e7718f3503c2d1c78a9609c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b50d51fa8f2a9ff187e439ce7a51011"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a9b50d51fa8f2a9ff187e439ce7a51011">fil_space_get_n_reserved_extents</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:a9b50d51fa8f2a9ff187e439ce7a51011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1a1d76ff9dbd4eae065327338f75d7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a5a1a1d76ff9dbd4eae065327338f75d7">fil_report_invalid_page_access</a> (ulint block_offset, ulint space_id, const char *space_name, ulint byte_offset, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:a5a1a1d76ff9dbd4eae065327338f75d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180c0b9659cc66798c18788498e13cfc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a180c0b9659cc66798c18788498e13cfc">fil_io</a> (ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, bool <a class="el" href="ibuf0ibuf_8cc.html#a6265893dd43b2df4e241408f9e736f2e">sync</a>, ulint space_id, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint block_offset, ulint byte_offset, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, void *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, void *message)</td></tr>
<tr class="separator:a180c0b9659cc66798c18788498e13cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4148e1a9c357e2b89ebfeea82cd9e5bf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a4148e1a9c357e2b89ebfeea82cd9e5bf">fil_aio_wait</a> (ulint segment)</td></tr>
<tr class="separator:a4148e1a9c357e2b89ebfeea82cd9e5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03445089b270f9e96b467ff432315ffc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a03445089b270f9e96b467ff432315ffc">fil_flush</a> (ulint space_id)</td></tr>
<tr class="separator:a03445089b270f9e96b467ff432315ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ea8834059b6eb8027a8a10a17085e3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a88ea8834059b6eb8027a8a10a17085e3">fil_flush_file_spaces</a> (ulint purpose)</td></tr>
<tr class="separator:a88ea8834059b6eb8027a8a10a17085e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3497a89c66230cec29b10ddb830fee7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#af3497a89c66230cec29b10ddb830fee7">fil_validate</a> (void)</td></tr>
<tr class="separator:af3497a89c66230cec29b10ddb830fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4802ee32fc62991424922156482dc039"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a4802ee32fc62991424922156482dc039">fil_addr_is_null</a> (<a class="el" href="structfil__addr__t.html">fil_addr_t</a> addr)</td></tr>
<tr class="separator:a4802ee32fc62991424922156482dc039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91898c43a23d1ba6eb51099774416627"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a91898c43a23d1ba6eb51099774416627">fil_page_get_prev</a> (const byte *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:a91898c43a23d1ba6eb51099774416627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6f96f4f226cd8211da46ab019ff361"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aaa6f96f4f226cd8211da46ab019ff361">fil_page_get_next</a> (const byte *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:aaa6f96f4f226cd8211da46ab019ff361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de7885f1ad647f574384d5ad85a97fe"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a5de7885f1ad647f574384d5ad85a97fe">fil_page_set_type</a> (byte *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:a5de7885f1ad647f574384d5ad85a97fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1f45c3807bbc2f9789cc2d33705353"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#abe1f45c3807bbc2f9789cc2d33705353">fil_page_get_type</a> (const byte *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:abe1f45c3807bbc2f9789cc2d33705353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c79821644673e3bfd5deb31fa86972"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#af3c79821644673e3bfd5deb31fa86972">fil_close</a> (void)</td></tr>
<tr class="separator:af3c79821644673e3bfd5deb31fa86972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43c4f994507ff8c416bc15342811880"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#ad43c4f994507ff8c416bc15342811880">fil_buf_block_init</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, byte *frame)</td></tr>
<tr class="separator:ad43c4f994507ff8c416bc15342811880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af049fe26b0ec422ddbecb86655bbfb8b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#af049fe26b0ec422ddbecb86655bbfb8b">fil_iterate</a> (const <a class="el" href="structfil__iterator__t.html">fil_iterator_t</a> &amp;iter, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="struct_page_callback.html">PageCallback</a> &amp;callback)</td></tr>
<tr class="separator:af049fe26b0ec422ddbecb86655bbfb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1e5aa5cf06cc2655d9bbb4adc5e6c2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a9c1e5aa5cf06cc2655d9bbb4adc5e6c2">fil_tablespace_iterate</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint n_io_buffers, <a class="el" href="struct_page_callback.html">PageCallback</a> &amp;callback)</td></tr>
<tr class="separator:a9c1e5aa5cf06cc2655d9bbb4adc5e6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e761efaee260f83df23820aaeb4e7f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a27e761efaee260f83df23820aaeb4e7f">fil_delete_file</a> (const char *ibd_name)</td></tr>
<tr class="separator:a27e761efaee260f83df23820aaeb4e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409a2f351e78146b8104c4f11e9dde4d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a409a2f351e78146b8104c4f11e9dde4d">fil_get_space_names</a> (space_name_list_t &amp;space_name_list)</td></tr>
<tr class="separator:a409a2f351e78146b8104c4f11e9dde4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f88cbf04b641328dcb080bf578fce6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a87f88cbf04b641328dcb080bf578fce6">fil_mtr_rename_log</a> (ulint old_space_id, const char *old_name, ulint new_space_id, const char *new_name, const char *tmp_name, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a87f88cbf04b641328dcb080bf578fce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0d9ae4bede2e8380526734a6068b04cf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a0d9ae4bede2e8380526734a6068b04cf">fil_path_to_mysql_datadir</a> = &quot;.&quot;</td></tr>
<tr class="separator:a0d9ae4bede2e8380526734a6068b04cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85734a9aa5af93fc873eac43f36e7cdb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a85734a9aa5af93fc873eac43f36e7cdb">fil_n_log_flushes</a> = 0</td></tr>
<tr class="separator:a85734a9aa5af93fc873eac43f36e7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdc1b41ed4a62ffa8e8ba36be0db99d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a9bdc1b41ed4a62ffa8e8ba36be0db99d">fil_n_pending_log_flushes</a> = 0</td></tr>
<tr class="separator:a9bdc1b41ed4a62ffa8e8ba36be0db99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8447fc265d5b768596164e086a5a68"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a2a8447fc265d5b768596164e086a5a68">fil_n_pending_tablespace_flushes</a> = 0</td></tr>
<tr class="separator:a2a8447fc265d5b768596164e086a5a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbaa0ec7b9883dfb795b296c9157b47"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aecbaa0ec7b9883dfb795b296c9157b47">fil_n_file_opened</a> = 0</td></tr>
<tr class="separator:aecbaa0ec7b9883dfb795b296c9157b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363867fc7abfed4c21f79b41c57cb080"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structfil__addr__t.html">fil_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a363867fc7abfed4c21f79b41c57cb080">fil_addr_null</a> = {<a class="el" href="fil0fil_8h.html#aa3cefe750718b6961ad77a77b24de271">FIL_NULL</a>, 0}</td></tr>
<tr class="separator:a363867fc7abfed4c21f79b41c57cb080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c66a0c479191f1eaae15c3d50d712"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structfil__system__t.html">fil_system_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#a7b9c66a0c479191f1eaae15c3d50d712">fil_system</a> = NULL</td></tr>
<tr class="separator:a7b9c66a0c479191f1eaae15c3d50d712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5d57f16a42ff58df937de43c36128e"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#aec5d57f16a42ff58df937de43c36128e">sum_of_sizes</a></td></tr>
<tr class="separator:aec5d57f16a42ff58df937de43c36128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb4cabfb679d4fce6dc3fa7c1ee5094"><td class="memItemLeft" align="right" valign="top">static ulint lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fil0fil_8cc.html#adfb4cabfb679d4fce6dc3fa7c1ee5094">lsn</a></td></tr>
<tr class="separator:adfb4cabfb679d4fce6dc3fa7c1ee5094"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The tablespace memory cache</p>
<p>Created 10/25/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="acf5193ba3b0717d5db0ee8f3a5049bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5193ba3b0717d5db0ee8f3a5049bd8">&#9670;&nbsp;</a></span>fil_buffering_disabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fil_buffering_disabled</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a>)-&gt;purpose == <a class="code" href="fil0fil_8h.html#a353b6ee6e3904ee68b204af0517a1fcd">FIL_TABLESPACE</a> \</div><div class="line">         &amp;&amp; srv_unix_file_flush_method  \</div><div class="line">         == <a class="code" href="srv0srv_8h.html#a15b3bbe041870ee299f7e042b0305e3cacaee0742a2724f8d8d67d7a8974a09e9">SRV_UNIX_O_DIRECT_NO_FSYNC</a>)</div><div class="ttc" id="srv0srv_8h_html_a15b3bbe041870ee299f7e042b0305e3cacaee0742a2724f8d8d67d7a8974a09e9"><div class="ttname"><a href="srv0srv_8h.html#a15b3bbe041870ee299f7e042b0305e3cacaee0742a2724f8d8d67d7a8974a09e9">SRV_UNIX_O_DIRECT_NO_FSYNC</a></div><div class="ttdef"><b>Definition:</b> srv0srv.h:499</div></div>
<div class="ttc" id="fil0fil_8h_html_a353b6ee6e3904ee68b204af0517a1fcd"><div class="ttname"><a href="fil0fil_8h.html#a353b6ee6e3904ee68b204af0517a1fcd">FIL_TABLESPACE</a></div><div class="ttdeci">#define FIL_TABLESPACE</div><div class="ttdef"><b>Definition:</b> fil0fil.h:206</div></div>
<div class="ttc" id="dict0mem_8cc_html_a9ebb0c5278a47b6001b42fdff65f648f"><div class="ttname"><a href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a></div><div class="ttdeci">static unsigned const char const char * s</div><div class="ttdef"><b>Definition:</b> dict0mem.cc:276</div></div>
</div><!-- fragment --><p>Determine if user has explicitly disabled fsync(). </p>

</div>
</div>
<a id="aaab4fdf47dd5f793a95d0ea32958c9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab4fdf47dd5f793a95d0ea32958c9af">&#9670;&nbsp;</a></span>fil_is_user_tablespace_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fil_is_user_tablespace_id</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a></td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>) &gt; <a class="el" href="srv0srv_8cc.html#a21a014089f3b6798290045b969bbb505">srv_undo_tablespaces_open</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if (i) is a user tablespace id or not. </p>

</div>
</div>
<a id="a32c8880b31da52b89328470e4d137c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c8880b31da52b89328470e4d137c93">&#9670;&nbsp;</a></span>FIL_NODE_MAGIC_N</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIL_NODE_MAGIC_N&#160;&#160;&#160;89389</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value of <a class="el" href="structfil__node__t.html#af925b259c3bf9ad7298336af8d31f994">fil_node_t::magic_n</a> </p>

</div>
</div>
<a id="a97767f7a305f12be3e2a360cfcdbf8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97767f7a305f12be3e2a360cfcdbf8fc">&#9670;&nbsp;</a></span>FIL_SPACE_MAGIC_N</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIL_SPACE_MAGIC_N&#160;&#160;&#160;89472</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value of <a class="el" href="structfil__space__t.html#a959fc361ed9df1aaacb7bb9ad766d34e">fil_space_t::magic_n</a> </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a71b124024e55e226be9dd3de4da5e2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b124024e55e226be9dd3de4da5e2aa">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(warn_unused_result)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the flushed lsn and the latest archived log number to the page header of the first page of a data file of the system tablespace (space 0), which is uncompressed.</p>
<p>Checks the consistency of the first data page of a tablespace at database startup. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on success, or if innodb_force_recovery is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an error message string</dd></dl>
<p>&lt; in: data page </p>

</div>
</div>
<a id="a704a682f713e3e629b6cd0f013c0e665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704a682f713e3e629b6cd0f013c0e665">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(unused)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">new</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>&lt; in: archived log number to write</p>
<p>Switch to a different input buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_buffer</td><td>The new input buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4802ee32fc62991424922156482dc039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4802ee32fc62991424922156482dc039">&#9670;&nbsp;</a></span>fil_addr_is_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_addr_is_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__addr__t.html">fil_addr_t</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if file address is undefined. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if undefined </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>in: address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4148e1a9c357e2b89ebfeea82cd9e5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4148e1a9c357e2b89ebfeea82cd9e5bf">&#9670;&nbsp;</a></span>fil_aio_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_aio_wait </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for an aio operation to complete. This function is used to write the handler for completed requests. The aio array of pending requests is divided into segments (see <a class="el" href="os0file_8cc.html">os0file.cc</a> for more info). The thread specifies which segment it wants to wait for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment</td><td>in: the number of the segment in the aio array to wait for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2bca8e593a99c8eead9bc19864ee2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bca8e593a99c8eead9bc19864ee2a2">&#9670;&nbsp;</a></span>fil_assign_new_space_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_assign_new_space_id </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>space_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns a new space id for a new single-table tablespace. This works simply by incrementing the global counter. If 4 billion id's is not enough, we may need to recycle id's. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if assigned, FALSE if not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in/out: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43c4f994507ff8c416bc15342811880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43c4f994507ff8c416bc15342811880">&#9670;&nbsp;</a></span>fil_buf_block_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_buf_block_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a buffer control block when the buf_pool is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to control block </td></tr>
    <tr><td class="paramname">frame</td><td>in: pointer to buffer frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a519ff40e8bee8e86d771331c911ed77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519ff40e8bee8e86d771331c911ed77f">&#9670;&nbsp;</a></span>fil_check_adress_in_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_check_adress_in_tablespace </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the pair space, page_no refers to an existing page in a tablespace file space. The tablespace must be cached in the memory cache. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the address is meaningful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af10ab1175c4688dd6beddeb814488469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10ab1175c4688dd6beddeb814488469">&#9670;&nbsp;</a></span>fil_check_pending_io()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint fil_check_pending_io </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> **&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> for pending IO. </p><dl class="section return"><dt>Returns</dt><dd>0 if no pending else count + 1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in/out: Tablespace to check </td></tr>
    <tr><td class="paramname">node</td><td>out: Node in space list </td></tr>
    <tr><td class="paramname">count</td><td>in: number of attempts so far </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27b1837c097f08281072e4256c90308b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b1837c097f08281072e4256c90308b">&#9670;&nbsp;</a></span>fil_check_pending_operations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_check_pending_operations </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__space__t.html">fil_space_t</a> **&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> pending operations on a tablespace. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error failure. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">space</td><td>out: tablespace instance in memory </td></tr>
    <tr><td class="paramname">path</td><td>out/own: tablespace path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3c79821644673e3bfd5deb31fa86972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c79821644673e3bfd5deb31fa86972">&#9670;&nbsp;</a></span>fil_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the tablespace memory cache. </p>

</div>
</div>
<a id="a91e886ae4bd2457d8b200296c8b949c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e886ae4bd2457d8b200296c8b949c1">&#9670;&nbsp;</a></span>fil_close_all_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_close_all_files </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes all open files. There must not be any pending i/o's or not flushed modifications in the files. </p>

</div>
</div>
<a id="a12fe8af05ceecfd14174ee118fed2d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fe8af05ceecfd14174ee118fed2d4f">&#9670;&nbsp;</a></span>fil_close_log_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_close_log_files </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the redo log files. There must not be any pending i/o's or not flushed modifications in the files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">free</td><td>in: whether to free the memory object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47781df16c9f20b3d05fa863d59e6557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47781df16c9f20b3d05fa863d59e6557">&#9670;&nbsp;</a></span>fil_close_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_close_tablespace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes a single-table tablespace. The tablespace must be cached in the memory cache. Free all pages used by the tablespace. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: Transaction covering the close </td></tr>
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63fc3b7648440e7e6298bc6d8074e80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc3b7648440e7e6298bc6d8074e80d">&#9670;&nbsp;</a></span>fil_create_directory_for_tablename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_create_directory_for_tablename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates the database directory for a table if it does not exist yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: name in the standard 'databasename/tablename' format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3ce26a3a21ae46c81b30af49e22ef4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ce26a3a21ae46c81b30af49e22ef4c">&#9670;&nbsp;</a></span>fil_create_link_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_create_link_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tablename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new InnoDB Symbolic Link (ISL) file. It is always created under the 'datadir' of MySQL. The datadir is the directory of a running mysqld program. We can refer to it by simply using the path '.'. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tablename</td><td>in: tablename </td></tr>
    <tr><td class="paramname">filepath</td><td>in: pathname of tablespace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50407a4a49e6b4ca164d96d311269546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50407a4a49e6b4ca164d96d311269546">&#9670;&nbsp;</a></span>fil_create_new_single_table_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_create_new_single_table_tablespace </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tablename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new single-table tablespace to a database directory of MySQL. Database directories are under the 'datadir' of MySQL. The datadir is the directory of a running mysqld program. We can refer to it by simply the path '.'. Tables created with CREATE TEMPORARY <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> we place in the temp dir of the mysqld server.</p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
    <tr><td class="paramname">tablename</td><td>in: the table name in the usual databasename/tablename format of InnoDB </td></tr>
    <tr><td class="paramname">dir_path</td><td>in: NULL or a dir path </td></tr>
    <tr><td class="paramname">flags</td><td>in: tablespace flags </td></tr>
    <tr><td class="paramname">flags2</td><td>in: table flags2 </td></tr>
    <tr><td class="paramname">size</td><td>in: the initial size of the tablespace file in pages, must be &gt;= FIL_IBD_FILE_INITIAL_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf8720a7a25993eec7148615034b6dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8720a7a25993eec7148615034b6dcc">&#9670;&nbsp;</a></span>fil_decr_pending_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_decr_pending_ops </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrements the count of pending operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27e761efaee260f83df23820aaeb4e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e761efaee260f83df23820aaeb4e7f">&#9670;&nbsp;</a></span>fil_delete_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_delete_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ibd_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete the tablespace file and any related files like .cfg. This should not be called for temporary tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibd_name</td><td>in: filepath of the ibd tablespace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2adf281c2c4b1bb23595a3f18ef61597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adf281c2c4b1bb23595a3f18ef61597">&#9670;&nbsp;</a></span>fil_delete_link_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_delete_link_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tablename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes an InnoDB Symbolic Link (ISL) file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tablename</td><td>in: name of table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb979fce49c0bd27d6371cee88b14df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb979fce49c0bd27d6371cee88b14df1">&#9670;&nbsp;</a></span>fil_delete_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_delete_tablespace </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a>&#160;</td>
          <td class="paramname"><em>buf_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a single-table tablespace. The tablespace must be cached in the memory cache. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">buf_remove</td><td>in: specify the action to take on the tables pages in the buffer pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4de06832778567dbe0ae14728d22af47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de06832778567dbe0ae14728d22af47">&#9670;&nbsp;</a></span>fil_discard_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_discard_tablespace </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Discards a single-table tablespace. The tablespace must be cached in the memory cache. Discarding is like deleting a tablespace, but</p>
<ol type="1">
<li>We do not drop the table from the data dictionary;</li>
<li>We remove all insert buffer entries for the tablespace immediately; in DROP <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> they are only removed gradually in the background;</li>
<li>Free all the pages in use by the tablespace. <dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error </dd></dl>
</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77f5de18476e82ce28875ce0a00dfca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f5de18476e82ce28875ce0a00dfca6">&#9670;&nbsp;</a></span>fil_extend_space_to_desired_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_extend_space_to_desired_size </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>actual_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size_after_extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to extend a data file so that it would accommodate the number of pages given. The tablespace must be cached in the memory cache. If the space is big enough already, does nothing. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actual_size</td><td>out: size of the space after extension; if we ran out of disk space this may be lower than the desired size </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
    <tr><td class="paramname">size_after_extend</td><td>in: desired size in pages after the extension; if the current space size is bigger than this already, the function does nothing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a406ddde700c2d397beae4fa8ee73ea7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406ddde700c2d397beae4fa8ee73ea7d">&#9670;&nbsp;</a></span>fil_file_readdir_next_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int fil_file_readdir_next_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a996944ca087e0aab572f2b5ea990a108">os_file_dir_t</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structos__file__stat__t.html">os_file_stat_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A fault-tolerant function that tries to read the next file name in the directory. We retry 100 times if <a class="el" href="os0file_8h.html#a5c4c24bb3f7cd4ab3ba2d999211e73ab">os_file_readdir_next_file()</a> returns -1. The idea is to read as much good data as we can and jump over bad data. </p><dl class="section return"><dt>Returns</dt><dd>0 if ok, -1 if error even after the retries, 1 if at the end of the directory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>out: this is set to DB_ERROR if an error was encountered, otherwise not changed </td></tr>
    <tr><td class="paramname">dirname</td><td>in: directory name or path </td></tr>
    <tr><td class="paramname">dir</td><td>in: directory stream </td></tr>
    <tr><td class="paramname">info</td><td>in/out: buffer where the info is returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03445089b270f9e96b467ff432315ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03445089b270f9e96b467ff432315ffc">&#9670;&nbsp;</a></span>fil_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_flush </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes to disk possible writes cached by the OS. If the space does not exist or is being dropped, does not do anything. </p>
<p>&lt; prevent dropping of the space while we are flushing </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: file space id (this can be a group of log files or a tablespace of the database) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ea8834059b6eb8027a8a10a17085e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ea8834059b6eb8027a8a10a17085e3">&#9670;&nbsp;</a></span>fil_flush_file_spaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_flush_file_spaces </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>purpose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes to disk the writes in file spaces of the given type possibly cached by the OS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">purpose</td><td>in: FIL_TABLESPACE, FIL_LOG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a438cca87418dbe8d3cdda93c455b2d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438cca87418dbe8d3cdda93c455b2d47">&#9670;&nbsp;</a></span>fil_get_space_id_for_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_get_space_id_for_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tablename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a single-table tablespace for a given table name exists in the tablespace memory cache. </p><dl class="section return"><dt>Returns</dt><dd>space id, ULINT_UNDEFINED if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tablename</td><td>in: table name in the standard 'databasename/tablename' format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409a2f351e78146b8104c4f11e9dde4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409a2f351e78146b8104c4f11e9dde4d">&#9670;&nbsp;</a></span>fil_get_space_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_get_space_names </td>
          <td>(</td>
          <td class="paramtype">space_name_list_t &amp;&#160;</td>
          <td class="paramname"><em>space_name_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over all the spaces in the space list and fetch the tablespace names. It will return a copy of the name that must be freed by the caller using: delete[]. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_name_list</td><td>in/out: <a class="el" href="class_list.html">List</a> to append to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2b86443a27a1e344c45c064c69934f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b86443a27a1e344c45c064c69934f6">&#9670;&nbsp;</a></span>fil_ibuf_check_pending_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint fil_ibuf_check_pending_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> for change buffer merges. </p><dl class="section return"><dt>Returns</dt><dd>0 if no merges else count + 1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in/out: Tablespace to check </td></tr>
    <tr><td class="paramname">count</td><td>in: number of attempts so far </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfa507b17351caa27faee60e20cba250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa507b17351caa27faee60e20cba250">&#9670;&nbsp;</a></span>fil_inc_pending_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_inc_pending_ops </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>print_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments the count of pending operation, if space is not being deleted. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if being deleted, and operation should be skipped </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">print_err</td><td>in: need to print error or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1176740e17691150bbbd166a07da13a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1176740e17691150bbbd166a07da13a5">&#9670;&nbsp;</a></span>fil_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hash_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_n_open</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the tablespace memory cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_size</td><td>in: hash table size </td></tr>
    <tr><td class="paramname">max_n_open</td><td>in: max number of open files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a180c0b9659cc66798c18788498e13cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180c0b9659cc66798c18788498e13cfc">&#9670;&nbsp;</a></span>fil_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_io </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>block_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads or writes data. This operation is asynchronous (aio). </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, or DB_TABLESPACE_DELETED if we are trying to do i/o on a tablespace which does not exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: OS_FILE_READ or OS_FILE_WRITE, ORed to OS_FILE_LOG, if a log i/o and ORed to OS_AIO_SIMULATED_WAKE_LATER if simulated aio and we want to post a batch of i/os; NOTE that a simulated batch may introduce hidden chances of deadlocks, because i/os are not actually handled until all have been posted: use with great caution! </td></tr>
    <tr><td class="paramname">sync</td><td>in: true if synchronous aio is desired </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes; 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">block_offset</td><td>in: offset in number of blocks </td></tr>
    <tr><td class="paramname">byte_offset</td><td>in: remainder of offset in bytes; in aio this must be divisible by the OS block size </td></tr>
    <tr><td class="paramname">len</td><td>in: how many bytes to read or write; this must not cross a file boundary; in aio this must be a block size multiple </td></tr>
    <tr><td class="paramname">buf</td><td>in/out: buffer where to store read data or from where to write; in aio this must be appropriately aligned </td></tr>
    <tr><td class="paramname">message</td><td>in: message for aio handler if non-sync aio used, else ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af049fe26b0ec422ddbecb86655bbfb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af049fe26b0ec422ddbecb86655bbfb8b">&#9670;&nbsp;</a></span>fil_iterate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_iterate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfil__iterator__t.html">fil_iterator_t</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_page_callback.html">PageCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: This can be made parallel trivially by chunking up the file and creating a callback per thread. . Main benefit will be to use multiple CPUs for checksums and compressed tables. We have to do compressed tables block by block right now. Secondly we need to decompress/compress and copy too much of data. These are CPU intensive.</p>
<p>Iterate over all the pages in the tablespace. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>- Tablespace iterator </td></tr>
    <tr><td class="paramname">block</td><td>- block to use for IO </td></tr>
    <tr><td class="paramname">callback</td><td>- Callback to inspect and update page contents </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>or error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92d87fc7382b6b95e25facdb502fddf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d87fc7382b6b95e25facdb502fddf6">&#9670;&nbsp;</a></span>fil_load_single_table_tablespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_load_single_table_tablespace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens an .ibd file and adds the associated single-table tablespace to the InnoDB <a class="el" href="fil0fil_8cc.html">fil0fil.cc</a> data structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbname</td><td>in: database name </td></tr>
    <tr><td class="paramname">filename</td><td>in: file name (not a path), including the .ibd or .isl extension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0288e7c7e88e282b6247cf2826920f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0288e7c7e88e282b6247cf2826920f0e">&#9670;&nbsp;</a></span>fil_load_single_table_tablespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_load_single_table_tablespaces </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>At the server startup, if we need crash recovery, scans the database directories under the MySQL datadir, looking for .ibd files. Those files are single-table tablespaces. We need to know the space id in each of them so that we know into which file we should look to check the contents of a page stored in the doublewrite buffer, also to know where to apply log records where the space id is != 0. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error number </dd></dl>

</div>
</div>
<a id="aada7d21afc2cdd69a53c4c1fa0997aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada7d21afc2cdd69a53c4c1fa0997aae">&#9670;&nbsp;</a></span>fil_make_cfg_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* fil_make_cfg_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a file name for the EXPORT/IMPORT config file name. The string must be freed by caller with <a class="el" href="mem0mem_8h.html#a4cdeda261ea5f6db299898f33e6bbdbf">mem_free()</a>. </p><dl class="section return"><dt>Returns</dt><dd>own: file name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>in: .ibd file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a361c82b308c23fc7186ae38c55c9513a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361c82b308c23fc7186ae38c55c9513a">&#9670;&nbsp;</a></span>fil_make_ibd_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* fil_make_ibd_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_full_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a file name for a single-table tablespace. The string must be freed by caller with <a class="el" href="mem0mem_8h.html#a4cdeda261ea5f6db299898f33e6bbdbf">mem_free()</a>. </p><dl class="section return"><dt>Returns</dt><dd>own: file name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name or a dir path </td></tr>
    <tr><td class="paramname">is_full_path</td><td>in: TRUE if it is a dir path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c08abc73f26d23ecadf1714d8253afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c08abc73f26d23ecadf1714d8253afd">&#9670;&nbsp;</a></span>fil_make_isl_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* fil_make_isl_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a file name for a tablespace ISL file (InnoDB Symbolic Link). The string must be freed by caller with <a class="el" href="mem0mem_8h.html#a4cdeda261ea5f6db299898f33e6bbdbf">mem_free()</a>. </p><dl class="section return"><dt>Returns</dt><dd>own: file name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87f88cbf04b641328dcb080bf578fce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f88cbf04b641328dcb080bf578fce6">&#9670;&nbsp;</a></span>fil_mtr_rename_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_mtr_rename_log </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>old_space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>new_space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tmp_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate redo logs for swapping two .ibd files </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_space_id</td><td>in: tablespace id of the old table. </td></tr>
    <tr><td class="paramname">old_name</td><td>in: old table name </td></tr>
    <tr><td class="paramname">new_space_id</td><td>in: tablespace id of the new table </td></tr>
    <tr><td class="paramname">new_name</td><td>in: new table name </td></tr>
    <tr><td class="paramname">tmp_name</td><td>in: temp table name used while swapping </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1baa65a9c9c95cbbfd0735a4da852f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1baa65a9c9c95cbbfd0735a4da852f3e">&#9670;&nbsp;</a></span>fil_mutex_enter_and_prepare_for_io()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_mutex_enter_and_prepare_for_io </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reserves the fil_system mutex and tries to make sure we can open at least one file while holding it. This should be called before calling <a class="el" href="fil0fil_8cc.html#a8c9bcc5f9f714ef9d439ca8e49f263ea">fil_node_prepare_for_io()</a>, because that function may need to open a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c7abe73431e6e669f40658a6565b9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7abe73431e6e669f40658a6565b9fb">&#9670;&nbsp;</a></span>fil_node_close_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_node_close_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__system__t.html">fil_system_t</a> *&#160;</td>
          <td class="paramname"><em>system</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: file node </td></tr>
    <tr><td class="paramname">system</td><td>in: tablespace memory cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30abd8466829d2f311a9b791a13c26ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30abd8466829d2f311a9b791a13c26ad">&#9670;&nbsp;</a></span>fil_node_complete_io()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_node_complete_io </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__system__t.html">fil_system_t</a> *&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the data structures when an i/o operation finishes. Updates the pending i/o's field in the node appropriately. in: OS_FILE_WRITE or OS_FILE_READ; marks the node as modified if type == OS_FILE_WRITE</p>
<p>Updates the data structures when an i/o operation finishes. Updates the pending i/o's field in the node appropriately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: file node </td></tr>
    <tr><td class="paramname">system</td><td>in: tablespace memory cache </td></tr>
    <tr><td class="paramname">type</td><td>in: OS_FILE_WRITE or OS_FILE_READ; marks the node as modified if type == OS_FILE_WRITE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10dcf2980d5a2cc899c18d5fe2d11265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dcf2980d5a2cc899c18d5fe2d11265">&#9670;&nbsp;</a></span>fil_node_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* fil_node_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>is_raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends a new file to the chain of files of a space. File must be closed. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the file name, or NULL on error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: file name (file must be closed) </td></tr>
    <tr><td class="paramname">size</td><td>in: file size in database blocks, rounded downwards to an integer </td></tr>
    <tr><td class="paramname">id</td><td>in: space id where to append </td></tr>
    <tr><td class="paramname">is_raw</td><td>in: TRUE if a raw device or a raw disk partition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdcc72794b2954ec733806e1cd255603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdcc72794b2954ec733806e1cd255603">&#9670;&nbsp;</a></span>fil_node_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_node_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__system__t.html">fil_system_t</a> *&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a file node object from a tablespace memory cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in, own: file node </td></tr>
    <tr><td class="paramname">system</td><td>in: tablespace memory cache </td></tr>
    <tr><td class="paramname">space</td><td>in: space where the file node is chained </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad88ed35568b0ded52a7a6b1249f38f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88ed35568b0ded52a7a6b1249f38f37">&#9670;&nbsp;</a></span>fil_node_open_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fil_node_open_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__system__t.html">fil_system_t</a> *&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens a file of a node of a tablespace. The caller must own the fil_system mutex. </p><dl class="section return"><dt>Returns</dt><dd>false if the file can't be opened, otherwise true </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: file node </td></tr>
    <tr><td class="paramname">system</td><td>in: tablespace memory cache </td></tr>
    <tr><td class="paramname">space</td><td>in: space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c9bcc5f9f714ef9d439ca8e49f263ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9bcc5f9f714ef9d439ca8e49f263ea">&#9670;&nbsp;</a></span>fil_node_prepare_for_io()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fil_node_prepare_for_io </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__system__t.html">fil_system_t</a> *&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NOTE: you must call <a class="el" href="fil0fil_8cc.html#a1baa65a9c9c95cbbfd0735a4da852f3e">fil_mutex_enter_and_prepare_for_io()</a> first!</p>
<p>Prepares a file node for i/o. Opens the file if it is closed. Updates the pending i/o's field in the node and the system appropriately. Takes the node off the LRU list if it is in the LRU list. The caller must hold the fil_sys mutex. </p><dl class="section return"><dt>Returns</dt><dd>false if the file can't be opened, otherwise true in: space</dd></dl>
<p>NOTE: you must call <a class="el" href="fil0fil_8cc.html#a1baa65a9c9c95cbbfd0735a4da852f3e">fil_mutex_enter_and_prepare_for_io()</a> first!</p>
<p>Prepares a file node for i/o. Opens the file if it is closed. Updates the pending i/o's field in the node and the system appropriately. Takes the node off the LRU list if it is in the LRU list. The caller must hold the fil_sys mutex. </p><dl class="section return"><dt>Returns</dt><dd>false if the file can't be opened, otherwise true </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: file node </td></tr>
    <tr><td class="paramname">system</td><td>in: tablespace memory cache </td></tr>
    <tr><td class="paramname">space</td><td>in: space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa26747387fc164754ccb513d23565ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26747387fc164754ccb513d23565ba3">&#9670;&nbsp;</a></span>fil_op_log_parse_or_replay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* fil_op_log_parse_or_replay </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>log_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the body of a log record written about an .ibd file operation. That is, the log record part after the standard (type, space id, page no) header of the log record.</p>
<p>If desired, also replays the delete or rename operation if the .ibd file exists and the space id in it matches. Replays the create operation if a file at that path does not exist yet. If the database directory for the file to be created does not exist, then we create the directory, too.</p>
<p>Note that mysqlbackup &ndash;apply-log sets fil_path_to_mysql_datadir to point to the datadir that we should use in replaying the file operations.</p>
<p>InnoDB recovery does not replay these fully since it always sets the space id to zero. But mysqlbackup does replay them. TODO: If remote tablespaces are used, mysqlbackup will only create tables in the default directory since MLOG_FILE_CREATE and MLOG_FILE_CREATE2 only know the tablename, not the path.</p>
<dl class="section return"><dt>Returns</dt><dd>end of log record, or NULL if the record was not completely contained between ptr and end_ptr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer containing the log record body, or an initial segment of it, if the record does not fir completely between ptr and end_ptr </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">type</td><td>in: the type of this log record </td></tr>
    <tr><td class="paramname">space_id</td><td>in: the space id of the tablespace in question, or 0 if the log record should only be parsed but not replayed </td></tr>
    <tr><td class="paramname">log_flags</td><td>in: redo log flags (stored in the page number parameter) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33d1f90ff3554ae6ee3743e060c1f01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d1f90ff3554ae6ee3743e060c1f01e">&#9670;&nbsp;</a></span>fil_op_write_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_op_write_log </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>log_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes a log record about an .ibd file create/rename/delete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: MLOG_FILE_CREATE, MLOG_FILE_CREATE2, MLOG_FILE_DELETE, or MLOG_FILE_RENAME </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
    <tr><td class="paramname">log_flags</td><td>in: redo log flags (stored in the page number field) </td></tr>
    <tr><td class="paramname">flags</td><td>in: compressed page size and file format if type==MLOG_FILE_CREATE2, or 0 </td></tr>
    <tr><td class="paramname">name</td><td>in: table name in the familiar 'databasename/tablename' format, or the file path in the case of MLOG_FILE_DELETE </td></tr>
    <tr><td class="paramname">new_name</td><td>in: if type is MLOG_FILE_RENAME, the new table name in the 'databasename/tablename' format </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5312c685859f9961b0bd7226e99afb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5312c685859f9961b0bd7226e99afb0">&#9670;&nbsp;</a></span>fil_open_linked_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_open_linked_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tablename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>remote_filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> *&#160;</td>
          <td class="paramname"><em>remote_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a handle to the file linked to in an InnoDB Symbolic Link file. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if remote linked tablespace file is found and opened. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tablename</td><td>in: database/tablename </td></tr>
    <tr><td class="paramname">remote_filepath</td><td>out: remote filepath </td></tr>
    <tr><td class="paramname">remote_file</td><td>out: remote file handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3879af28c90e280336d1943c7d65e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3879af28c90e280336d1943c7d65e07">&#9670;&nbsp;</a></span>fil_open_log_and_system_tablespace_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_open_log_and_system_tablespace_files </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens all log files and system tablespace data files. They stay open until the database server shutdown. This should be called at a server startup after the space objects for the log and the system tablespace have been created. The purpose of this operation is to make sure we never run out of file descriptors if we need to read from the insert buffer or to write to the log. </p>

</div>
</div>
<a id="a97c3703629a96f531192c0c2ae85977d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c3703629a96f531192c0c2ae85977d">&#9670;&nbsp;</a></span>fil_open_single_table_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_open_single_table_tablespace </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fix_dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tablename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to open a single-table tablespace and optionally checks that the space id in it is correct. If this does not succeed, print an error message to the .err log. This function is used to open a tablespace when we start mysqld after the dictionary has been booted, and also in IMPORT TABLESPACE.</p>
<p>NOTE that we assume this operation is used either at the database startup or under the protection of the dictionary mutex, so that two users cannot race here. This operation does not leave the file associated with the tablespace open, but closes it after we have looked at the space id in it.</p>
<p>If the validate boolean is set, we read the first page of the file and check that the space id in the file is what we expect. We assume that this function runs much faster if no check is made, since accessing the file inode probably is much faster (the OS caches them) than accessing the first page of the file. This boolean may be initially FALSE, but if a remote tablespace is found it will be changed to true.</p>
<p>If the fix_dict boolean is set, then it is safe to use an internal SQL statement to update the dictionary tables if they are incorrect.</p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validate</td><td>in: Do we validate tablespace? </td></tr>
    <tr><td class="paramname">fix_dict</td><td>in: Can we fix the dictionary? </td></tr>
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">flags</td><td>in: tablespace flags </td></tr>
    <tr><td class="paramname">tablename</td><td>in: table name in the databasename/tablename format </td></tr>
    <tr><td class="paramname">path_in</td><td>in: tablespace filepath </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa6f96f4f226cd8211da46ab019ff361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6f96f4f226cd8211da46ab019ff361">&#9670;&nbsp;</a></span>fil_page_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_page_get_next </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the successor of a file page. </p><dl class="section return"><dt>Returns</dt><dd>FIL_PAGE_NEXT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91898c43a23d1ba6eb51099774416627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91898c43a23d1ba6eb51099774416627">&#9670;&nbsp;</a></span>fil_page_get_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_page_get_prev </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the predecessor of a file page. </p><dl class="section return"><dt>Returns</dt><dd>FIL_PAGE_PREV </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe1f45c3807bbc2f9789cc2d33705353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1f45c3807bbc2f9789cc2d33705353">&#9670;&nbsp;</a></span>fil_page_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_page_get_type </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the file page type. </p><dl class="section return"><dt>Returns</dt><dd>type; NOTE that if the type has not been written to page, the return value not defined </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5de7885f1ad647f574384d5ad85a97fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de7885f1ad647f574384d5ad85a97fe">&#9670;&nbsp;</a></span>fil_page_set_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_page_set_type </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the file page type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in/out: file page </td></tr>
    <tr><td class="paramname">type</td><td>in: type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ea12f88dede7e83bdf7f47febd3be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ea12f88dede7e83bdf7f47febd3be2">&#9670;&nbsp;</a></span>fil_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_read </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>block_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads data from a space to a buffer. Remember that the possible incomplete blocks at the end of file are ignored: they are not taken into account when calculating the byte offset within a space. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, or DB_TABLESPACE_DELETED if we are trying to do i/o on a tablespace which does not exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>in: true if synchronous aio is desired </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes; 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">block_offset</td><td>in: offset in number of blocks </td></tr>
    <tr><td class="paramname">byte_offset</td><td>in: remainder of offset in bytes; in aio this must be divisible by the OS block size </td></tr>
    <tr><td class="paramname">len</td><td>in: how many bytes to read; this must not cross a file boundary; in aio this must be a block size multiple </td></tr>
    <tr><td class="paramname">buf</td><td>in/out: buffer where to store data read; in aio this must be appropriately aligned </td></tr>
    <tr><td class="paramname">message</td><td>in: message for aio handler if non-sync aio used, else ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cd40331d65268884f95dde9b230f167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd40331d65268884f95dde9b230f167">&#9670;&nbsp;</a></span>fil_read_first_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* fil_read_first_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>data_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>one_read_already</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t *&#160;</td>
          <td class="paramname"><em>min_flushed_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t *&#160;</td>
          <td class="paramname"><em>max_flushed_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the flushed lsn, arch no, space_id and tablespace flag fields from the first page of a data file at database startup. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on success, or if innodb_force_recovery is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an error message string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_file</td><td>in: open data file </td></tr>
    <tr><td class="paramname">one_read_already</td><td>in: TRUE if min and max parameters below already contain sensible data </td></tr>
    <tr><td class="paramname">flags</td><td>out: tablespace flags </td></tr>
    <tr><td class="paramname">space_id</td><td>out: tablespace ID </td></tr>
    <tr><td class="paramname">min_flushed_lsn</td><td>out: min of flushed lsn values in data files </td></tr>
    <tr><td class="paramname">max_flushed_lsn</td><td>out: max of flushed lsn values in data files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0b9e2a6418bd07fc29f2b14e32e699a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b9e2a6418bd07fc29f2b14e32e699a">&#9670;&nbsp;</a></span>fil_read_link_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* fil_read_link_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an InnoDB Symbolic Link (ISL) file. It is always created under the 'datadir' of MySQL. The name is of the form {databasename}/{tablename}. and the isl file is expected to be in a '{databasename}' directory called '{tablename}.isl'. The caller must free the memory of the null-terminated path returned if it is not null. </p><dl class="section return"><dt>Returns</dt><dd>own: filepath found in link file, NULL if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: tablespace name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a921aabc85334206af22b02b27762efd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921aabc85334206af22b02b27762efd3">&#9670;&nbsp;</a></span>fil_rename_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_rename_tablespace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>old_name_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_path_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renames a single-table tablespace. The tablespace must be cached in the tablespace memory cache. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_name_in</td><td>in: old table name in the standard databasename/tablename format of InnoDB, or NULL if we do the rename based on the space id only </td></tr>
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">new_name</td><td>in: new table name in the standard databasename/tablename format of InnoDB </td></tr>
    <tr><td class="paramname">new_path_in</td><td>in: new full datafile path if the tablespace is remotely located, or NULL if it is located in the normal data directory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94a06ea6c5efd8e7bed4ddf07e9f71f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a06ea6c5efd8e7bed4ddf07e9f71f7">&#9670;&nbsp;</a></span>fil_rename_tablespace_in_mem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fil_rename_tablespace_in_mem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Renames the memory cache structures of a single-table tablespace. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: tablespace memory object </td></tr>
    <tr><td class="paramname">node</td><td>in: file node of that tablespace </td></tr>
    <tr><td class="paramname">new_name</td><td>in: new name </td></tr>
    <tr><td class="paramname">new_path</td><td>in: new file path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a050964df8fae71ea2abb7d2a2fd22f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050964df8fae71ea2abb7d2a2fd22f6f">&#9670;&nbsp;</a></span>fil_report_bad_tablespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_report_bad_tablespace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>check_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>found_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>found_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>expected_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>expected_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Report information about a bad tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>in: filepath </td></tr>
    <tr><td class="paramname">check_msg</td><td>in: fil_check_first_page() </td></tr>
    <tr><td class="paramname">found_id</td><td>in: found space ID </td></tr>
    <tr><td class="paramname">found_flags</td><td>in: found flags </td></tr>
    <tr><td class="paramname">expected_id</td><td>in: expected space id </td></tr>
    <tr><td class="paramname">expected_flags</td><td>in: expected flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a1a1d76ff9dbd4eae065327338f75d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1a1d76ff9dbd4eae065327338f75d7">&#9670;&nbsp;</a></span>fil_report_invalid_page_access()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_report_invalid_page_access </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>block_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>space_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Report information about an invalid page access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_offset</td><td>in: block offset </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
    <tr><td class="paramname">space_name</td><td>in: space name </td></tr>
    <tr><td class="paramname">byte_offset</td><td>in: byte offset </td></tr>
    <tr><td class="paramname">len</td><td>in: I/O length </td></tr>
    <tr><td class="paramname">type</td><td>in: I/O type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7dbabe9a6c902c0f9b2d71ad2e58733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7dbabe9a6c902c0f9b2d71ad2e58733">&#9670;&nbsp;</a></span>fil_report_missing_tablespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_report_missing_tablespace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Report that a tablespace for a table was not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name </td></tr>
    <tr><td class="paramname">space_id</td><td>in: table's space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa684ec2b3df65dbd5781785e443a4c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa684ec2b3df65dbd5781785e443a4c21">&#9670;&nbsp;</a></span>fil_set_max_space_id_if_bigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_set_max_space_id_if_bigger </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the max tablespace id counter if the given number is bigger than the previous value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_id</td><td>in: maximum known id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61854371bfb59efabf6a63b95674f430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61854371bfb59efabf6a63b95674f430">&#9670;&nbsp;</a></span>fil_space_belongs_in_lru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool fil_space_belongs_in_lru </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a file node belongs to the least-recently-used list. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the file belongs to fil_system-&gt;LRU mutex. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: file space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8579f9c3d0bcffa49d572edbc8f8dc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8579f9c3d0bcffa49d572edbc8f8dc78">&#9670;&nbsp;</a></span>fil_space_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_space_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>purpose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a space memory object and puts it to the 'fil system' hash table. If there is an error, prints an error message to the .err log. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: space name </td></tr>
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">flags</td><td>in: tablespace flags </td></tr>
    <tr><td class="paramname">purpose</td><td>in: FIL_TABLESPACE, or FIL_LOG if log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a519541e228b94b326d4b55edbda664c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519541e228b94b326d4b55edbda664c4">&#9670;&nbsp;</a></span>fil_space_for_table_exists_in_mem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_space_for_table_exists_in_mem </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>mark_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>print_error_if_does_not_exist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjust_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_id_t&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if a matching tablespace exists in the InnoDB tablespace memory cache. Note that if we have not done a crash recovery at the database startup, there may be many tablespaces which are not yet in the memory cache. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if a matching tablespace exists in the memory cache </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">name</td><td>in: table name used in <a class="el" href="fil0fil_8cc.html#a8579f9c3d0bcffa49d572edbc8f8dc78">fil_space_create()</a>. Either the standard 'dbname/tablename' format or table-&gt;dir_path_of_temp_table </td></tr>
    <tr><td class="paramname">mark_space</td><td>in: in crash recovery, at database startup we mark all spaces which have an associated table in the InnoDB data dictionary, so that we can print a warning about orphaned tablespaces </td></tr>
    <tr><td class="paramname">print_error_if_does_not_exist</td><td>in: print detailed error information to the .err log if a matching tablespace is not found from memory </td></tr>
    <tr><td class="paramname">adjust_space</td><td>in: whether to adjust space id when find table space mismatch </td></tr>
    <tr><td class="paramname">heap</td><td>in: heap memory </td></tr>
    <tr><td class="paramname">table_id</td><td>in: table id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68c2665967c66df9026dd02a78137843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c2665967c66df9026dd02a78137843">&#9670;&nbsp;</a></span>fil_space_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fil_space_free </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>x_latched</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a space object from the tablespace memory cache. Closes the files in the chain but does not delete them. There must not be any pending i/o's or flushes on the files. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success</dd></dl>
<p>Frees a space object from the tablespace memory cache. Closes the files in the chain but does not delete them. There must not be any pending i/o's or flushes on the files. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>

</div>
</div>
<a id="a05245f5807e7705f139809665cbff028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05245f5807e7705f139809665cbff028">&#9670;&nbsp;</a></span>fil_space_get_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structfil__space__t.html">fil_space_t</a>* fil_space_get_by_id </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the table space by a given id, NULL if not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92aad0f1d64b64c33c8e4db9689183eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92aad0f1d64b64c33c8e4db9689183eb">&#9670;&nbsp;</a></span>fil_space_get_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structfil__space__t.html">fil_space_t</a>* fil_space_get_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the table space by a given name, NULL if not found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: space name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a225b7a4c10101f39efa0b9b811172445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225b7a4c10101f39efa0b9b811172445">&#9670;&nbsp;</a></span>fil_space_get_first_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* fil_space_get_first_path </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the path from the first <a class="el" href="structfil__node__t.html">fil_node_t</a> found for the space ID sent. The caller is responsible for freeing the memory allocated here for the value returned. </p><dl class="section return"><dt>Returns</dt><dd>own: A copy of fil_node_t::path, NULL if space ID is zero or not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b4ed0e5ded56070991831d36ba28213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4ed0e5ded56070991831d36ba28213">&#9670;&nbsp;</a></span>fil_space_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_space_get_flags </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the flags of the space. The tablespace must be cached in the memory cache. </p><dl class="section return"><dt>Returns</dt><dd>flags, ULINT_UNDEFINED if space not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a2b6eef6add57c6d75c8d1772401006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2b6eef6add57c6d75c8d1772401006">&#9670;&nbsp;</a></span>fil_space_get_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structrw__lock__t.html">rw_lock_t</a>* fil_space_get_latch </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the latch of a file space. </p><dl class="section return"><dt>Returns</dt><dd>latch protecting storage allocation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">flags</td><td>out: tablespace flags </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b50d51fa8f2a9ff187e439ce7a51011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b50d51fa8f2a9ff187e439ce7a51011">&#9670;&nbsp;</a></span>fil_space_get_n_reserved_extents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_space_get_n_reserved_extents </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of reserved extents. If the database is silent, this number should be zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad30cf3eec2fd6c3e4e3dbd34e3f8fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad30cf3eec2fd6c3e4e3dbd34e3f8fcf">&#9670;&nbsp;</a></span>fil_space_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_space_get_size </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the space in pages. The tablespace must be cached in the memory cache. </p><dl class="section return"><dt>Returns</dt><dd>space size, 0 if space not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abeb387f5155d53506cd2c42fde401d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb387f5155d53506cd2c42fde401d19">&#9670;&nbsp;</a></span>fil_space_get_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structfil__space__t.html">fil_space_t</a>* fil_space_get_space </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the file_space_t that is in the memory cache associated with a space id. The caller must lock fil_system-&gt;mutex. </p><dl class="section return"><dt>Returns</dt><dd>file_space_t pointer, NULL if space not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb31919b213988278ef69c102f7c5c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb31919b213988278ef69c102f7c5c78">&#9670;&nbsp;</a></span>fil_space_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_space_get_type </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of a file space. </p><dl class="section return"><dt>Returns</dt><dd>FIL_TABLESPACE or FIL_LOG </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d8b48a141176a1f720eba4a41ad787e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8b48a141176a1f720eba4a41ad787e">&#9670;&nbsp;</a></span>fil_space_get_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ib_int64_t fil_space_get_version </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the version number of a tablespace, -1 if not found. </p><dl class="section return"><dt>Returns</dt><dd>version number, -1 if the tablespace does not exist in the memory cache </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a946871486b5f407a1f4ba064bddd8551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946871486b5f407a1f4ba064bddd8551">&#9670;&nbsp;</a></span>fil_space_get_zip_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_space_get_zip_size </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the compressed page size of the space, or 0 if the space is not compressed. The tablespace must be cached in the memory cache. </p><dl class="section return"><dt>Returns</dt><dd>compressed page size, ULINT_UNDEFINED if space not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac993498b99dcc9981161a790b7d999f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac993498b99dcc9981161a790b7d999f9">&#9670;&nbsp;</a></span>fil_space_is_flushed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fil_space_is_flushed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfil__space__t.html">fil_space_t</a> *&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if all the file nodes in a space are flushed. The caller must hold the fil_system mutex. </p><dl class="section return"><dt>Returns</dt><dd>true if all are flushed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7d88c959e7718f3503c2d1c78a9609c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d88c959e7718f3503c2d1c78a9609c">&#9670;&nbsp;</a></span>fil_space_release_free_extents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fil_space_release_free_extents </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_reserved</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases free extents in a file space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">n_reserved</td><td>in: how many one reserved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b8b440963bc21f4366c8816f715b4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8b440963bc21f4366c8816f715b4dc">&#9670;&nbsp;</a></span>fil_space_reserve_free_extents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_space_reserve_free_extents </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_free_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_to_reserve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to reserve free extents in a file space. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if succeed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">n_free_now</td><td>in: number of free extents now </td></tr>
    <tr><td class="paramname">n_to_reserve</td><td>in: how many one wants to reserve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4ba86f6ec9233a99058d40a2ad07e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ba86f6ec9233a99058d40a2ad07e7c">&#9670;&nbsp;</a></span>fil_tablespace_deleted_or_being_deleted_in_mem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_tablespace_deleted_or_being_deleted_in_mem </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_int64_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if a single-table tablespace does not exist in the memory cache, or is being deleted there. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if does not exist or is being deleted </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">version</td><td>in: tablespace_version should be this; if you pass -1 as the value of this, then this parameter is ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d0533f2301d7ee226d088264de54a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0533f2301d7ee226d088264de54a5c">&#9670;&nbsp;</a></span>fil_tablespace_exists_in_mem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_tablespace_exists_in_mem </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if a single-table tablespace exists in the memory cache. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add3b73168dc3e08f29d228d3f1d3f5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3b73168dc3e08f29d228d3f1d3f5da">&#9670;&nbsp;</a></span>fil_tablespace_is_being_deleted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_tablespace_is_being_deleted </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if a single-table tablespace is being deleted. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if being deleted </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c1e5aa5cf06cc2655d9bbb4adc5e6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1e5aa5cf06cc2655d9bbb4adc5e6c2">&#9670;&nbsp;</a></span>fil_tablespace_iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_tablespace_iterate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_io_buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_page_callback.html">PageCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over all the pages in the tablespace. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>- the table definiton in the server </td></tr>
    <tr><td class="paramname">n_io_buffers</td><td>- number of blocks to read and write together </td></tr>
    <tr><td class="paramname">callback</td><td>- functor that will do the page updates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<p>Add an extra page for compressed page scratch area. </p>

</div>
</div>
<a id="a2afdf4e32f4a8aedf3c8abe8b45a6dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afdf4e32f4a8aedf3c8abe8b45a6dcf">&#9670;&nbsp;</a></span>fil_try_to_close_file_in_LRU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fil_try_to_close_file_in_LRU </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>print_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to close a file in the LRU list. The caller must hold the fil_sys mutex. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success, FALSE if should retry later; since i/o's generally complete in &lt; 100 ms, and as InnoDB writes at most 128 pages from the buffer pool in a batch, and then immediately flushes the files, there is a good chance that the next time we find a suitable node from the LRU list </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structprint__info.html">print_info</a></td><td>in: if TRUE, prints information why it cannot close a file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ba6fef965c5261b055a7a3813b3f5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba6fef965c5261b055a7a3813b3f5b0">&#9670;&nbsp;</a></span>fil_user_tablespace_find_space_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fil_user_tablespace_find_space_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsp__open__info.html">fsp_open_info</a> *&#160;</td>
          <td class="paramname"><em>fsp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine the space id of the given file descriptor by reading a few pages from the beginning of the .ibd file. </p><dl class="section return"><dt>Returns</dt><dd>true if space id was successfully identified, or false. </dd></dl>

</div>
</div>
<a id="a067a1660fa770cf70ebacbda30df17ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067a1660fa770cf70ebacbda30df17ef">&#9670;&nbsp;</a></span>fil_user_tablespace_restore_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fil_user_tablespace_restore_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfsp__open__info.html">fsp_open_info</a> *&#160;</td>
          <td class="paramname"><em>fsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the given page_no of the given space id from the double write buffer, and copies it to the corresponding .ibd file. </p><dl class="section return"><dt>Returns</dt><dd>true if copy was successful, or false. </dd></dl>

</div>
</div>
<a id="af3497a89c66230cec29b10ddb830fee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3497a89c66230cec29b10ddb830fee7">&#9670;&nbsp;</a></span>fil_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fil_validate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the consistency of the tablespace cache. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>

</div>
</div>
<a id="a97fc234e11550020cb31d9f9c356d6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fc234e11550020cb31d9f9c356d6cd">&#9670;&nbsp;</a></span>fil_validate_single_table_tablespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fil_validate_single_table_tablespace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tablename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfsp__open__info.html">fsp_open_info</a> *&#160;</td>
          <td class="paramname"><em>fsp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens an .ibd file and adds the associated single-table tablespace to the InnoDB <a class="el" href="fil0fil_8cc.html">fil0fil.cc</a> data structures. Set fsp-&gt;success to TRUE if tablespace is valid, FALSE if not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tablename</td><td>in: database/tablename </td></tr>
    <tr><td class="paramname">fsp</td><td>in/out: tablespace info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb3925ae6b3fa2868cea7ad5205fe7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb3925ae6b3fa2868cea7ad5205fe7a">&#9670;&nbsp;</a></span>fil_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_write </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>block_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data to a space from a buffer. Remember that the possible incomplete blocks at the end of file are ignored: they are not taken into account when calculating the byte offset within a space. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, or DB_TABLESPACE_DELETED if we are trying to do i/o on a tablespace which does not exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>in: true if synchronous aio is desired </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes; 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">block_offset</td><td>in: offset in number of blocks </td></tr>
    <tr><td class="paramname">byte_offset</td><td>in: remainder of offset in bytes; in aio this must be divisible by the OS block size </td></tr>
    <tr><td class="paramname">len</td><td>in: how many bytes to write; this must not cross a file boundary; in aio this must be a block size multiple </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer from which to write; in aio this must be appropriately aligned </td></tr>
    <tr><td class="paramname">message</td><td>in: message for aio handler if non-sync aio used, else ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04b6ca3b6843a7764ccce4b897f389b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b6ca3b6843a7764ccce4b897f389b5">&#9670;&nbsp;</a></span>fil_write_flushed_lsn_to_data_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> fil_write_flushed_lsn_to_data_files </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>arch_log_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the flushed lsn and the latest archived log number to the page header of the first page of each data file in the system tablespace. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lsn</td><td>in: lsn to write </td></tr>
    <tr><td class="paramname">arch_log_no</td><td>in: latest archived log file number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a363867fc7abfed4c21f79b41c57cb080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363867fc7abfed4c21f79b41c57cb080">&#9670;&nbsp;</a></span>fil_addr_null</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structfil__addr__t.html">fil_addr_t</a> fil_addr_null = {<a class="el" href="fil0fil_8h.html#aa3cefe750718b6961ad77a77b24de271">FIL_NULL</a>, 0}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The null file address </p>

</div>
</div>
<a id="aecbaa0ec7b9883dfb795b296c9157b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbaa0ec7b9883dfb795b296c9157b47">&#9670;&nbsp;</a></span>fil_n_file_opened</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_n_file_opened = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of files currently open </p>

</div>
</div>
<a id="a85734a9aa5af93fc873eac43f36e7cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85734a9aa5af93fc873eac43f36e7cdb">&#9670;&nbsp;</a></span>fil_n_log_flushes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_n_log_flushes = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of fsyncs done to the log </p>

</div>
</div>
<a id="a9bdc1b41ed4a62ffa8e8ba36be0db99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdc1b41ed4a62ffa8e8ba36be0db99d">&#9670;&nbsp;</a></span>fil_n_pending_log_flushes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_n_pending_log_flushes = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of pending redo log flushes </p>

</div>
</div>
<a id="a2a8447fc265d5b768596164e086a5a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8447fc265d5b768596164e086a5a68">&#9670;&nbsp;</a></span>fil_n_pending_tablespace_flushes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fil_n_pending_tablespace_flushes = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of pending tablespace flushes </p>

</div>
</div>
<a id="a0d9ae4bede2e8380526734a6068b04cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9ae4bede2e8380526734a6068b04cf">&#9670;&nbsp;</a></span>fil_path_to_mysql_datadir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* fil_path_to_mysql_datadir = &quot;.&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When mysqld is run, the default directory "." is the mysqld datadir, but in the MySQL Embedded Server Library and mysqlbackup it is not the default directory, and we must set the base file path explicitly </p>

</div>
</div>
<a id="a7b9c66a0c479191f1eaae15c3d50d712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9c66a0c479191f1eaae15c3d50d712">&#9670;&nbsp;</a></span>fil_system</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfil__system__t.html">fil_system_t</a>* fil_system = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The tablespace memory cache. This variable is NULL before the module is initialized. </p>

</div>
</div>
<a id="adfb4cabfb679d4fce6dc3fa7c1ee5094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb4cabfb679d4fce6dc3fa7c1ee5094">&#9670;&nbsp;</a></span>lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lsn_t lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: lsn to write </p>

</div>
</div>
<a id="aec5d57f16a42ff58df937de43c36128e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5d57f16a42ff58df937de43c36128e">&#9670;&nbsp;</a></span>sum_of_sizes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint sum_of_sizes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: space to write to in: combined size of previous files in space, in database pages </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

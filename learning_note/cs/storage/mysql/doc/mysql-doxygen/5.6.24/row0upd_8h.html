<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/row0upd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">row0upd.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="data0data_8h_source.html">data0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0types_8h_source.html">row0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0types_8h_source.html">btr0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0pcur_8h_source.html">btr0pcur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0types_8h_source.html">que0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0types_8h_source.html">pars0types.h</a>&quot;</code><br />
<code>#include &quot;row0upd.ic&quot;</code><br />
</div>
<p><a href="row0upd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupd__field__t.html">upd_field_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupd__t.html">upd_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupd__node__t.html">upd_node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa2b569e8bf695ff9b2f2d5881d8cc6d8"><td class="memItemLeft" align="right" valign="top"><a id="aa2b569e8bf695ff9b2f2d5881d8cc6d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>upd_get_nth_field</b>(<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>,  <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)&#160;&#160;&#160;((<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>)-&gt;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a> + (<a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>))</td></tr>
<tr class="separator:aa2b569e8bf695ff9b2f2d5881d8cc6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c0370d392197d4d1b745e3d464985"><td class="memItemLeft" align="right" valign="top"><a id="a908c0370d392197d4d1b745e3d464985"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>row_upd_changes_ord_field_binary</b>(<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>,  <a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>,  <a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>,  <a class="el" href="row0log_8cc.html#ad42e2d1ad172100a2cd1338656cf0425">row</a>,  ext)&#160;&#160;&#160;<a class="el" href="row0upd_8cc.html#a6f07664413391a2e946d3f503eb04c51">row_upd_changes_ord_field_binary_func</a>(<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>,<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>,<a class="el" href="row0log_8cc.html#ad42e2d1ad172100a2cd1338656cf0425">row</a>,ext)</td></tr>
<tr class="separator:a908c0370d392197d4d1b745e3d464985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c347f996e51f6fb49ef6c067ba04bf"><td class="memItemLeft" align="right" valign="top"><a id="a96c347f996e51f6fb49ef6c067ba04bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_MAGIC_N</b>&#160;&#160;&#160;1579975</td></tr>
<tr class="separator:a96c347f996e51f6fb49ef6c067ba04bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44102f8533c40d47458f13aac650ef38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_SET_IX_LOCK</b></td></tr>
<tr class="separator:a44102f8533c40d47458f13aac650ef38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ed1fcdf27db3b4ada62729f09fd233"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_UPDATE_CLUSTERED</b></td></tr>
<tr class="separator:a78ed1fcdf27db3b4ada62729f09fd233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0446f02f1cc4570e730ed640bf311493"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_INSERT_CLUSTERED</b></td></tr>
<tr class="separator:a0446f02f1cc4570e730ed640bf311493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ffe141c170c94d10b218c89ae19b18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_INSERT_BLOB</b></td></tr>
<tr class="separator:af8ffe141c170c94d10b218c89ae19b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1678d94ec05825c81d2a4748f19c4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_UPDATE_ALL_SEC</b></td></tr>
<tr class="separator:acc1678d94ec05825c81d2a4748f19c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5381bd0d873234a70f103df73b1b02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_UPDATE_SOME_SEC</b></td></tr>
<tr class="separator:abe5381bd0d873234a70f103df73b1b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521a1927c7f930bb014e8697bcc579cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_NO_ORD_CHANGE</b></td></tr>
<tr class="separator:a521a1927c7f930bb014e8697bcc579cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f48e6b565f0a43dce9888b2d23d16e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_NO_SIZE_CHANGE</b></td></tr>
<tr class="separator:ac1f48e6b565f0a43dce9888b2d23d16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae4662cf8a186586e3caad5a7a28cf9ec"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ae4662cf8a186586e3caad5a7a28cf9ec">upd_create</a> (ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:ae4662cf8a186586e3caad5a7a28cf9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0bebe9c2bdc7ec292e9784374476f2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#adc0bebe9c2bdc7ec292e9784374476f2">upd_get_n_fields</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>)</td></tr>
<tr class="separator:adc0bebe9c2bdc7ec292e9784374476f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba68102b6521acae8f0d8c3e6ba0a26"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#abba68102b6521acae8f0d8c3e6ba0a26">upd_field_set_field_no</a> (<a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field, ulint <a class="el" href="row0sel_8cc.html#a9abb5656a4ae7d5790d74b5351cf0829">field_no</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:abba68102b6521acae8f0d8c3e6ba0a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3200d1eff72999c5967d2e294a308552"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a3200d1eff72999c5967d2e294a308552">upd_get_field_by_field_no</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, ulint no) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a3200d1eff72999c5967d2e294a308552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d7c8cfa676ad73cf68f61cd4fc3068"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a51d7c8cfa676ad73cf68f61cd4fc3068">row_upd_write_sys_vals_to_log</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> <a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a>, byte *log_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a51d7c8cfa676ad73cf68f61cd4fc3068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dbc3d05e7439c1afdb28063ab827cf"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#aa0dbc3d05e7439c1afdb28063ab827cf">row_upd_rec_sys_fields</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> <a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a>)</td></tr>
<tr class="separator:aa0dbc3d05e7439c1afdb28063ab827cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ad2921018c2e34da12dff331f17308"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a26ad2921018c2e34da12dff331f17308">row_upd_index_entry_sys_field</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, ib_uint64_t val)</td></tr>
<tr class="separator:a26ad2921018c2e34da12dff331f17308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbf24a5f1842095a0aea1bde91e66f0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#adcbf24a5f1842095a0aea1bde91e66f0">upd_node_create</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:adcbf24a5f1842095a0aea1bde91e66f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813e11390074690cd46e0a2831e465cf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a813e11390074690cd46e0a2831e465cf">row_upd_index_write_log</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, byte *log_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a813e11390074690cd46e0a2831e465cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5b95f92367fcb6d487efcbd1e3a8d4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#aed5b95f92367fcb6d487efcbd1e3a8d4">row_upd_changes_field_size_or_external</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>)</td></tr>
<tr class="separator:aed5b95f92367fcb6d487efcbd1e3a8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77140b33bf5c26c271f757158e2659ec"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a77140b33bf5c26c271f757158e2659ec">row_upd_changes_disowned_external</a> (const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a77140b33bf5c26c271f757158e2659ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736d5872d84c0e81c7c63d308e66e2f8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a736d5872d84c0e81c7c63d308e66e2f8">row_upd_rec_in_place</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:a736d5872d84c0e81c7c63d308e66e2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93d1954fd61b310cc669c6890cd4f8a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ad93d1954fd61b310cc669c6890cd4f8a">row_upd_build_sec_rec_difference_binary</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result</td></tr>
<tr class="separator:ad93d1954fd61b310cc669c6890cd4f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1677f476fdfab2124e69dce9e2b578"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a0b1677f476fdfab2124e69dce9e2b578">row_upd_build_difference_binary</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, bool no_sys, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull(1</td></tr>
<tr class="separator:a0b1677f476fdfab2124e69dce9e2b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e17d16c70c82824e35cbba7a509287a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a3e17d16c70c82824e35cbba7a509287a">row_upd_index_replace_new_col_vals_index_pos</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, ibool order_only, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a3e17d16c70c82824e35cbba7a509287a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed4d551fb88d4b10dbca5a9920dbed9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a0ed4d551fb88d4b10dbca5a9920dbed9">row_upd_index_replace_new_col_vals</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a0ed4d551fb88d4b10dbca5a9920dbed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7169668781a556da74cd6b6821986ca5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a7169668781a556da74cd6b6821986ca5">row_upd_replace</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0log_8cc.html#ad42e2d1ad172100a2cd1338656cf0425">row</a>, <a class="el" href="structrow__ext__t.html">row_ext_t</a> **ext, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a7169668781a556da74cd6b6821986ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae093d5c4ce0344580f221fcdb234567d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ae093d5c4ce0344580f221fcdb234567d">row_upd_changes_ord_field_binary_func</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0log_8cc.html#ad42e2d1ad172100a2cd1338656cf0425">row</a>, const <a class="el" href="structrow__ext__t.html">row_ext_t</a> *ext) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull(1</td></tr>
<tr class="separator:ae093d5c4ce0344580f221fcdb234567d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703e5befbbafbade1b692d71b5ad4968"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a703e5befbbafbade1b692d71b5ad4968">row_upd_changes_fts_column</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field)</td></tr>
<tr class="separator:a703e5befbbafbade1b692d71b5ad4968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a2f6253a187db31837fd692f4a31ce"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a22a2f6253a187db31837fd692f4a31ce">row_upd_changes_doc_id</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a22a2f6253a187db31837fd692f4a31ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ca86abc5e48fd642b989e9c0b9b509"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#af6ca86abc5e48fd642b989e9c0b9b509">row_upd_changes_some_index_ord_field_binary</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>)</td></tr>
<tr class="separator:af6ca86abc5e48fd642b989e9c0b9b509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef8c0ae6eea82f02c7ba30a644f1b57"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a6ef8c0ae6eea82f02c7ba30a644f1b57">row_upd_step</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a6ef8c0ae6eea82f02c7ba30a644f1b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941717af7d57a7b6bf841f0c98948199"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a941717af7d57a7b6bf841f0c98948199">row_upd_parse_sys_vals</a> (byte *ptr, byte *end_ptr, ulint *pos, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> *<a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *<a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a>)</td></tr>
<tr class="separator:a941717af7d57a7b6bf841f0c98948199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cb047352eff637ca3adc6816d7bfd4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a23cb047352eff637ca3adc6816d7bfd4">row_upd_rec_sys_fields_in_recovery</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint pos, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> <a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a>)</td></tr>
<tr class="separator:a23cb047352eff637ca3adc6816d7bfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65084faf3a9b76b650131636bdc1497"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ab65084faf3a9b76b650131636bdc1497">row_upd_index_parse</a> (byte *ptr, byte *end_ptr, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, <a class="el" href="structupd__t.html">upd_t</a> **update_out)</td></tr>
<tr class="separator:ab65084faf3a9b76b650131636bdc1497"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae58949c549af9adadaf6a12217154351"><td class="memItemLeft" align="right" valign="top"><a id="ae58949c549af9adadaf6a12217154351"></a>
UNIV_INLINE const <a class="el" href="structupd__field__t.html">upd_field_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pure</b></td></tr>
<tr class="separator:ae58949c549af9adadaf6a12217154351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a31286e6ebf5b6779daa64b811d284d"><td class="memItemLeft" align="right" valign="top"><a id="a8a31286e6ebf5b6779daa64b811d284d"></a>
UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><b>warn_unused_result</b></td></tr>
<tr class="separator:a8a31286e6ebf5b6779daa64b811d284d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cb52397ac67f88957396c09111ac9d"><td class="memItemLeft" align="right" valign="top"><a id="a21cb52397ac67f88957396c09111ac9d"></a>
UNIV_INTERN <a class="el" href="structupd__t.html">upd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nonnull</b></td></tr>
<tr class="separator:a21cb52397ac67f88957396c09111ac9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Update of a row</p>
<p>Created 12/27/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af8ffe141c170c94d10b218c89ae19b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ffe141c170c94d10b218c89ae19b18">&#9670;&nbsp;</a></span>UPD_NODE_INSERT_BLOB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_INSERT_BLOB</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">4       <span class="comment">/* clustered index record should be</span></div><div class="line"><span class="comment">                                        inserted, old record is already</span></div><div class="line"><span class="comment">                                        delete-marked; non-updated BLOBs</span></div><div class="line"><span class="comment">                                        should be inherited by the new record</span></div><div class="line"><span class="comment">                                        and disowned by the old record */</span></div></div><!-- fragment -->
</div>
</div>
<a id="a0446f02f1cc4570e730ed640bf311493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0446f02f1cc4570e730ed640bf311493">&#9670;&nbsp;</a></span>UPD_NODE_INSERT_CLUSTERED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_INSERT_CLUSTERED</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">3       <span class="comment">/* clustered index record should be</span></div><div class="line"><span class="comment">                                        inserted, old record is already delete</span></div><div class="line"><span class="comment">                                        marked */</span></div></div><!-- fragment -->
</div>
</div>
<a id="a521a1927c7f930bb014e8697bcc579cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521a1927c7f930bb014e8697bcc579cf">&#9670;&nbsp;</a></span>UPD_NODE_NO_ORD_CHANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_NO_ORD_CHANGE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">1       <span class="comment">/* no secondary index record will be</span></div><div class="line"><span class="comment">                                        changed in the update and no ordering</span></div><div class="line"><span class="comment">                                        field of the clustered index */</span></div></div><!-- fragment -->
</div>
</div>
<a id="ac1f48e6b565f0a43dce9888b2d23d16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f48e6b565f0a43dce9888b2d23d16e">&#9670;&nbsp;</a></span>UPD_NODE_NO_SIZE_CHANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_NO_SIZE_CHANGE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">2       <span class="comment">/* no record field size will be</span></div><div class="line"><span class="comment">                                        changed in the update */</span></div></div><!-- fragment -->
</div>
</div>
<a id="a44102f8533c40d47458f13aac650ef38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44102f8533c40d47458f13aac650ef38">&#9670;&nbsp;</a></span>UPD_NODE_SET_IX_LOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_SET_IX_LOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">1       <span class="comment">/* execution came to the node from</span></div><div class="line"><span class="comment">                                        a node above and if the field</span></div><div class="line"><span class="comment">                                        has_clust_rec_x_lock is FALSE, we</span></div><div class="line"><span class="comment">                                        should set an intention x-lock on</span></div><div class="line"><span class="comment">                                        the table */</span></div></div><!-- fragment -->
</div>
</div>
<a id="acc1678d94ec05825c81d2a4748f19c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1678d94ec05825c81d2a4748f19c4a">&#9670;&nbsp;</a></span>UPD_NODE_UPDATE_ALL_SEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_UPDATE_ALL_SEC</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">5       <span class="comment">/* an ordering field of the clustered</span></div><div class="line"><span class="comment">                                        index record was changed, or this is</span></div><div class="line"><span class="comment">                                        a delete operation: should update</span></div><div class="line"><span class="comment">                                        all the secondary index records */</span></div></div><!-- fragment -->
</div>
</div>
<a id="a78ed1fcdf27db3b4ada62729f09fd233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ed1fcdf27db3b4ada62729f09fd233">&#9670;&nbsp;</a></span>UPD_NODE_UPDATE_CLUSTERED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_UPDATE_CLUSTERED</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">2       <span class="comment">/* clustered index record should be</span></div><div class="line"><span class="comment">                                        updated */</span></div></div><!-- fragment -->
</div>
</div>
<a id="abe5381bd0d873234a70f103df73b1b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5381bd0d873234a70f103df73b1b02">&#9670;&nbsp;</a></span>UPD_NODE_UPDATE_SOME_SEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_UPDATE_SOME_SEC</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">6       <span class="comment">/* secondary index entries should be</span></div><div class="line"><span class="comment">                                        looked at and updated if an ordering</span></div><div class="line"><span class="comment">                                        field changed */</span></div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0b1677f476fdfab2124e69dce9e2b578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1677f476fdfab2124e69dce9e2b578">&#9670;&nbsp;</a></span>row_upd_build_difference_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structupd__t.html">upd_t</a>* row_upd_build_difference_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds an update vector from those fields, excluding the roll ptr and trx id fields, which in an index entry differ from a record that has the equal ordering fields. NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>own: update vector of differing fields, excluding roll ptr and trx id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>in: clustered index record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec,index), or NULL </td></tr>
    <tr><td class="paramname">no_sys</td><td>in: skip the system columns DB_TRX_ID and DB_ROLL_PTR </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction (for diagnostics), or NULL </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap from which allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad93d1954fd61b310cc669c6890cd4f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93d1954fd61b310cc669c6890cd4f8a">&#9670;&nbsp;</a></span>row_upd_build_sec_rec_difference_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structupd__t.html">upd_t</a>* row_upd_build_sec_rec_difference_binary </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds an update vector from those fields which in a secondary index entry differ from a record that has the equal ordering fields. NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>own: update vector of differing fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: secondary index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry to insert </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap from which allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77140b33bf5c26c271f757158e2659ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77140b33bf5c26c271f757158e2659ec">&#9670;&nbsp;</a></span>row_upd_changes_disowned_external()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool row_upd_changes_disowned_external </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if row update contains disowned external fields. </p><dl class="section return"><dt>Returns</dt><dd>true if the update contains disowned external fields. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22a2f6253a187db31837fd692f4a31ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a2f6253a187db31837fd692f4a31ce">&#9670;&nbsp;</a></span>row_upd_changes_doc_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool row_upd_changes_doc_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if an FTS Doc ID column is affected by an UPDATE. </p><dl class="section return"><dt>Returns</dt><dd>whether Doc ID column is affected </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">upd_field</td><td>in: field to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed5b95f92367fcb6d487efcbd1e3a8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5b95f92367fcb6d487efcbd1e3a8d4">&#9670;&nbsp;</a></span>row_upd_changes_field_size_or_external()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool row_upd_changes_field_size_or_external </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if row update changes size of some field in index or if some field to be updated is stored externally in rec or update. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the update changes the size of some field in index or the field is external in rec or update in: update vector</dd></dl>
<p>Returns TRUE if row update changes size of some field in index or if some field to be updated is stored externally in rec or update. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the update changes the size of some field in index or the field is external in rec or update </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a703e5befbbafbade1b692d71b5ad4968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703e5befbbafbade1b692d71b5ad4968">&#9670;&nbsp;</a></span>row_upd_changes_fts_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint row_upd_changes_fts_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if an FTS indexed column is affected by an UPDATE. </p><dl class="section return"><dt>Returns</dt><dd>offset within <a class="el" href="structfts__t.html#afc118c175b3dfcf1e30290bb68f2284e">fts_t::indexes</a> if FTS indexed column updated else ULINT_UNDEFINED in: field to check</dd></dl>
<p>Checks if an FTS indexed column is affected by an UPDATE. </p><dl class="section return"><dt>Returns</dt><dd>offset within <a class="el" href="structfts__t.html#afc118c175b3dfcf1e30290bb68f2284e">fts_t::indexes</a> if FTS indexed column updated else ULINT_UNDEFINED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">upd_field</td><td>in: field to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae093d5c4ce0344580f221fcdb234567d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae093d5c4ce0344580f221fcdb234567d">&#9670;&nbsp;</a></span>row_upd_changes_ord_field_binary_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool row_upd_changes_ord_field_binary_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrow__ext__t.html">row_ext_t</a> *&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if an update vector changes an ordering field of an index record.</p>
<p>This function is fast if the update vector is short or the number of ordering fields in the index is small. Otherwise, this can be quadratic. NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>TRUE if update vector changes an ordering field in the index record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of the record </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector for the row; NOTE: the field numbers in this MUST be clustered index positions! </td></tr>
    <tr><td class="paramname">row</td><td>in: old value of row, or NULL if the row and the data values in update are not known when this function is called, e.g., at compile time </td></tr>
    <tr><td class="paramname">ext</td><td>NULL, or prefixes of the externally stored columns in the old row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6ca86abc5e48fd642b989e9c0b9b509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ca86abc5e48fd642b989e9c0b9b509">&#9670;&nbsp;</a></span>row_upd_changes_some_index_ord_field_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool row_upd_changes_some_index_ord_field_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if an update vector changes an ordering field of an index record. This function is fast if the update vector is short or the number of ordering fields in the index is small. Otherwise, this can be quadratic. NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>TRUE if update vector may change an ordering field in an index record in: update vector for the row</dd></dl>
<p>Checks if an update vector changes an ordering field of an index record. NOTE: we compare the fields as binary strings! </p><dl class="section return"><dt>Returns</dt><dd>TRUE if update vector may change an ordering field in an index record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector for the row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26ad2921018c2e34da12dff331f17308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ad2921018c2e34da12dff331f17308">&#9670;&nbsp;</a></span>row_upd_index_entry_sys_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_index_entry_sys_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the trx id or roll ptr field of a clustered index entry. in: value to write</p>
<p>Sets the trx id or roll ptr field of a clustered index entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in/out: index entry, where the memory buffers for sys fields are already allocated: the function just copies the new values to them </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">type</td><td>in: DATA_TRX_ID or DATA_ROLL_PTR </td></tr>
    <tr><td class="paramname">val</td><td>in: value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab65084faf3a9b76b650131636bdc1497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65084faf3a9b76b650131636bdc1497">&#9670;&nbsp;</a></span>row_upd_index_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* row_upd_index_parse </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__t.html">upd_t</a> **&#160;</td>
          <td class="paramname"><em>update_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the log data written by row_upd_index_write_log. </p><dl class="section return"><dt>Returns</dt><dd>log data end or NULL out: update vector</dd></dl>
<p>Parses the log data written by row_upd_index_write_log. </p><dl class="section return"><dt>Returns</dt><dd>log data end or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where update vector is built </td></tr>
    <tr><td class="paramname">update_out</td><td>out: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ed4d551fb88d4b10dbca5a9920dbed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed4d551fb88d4b10dbca5a9920dbed9">&#9670;&nbsp;</a></span>row_upd_index_replace_new_col_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_index_replace_new_col_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the new column values stored in the update vector to the index entry given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in/out: index entry where replaced; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramname">index</td><td>in: index; NOTE that this may also be a non-clustered index </td></tr>
    <tr><td class="paramname">update</td><td>in: an update vector built for the CLUSTERED index so that the field number in an upd_field is the clustered index position </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap for allocating and copying the new values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e17d16c70c82824e35cbba7a509287a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e17d16c70c82824e35cbba7a509287a">&#9670;&nbsp;</a></span>row_upd_index_replace_new_col_vals_index_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>order_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the new column values stored in the update vector to the index entry given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in/out: index entry where replaced; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramname">index</td><td>in: index; NOTE that this may also be a non-clustered index </td></tr>
    <tr><td class="paramname">update</td><td>in: an update vector built for the index so that the field number in an upd_field is the index position </td></tr>
    <tr><td class="paramname">order_only</td><td>in: if TRUE, limit the replacement to ordering fields of index; note that this does not work for non-clustered indexes. </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap for allocating and copying the new values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a813e11390074690cd46e0a2831e465cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813e11390074690cd46e0a2831e465cf">&#9670;&nbsp;</a></span>row_upd_index_write_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_index_write_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>log_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to the redo log the new values of the fields occurring in the index. in: mtr into whose log to write</p>
<p>Writes to the redo log the new values of the fields occurring in the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">log_ptr</td><td>in: pointer to mlog buffer: must contain at least MLOG_BUF_MARGIN bytes of free space; the buffer is closed within this function </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr into whose log to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a941717af7d57a7b6bf841f0c98948199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941717af7d57a7b6bf841f0c98948199">&#9670;&nbsp;</a></span>row_upd_parse_sys_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* row_upd_parse_sys_vals </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> *&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the log data of system field values. </p><dl class="section return"><dt>Returns</dt><dd>log data end or NULL out: roll ptr</dd></dl>
<p>Parses the log data of system field values. </p><dl class="section return"><dt>Returns</dt><dd>log data end or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">pos</td><td>out: TRX_ID position in record </td></tr>
    <tr><td class="paramname">trx_id</td><td>out: trx id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>out: roll ptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a736d5872d84c0e81c7c63d308e66e2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736d5872d84c0e81c7c63d308e66e2f8">&#9670;&nbsp;</a></span>row_upd_rec_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_rec_in_place </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the new column values stored in the update vector to the record given. No field size changes are allowed. This function is usually invoked on a clustered index. The only use case for a secondary index is row_ins_sec_index_entry_by_modify() or its counterpart in <a class="el" href="ibuf0ibuf_8cc.html#a93b0a670dfaa0d2a262ff188820f0196">ibuf_insert_to_index_page()</a>. in: compressed page with enough space available, or NULL</p>
<p>Replaces the new column values stored in the update vector to the record given. No field size changes are allowed. This function is usually invoked on a clustered index. The only use case for a secondary index is row_ins_sec_index_entry_by_modify() or its counterpart in <a class="el" href="ibuf0ibuf_8cc.html#a93b0a670dfaa0d2a262ff188820f0196">ibuf_insert_to_index_page()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record where replaced </td></tr>
    <tr><td class="paramname">index</td><td>in: the index the record belongs to </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">page_zip</td><td>in: compressed page with enough space available, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0dbc3d05e7439c1afdb28063ab827cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0dbc3d05e7439c1afdb28063ab827cf">&#9670;&nbsp;</a></span>row_upd_rec_sys_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_upd_rec_sys_fields </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the trx id and roll ptr field in a clustered index record when a row is updated or marked deleted. in: roll ptr of the undo log record, can be 0 during IMPORT </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23cb047352eff637ca3adc6816d7bfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cb047352eff637ca3adc6816d7bfd4">&#9670;&nbsp;</a></span>row_upd_rec_sys_fields_in_recovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_rec_sys_fields_in_recovery </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the trx id and roll ptr field in a clustered index record in database recovery. in: roll ptr of the undo log record</p>
<p>Updates the trx id and roll ptr field in a clustered index record in database recovery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">pos</td><td>in: TRX_ID position in rec </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr of the undo log record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7169668781a556da74cd6b6821986ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7169668781a556da74cd6b6821986ca5">&#9670;&nbsp;</a></span>row_upd_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__ext__t.html">row_ext_t</a> **&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the new column values stored in the update vector. in: memory heap</p>
<p>Replaces the new column values stored in the update vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>in/out: row where replaced, indexed by col_no; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramname">ext</td><td>out, own: NULL, or externally stored column prefixes </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">update</td><td>in: an update vector built for the clustered index </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ef8c0ae6eea82f02c7ba30a644f1b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef8c0ae6eea82f02c7ba30a644f1b57">&#9670;&nbsp;</a></span>row_upd_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a>* row_upd_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates a row in a table. This is a high-level function used in SQL execution graphs. </p><dl class="section return"><dt>Returns</dt><dd>query thread to run next or NULL in: query thread</dd></dl>
<p>Updates a row in a table. This is a high-level function used in SQL execution graphs. </p><dl class="section return"><dt>Returns</dt><dd>query thread to run next or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51d7c8cfa676ad73cf68f61cd4fc3068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d7c8cfa676ad73cf68f61cd4fc3068">&#9670;&nbsp;</a></span>row_upd_write_sys_vals_to_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* row_upd_write_sys_vals_to_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>log_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes into the redo log the values of trx id and roll ptr and enough info to determine their positions within a clustered index record. </p><dl class="section return"><dt>Returns</dt><dd>new pointer to mlog in: mtr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr of the undo log record </td></tr>
    <tr><td class="paramname">log_ptr</td><td>pointer to a buffer of size &gt; 20 opened in mlog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4662cf8a186586e3caad5a7a28cf9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4662cf8a186586e3caad5a7a28cf9ec">&#9670;&nbsp;</a></span>upd_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structupd__t.html">upd_t</a>* upd_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an update vector object. </p><dl class="section return"><dt>Returns</dt><dd>own: update vector object in: heap from which memory allocated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: number of fields </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abba68102b6521acae8f0d8c3e6ba0a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba68102b6521acae8f0d8c3e6ba0a26">&#9670;&nbsp;</a></span>upd_field_set_field_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void upd_field_set_field_no </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>field_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an index field number to be updated by an update vector field. in: transaction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upd_field</td><td>in: update vector field </td></tr>
    <tr><td class="paramname">field_no</td><td>in: field number in a clustered index </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3200d1eff72999c5967d2e294a308552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3200d1eff72999c5967d2e294a308552">&#9670;&nbsp;</a></span>upd_get_field_by_field_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structupd__field__t.html">upd_field_t</a>* upd_get_field_by_field_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a field of an update vector by field_no. </p><dl class="section return"><dt>Returns</dt><dd>update vector field, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">no</td><td>in: field_no </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc0bebe9c2bdc7ec292e9784374476f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0bebe9c2bdc7ec292e9784374476f2">&#9670;&nbsp;</a></span>upd_get_n_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint upd_get_n_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of fields in the update vector == number of columns to be updated by an update vector. </p><dl class="section return"><dt>Returns</dt><dd>number of fields in: update vector </dd></dl>

</div>
</div>
<a id="adcbf24a5f1842095a0aea1bde91e66f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbf24a5f1842095a0aea1bde91e66f0">&#9670;&nbsp;</a></span>upd_node_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structupd__node__t.html">upd_node_t</a>* upd_node_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an update node for a query graph. </p><dl class="section return"><dt>Returns</dt><dd>own: update node in: mem heap where created</dd></dl>
<p>Creates an update node for a query graph. </p><dl class="section return"><dt>Returns</dt><dd>own: update node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: mem heap where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

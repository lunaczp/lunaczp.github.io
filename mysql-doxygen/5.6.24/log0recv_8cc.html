<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/log/log0recv.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_7c61b8982e4f26eda8a4a9a87fddd769.html">log</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">log0recv.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;my_config.h&quot;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="log0recv_8h_source.html">log0recv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0flu_8h_source.html">buf0flu.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0mtr_8h_source.html">mtr0mtr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0log_8h_source.html">mtr0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0cur_8h_source.html">page0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0undo_8h_source.html">trx0undo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0rec_8h_source.html">trx0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0rea_8h_source.html">buf0rea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0roll_8h_source.html">trx0roll.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0merge_8h_source.html">row0merge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a599884251054cd22af6500c6fbe03eb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a599884251054cd22af6500c6fbe03eb8">RECV_DATA_BLOCK_SIZE</a>&#160;&#160;&#160;(MEM_MAX_ALLOC_IN_BUF - sizeof(<a class="el" href="structrecv__data__t.html">recv_data_t</a>))</td></tr>
<tr class="separator:a599884251054cd22af6500c6fbe03eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3295cbcda6a620a2751dc47206d6a02c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a3295cbcda6a620a2751dc47206d6a02c">RECV_READ_AHEAD_AREA</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a3295cbcda6a620a2751dc47206d6a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0143b997363d0ce9283e4f81e4181e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a5e0143b997363d0ce9283e4f81e4181e">recv_is_making_a_backup</a>&#160;&#160;&#160;FALSE</td></tr>
<tr class="separator:a5e0143b997363d0ce9283e4f81e4181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03f8edafc9d1b7a63fc100dc3301039"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#af03f8edafc9d1b7a63fc100dc3301039">recv_is_from_backup</a>&#160;&#160;&#160;FALSE</td></tr>
<tr class="separator:af03f8edafc9d1b7a63fc100dc3301039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b5060240da2b6b7513201d34014746"><td class="memItemLeft" align="right" valign="top"><a id="a56b5060240da2b6b7513201d34014746"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TYPE_CHECKPOINT</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a56b5060240da2b6b7513201d34014746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f752f457030eb3cf6fe57d6665249a5"><td class="memItemLeft" align="right" valign="top"><a id="a7f752f457030eb3cf6fe57d6665249a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LIMIT_LSN</b>&#160;&#160;&#160;LSN_MAX</td></tr>
<tr class="separator:a7f752f457030eb3cf6fe57d6665249a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae28110ea7dec38ca47b81da1b6947687"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#ae28110ea7dec38ca47b81da1b6947687">recv_init_crash_recovery</a> (void)</td></tr>
<tr class="separator:ae28110ea7dec38ca47b81da1b6947687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6a2e802976bbca76d67d8788c711d8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#aaa6a2e802976bbca76d67d8788c711d8">recv_sys_create</a> (void)</td></tr>
<tr class="separator:aaa6a2e802976bbca76d67d8788c711d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b14557f39abeba9b80bd66fbc96aeb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a65b14557f39abeba9b80bd66fbc96aeb">recv_sys_close</a> (void)</td></tr>
<tr class="separator:a65b14557f39abeba9b80bd66fbc96aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41975a23eb880acab4a47274910cd338"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a41975a23eb880acab4a47274910cd338">recv_sys_mem_free</a> (void)</td></tr>
<tr class="separator:a41975a23eb880acab4a47274910cd338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa292eaf15cfd7536fefda28f01a19a7e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#aa292eaf15cfd7536fefda28f01a19a7e">recv_sys_var_init</a> (void)</td></tr>
<tr class="separator:aa292eaf15cfd7536fefda28f01a19a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a156f8e7f1b461bc434a3dbd0b6a990"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a8a156f8e7f1b461bc434a3dbd0b6a990">recv_writer_thread</a> (void *arg <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:a8a156f8e7f1b461bc434a3dbd0b6a990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78f6b379d555b6609120b94a88e48c8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#af78f6b379d555b6609120b94a88e48c8">recv_sys_init</a> (ulint available_memory)</td></tr>
<tr class="separator:af78f6b379d555b6609120b94a88e48c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845af78fbf918cb6f7614ec20b43ede4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a845af78fbf918cb6f7614ec20b43ede4">recv_sys_empty_hash</a> (void)</td></tr>
<tr class="separator:a845af78fbf918cb6f7614ec20b43ede4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eecde9bf48472bcf4bcc16a4c74372"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a44eecde9bf48472bcf4bcc16a4c74372">recv_sys_debug_free</a> (void)</td></tr>
<tr class="separator:a44eecde9bf48472bcf4bcc16a4c74372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94c57b83ed03df57a0fb49ca7d7fc2d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#aa94c57b83ed03df57a0fb49ca7d7fc2d">recv_synchronize_groups</a> ()</td></tr>
<tr class="separator:aa94c57b83ed03df57a0fb49ca7d7fc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d4e607344ca74b3e3402a6c2b9e50b"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#af3d4e607344ca74b3e3402a6c2b9e50b">recv_check_cp_is_consistent</a> (const byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:af3d4e607344ca74b3e3402a6c2b9e50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1ea68a4bf6d74a6ff8fb1014cdb083"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#add1ea68a4bf6d74a6ff8fb1014cdb083">__attribute__</a> ((nonnull, warn_unused_result)) <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> recv_find_max_checkpoint(<a class="el" href="structlog__group__t.html">log_group_t</a> **max_group</td></tr>
<tr class="separator:add1ea68a4bf6d74a6ff8fb1014cdb083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d66b1b1925927e8bf59ed69a83d9f1d"><td class="memItemLeft" align="right" valign="top"><a id="a7d66b1b1925927e8bf59ed69a83d9f1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>while</b> (group)</td></tr>
<tr class="separator:a7d66b1b1925927e8bf59ed69a83d9f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61828c7bca427fa82972d653ba5d505f"><td class="memItemLeft" align="right" valign="top"><a id="a61828c7bca427fa82972d653ba5d505f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (DB_ERROR)</td></tr>
<tr class="separator:a61828c7bca427fa82972d653ba5d505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac56458861b2e62f1e3520e6df16f73"><td class="memItemLeft" align="right" valign="top"><a id="a3ac56458861b2e62f1e3520e6df16f73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (DB_SUCCESS)</td></tr>
<tr class="separator:a3ac56458861b2e62f1e3520e6df16f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494883429ba0c7d58cdb3e1648106d8b"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a494883429ba0c7d58cdb3e1648106d8b">log_block_checksum_is_ok_or_old_format</a> (const byte *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a494883429ba0c7d58cdb3e1648106d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff87c1bd4a26054bba9d8a8f64484b9"><td class="memItemLeft" align="right" valign="top">static byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a4ff87c1bd4a26054bba9d8a8f64484b9">recv_parse_or_apply_log_rec_body</a> (byte <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, byte *ptr, byte *end_ptr, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, ulint space_id)</td></tr>
<tr class="separator:a4ff87c1bd4a26054bba9d8a8f64484b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb669dd1cc853e214cef4b8f40095f33"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#acb669dd1cc853e214cef4b8f40095f33">recv_fold</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:acb669dd1cc853e214cef4b8f40095f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a59c74dacbb29bc1bf625df47adc412"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a2a59c74dacbb29bc1bf625df47adc412">recv_hash</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a2a59c74dacbb29bc1bf625df47adc412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9044ecd7918959bbba7684abdc3737"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrecv__addr__t.html">recv_addr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a9e9044ecd7918959bbba7684abdc3737">recv_get_fil_addr_struct</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a9e9044ecd7918959bbba7684abdc3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84782e73c99f22b5a637bba491a1601"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#ab84782e73c99f22b5a637bba491a1601">recv_add_to_hash_table</a> (byte <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, byte *body, byte *rec_end, lsn_t start_lsn, lsn_t end_lsn)</td></tr>
<tr class="separator:ab84782e73c99f22b5a637bba491a1601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447effce39ac90b8ae6a1e1e83b0e6cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a447effce39ac90b8ae6a1e1e83b0e6cc">recv_data_copy_to_buf</a> (byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, <a class="el" href="structrecv__t.html">recv_t</a> *recv)</td></tr>
<tr class="separator:a447effce39ac90b8ae6a1e1e83b0e6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bab7e1e70f3c89ccba51bb66a7b5cb8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a6bab7e1e70f3c89ccba51bb66a7b5cb8">recv_recover_page_func</a> (ibool just_read_in, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a6bab7e1e70f3c89ccba51bb66a7b5cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6ea320af235dca02611fc64b850e7a"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a0c6ea320af235dca02611fc64b850e7a">recv_read_in_area</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a0c6ea320af235dca02611fc64b850e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d4a25490a9a0a3723b1c99f22706a3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a66d4a25490a9a0a3723b1c99f22706a3">recv_apply_hashed_log_recs</a> (ibool allow_ibuf)</td></tr>
<tr class="separator:a66d4a25490a9a0a3723b1c99f22706a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ea115aad248388139db286659cb942"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#aa3ea115aad248388139db286659cb942">recv_parse_log_rec</a> (byte *ptr, byte *end_ptr, byte *<a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, ulint *<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint *<a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, byte **body)</td></tr>
<tr class="separator:aa3ea115aad248388139db286659cb942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdbf79f553558fd384331f4cfcf03ec"><td class="memItemLeft" align="right" valign="top">static lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#adcdbf79f553558fd384331f4cfcf03ec">recv_calc_lsn_on_data_add</a> (lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>, ib_uint64_t <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:adcdbf79f553558fd384331f4cfcf03ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1521692ae080bd0623dbb6fddf48886c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a1521692ae080bd0623dbb6fddf48886c">recv_report_corrupt_log</a> (byte *ptr, byte <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a1521692ae080bd0623dbb6fddf48886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8cde203cfb31082640034f72b6f3f1"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a9d8cde203cfb31082640034f72b6f3f1">recv_parse_log_recs</a> (ibool store_to_hash)</td></tr>
<tr class="separator:a9d8cde203cfb31082640034f72b6f3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb0002fb1b8e901558a8d4de135c214"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#aabb0002fb1b8e901558a8d4de135c214">recv_sys_add_to_parsing_buf</a> (const byte *log_block, lsn_t scanned_lsn)</td></tr>
<tr class="separator:aabb0002fb1b8e901558a8d4de135c214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777f3b35cfc87b9d9c5f2b1c47d20229"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a777f3b35cfc87b9d9c5f2b1c47d20229">recv_sys_justify_left_parsing_buf</a> (void)</td></tr>
<tr class="separator:a777f3b35cfc87b9d9c5f2b1c47d20229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f768c3dac723e2444428bb6f1388c3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a44f768c3dac723e2444428bb6f1388c3">recv_scan_log_recs</a> (ulint available_memory, ibool store_to_hash, const byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, lsn_t start_lsn, lsn_t *contiguous_lsn, lsn_t *group_scanned_lsn)</td></tr>
<tr class="separator:a44f768c3dac723e2444428bb6f1388c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e2f5833b549a311d173a58071fae84"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a03e2f5833b549a311d173a58071fae84">recv_group_scan_log_recs</a> (<a class="el" href="structlog__group__t.html">log_group_t</a> *group, lsn_t *contiguous_lsn, lsn_t *group_scanned_lsn)</td></tr>
<tr class="separator:a03e2f5833b549a311d173a58071fae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58d651ba2056c889b8296ad43d5d9c3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#ad58d651ba2056c889b8296ad43d5d9c3">recv_recovery_from_checkpoint_start_func</a> (lsn_t <a class="el" href="srv0start_8cc.html#a1d546c3fcf2f25749006e0d32da645f4">min_flushed_lsn</a>, lsn_t <a class="el" href="srv0start_8cc.html#a451b129f36127c7dc27ad05fe897b792">max_flushed_lsn</a>)</td></tr>
<tr class="separator:ad58d651ba2056c889b8296ad43d5d9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe97c7ed59b6670bd29aabde13ff61b4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#abe97c7ed59b6670bd29aabde13ff61b4">recv_recovery_from_checkpoint_finish</a> (void)</td></tr>
<tr class="separator:abe97c7ed59b6670bd29aabde13ff61b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ed9e29164666b1d7831257c1a04793"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a06ed9e29164666b1d7831257c1a04793">recv_recovery_rollback_active</a> (void)</td></tr>
<tr class="separator:a06ed9e29164666b1d7831257c1a04793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae039612836bd7c4b644a8eea84fa89aa"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#ae039612836bd7c4b644a8eea84fa89aa">recv_reset_logs</a> (lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>)</td></tr>
<tr class="separator:ae039612836bd7c4b644a8eea84fa89aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a618a348bd2f166ce0b5c1745a5d2fe67"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structrecv__sys__t.html">recv_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a618a348bd2f166ce0b5c1745a5d2fe67">recv_sys</a> = NULL</td></tr>
<tr class="separator:a618a348bd2f166ce0b5c1745a5d2fe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8e0bed85575450ddc021d891001b5e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a3e8e0bed85575450ddc021d891001b5e">recv_recovery_on</a></td></tr>
<tr class="separator:a3e8e0bed85575450ddc021d891001b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1caa70b85887f3a22392947f7e3b5a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#aef1caa70b85887f3a22392947f7e3b5a">recv_needed_recovery</a></td></tr>
<tr class="separator:aef1caa70b85887f3a22392947f7e3b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f7a2f3e33bd463d6dea739a1ff7f5b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a47f7a2f3e33bd463d6dea739a1ff7f5b">recv_lsn_checks_on</a></td></tr>
<tr class="separator:a47f7a2f3e33bd463d6dea739a1ff7f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4003bc4d71daf53de4ae643ae48d42"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#abc4003bc4d71daf53de4ae643ae48d42">recv_log_scan_is_startup_type</a></td></tr>
<tr class="separator:abc4003bc4d71daf53de4ae643ae48d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de8d3c1a7b66aa887117635fae926c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a5de8d3c1a7b66aa887117635fae926c0">recv_no_ibuf_operations</a></td></tr>
<tr class="separator:a5de8d3c1a7b66aa887117635fae926c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6ecd3f0dfa3ac76e714fe3bf699655"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a4c6ecd3f0dfa3ac76e714fe3bf699655">recv_scan_print_counter</a></td></tr>
<tr class="separator:a4c6ecd3f0dfa3ac76e714fe3bf699655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a30d94a7dcd44389105fb485bbeca4"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#ad8a30d94a7dcd44389105fb485bbeca4">recv_previous_parsed_rec_type</a></td></tr>
<tr class="separator:ad8a30d94a7dcd44389105fb485bbeca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f24c65829716eb85b58d20b26aac14f"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a5f24c65829716eb85b58d20b26aac14f">recv_previous_parsed_rec_offset</a></td></tr>
<tr class="separator:a5f24c65829716eb85b58d20b26aac14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b8e01590e0efa5ea1170f48dcc8bf7"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#ab4b8e01590e0efa5ea1170f48dcc8bf7">recv_previous_parsed_rec_is_multi</a></td></tr>
<tr class="separator:ab4b8e01590e0efa5ea1170f48dcc8bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfb545c29d88104549d211e426317b5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#aacfb545c29d88104549d211e426317b5">recv_max_parsed_page_no</a></td></tr>
<tr class="separator:aacfb545c29d88104549d211e426317b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a07a6e27d2410a013e5786463fcd59b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a4a07a6e27d2410a013e5786463fcd59b">recv_n_pool_free_frames</a></td></tr>
<tr class="separator:a4a07a6e27d2410a013e5786463fcd59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34015d5dafd1054ff3b840880ca91dbb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a34015d5dafd1054ff3b840880ca91dbb">recv_max_page_lsn</a></td></tr>
<tr class="separator:a34015d5dafd1054ff3b840880ca91dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d0d8855d3bac4c2d604aaff156243e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a53d0d8855d3bac4c2d604aaff156243e">recv_writer_thread_active</a> = false</td></tr>
<tr class="separator:a53d0d8855d3bac4c2d604aaff156243e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b8a453433f368728428e57ef155092"><td class="memItemLeft" align="right" valign="top"><a id="ab6b8a453433f368728428e57ef155092"></a>
UNIV_INTERN os_thread_t&#160;</td><td class="memItemRight" valign="bottom"><b>recv_writer_thread_handle</b> = 0</td></tr>
<tr class="separator:ab6b8a453433f368728428e57ef155092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060b50a6d42d7282c0c67d7d6ae2a043"><td class="memItemLeft" align="right" valign="top">static ulint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8cc.html#a060b50a6d42d7282c0c67d7d6ae2a043">max_field</a></td></tr>
<tr class="separator:a060b50a6d42d7282c0c67d7d6ae2a043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fb9214d68d4d7f44ae03dcf3cb60c3"><td class="memItemLeft" align="right" valign="top"><a id="a12fb9214d68d4d7f44ae03dcf3cb60c3"></a>
ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>max_no</b> = 0</td></tr>
<tr class="separator:a12fb9214d68d4d7f44ae03dcf3cb60c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed08c0ba078c9eca854acd1a9a785c1"><td class="memItemLeft" align="right" valign="top"><a id="a1ed08c0ba078c9eca854acd1a9a785c1"></a>
ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>checkpoint_no</b></td></tr>
<tr class="separator:a1ed08c0ba078c9eca854acd1a9a785c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09950898aae26909cd39999b1d70796d"><td class="memItemLeft" align="right" valign="top"><a id="a09950898aae26909cd39999b1d70796d"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>field</b></td></tr>
<tr class="separator:a09950898aae26909cd39999b1d70796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ed5d3fdf874dd4c8685cb51c3f1a6"><td class="memItemLeft" align="right" valign="top"><a id="a680ed5d3fdf874dd4c8685cb51c3f1a6"></a>
byte *&#160;</td><td class="memItemRight" valign="bottom"><b>buf</b> = log_sys-&gt;checkpoint_buf</td></tr>
<tr class="separator:a680ed5d3fdf874dd4c8685cb51c3f1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9123af540f084d1c0421dccc31e1dd"><td class="memItemLeft" align="right" valign="top"><a id="a0f9123af540f084d1c0421dccc31e1dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>group</b> = <a class="el" href="ut0lst_8h.html#a66c00d8789075273116abec24f7ba487">UT_LIST_GET_FIRST</a>(log_sys-&gt;log_groups)</td></tr>
<tr class="separator:a0f9123af540f084d1c0421dccc31e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e660a9ba64cd9a908159c427010e234"><td class="memItemLeft" align="right" valign="top"><a id="a0e660a9ba64cd9a908159c427010e234"></a>
*&#160;</td><td class="memItemRight" valign="bottom"><b>max_group</b> = NULL</td></tr>
<tr class="separator:a0e660a9ba64cd9a908159c427010e234"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Recovery</p>
<p>Created 9/20/1997 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a599884251054cd22af6500c6fbe03eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599884251054cd22af6500c6fbe03eb8">&#9670;&nbsp;</a></span>RECV_DATA_BLOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RECV_DATA_BLOCK_SIZE&#160;&#160;&#160;(MEM_MAX_ALLOC_IN_BUF - sizeof(<a class="el" href="structrecv__data__t.html">recv_data_t</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log records are stored in the hash table in chunks at most of this size; this must be less than UNIV_PAGE_SIZE as it is stored in the buffer pool </p>

</div>
</div>
<a id="af03f8edafc9d1b7a63fc100dc3301039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03f8edafc9d1b7a63fc100dc3301039">&#9670;&nbsp;</a></span>recv_is_from_backup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define recv_is_from_backup&#160;&#160;&#160;FALSE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE when recovering from a backed up redo log file </p>

</div>
</div>
<a id="a5e0143b997363d0ce9283e4f81e4181e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0143b997363d0ce9283e4f81e4181e">&#9670;&nbsp;</a></span>recv_is_making_a_backup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define recv_is_making_a_backup&#160;&#160;&#160;FALSE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE when the redo log is being backed up </p>

</div>
</div>
<a id="a3295cbcda6a620a2751dc47206d6a02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3295cbcda6a620a2751dc47206d6a02c">&#9670;&nbsp;</a></span>RECV_READ_AHEAD_AREA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RECV_READ_AHEAD_AREA&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-ahead area in applying log records to file pages </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="add1ea68a4bf6d74a6ff8fb1014cdb083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1ea68a4bf6d74a6ff8fb1014cdb083">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull, warn_unused_result)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the maximum consistent checkpoint from the log groups. </p><dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS </dd></dl>

</div>
</div>
<a id="a494883429ba0c7d58cdb3e1648106d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494883429ba0c7d58cdb3e1648106d8b">&#9670;&nbsp;</a></span>log_block_checksum_is_ok_or_old_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool log_block_checksum_is_ok_or_old_format </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks the 4-byte checksum to the trailer checksum field of a log block. We also accept a log block in the old format before InnoDB-3.23.52 where the checksum field contains the log block number. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok, or if the log block may be in the format of InnoDB version predating 3.23.52 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to a log block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab84782e73c99f22b5a637bba491a1601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84782e73c99f22b5a637bba491a1601">&#9670;&nbsp;</a></span>recv_add_to_hash_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void recv_add_to_hash_table </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>rec_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>end_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new log record to the hash table of log records. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: log record type </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
    <tr><td class="paramname">body</td><td>in: log record body </td></tr>
    <tr><td class="paramname">rec_end</td><td>in: log record end </td></tr>
    <tr><td class="paramname">start_lsn</td><td>in: start lsn of the mtr </td></tr>
    <tr><td class="paramname">end_lsn</td><td>in: end lsn of the mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66d4a25490a9a0a3723b1c99f22706a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d4a25490a9a0a3723b1c99f22706a3">&#9670;&nbsp;</a></span>recv_apply_hashed_log_recs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_apply_hashed_log_recs </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>allow_ibuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empties the hash table of stored log records, applying them to appropriate pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allow_ibuf</td><td>in: if TRUE, also ibuf operations are allowed during the application; if FALSE, no ibuf operations are allowed, and after the application all file pages are flushed to disk and invalidated in buffer pool: this alternative means that no new log records can be generated during the application; the caller must in this case own the log mutex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcdbf79f553558fd384331f4cfcf03ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdbf79f553558fd384331f4cfcf03ec">&#9670;&nbsp;</a></span>recv_calc_lsn_on_data_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static lsn_t recv_calc_lsn_on_data_add </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the new value for lsn when more data is added to the log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lsn</td><td>in: old lsn </td></tr>
    <tr><td class="paramname">len</td><td>in: this many bytes of data is added, log block headers not included </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3d4e607344ca74b3e3402a6c2b9e50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d4e607344ca74b3e3402a6c2b9e50b">&#9670;&nbsp;</a></span>recv_check_cp_is_consistent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool recv_check_cp_is_consistent </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks the consistency of the checkpoint info </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in: buffer containing checkpoint info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a447effce39ac90b8ae6a1e1e83b0e6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447effce39ac90b8ae6a1e1e83b0e6cc">&#9670;&nbsp;</a></span>recv_data_copy_to_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void recv_data_copy_to_buf </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrecv__t.html">recv_t</a> *&#160;</td>
          <td class="paramname"><em>recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the log record body from recv to buf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in: buffer of length at least recv-&gt;len </td></tr>
    <tr><td class="paramname">recv</td><td>in: log record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb669dd1cc853e214cef4b8f40095f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb669dd1cc853e214cef4b8f40095f33">&#9670;&nbsp;</a></span>recv_fold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint recv_fold </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the fold value of a page file address: used in inserting or searching for a log record in the hash table. </p><dl class="section return"><dt>Returns</dt><dd>folded value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e9044ecd7918959bbba7684abdc3737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9044ecd7918959bbba7684abdc3737">&#9670;&nbsp;</a></span>recv_get_fil_addr_struct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrecv__addr__t.html">recv_addr_t</a>* recv_get_fil_addr_struct </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the hashed file address struct for a page. </p><dl class="section return"><dt>Returns</dt><dd>file address struct, NULL if not found from the hash table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03e2f5833b549a311d173a58071fae84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e2f5833b549a311d173a58071fae84">&#9670;&nbsp;</a></span>recv_group_scan_log_recs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void recv_group_scan_log_recs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlog__group__t.html">log_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t *&#160;</td>
          <td class="paramname"><em>contiguous_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t *&#160;</td>
          <td class="paramname"><em>group_scanned_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scans log from a buffer and stores new log data to the parsing buffer. Parses and hashes the log records if new data found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>in: log group </td></tr>
    <tr><td class="paramname">contiguous_lsn</td><td>in/out: it is known that all log groups contain contiguous log data up to this lsn </td></tr>
    <tr><td class="paramname">group_scanned_lsn</td><td>out: scanning succeeded up to this lsn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a59c74dacbb29bc1bf625df47adc412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a59c74dacbb29bc1bf625df47adc412">&#9670;&nbsp;</a></span>recv_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint recv_hash </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the hash value of a page file address: used in inserting or searching for a log record in the hash table. </p><dl class="section return"><dt>Returns</dt><dd>folded value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae28110ea7dec38ca47b81da1b6947687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28110ea7dec38ca47b81da1b6947687">&#9670;&nbsp;</a></span>recv_init_crash_recovery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void recv_init_crash_recovery </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize crash recovery environment. Can be called iff recv_needed_recovery == FALSE. </p>

</div>
</div>
<a id="aa3ea115aad248388139db286659cb942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ea115aad248388139db286659cb942">&#9670;&nbsp;</a></span>recv_parse_log_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint recv_parse_log_rec </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to parse a single log record and returns its length. </p><dl class="section return"><dt>Returns</dt><dd>length of the record, or 0 if the record was not complete </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: pointer to a buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: pointer to the buffer end </td></tr>
    <tr><td class="paramname">type</td><td>out: type </td></tr>
    <tr><td class="paramname">space</td><td>out: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>out: page number </td></tr>
    <tr><td class="paramname">body</td><td>out: log record body start </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d8cde203cfb31082640034f72b6f3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8cde203cfb31082640034f72b6f3f1">&#9670;&nbsp;</a></span>recv_parse_log_recs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool recv_parse_log_recs </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>store_to_hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parses log records from a buffer and stores them to a hash table to wait merging to file pages. </p><dl class="section return"><dt>Returns</dt><dd>currently always returns FALSE </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store_to_hash</td><td>in: TRUE if the records should be stored to the hash table; this is set to FALSE if just debug checking is needed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ff87c1bd4a26054bba9d8a8f64484b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff87c1bd4a26054bba9d8a8f64484b9">&#9670;&nbsp;</a></span>recv_parse_or_apply_log_rec_body()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static byte* recv_parse_or_apply_log_rec_body </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to parse a single log record body and also applies it to a page if specified. File ops are parsed, but not applied in this function. </p><dl class="section return"><dt>Returns</dt><dd>log record end, NULL if not a complete record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: type </td></tr>
    <tr><td class="paramname">ptr</td><td>in: pointer to a buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: pointer to the buffer end </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block or NULL; if not NULL, then the log record is applied to the page, and the log record should be complete then </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL; should be non-NULL if and only if block is non-NULL </td></tr>
    <tr><td class="paramname">space_id</td><td>in: tablespace id obtained by parsing initial log record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c6ea320af235dca02611fc64b850e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6ea320af235dca02611fc64b850e7a">&#9670;&nbsp;</a></span>recv_read_in_area()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint recv_read_in_area </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads in pages which have hashed log records, from an area around a given page number. </p><dl class="section return"><dt>Returns</dt><dd>number of pages found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes, or 0 </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bab7e1e70f3c89ccba51bb66a7b5cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bab7e1e70f3c89ccba51bb66a7b5cb8">&#9670;&nbsp;</a></span>recv_recover_page_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_recover_page_func </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>just_read_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the hashed log records to the page, if the page lsn is less than the lsn of a log record. This can be called when a buffer page has just been read in, or also for a page already in the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">just_read_in</td><td>in: TRUE if the i/o handler calls this for a freshly read page </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe97c7ed59b6670bd29aabde13ff61b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe97c7ed59b6670bd29aabde13ff61b4">&#9670;&nbsp;</a></span>recv_recovery_from_checkpoint_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_recovery_from_checkpoint_finish </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes recovery from a checkpoint. </p>

</div>
</div>
<a id="ad58d651ba2056c889b8296ad43d5d9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58d651ba2056c889b8296ad43d5d9c3">&#9670;&nbsp;</a></span>recv_recovery_from_checkpoint_start_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> recv_recovery_from_checkpoint_start_func </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>min_flushed_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>max_flushed_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recovers from a checkpoint. When this function returns, the database is able to start processing of new user transactions, but the function recv_recovery_from_checkpoint_finish should be called later to complete the recovery and free the resources used in it. </p><dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS </dd></dl>
<p>TRUE when recovering from a checkpoint</p>
<p>Recover up to this log sequence number </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_flushed_lsn</td><td>in: min flushed lsn from data files </td></tr>
    <tr><td class="paramname">max_flushed_lsn</td><td>in: max flushed lsn from data files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06ed9e29164666b1d7831257c1a04793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ed9e29164666b1d7831257c1a04793">&#9670;&nbsp;</a></span>recv_recovery_rollback_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_recovery_rollback_active </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates the rollback of active transactions. </p>

</div>
</div>
<a id="a1521692ae080bd0623dbb6fddf48886c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1521692ae080bd0623dbb6fddf48886c">&#9670;&nbsp;</a></span>recv_report_corrupt_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void recv_report_corrupt_log </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints diagnostic info of corrupt log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: pointer to corrupt log record </td></tr>
    <tr><td class="paramname">type</td><td>in: type of the record </td></tr>
    <tr><td class="paramname">space</td><td>in: space id, this may also be garbage </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number, this may also be garbage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae039612836bd7c4b644a8eea84fa89aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae039612836bd7c4b644a8eea84fa89aa">&#9670;&nbsp;</a></span>recv_reset_logs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_reset_logs </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the logs. The contents of log files will be lost! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lsn</td><td>in: reset to this lsn rounded up to be divisible by OS_FILE_LOG_BLOCK_SIZE, after which we add LOG_BLOCK_HDR_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44f768c3dac723e2444428bb6f1388c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f768c3dac723e2444428bb6f1388c3">&#9670;&nbsp;</a></span>recv_scan_log_recs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool recv_scan_log_recs </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>available_memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>store_to_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t *&#160;</td>
          <td class="paramname"><em>contiguous_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t *&#160;</td>
          <td class="paramname"><em>group_scanned_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans log from a buffer and stores new log data to the parsing buffer. Parses and hashes the log records if new data found. Unless UNIV_HOTBACKUP is defined, this function will apply log records automatically when the hash table becomes full. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if limit_lsn has been reached, or not able to scan any more in this log group </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">available_memory</td><td>in: we let the hash table of recs to grow to this size, at the maximum </td></tr>
    <tr><td class="paramname">store_to_hash</td><td>in: TRUE if the records should be stored to the hash table; this is set to FALSE if just debug checking is needed </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer containing a log segment or garbage </td></tr>
    <tr><td class="paramname">len</td><td>in: buffer length </td></tr>
    <tr><td class="paramname">start_lsn</td><td>in: buffer start lsn </td></tr>
    <tr><td class="paramname">contiguous_lsn</td><td>in/out: it is known that all log groups contain contiguous log data up to this lsn </td></tr>
    <tr><td class="paramname">group_scanned_lsn</td><td>out: scanning succeeded up to this lsn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa94c57b83ed03df57a0fb49ca7d7fc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94c57b83ed03df57a0fb49ca7d7fc2d">&#9670;&nbsp;</a></span>recv_synchronize_groups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void recv_synchronize_groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a log segment from the most up-to-date log group to the other log groups, so that they all contain the latest log data. Also writes the info about the latest checkpoint to the groups, and inits the fields in the group memory structs to up-to-date values. </p>

</div>
</div>
<a id="aabb0002fb1b8e901558a8d4de135c214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb0002fb1b8e901558a8d4de135c214">&#9670;&nbsp;</a></span>recv_sys_add_to_parsing_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool recv_sys_add_to_parsing_buf </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>log_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>scanned_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds data from a new log block to the parsing buffer of recv_sys if recv_sys-&gt;parse_start_lsn is non-zero. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if more data added </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_block</td><td>in: log block </td></tr>
    <tr><td class="paramname">scanned_lsn</td><td>in: lsn of how far we were able to find data in this log block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65b14557f39abeba9b80bd66fbc96aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b14557f39abeba9b80bd66fbc96aeb">&#9670;&nbsp;</a></span>recv_sys_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release recovery system mutexes. </p>

</div>
</div>
<a id="aaa6a2e802976bbca76d67d8788c711d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6a2e802976bbca76d67d8788c711d8">&#9670;&nbsp;</a></span>recv_sys_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the recovery system. </p>

</div>
</div>
<a id="a44eecde9bf48472bcf4bcc16a4c74372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44eecde9bf48472bcf4bcc16a4c74372">&#9670;&nbsp;</a></span>recv_sys_debug_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void recv_sys_debug_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees the recovery system. </p>

</div>
</div>
<a id="a845af78fbf918cb6f7614ec20b43ede4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845af78fbf918cb6f7614ec20b43ede4">&#9670;&nbsp;</a></span>recv_sys_empty_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void recv_sys_empty_hash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Empties the hash table when it has been fully processed. </p>

</div>
</div>
<a id="af78f6b379d555b6609120b94a88e48c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78f6b379d555b6609120b94a88e48c8">&#9670;&nbsp;</a></span>recv_sys_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>available_memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inits the recovery system for a recovery operation. in: available memory in bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">available_memory</td><td>in: available memory in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a777f3b35cfc87b9d9c5f2b1c47d20229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777f3b35cfc87b9d9c5f2b1c47d20229">&#9670;&nbsp;</a></span>recv_sys_justify_left_parsing_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void recv_sys_justify_left_parsing_buf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves the parsing buffer data left to the buffer start. </p>

</div>
</div>
<a id="a41975a23eb880acab4a47274910cd338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41975a23eb880acab4a47274910cd338">&#9670;&nbsp;</a></span>recv_sys_mem_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_mem_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the recovery system memory. </p>

</div>
</div>
<a id="aa292eaf15cfd7536fefda28f01a19a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa292eaf15cfd7536fefda28f01a19a7e">&#9670;&nbsp;</a></span>recv_sys_var_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_var_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the state of the recovery system variables. </p>

</div>
</div>
<a id="a8a156f8e7f1b461bc434a3dbd0b6a990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a156f8e7f1b461bc434a3dbd0b6a990">&#9670;&nbsp;</a></span>recv_writer_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>() recv_writer_thread </td>
          <td>(</td>
          <td class="paramtype">void *arg &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>recv_writer thread tasked with flushing dirty pages from the buffer pools. </p><dl class="section return"><dt>Returns</dt><dd>a dummy parameter </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__attribute__</td><td>in: a dummy parameter required by os_thread_create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a060b50a6d42d7282c0c67d7d6ae2a043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060b50a6d42d7282c0c67d7d6ae2a043">&#9670;&nbsp;</a></span>max_field</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* max_field</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <a class="code" href="structlog__group__t.html">log_group_t</a>*    group</div><div class="ttc" id="structlog__group__t_html"><div class="ttname"><a href="structlog__group__t.html">log_group_t</a></div><div class="ttdef"><b>Definition:</b> log0log.h:713</div></div>
</div><!-- fragment --><p>&lt; out: max group</p>
<p>&lt; out: LOG_CHECKPOINT_1 or LOG_CHECKPOINT_2 </p>

</div>
</div>
<a id="abc4003bc4d71daf53de4ae643ae48d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4003bc4d71daf53de4ae643ae48d42">&#9670;&nbsp;</a></span>recv_log_scan_is_startup_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ibool recv_log_scan_is_startup_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>There are two conditions under which we scan the logs, the first is normal startup and the second is when we do a recovery from an archive. This flag is set if we are doing a scan from the last checkpoint during startup. If we find log entries that were written after the last checkpoint we know that the server was not cleanly shutdown. We must then initialize the crash recovery environment before attempting to store these entries in the log hash table. </p>

</div>
</div>
<a id="a47f7a2f3e33bd463d6dea739a1ff7f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f7a2f3e33bd463d6dea739a1ff7f5b">&#9670;&nbsp;</a></span>recv_lsn_checks_on</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool recv_lsn_checks_on</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if <a class="el" href="buf0buf_8cc.html#a97d1cedcc7115ef5e7518d26cc24ccbc">buf_page_is_corrupted()</a> should check if the log sequence number (FIL_PAGE_LSN) is in the future. Initially FALSE, and set by <a class="el" href="log0recv_8cc.html#ad58d651ba2056c889b8296ad43d5d9c3">recv_recovery_from_checkpoint_start_func()</a>. </p>

</div>
</div>
<a id="a34015d5dafd1054ff3b840880ca91dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34015d5dafd1054ff3b840880ca91dbb">&#9670;&nbsp;</a></span>recv_max_page_lsn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN lsn_t recv_max_page_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum lsn we see for a page during the recovery process. If this is bigger than the lsn we are able to scan up to, that is an indication that the recovery failed and the database may be corrupt. </p>

</div>
</div>
<a id="aacfb545c29d88104549d211e426317b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfb545c29d88104549d211e426317b5">&#9670;&nbsp;</a></span>recv_max_parsed_page_no</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint recv_max_parsed_page_no</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum page number encountered in the redo log </p>

</div>
</div>
<a id="a4a07a6e27d2410a013e5786463fcd59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a07a6e27d2410a013e5786463fcd59b">&#9670;&nbsp;</a></span>recv_n_pool_free_frames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint recv_n_pool_free_frames</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This many frames must be left free in the buffer pool when we scan the log and store the scanned log records in the buffer pool: we will use these free frames to read in pages when we start applying the log records to the database. This is the default value. If the actual size of the buffer pool is larger than 10 MB we'll set this value to 512. </p>

</div>
</div>
<a id="aef1caa70b85887f3a22392947f7e3b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1caa70b85887f3a22392947f7e3b5a">&#9670;&nbsp;</a></span>recv_needed_recovery</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool recv_needed_recovery</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE when <a class="el" href="log0recv_8cc.html#ae28110ea7dec38ca47b81da1b6947687">recv_init_crash_recovery()</a> has been called. </p>

</div>
</div>
<a id="a5de8d3c1a7b66aa887117635fae926c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de8d3c1a7b66aa887117635fae926c0">&#9670;&nbsp;</a></span>recv_no_ibuf_operations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool recv_no_ibuf_operations</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the following is TRUE, the buffer pool file pages must be invalidated after recovery and no ibuf operations are allowed; this becomes TRUE if the log record hash table becomes too full, and log records must be merged to file pages already before the recovery is finished: in this case no ibuf operations are allowed, as they could modify the pages read in the buffer pool before the pages have been recovered to the up-to-date state.</p>
<p>TRUE means that recovery is running and no operations on the log files are allowed yet: the variable name is misleading. </p>

</div>
</div>
<a id="ab4b8e01590e0efa5ea1170f48dcc8bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b8e01590e0efa5ea1170f48dcc8bf7">&#9670;&nbsp;</a></span>recv_previous_parsed_rec_is_multi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint recv_previous_parsed_rec_is_multi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The 'multi' flag of the previous parsed redo log record </p>

</div>
</div>
<a id="a5f24c65829716eb85b58d20b26aac14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f24c65829716eb85b58d20b26aac14f">&#9670;&nbsp;</a></span>recv_previous_parsed_rec_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint recv_previous_parsed_rec_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The offset of the previous parsed redo log record </p>

</div>
</div>
<a id="ad8a30d94a7dcd44389105fb485bbeca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a30d94a7dcd44389105fb485bbeca4">&#9670;&nbsp;</a></span>recv_previous_parsed_rec_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint recv_previous_parsed_rec_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The type of the previous parsed redo log record </p>

</div>
</div>
<a id="a3e8e0bed85575450ddc021d891001b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8e0bed85575450ddc021d891001b5e">&#9670;&nbsp;</a></span>recv_recovery_on</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool recv_recovery_on</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE when applying redo log records during crash recovery; FALSE otherwise. Note that this is FALSE while a background thread is rolling back incomplete transactions. </p>

</div>
</div>
<a id="a4c6ecd3f0dfa3ac76e714fe3bf699655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6ecd3f0dfa3ac76e714fe3bf699655">&#9670;&nbsp;</a></span>recv_scan_print_counter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint recv_scan_print_counter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following counter is used to decide when to print info on log scan </p>

</div>
</div>
<a id="a618a348bd2f166ce0b5c1745a5d2fe67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618a348bd2f166ce0b5c1745a5d2fe67">&#9670;&nbsp;</a></span>recv_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structrecv__sys__t.html">recv_sys_t</a>* recv_sys = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The recovery system </p>

</div>
</div>
<a id="a53d0d8855d3bac4c2d604aaff156243e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d0d8855d3bac4c2d604aaff156243e">&#9670;&nbsp;</a></span>recv_writer_thread_active</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool recv_writer_thread_active = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicating if recv_writer thread is active. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: MDL_lock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_m_d_l__lock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MDL_lock Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for MDL_lock:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_m_d_l__lock.png" usemap="#MDL_5Flock_map" alt=""/>
  <map id="MDL_5Flock_map" name="MDL_5Flock_map">
<area href="class_m_d_l__object__lock.html" alt="MDL_object_lock" shape="rect" coords="0,56,117,80"/>
<area href="class_m_d_l__scoped__lock.html" alt="MDL_scoped_lock" shape="rect" coords="127,56,244,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock_1_1_ticket__list.html">Ticket_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af49d3a2db62c2c6dda844e0d4531ab12"><td class="memItemLeft" align="right" valign="top"><a id="af49d3a2db62c2c6dda844e0d4531ab12"></a>
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>bitmap_t</b></td></tr>
<tr class="separator:af49d3a2db62c2c6dda844e0d4531ab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cdf73e78c2f3288e20676e9ec19ea5"><td class="memItemLeft" align="right" valign="top"><a id="a32cdf73e78c2f3288e20676e9ec19ea5"></a>
typedef <a class="el" href="class_i___p___list__iterator.html">Ticket_list::List::Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Ticket_iterator</b></td></tr>
<tr class="separator:a32cdf73e78c2f3288e20676e9ec19ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f746450dc5bc7ae141d907ae34b2f3a"><td class="memItemLeft" align="right" valign="top"><a id="a1f746450dc5bc7ae141d907ae34b2f3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_empty</b> () const</td></tr>
<tr class="separator:a1f746450dc5bc7ae141d907ae34b2f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8993c86b210f7cb61c80220329e6e02a"><td class="memItemLeft" align="right" valign="top"><a id="a8993c86b210f7cb61c80220329e6e02a"></a>
virtual const bitmap_t *&#160;</td><td class="memItemRight" valign="bottom"><b>incompatible_granted_types_bitmap</b> () const =0</td></tr>
<tr class="separator:a8993c86b210f7cb61c80220329e6e02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c904f6afb66ebb7e8db07134fe323b"><td class="memItemLeft" align="right" valign="top"><a id="ad3c904f6afb66ebb7e8db07134fe323b"></a>
virtual const bitmap_t *&#160;</td><td class="memItemRight" valign="bottom"><b>incompatible_waiting_types_bitmap</b> () const =0</td></tr>
<tr class="separator:ad3c904f6afb66ebb7e8db07134fe323b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7707e02d9695b5694336787a622b0060"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a7707e02d9695b5694336787a622b0060">has_pending_conflicting_lock</a> (enum_mdl_type <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:a7707e02d9695b5694336787a622b0060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1679df85ff792e2f45916a0c49e9ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#abb1679df85ff792e2f45916a0c49e9ea">can_grant_lock</a> (enum_mdl_type <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, <a class="el" href="class_m_d_l__context.html">MDL_context</a> *requstor_ctx, bool ignore_lock_priority) const</td></tr>
<tr class="separator:abb1679df85ff792e2f45916a0c49e9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07003cc6619a99b6cc36f564c62e4e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a07003cc6619a99b6cc36f564c62e4e94">reschedule_waiters</a> ()</td></tr>
<tr class="separator:a07003cc6619a99b6cc36f564c62e4e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7adbc9462b159451a388353ca59df8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a6c7adbc9462b159451a388353ca59df8">remove_ticket</a> (<a class="el" href="class_m_d_l__lock_1_1_ticket__list.html">Ticket_list</a> MDL_lock::*queue, <a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="separator:a6c7adbc9462b159451a388353ca59df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e5025d3f3cff97923bc283c715566d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a56e5025d3f3cff97923bc283c715566d">visit_subgraph</a> (<a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *waiting_ticket, <a class="el" href="class_m_d_l__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *gvisitor)</td></tr>
<tr class="separator:a56e5025d3f3cff97923bc283c715566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac381385a3fe30868791370db3e1c94ad"><td class="memItemLeft" align="right" valign="top"><a id="ac381385a3fe30868791370db3e1c94ad"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>needs_notification</b> (const <a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *ticket) const =0</td></tr>
<tr class="separator:ac381385a3fe30868791370db3e1c94ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7cbf9885b20cf2416ce625a2715531"><td class="memItemLeft" align="right" valign="top"><a id="a0e7cbf9885b20cf2416ce625a2715531"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>notify_conflicting_locks</b> (<a class="el" href="class_m_d_l__context.html">MDL_context</a> *ctx)=0</td></tr>
<tr class="separator:a0e7cbf9885b20cf2416ce625a2715531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859c4eb6f130447d4b94c125c232ceca"><td class="memItemLeft" align="right" valign="top"><a id="a859c4eb6f130447d4b94c125c232ceca"></a>
virtual bitmap_t&#160;</td><td class="memItemRight" valign="bottom"><b>hog_lock_types_bitmap</b> () const =0</td></tr>
<tr class="separator:a859c4eb6f130447d4b94c125c232ceca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4612530248e072e71efd50e2304b82"><td class="memItemLeft" align="right" valign="top"><a id="aba4612530248e072e71efd50e2304b82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MDL_lock</b> (const <a class="el" href="class_m_d_l__key.html">MDL_key</a> *key_arg, <a class="el" href="class_m_d_l__map__partition.html">MDL_map_partition</a> *map_part)</td></tr>
<tr class="separator:aba4612530248e072e71efd50e2304b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2465460ca8b04f73d2381043a997dfed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_d_l__lock.html">MDL_lock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a2465460ca8b04f73d2381043a997dfed">create</a> (const <a class="el" href="class_m_d_l__key.html">MDL_key</a> *<a class="el" href="class_m_d_l__lock.html#aefb48179bc3f6ef64c213b253c379da4">key</a>, <a class="el" href="class_m_d_l__map__partition.html">MDL_map_partition</a> *map_part)</td></tr>
<tr class="separator:a2465460ca8b04f73d2381043a997dfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b25c48d98250c1603a5c55eeace3986"><td class="memItemLeft" align="right" valign="top"><a id="a0b25c48d98250c1603a5c55eeace3986"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> (<a class="el" href="class_m_d_l__lock.html">MDL_lock</a> *lock)</td></tr>
<tr class="separator:a0b25c48d98250c1603a5c55eeace3986"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aefb48179bc3f6ef64c213b253c379da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_d_l__key.html">MDL_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#aefb48179bc3f6ef64c213b253c379da4">key</a></td></tr>
<tr class="separator:aefb48179bc3f6ef64c213b253c379da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1308b4506d8cb6d754b4f173e3aa4962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___thread__instrumentation.html#ga91f9e9de0d35a9c7ebfdaaeaf6934f52">mysql_prlock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">m_rwlock</a></td></tr>
<tr class="separator:a1308b4506d8cb6d754b4f173e3aa4962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188dd53561f6cf6148277512b706ea74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_d_l__lock_1_1_ticket__list.html">Ticket_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a188dd53561f6cf6148277512b706ea74">m_granted</a></td></tr>
<tr class="separator:a188dd53561f6cf6148277512b706ea74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4443cad6b484e2af5c816949ddb209dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_d_l__lock_1_1_ticket__list.html">Ticket_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a4443cad6b484e2af5c816949ddb209dc">m_waiting</a></td></tr>
<tr class="separator:a4443cad6b484e2af5c816949ddb209dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab173b2eb68fdd6de02d9e4e8a0c94405"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#ab173b2eb68fdd6de02d9e4e8a0c94405">m_hog_lock_count</a></td></tr>
<tr class="separator:ab173b2eb68fdd6de02d9e4e8a0c94405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5656ede3fc7772e612f6ae5c9a32a7"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a5a5656ede3fc7772e612f6ae5c9a32a7">m_ref_usage</a></td></tr>
<tr class="separator:a5a5656ede3fc7772e612f6ae5c9a32a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ae1fe3de8bd7d46cdd8e8428d2e8b8"><td class="memItemLeft" align="right" valign="top"><a id="a36ae1fe3de8bd7d46cdd8e8428d2e8b8"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_ref_release</b></td></tr>
<tr class="separator:a36ae1fe3de8bd7d46cdd8e8428d2e8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53b8e719370bc438e91bbb09549ec5b"><td class="memItemLeft" align="right" valign="top"><a id="af53b8e719370bc438e91bbb09549ec5b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_is_destroyed</b></td></tr>
<tr class="separator:af53b8e719370bc438e91bbb09549ec5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2e5e43c2e415d9205e7fdc227ceb2e"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#a6c2e5e43c2e415d9205e7fdc227ceb2e">m_version</a></td></tr>
<tr class="separator:a6c2e5e43c2e415d9205e7fdc227ceb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1abde8ba2ec734301891301ff8d99ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_d_l__map__partition.html">MDL_map_partition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_d_l__lock.html#aa1abde8ba2ec734301891301ff8d99ff">m_map_part</a></td></tr>
<tr class="separator:aa1abde8ba2ec734301891301ff8d99ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The lock context. Created internally for an acquired lock. For a given name, there exists only one <a class="el" href="class_m_d_l__lock.html">MDL_lock</a> instance, and it exists only when the lock has been granted. Can be seen as an MDL subsystem's version of <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a>.</p>
<p>This is an abstract class which lacks information about compatibility rules for lock types. They should be specified in its descendants. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abb1679df85ff792e2f45916a0c49e9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1679df85ff792e2f45916a0c49e9ea">&#9670;&nbsp;</a></span>can_grant_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::can_grant_lock </td>
          <td>(</td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>type_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__context.html">MDL_context</a> *&#160;</td>
          <td class="paramname"><em>requestor_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_lock_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if request for the metadata lock can be satisfied given its current state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_arg</td><td>The requested lock type. </td></tr>
    <tr><td class="paramname">requestor_ctx</td><td>The MDL context of the requestor. </td></tr>
    <tr><td class="paramname">ignore_lock_priority</td><td>Ignore lock priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Lock request can be satisfied </td></tr>
    <tr><td class="paramname">FALSE</td><td>There is some conflicting lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In cases then current context already has "stronger" type of lock on the object it will be automatically granted thanks to usage of the <a class="el" href="class_m_d_l__context.html#ad38694ab0fa2d63ac1c1d56c80966a21">MDL_context::find_ticket()</a> method. </dd></dl>

</div>
</div>
<a id="a2465460ca8b04f73d2381043a997dfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2465460ca8b04f73d2381043a997dfed">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_d_l__lock.html">MDL_lock</a> * MDL_lock::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_d_l__key.html">MDL_key</a> *&#160;</td>
          <td class="paramname"><em>mdl_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__map__partition.html">MDL_map_partition</a> *&#160;</td>
          <td class="paramname"><em>map_part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary functions needed for creation/destruction of <a class="el" href="class_m_d_l__lock.html">MDL_lock</a> objects.</p>
<dl class="section note"><dt>Note</dt><dd>Also chooses an <a class="el" href="class_m_d_l__lock.html">MDL_lock</a> descendant appropriate for object namespace. </dd></dl>

</div>
</div>
<a id="a7707e02d9695b5694336787a622b0060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7707e02d9695b5694336787a622b0060">&#9670;&nbsp;</a></span>has_pending_conflicting_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::has_pending_conflicting_lock </td>
          <td>(</td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if we have any pending locks which conflict with existing shared lock.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The ticket must match an acquired lock.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if there is a conflicting lock request, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a6c7adbc9462b159451a388353ca59df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7adbc9462b159451a388353ca59df8">&#9670;&nbsp;</a></span>remove_ticket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::remove_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__lock_1_1_ticket__list.html">Ticket_list</a> MDL_lock::*&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a ticket from waiting or pending queue and wakeup up waiters. </p>

</div>
</div>
<a id="a07003cc6619a99b6cc36f564c62e4e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07003cc6619a99b6cc36f564c62e4e94">&#9670;&nbsp;</a></span>reschedule_waiters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::reschedule_waiters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine waiting contexts which requests for the lock can be satisfied, grant lock to them and wake them up.</p>
<dl class="section note"><dt>Note</dt><dd>Together with MDL_lock::add_ticket() this method implements fair scheduling among requests with the same priority. It tries to grant lock from the head of waiters list, while add_ticket() adds new requests to the back of this list. </dd></dl>

</div>
</div>
<a id="a56e5025d3f3cff97923bc283c715566d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e5025d3f3cff97923bc283c715566d">&#9670;&nbsp;</a></span>visit_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::visit_subgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_d_l__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>waiting_ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_d_l__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *&#160;</td>
          <td class="paramname"><em>gvisitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A fragment of recursive traversal of the wait-for graph in search for deadlocks. Direct the deadlock visitor to all contexts that own the lock the current node in the wait-for graph is waiting for. As long as the initial node is remembered in the visitor, a deadlock is found when the same node is seen twice. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aefb48179bc3f6ef64c213b253c379da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb48179bc3f6ef64c213b253c379da4">&#9670;&nbsp;</a></span>key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_d_l__key.html">MDL_key</a> MDL_lock::key</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The key of the object (data) being protected. </p>

</div>
</div>
<a id="a188dd53561f6cf6148277512b706ea74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188dd53561f6cf6148277512b706ea74">&#9670;&nbsp;</a></span>m_granted</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_d_l__lock_1_1_ticket__list.html">Ticket_list</a> MDL_lock::m_granted</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_list.html">List</a> of granted tickets for this lock. </p>

</div>
</div>
<a id="ab173b2eb68fdd6de02d9e4e8a0c94405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab173b2eb68fdd6de02d9e4e8a0c94405">&#9670;&nbsp;</a></span>m_hog_lock_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulong MDL_lock::m_hog_lock_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of times high priority lock requests have been granted while low priority lock requests were waiting. </p>

</div>
</div>
<a id="aa1abde8ba2ec734301891301ff8d99ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1abde8ba2ec734301891301ff8d99ff">&#9670;&nbsp;</a></span>m_map_part</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_d_l__map__partition.html">MDL_map_partition</a>* MDL_lock::m_map_part</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition of <a class="el" href="class_m_d_l__map.html">MDL_map</a> where the lock is stored. </p>

</div>
</div>
<a id="a5a5656ede3fc7772e612f6ae5c9a32a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5656ede3fc7772e612f6ae5c9a32a7">&#9670;&nbsp;</a></span>m_ref_usage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint MDL_lock::m_ref_usage</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These three members are used to make it possible to separate the MDL_map_partition::m_mutex mutex and <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> in <a class="el" href="class_m_d_l__map.html#a9a1b825896ad4b0a5d04a9cff8bfcaf5">MDL_map::find_or_insert()</a> for increased scalability. The 'm_is_destroyed' member is only set by destroyers that have both the MDL_map_partition::m_mutex and <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a>, thus holding any of the mutexes is sufficient to read it. The 'm_ref_usage; is incremented under protection by MDL_map_partition::m_mutex, but when 'm_is_destroyed' is set to TRUE, this member is moved to be protected by the <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a>. This means that the <a class="el" href="class_m_d_l__map.html#a9a1b825896ad4b0a5d04a9cff8bfcaf5">MDL_map::find_or_insert()</a> which only holds the <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> can compare it to 'm_ref_release' without acquiring MDL_map_partition::m_mutex again and if equal it can also destroy the lock object safely. The 'm_ref_release' is incremented under protection by <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a>. Note since we are only interested in equality of these two counters we don't have to worry about overflows as long as their size is big enough to hold maximum number of concurrent threads on the system. </p>

</div>
</div>
<a id="a1308b4506d8cb6d754b4f173e3aa4962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1308b4506d8cb6d754b4f173e3aa4962">&#9670;&nbsp;</a></span>m_rwlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___thread__instrumentation.html#ga91f9e9de0d35a9c7ebfdaaeaf6934f52">mysql_prlock_t</a> MDL_lock::m_rwlock</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-write lock protecting this lock context.</p>
<dl class="section note"><dt>Note</dt><dd>The fact that we use read-write lock prefers readers here is important as deadlock detector won't work correctly otherwise.</dd></dl>
<p>For example, imagine that we have following waiters graph: </p><pre class="fragment">         ctxA -&gt; obj1 -&gt; ctxB -&gt; obj1 -|
          ^                            |
          |----------------------------|
</pre><p>and both ctxA and ctxB start deadlock detection process:</p>
<p>ctxA read-locks obj1 ctxB read-locks obj2 ctxA goes deeper ctxB goes deeper</p>
<p>Now ctxC comes in who wants to start waiting on obj1, also ctxD comes in who wants to start waiting on obj2.</p>
<p>ctxC tries to write-lock obj1 ctxD tries to write-lock obj2 ctxC is blocked ctxD is blocked</p>
<p>Now ctxA and ctxB resume their search:</p>
<p>ctxA tries to read-lock obj2 ctxB tries to read-lock obj1</p>
<p>If m_rwlock prefers writes (or fair) both ctxA and ctxB would be blocked because of pending write locks from ctxD and ctxC correspondingly. Thus we will get a deadlock in deadlock detector. If m_wrlock prefers readers (actually ignoring pending writers is enough) ctxA and ctxB will continue and no deadlock will occur. </p>

</div>
</div>
<a id="a6c2e5e43c2e415d9205e7fdc227ceb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2e5e43c2e415d9205e7fdc227ceb2e">&#9670;&nbsp;</a></span>m_version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong MDL_lock::m_version</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We use the same idea and an additional version counter to support caching of unused <a class="el" href="class_m_d_l__lock.html">MDL_lock</a> object for further re-use. This counter is incremented while holding both MDL_map_partition::m_mutex and <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> locks each time when a <a class="el" href="class_m_d_l__lock.html">MDL_lock</a> is moved from the partitioned hash to the paritioned unused objects list (or destroyed). A thread, which has found a <a class="el" href="class_m_d_l__lock.html">MDL_lock</a> object for the key in the hash and then released the MDL_map_partition::m_mutex before acquiring the <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a>, can determine that this object was moved to the unused objects list (or destroyed) while it held no locks by comparing the version value which it read while holding the MDL_map_partition::m_mutex with the value read after acquiring the <a class="el" href="class_m_d_l__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a>. Note that since it takes several years to overflow this counter such theoretically possible overflows should not have any practical effects. </p>

</div>
</div>
<a id="a4443cad6b484e2af5c816949ddb209dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4443cad6b484e2af5c816949ddb209dc">&#9670;&nbsp;</a></span>m_waiting</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_d_l__lock_1_1_ticket__list.html">Ticket_list</a> MDL_lock::m_waiting</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tickets for contexts waiting to acquire a lock. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sql/mdl.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

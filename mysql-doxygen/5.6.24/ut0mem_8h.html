<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/ut0mem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ut0mem.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="os0sync_8h_source.html">os0sync.h</a>&quot;</code><br />
<code>#include &quot;ut0mem.ic&quot;</code><br />
</div>
<p><a href="ut0mem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af45d7208632c06d0806165cc2b84370b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#af45d7208632c06d0806165cc2b84370b">ut_malloc</a>(<a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)&#160;&#160;&#160;<a class="el" href="ut0mem_8cc.html#a473e5df78914057653b9507f17af1708">ut_malloc_low</a>(<a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, TRUE)</td></tr>
<tr class="separator:af45d7208632c06d0806165cc2b84370b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae46ac5cb8be8d1cba812480a71007cfd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ae46ac5cb8be8d1cba812480a71007cfd">ut_memcpy</a> (void *dest, const void *sour, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:ae46ac5cb8be8d1cba812480a71007cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3869c7f784b9bf5979a9d52e6562523"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ae3869c7f784b9bf5979a9d52e6562523">ut_memmove</a> (void *dest, const void *sour, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:ae3869c7f784b9bf5979a9d52e6562523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606e39d960b5c600f7f02dfd378d4597"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a606e39d960b5c600f7f02dfd378d4597">ut_memcmp</a> (const void *str1, const void *str2, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a606e39d960b5c600f7f02dfd378d4597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b2a56b2abf87ef97001adf5d443513"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a76b2a56b2abf87ef97001adf5d443513">ut_mem_init</a> (void)</td></tr>
<tr class="separator:a76b2a56b2abf87ef97001adf5d443513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537d6138f097170c63331d46958ebf5e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a537d6138f097170c63331d46958ebf5e">ut_malloc_low</a> (ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, ibool assert_on_error) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((malloc))</td></tr>
<tr class="separator:a537d6138f097170c63331d46958ebf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b62984945c78f9b88ff6b857faf6fd4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a9b62984945c78f9b88ff6b857faf6fd4">ut_free</a> (void *ptr)</td></tr>
<tr class="separator:a9b62984945c78f9b88ff6b857faf6fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c82273ea2d85aaa920f319ee6f886e6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a7c82273ea2d85aaa920f319ee6f886e6">ut_realloc</a> (void *ptr, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a7c82273ea2d85aaa920f319ee6f886e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3e259f2b4397229654e3ff855600fc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#abc3e259f2b4397229654e3ff855600fc">ut_free_all_mem</a> (void)</td></tr>
<tr class="separator:abc3e259f2b4397229654e3ff855600fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffcb9c007799972d8166369e540309d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a6ffcb9c007799972d8166369e540309d">ut_strcpy</a> (char *dest, const char *sour)</td></tr>
<tr class="separator:a6ffcb9c007799972d8166369e540309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5def94673c888fec3317cef51176abd1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a5def94673c888fec3317cef51176abd1">ut_strlen</a> (const char *str)</td></tr>
<tr class="separator:a5def94673c888fec3317cef51176abd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d6cde2c9e72b100abd9387345f8d5a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a57d6cde2c9e72b100abd9387345f8d5a">ut_strcmp</a> (const char *str1, const char *str2)</td></tr>
<tr class="separator:a57d6cde2c9e72b100abd9387345f8d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40bcb512f5d8c45a601852e49a5eaeb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#af40bcb512f5d8c45a601852e49a5eaeb">ut_strlcpy</a> (char *dst, const char *src, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:af40bcb512f5d8c45a601852e49a5eaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05589b775b882e0e83716df0616073fd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a05589b775b882e0e83716df0616073fd">ut_strlcpy_rev</a> (char *dst, const char *src, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a05589b775b882e0e83716df0616073fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac771c7309a91527bb7b5cfe40e6a2a5c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ac771c7309a91527bb7b5cfe40e6a2a5c">ut_strcount</a> (const char *s1, const char *s2)</td></tr>
<tr class="separator:ac771c7309a91527bb7b5cfe40e6a2a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c268612b98795d01d49e2e741537dab"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a2c268612b98795d01d49e2e741537dab">ut_strreplace</a> (const char *str, const char *s1, const char *s2)</td></tr>
<tr class="separator:a2c268612b98795d01d49e2e741537dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d84dac6ac30f3108a78a94680cfffe9"><td class="memItemLeft" align="right" valign="top"><a id="a0d84dac6ac30f3108a78a94680cfffe9"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>ut_str3cat</b> (const char *s1, const char *s2, const char *s3)</td></tr>
<tr class="separator:a0d84dac6ac30f3108a78a94680cfffe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c428872995f7520e57a3f9e1e91a01"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ab0c428872995f7520e57a3f9e1e91a01">ut_raw_to_hex</a> (const void *raw, ulint raw_size, char *hex, ulint hex_size)</td></tr>
<tr class="separator:ab0c428872995f7520e57a3f9e1e91a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dbe1fcbd03258c2d8698fbfc8474dc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#aa8dbe1fcbd03258c2d8698fbfc8474dc">ut_str_sql_format</a> (const char *str, ulint str_len, char *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0merge_8cc.html#a4454283b5709de09b07c6d13c63c3927">buf_size</a>)</td></tr>
<tr class="separator:aa8dbe1fcbd03258c2d8698fbfc8474dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad184ac85bd316658026a02cb5b1f265c"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ad184ac85bd316658026a02cb5b1f265c">ut_total_allocated_memory</a></td></tr>
<tr class="separator:ad184ac85bd316658026a02cb5b1f265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb3ef99ba2b05249a1d71ddc03f836b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structos__fast__mutex__t.html">os_fast_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#aacb3ef99ba2b05249a1d71ddc03f836b">ut_list_mutex</a></td></tr>
<tr class="separator:aacb3ef99ba2b05249a1d71ddc03f836b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory primitives</p>
<p>Created 5/30/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af45d7208632c06d0806165cc2b84370b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45d7208632c06d0806165cc2b84370b">&#9670;&nbsp;</a></span>ut_malloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ut_malloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ut0mem_8cc.html#a473e5df78914057653b9507f17af1708">ut_malloc_low</a>(<a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, TRUE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9b62984945c78f9b88ff6b857faf6fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b62984945c78f9b88ff6b857faf6fd4">&#9670;&nbsp;</a></span>ut_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ut_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a memory block allocated with ut_malloc. Freeing a NULL pointer is a nop. in, own: memory block, can be NULL</p>
<p>Frees a memory block allocated with ut_malloc. Freeing a NULL pointer is a nop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in, own: memory block, can be NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc3e259f2b4397229654e3ff855600fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3e259f2b4397229654e3ff855600fc">&#9670;&nbsp;</a></span>ut_free_all_mem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ut_free_all_mem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees in shutdown all allocated memory not freed yet. </p>

</div>
</div>
<a id="a537d6138f097170c63331d46958ebf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537d6138f097170c63331d46958ebf5e">&#9670;&nbsp;</a></span>ut_malloc_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void* ut_malloc_low </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>assert_on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory. </p><dl class="section return"><dt>Returns</dt><dd>own: allocated memory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: number of bytes to allocate </td></tr>
    <tr><td class="paramname">assert_on_error</td><td>in: if TRUE, we crash mysqld if the memory cannot be allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76b2a56b2abf87ef97001adf5d443513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b2a56b2abf87ef97001adf5d443513">&#9670;&nbsp;</a></span>ut_mem_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ut_mem_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the mem block list at database startup. </p>

</div>
</div>
<a id="a606e39d960b5c600f7f02dfd378d4597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606e39d960b5c600f7f02dfd378d4597">&#9670;&nbsp;</a></span>ut_memcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE int ut_memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for memcmp(3). Compare memory areas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>in: first memory block to compare </td></tr>
    <tr><td class="paramname">str2</td><td>in: second memory block to compare </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative, 0, or positive if str1 is smaller, equal, or greater than str2, respectively. </dd></dl>

</div>
</div>
<a id="ae46ac5cb8be8d1cba812480a71007cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46ac5cb8be8d1cba812480a71007cfd">&#9670;&nbsp;</a></span>ut_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* ut_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for memcpy(3). Copy memory area when the source and target are not overlapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>in: copy to </td></tr>
    <tr><td class="paramname">sour</td><td>in: copy from </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="ae3869c7f784b9bf5979a9d52e6562523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3869c7f784b9bf5979a9d52e6562523">&#9670;&nbsp;</a></span>ut_memmove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* ut_memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for memmove(3). Copy memory area when the source and target are overlapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>in: copy to </td></tr>
    <tr><td class="paramname">sour</td><td>in: copy from </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="ab0c428872995f7520e57a3f9e1e91a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c428872995f7520e57a3f9e1e91a01">&#9670;&nbsp;</a></span>ut_raw_to_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint ut_raw_to_hex </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>raw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>raw_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hex_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a raw binary data to a NUL-terminated hex string. The output is truncated if there is not enough space in "hex", make sure "hex_size" is at least (2 * raw_size + 1) if you do not want this to happen. Returns the actual number of characters written to "hex" (including the NUL). </p><dl class="section return"><dt>Returns</dt><dd>number of chars written in: "hex" size in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>in: raw data </td></tr>
    <tr><td class="paramname">raw_size</td><td>in: "raw" length in bytes </td></tr>
    <tr><td class="paramname">hex</td><td>out: hex string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c82273ea2d85aaa920f319ee6f886e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c82273ea2d85aaa920f319ee6f886e6">&#9670;&nbsp;</a></span>ut_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void* ut_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements realloc. This is needed by /pars/lexyy.cc. Otherwise, you should not use this function because the allocation functions in <a class="el" href="mem0mem_8h.html">mem0mem.h</a> are the recommended ones in InnoDB.</p>
<p>man realloc in Linux, 2004: </p><pre class="fragment">   realloc()  changes the size of the memory block pointed to
   by ptr to size bytes.  The contents will be  unchanged  to
   the minimum of the old and new sizes; newly allocated mem­
   ory will be uninitialized.  If ptr is NULL,  the         call  is
   equivalent  to malloc(size); if size is equal to zero, the
   call is equivalent to free(ptr).  Unless ptr is  NULL,  it
   must  have  been  returned by an earlier call to malloc(),
   calloc() or realloc().
</pre><p>RETURN VALUE realloc() returns a pointer to the newly allocated memory, which is suitably aligned for any kind of variable and may be different from ptr, or NULL if the request fails. If size was equal to 0, either NULL or a pointer suitable to be passed to free() is returned. If realloc() fails the original block is left untouched - it is not freed or moved. </p><dl class="section return"><dt>Returns</dt><dd>own: pointer to new mem block or NULL in: desired size</dd></dl>
<p>Implements realloc. This is needed by /pars/lexyy.cc. Otherwise, you should not use this function because the allocation functions in <a class="el" href="mem0mem_8h.html">mem0mem.h</a> are the recommended ones in InnoDB.</p>
<p>man realloc in Linux, 2004: </p><pre class="fragment">   realloc()  changes the size of the memory block pointed to
   by ptr to size bytes.  The contents will be  unchanged  to
   the minimum of the old and new sizes; newly allocated mem-
   ory will be uninitialized.  If ptr is NULL,  the  call  is
   equivalent  to malloc(size); if size is equal to zero, the
   call is equivalent to free(ptr).  Unless ptr is  NULL,  it
   must  have  been  returned by an earlier call to malloc(),
   calloc() or realloc().
</pre><p>RETURN VALUE realloc() returns a pointer to the newly allocated memory, which is suitably aligned for any kind of variable and may be different from ptr, or NULL if the request fails. If size was equal to 0, either NULL or a pointer suitable to be passed to free() is returned. If realloc() fails the original block is left untouched - it is not freed or moved. </p><dl class="section return"><dt>Returns</dt><dd>own: pointer to new mem block or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: pointer to old block or NULL </td></tr>
    <tr><td class="paramname">size</td><td>in: desired size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8dbe1fcbd03258c2d8698fbfc8474dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dbe1fcbd03258c2d8698fbfc8474dc">&#9670;&nbsp;</a></span>ut_str_sql_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint ut_str_sql_format </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>str_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds single quotes to the start and end of string and escapes any quotes by doubling them. Returns the number of bytes that were written to "buf" (including the terminating NUL). If buf_size is too small then the trailing bytes from "str" are discarded. </p><dl class="section return"><dt>Returns</dt><dd>number of bytes that were written in: output buffer size in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string </td></tr>
    <tr><td class="paramname">str_len</td><td>in: string length in bytes </td></tr>
    <tr><td class="paramname">buf</td><td>out: output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57d6cde2c9e72b100abd9387345f8d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d6cde2c9e72b100abd9387345f8d5a">&#9670;&nbsp;</a></span>ut_strcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE int ut_strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for strcmp(3). Compare NUL-terminated strings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>in: first string to compare </td></tr>
    <tr><td class="paramname">str2</td><td>in: second string to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative, 0, or positive if str1 is smaller, equal, or greater than str2, respectively. </dd></dl>

</div>
</div>
<a id="ac771c7309a91527bb7b5cfe40e6a2a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac771c7309a91527bb7b5cfe40e6a2a5c">&#9670;&nbsp;</a></span>ut_strcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ut_strcount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of times s2 occurs in s1. Overlapping instances of s2 are only counted once. </p><dl class="section return"><dt>Returns</dt><dd>the number of times s2 occurs in s1 in: string to search for</dd></dl>
<p>Return the number of times s2 occurs in s1. Overlapping instances of s2 are only counted once. </p><dl class="section return"><dt>Returns</dt><dd>the number of times s2 occurs in s1 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>in: string to search in </td></tr>
    <tr><td class="paramname">s2</td><td>in: string to search for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ffcb9c007799972d8166369e540309d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffcb9c007799972d8166369e540309d">&#9670;&nbsp;</a></span>ut_strcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* ut_strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for strcpy(3). Copy a NUL-terminated string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>in: copy to </td></tr>
    <tr><td class="paramname">sour</td><td>in: copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a id="af40bcb512f5d8c45a601852e49a5eaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40bcb512f5d8c45a601852e49a5eaeb">&#9670;&nbsp;</a></span>ut_strlcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ut_strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies up to size - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result. Returns strlen(src), so truncation occurred if the return value &gt;= size. </p><dl class="section return"><dt>Returns</dt><dd>strlen(src) in: size of destination buffer</dd></dl>
<p>Copies up to size - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result. Returns strlen(src), so truncation occurred if the return value &gt;= size. </p><dl class="section return"><dt>Returns</dt><dd>strlen(src) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>in: destination buffer </td></tr>
    <tr><td class="paramname">src</td><td>in: source buffer </td></tr>
    <tr><td class="paramname">size</td><td>in: size of destination buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05589b775b882e0e83716df0616073fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05589b775b882e0e83716df0616073fd">&#9670;&nbsp;</a></span>ut_strlcpy_rev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ut_strlcpy_rev </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like ut_strlcpy, but if src doesn't fit in dst completely, copies the last (size - 1) bytes of src, not the first. </p><dl class="section return"><dt>Returns</dt><dd>strlen(src) in: size of destination buffer</dd></dl>
<p>Like ut_strlcpy, but if src doesn't fit in dst completely, copies the last (size - 1) bytes of src, not the first. </p><dl class="section return"><dt>Returns</dt><dd>strlen(src) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>in: destination buffer </td></tr>
    <tr><td class="paramname">src</td><td>in: source buffer </td></tr>
    <tr><td class="paramname">size</td><td>in: size of destination buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5def94673c888fec3317cef51176abd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5def94673c888fec3317cef51176abd1">&#9670;&nbsp;</a></span>ut_strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint ut_strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for strlen(3). Determine the length of a NUL-terminated string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the string in bytes, excluding the terminating NUL </dd></dl>

</div>
</div>
<a id="a2c268612b98795d01d49e2e741537dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c268612b98795d01d49e2e741537dab">&#9670;&nbsp;</a></span>ut_strreplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* ut_strreplace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace every occurrence of s1 in str with s2. Overlapping instances of s1 are only replaced once. </p><dl class="section return"><dt>Returns</dt><dd>own: modified string, must be freed with <a class="el" href="mem0mem_8h.html#a4cdeda261ea5f6db299898f33e6bbdbf">mem_free()</a> in: string to replace s1 with</dd></dl>
<p>Replace every occurrence of s1 in str with s2. Overlapping instances of s1 are only replaced once. </p><dl class="section return"><dt>Returns</dt><dd>own: modified string, must be freed with <a class="el" href="mem0mem_8h.html#a4cdeda261ea5f6db299898f33e6bbdbf">mem_free()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string to operate on </td></tr>
    <tr><td class="paramname">s1</td><td>in: string to replace </td></tr>
    <tr><td class="paramname">s2</td><td>in: string to replace s1 with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aacb3ef99ba2b05249a1d71ddc03f836b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb3ef99ba2b05249a1d71ddc03f836b">&#9670;&nbsp;</a></span>ut_list_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structos__fast__mutex__t.html">os_fast_mutex_t</a> ut_list_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mutex protecting ut_total_allocated_memory and ut_mem_block_list </p>

</div>
</div>
<a id="ad184ac85bd316658026a02cb5b1f265c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad184ac85bd316658026a02cb5b1f265c">&#9670;&nbsp;</a></span>ut_total_allocated_memory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint ut_total_allocated_memory</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The total amount of memory currently allocated from the operating system with <a class="el" href="os0proc_8h.html#a52cad9f64959d2e729c09dcd0490f635">os_mem_alloc_large()</a> or malloc(). Does not count malloc() if srv_use_sys_malloc is set. Protected by ut_list_mutex. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

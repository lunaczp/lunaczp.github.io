<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: handler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">handler Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="handler_8h_source.html">handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for handler:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhandler.png" usemap="#handler_map" alt=""/>
  <map id="handler_map" name="handler_map">
<area href="class_sql__alloc.html" alt="Sql_alloc" shape="rect" coords="0,0,99,24"/>
<area href="classha__archive.html" alt="ha_archive" shape="rect" coords="109,112,208,136"/>
<area href="classha__blackhole.html" alt="ha_blackhole" shape="rect" coords="109,168,208,192"/>
<area href="classha__example.html" title="Class definition for the storage engine. " alt="ha_example" shape="rect" coords="109,224,208,248"/>
<area href="classha__federated.html" alt="ha_federated" shape="rect" coords="109,280,208,304"/>
<area href="classha__heap.html" alt="ha_heap" shape="rect" coords="109,336,208,360"/>
<area href="classha__innobase.html" alt="ha_innobase" shape="rect" coords="109,392,208,416"/>
<area href="classha__myisam.html" alt="ha_myisam" shape="rect" coords="109,448,208,472"/>
<area href="classha__myisammrg.html" alt="ha_myisammrg" shape="rect" coords="109,504,208,528"/>
<area href="classha__ndbcluster.html" alt="ha_ndbcluster" shape="rect" coords="109,560,208,584"/>
<area href="classha__ndbinfo.html" alt="ha_ndbinfo" shape="rect" coords="109,616,208,640"/>
<area href="classha__partition.html" alt="ha_partition" shape="rect" coords="109,672,208,696"/>
<area href="classha__perfschema.html" alt="ha_perfschema" shape="rect" coords="109,728,208,752"/>
<area href="classha__tina.html" alt="ha_tina" shape="rect" coords="109,784,208,808"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab5b14b11876fb5ac53a4cc7aceea6a2d"><td class="memItemLeft" align="right" valign="top"><a id="ab5b14b11876fb5ac53a4cc7aceea6a2d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>enum_range_scan_direction</b> { <b>RANGE_SCAN_ASC</b>, 
<b>RANGE_SCAN_DESC</b>
 }</td></tr>
<tr class="separator:ab5b14b11876fb5ac53a4cc7aceea6a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17118f023ca8fc0db852fc578206c4fe"><td class="memItemLeft" align="right" valign="top"><a id="a17118f023ca8fc0db852fc578206c4fe"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NONE</b> =0, 
<b>INDEX</b>, 
<b>RND</b>
 }</td></tr>
<tr class="separator:a17118f023ca8fc0db852fc578206c4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67af5473a36655c922682399d4c5b6ec"><td class="memItemLeft" align="right" valign="top"><a id="a67af5473a36655c922682399d4c5b6ec"></a>
typedef ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>Table_flags</b></td></tr>
<tr class="separator:a67af5473a36655c922682399d4c5b6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72cfeaceefd05a2f700c138c194770fc"><td class="memItemLeft" align="right" valign="top"><a id="a72cfeaceefd05a2f700c138c194770fc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unbind_psi</b> ()</td></tr>
<tr class="separator:a72cfeaceefd05a2f700c138c194770fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e335a403d8203854bc5b94111992b79"><td class="memItemLeft" align="right" valign="top"><a id="a1e335a403d8203854bc5b94111992b79"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rebind_psi</b> ()</td></tr>
<tr class="separator:a1e335a403d8203854bc5b94111992b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae8f7f7b4f67773b73906143238dc9f"><td class="memItemLeft" align="right" valign="top"><a id="a9ae8f7f7b4f67773b73906143238dc9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b> (<a class="el" href="structhandlerton.html">handlerton</a> *ht_arg, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share_arg)</td></tr>
<tr class="separator:a9ae8f7f7b4f67773b73906143238dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc340039f5cf37a26e7c3b53685794"><td class="memItemLeft" align="right" valign="top"><a id="a97fc340039f5cf37a26e7c3b53685794"></a>
virtual <a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:a97fc340039f5cf37a26e7c3b53685794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad6edb66592b200a7c7ac0f947dc66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init</a> ()</td></tr>
<tr class="separator:ab1ad6edb66592b200a7c7ac0f947dc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e02829386929734724b143391e0a11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5e02829386929734724b143391e0a11">ha_open</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, int <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, int test_if_locked)</td></tr>
<tr class="memdesc:ab5e02829386929734724b143391e0a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open database-handler.  <a href="#ab5e02829386929734724b143391e0a11">More...</a><br /></td></tr>
<tr class="separator:ab5e02829386929734724b143391e0a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28824cdff2c1812e282463c908e84c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">ha_close</a> (void)</td></tr>
<tr class="separator:ae28824cdff2c1812e282463c908e84c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af23462b249041a0db03c1c7139d76b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init</a> (uint idx, bool sorted)</td></tr>
<tr class="separator:a0af23462b249041a0db03c1c7139d76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6bd01057c6cdd86d2ea2ee4ea65ca3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a> ()</td></tr>
<tr class="separator:afa6bd01057c6cdd86d2ea2ee4ea65ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c99736cb400350e007578889b8375"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init</a> (bool scan)</td></tr>
<tr class="separator:afb5c99736cb400350e007578889b8375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9bf34ac0a004d8c5c32267f20842f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a> ()</td></tr>
<tr class="separator:ad4d9bf34ac0a004d8c5c32267f20842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3743f3a48e7be751dbb2691be4c992a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">ha_rnd_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ad3743f3a48e7be751dbb2691be4c992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8615219b3e692e7d484d2ba6cfa86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uchar *pos)</td></tr>
<tr class="separator:abcd8615219b3e692e7d484d2ba6cfa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729d9c9c011527b81287574294887bf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">ha_index_read_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a729d9c9c011527b81287574294887bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9be09b8d0b1c03c96eb95f79dd7c9"><td class="memItemLeft" align="right" valign="top"><a id="a3fa9be09b8d0b1c03c96eb95f79dd7c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_read_last_map</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a3fa9be09b8d0b1c03c96eb95f79dd7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831321e8d33958db4fd4968de932acf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">ha_index_read_idx_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:ac831321e8d33958db4fd4968de932acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c99e96a8350ff577a94529be9387a30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">ha_index_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a4c99e96a8350ff577a94529be9387a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb977dac0435158be227e45e04c8b798"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb977dac0435158be227e45e04c8b798">ha_index_prev</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:abb977dac0435158be227e45e04c8b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd574a3025588e9b0cd49e0d6908e3b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">ha_index_first</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:abd574a3025588e9b0cd49e0d6908e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7415f1744039a51ef15e923ef7da1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">ha_index_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a2a7415f1744039a51ef15e923ef7da1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f79360a45d50c6b558feb1c308c4157"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">ha_index_next_same</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a3f79360a45d50c6b558feb1c308c4157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f8c07d2ede3fb1f46fc0afb4052d2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a37f8c07d2ede3fb1f46fc0afb4052d2c">ha_index_read</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a37f8c07d2ede3fb1f46fc0afb4052d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1790fe12f8d773f27d5b4b1cb30bd7ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1790fe12f8d773f27d5b4b1cb30bd7ab">ha_index_read_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len)</td></tr>
<tr class="separator:a1790fe12f8d773f27d5b4b1cb30bd7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d38f167906d8aaa9e560c71e595a42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">ha_reset</a> ()</td></tr>
<tr class="memdesc:a53d38f167906d8aaa9e560c71e595a42"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_check.html">Check</a> handler usage and reset state of file to after 'open'.  <a href="#a53d38f167906d8aaa9e560c71e595a42">More...</a><br /></td></tr>
<tr class="separator:a53d38f167906d8aaa9e560c71e595a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1ef9b6ab27156116f91bf50b1ac19f"><td class="memItemLeft" align="right" valign="top"><a id="a6e1ef9b6ab27156116f91bf50b1ac19f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_or_rnd_end</b> ()</td></tr>
<tr class="separator:a6e1ef9b6ab27156116f91bf50b1ac19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3015577f49008561db1d34ae750e70"><td class="memItemLeft" align="right" valign="top">Table_flags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b3015577f49008561db1d34ae750e70">ha_table_flags</a> () const</td></tr>
<tr class="separator:a6b3015577f49008561db1d34ae750e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99b5f8ae28bc5c374919396f8dcf08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">ha_external_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, int lock_type)</td></tr>
<tr class="separator:a9a99b5f8ae28bc5c374919396f8dcf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e651543ba0dbb2257a50dc1cdb5ea9"><td class="memItemLeft" align="right" valign="top"><a id="ad8e651543ba0dbb2257a50dc1cdb5ea9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_write_row</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ad8e651543ba0dbb2257a50dc1cdb5ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6bb19636dda0f1537fe780b6aca17a"><td class="memItemLeft" align="right" valign="top"><a id="a1f6bb19636dda0f1537fe780b6aca17a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr class="separator:a1f6bb19636dda0f1537fe780b6aca17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e3b24f5bb5b2a8fa0c45732db8cdd"><td class="memItemLeft" align="right" valign="top"><a id="a3f0e3b24f5bb5b2a8fa0c45732db8cdd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_delete_row</b> (const uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a3f0e3b24f5bb5b2a8fa0c45732db8cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbcbef5b9b8ed0f76d700a29091ad3f"><td class="memItemLeft" align="right" valign="top"><a id="abfbcbef5b9b8ed0f76d700a29091ad3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_release_auto_increment</b> ()</td></tr>
<tr class="separator:abfbcbef5b9b8ed0f76d700a29091ad3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234580f9765751ce185182dd1edc3bdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a234580f9765751ce185182dd1edc3bdb">check_collation_compatibility</a> ()</td></tr>
<tr class="separator:a234580f9765751ce185182dd1edc3bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a8030a4a3928d216599e1c03e9b28c"><td class="memItemLeft" align="right" valign="top"><a id="a79a8030a4a3928d216599e1c03e9b28c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_check_for_upgrade</b> (<a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a79a8030a4a3928d216599e1c03e9b28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56545ec9967544c80d5612f8ac9b8e6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">ha_check</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a56545ec9967544c80d5612f8ac9b8e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d70543d9566894b5a81d25eca2e8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">ha_repair</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ad28d70543d9566894b5a81d25eca2e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f09a15d46c019a621b0a65bb1ec89d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">ha_start_bulk_insert</a> (ha_rows rows)</td></tr>
<tr class="separator:a3f09a15d46c019a621b0a65bb1ec89d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f3cbf4a769155c994ed39f76433106"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">ha_end_bulk_insert</a> ()</td></tr>
<tr class="separator:a30f3cbf4a769155c994ed39f76433106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c8ce82a564b0cbf6340dc9b74a9c23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">ha_bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:a49c8ce82a564b0cbf6340dc9b74a9c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef228137a11565f7d52a60ad802004"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">ha_delete_all_rows</a> ()</td></tr>
<tr class="separator:a1fef228137a11565f7d52a60ad802004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25394328a49d42bb45b3b263009f02c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a25394328a49d42bb45b3b263009f02c7">ha_truncate</a> ()</td></tr>
<tr class="separator:a25394328a49d42bb45b3b263009f02c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68b71d64ca04789d1c6130320eaf22c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af68b71d64ca04789d1c6130320eaf22c">ha_reset_auto_increment</a> (ulonglong value)</td></tr>
<tr class="separator:af68b71d64ca04789d1c6130320eaf22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a8a7650a41fd9a05a32521826ccd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">ha_optimize</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a980a8a7650a41fd9a05a32521826ccd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc9e4971b8e768c102398da0656a7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">ha_analyze</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a66cc9e4971b8e768c102398da0656a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d5287bdf480f8cd20f758bb2d9bd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">ha_check_and_repair</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:a169d5287bdf480f8cd20f758bb2d9bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb079b3dc59160ba828ef89b4463921"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">ha_disable_indexes</a> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:aeeb079b3dc59160ba828ef89b4463921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9c53758728e07eb37cbb65ea3ab50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">ha_enable_indexes</a> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a36e9c53758728e07eb37cbb65ea3ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f75cf982985d21907140a17521cd6c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1f75cf982985d21907140a17521cd6c5">ha_discard_or_import_tablespace</a> (my_bool discard)</td></tr>
<tr class="separator:a1f75cf982985d21907140a17521cd6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee228a60527e81efd9a49ddfdd4850d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ee228a60527e81efd9a49ddfdd4850d">ha_rename_table</a> (const char *<a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a>, const char *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>)</td></tr>
<tr class="separator:a6ee228a60527e81efd9a49ddfdd4850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28700a3bf1af24f9a31ebae51bf877db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a28700a3bf1af24f9a31ebae51bf877db">ha_delete_table</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a28700a3bf1af24f9a31ebae51bf877db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcc37ec84386f5d6cc86448781666cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">ha_drop_table</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a6bcc37ec84386f5d6cc86448781666cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14af5825a427ba6baac74b13223637f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a14af5825a427ba6baac74b13223637f8">ha_create</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="ha__innodb_8cc.html#ae64f1475e9ca79d24be2a8091b9cbdd7">form</a>, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a14af5825a427ba6baac74b13223637f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722462d7e71059a8ed1f43d0fb28366b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a722462d7e71059a8ed1f43d0fb28366b">ha_create_handler_files</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a722462d7e71059a8ed1f43d0fb28366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fb90782fea926f7a4450889d2d4a93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5fb90782fea926f7a4450889d2d4a93">ha_change_partitions</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)</td></tr>
<tr class="separator:ab5fb90782fea926f7a4450889d2d4a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af575e947965117a3a200aec827b1a7c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af575e947965117a3a200aec827b1a7c3">ha_drop_partitions</a> (const char *path)</td></tr>
<tr class="separator:af575e947965117a3a200aec827b1a7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624a8892433666df834a9b6ed6b8c2dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a624a8892433666df834a9b6ed6b8c2dd">ha_rename_partitions</a> (const char *path)</td></tr>
<tr class="separator:a624a8892433666df834a9b6ed6b8c2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c090210fefb7e95d885688f5717028"><td class="memItemLeft" align="right" valign="top"><a id="ad4c090210fefb7e95d885688f5717028"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_next_insert_id_after_explicit_value</b> (ulonglong nr)</td></tr>
<tr class="separator:ad4c090210fefb7e95d885688f5717028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d2f9da11425e388640206b4d22241"><td class="memItemLeft" align="right" valign="top"><a id="a8a7d2f9da11425e388640206b4d22241"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>update_auto_increment</b> ()</td></tr>
<tr class="separator:a8a7d2f9da11425e388640206b4d22241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda4f1390385a4dc0bfd2981fee23e6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">print_error</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, myf errflag)</td></tr>
<tr class="separator:afda4f1390385a4dc0bfd2981fee23e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce8ffd064ce683481494c7503ef820c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">get_error_message</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, <a class="el" href="class_string.html">String</a> *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:afce8ffd064ce683481494c7503ef820c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eede0999f8273864faa40c5e181793"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">get_dup_key</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>)</td></tr>
<tr class="separator:ad5eede0999f8273864faa40c5e181793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20878b1fb8d31b91dbf53ac963d90f78"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a20878b1fb8d31b91dbf53ac963d90f78">get_foreign_dup_key</a> (char *child_table_name, uint child_table_name_len, char *child_key_name, uint child_key_name_len)</td></tr>
<tr class="separator:a20878b1fb8d31b91dbf53ac963d90f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b117a976fc9423d2337da59f35d128c"><td class="memItemLeft" align="right" valign="top"><a id="a2b117a976fc9423d2337da59f35d128c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>change_table_ptr</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table_arg, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:a2b117a976fc9423d2337da59f35d128c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f8e5188e2bd9636a564bbc0c3fef86"><td class="memItemLeft" align="right" valign="top"><a id="a65f8e5188e2bd9636a564bbc0c3fef86"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>scan_time</b> ()</td></tr>
<tr class="separator:a65f8e5188e2bd9636a564bbc0c3fef86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061b519fb16fbff126b0e21530973c2e"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">read_time</a> (uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, uint ranges, ha_rows rows)</td></tr>
<tr class="separator:a061b519fb16fbff126b0e21530973c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ac6b2908a899c0ce230818bb7a993"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time</a> (uint keynr, double <a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a>)</td></tr>
<tr class="separator:a4a2ac6b2908a899c0ce230818bb7a993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475f7fbe39f6ff0e9da2ac6c3d6c629e"><td class="memItemLeft" align="right" valign="top">virtual longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a475f7fbe39f6ff0e9da2ac6c3d6c629e">get_memory_buffer_size</a> () const</td></tr>
<tr class="separator:a475f7fbe39f6ff0e9da2ac6c3d6c629e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee356d2340552eb121d423fc01597f8"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">multi_range_read_info_const</a> (uint keyno, <a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint *bufsz, uint *<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_cost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:a5ee356d2340552eb121d423fc01597f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5add40a6cd7088ffef25a3816294b624"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">multi_range_read_info</a> (uint keyno, uint n_ranges, uint keys, uint *bufsz, uint *<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_cost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:a5add40a6cd7088ffef25a3816294b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e8899f4bae262b6b91c7284f1d946e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init</a> (<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, <a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a33e8899f4bae262b6b91c7284f1d946e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3419071f3d4abf183dac95ef565adfff"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">multi_range_read_next</a> (char **range_info)</td></tr>
<tr class="separator:a3419071f3d4abf183dac95ef565adfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c43b5f1fb4c515d2c5842dcbc24fac"><td class="memItemLeft" align="right" valign="top"><a id="a29c43b5f1fb4c515d2c5842dcbc24fac"></a>
virtual const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keys_to_use_for_scanning</b> ()</td></tr>
<tr class="separator:a29c43b5f1fb4c515d2c5842dcbc24fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d4ecfa5cfe85d8179aa52488016d0"><td class="memItemLeft" align="right" valign="top"><a id="ae73d4ecfa5cfe85d8179aa52488016d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_transactions</b> ()</td></tr>
<tr class="separator:ae73d4ecfa5cfe85d8179aa52488016d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fd434bc44b88f4e47f44f02c877c91"><td class="memItemLeft" align="right" valign="top"><a id="a27fd434bc44b88f4e47f44f02c877c91"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>extra_rec_buf_length</b> () const</td></tr>
<tr class="separator:a27fd434bc44b88f4e47f44f02c877c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc56a8f3a2c01c127ad553fdf2a8c18"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1bc56a8f3a2c01c127ad553fdf2a8c18">is_fatal_error</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:a1bc56a8f3a2c01c127ad553fdf2a8c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c1bde4ae61f0aee31d241b0821369c"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a> ()</td></tr>
<tr class="separator:a85c1bde4ae61f0aee31d241b0821369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59e9a1d36d852f4dd5dd00bff5f1ae4"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">estimate_rows_upper_bound</a> ()</td></tr>
<tr class="separator:ae59e9a1d36d852f4dd5dd00bff5f1ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163a360c0cd4575ae207553b8d5c918d"><td class="memItemLeft" align="right" valign="top">virtual enum row_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a163a360c0cd4575ae207553b8d5c918d">get_row_type</a> () const</td></tr>
<tr class="separator:a163a360c0cd4575ae207553b8d5c918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e51a7f02396ce5cef9cbe41a4a0a888"><td class="memItemLeft" align="right" valign="top"><a id="a1e51a7f02396ce5cef9cbe41a4a0a888"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> (uint key_number)</td></tr>
<tr class="separator:a1e51a7f02396ce5cef9cbe41a4a0a888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de97045e5381007565fd2b0da235c07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07">column_bitmaps_signal</a> ()</td></tr>
<tr class="memdesc:a4de97045e5381007565fd2b0da235c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL signal that it changed the column bitmap.  <a href="#a4de97045e5381007565fd2b0da235c07">More...</a><br /></td></tr>
<tr class="separator:a4de97045e5381007565fd2b0da235c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf0aed6539181d465676ebc661f2b5"><td class="memItemLeft" align="right" valign="top"><a id="aacdf0aed6539181d465676ebc661f2b5"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>get_index</b> (void) const</td></tr>
<tr class="separator:aacdf0aed6539181d465676ebc661f2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488245f51aa4676c872bb0564dbe71f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">start_bulk_update</a> ()</td></tr>
<tr class="separator:a7488245f51aa4676c872bb0564dbe71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf7319a6498f655f8f07b1b34b12fc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">start_bulk_delete</a> ()</td></tr>
<tr class="separator:acdaf7319a6498f655f8f07b1b34b12fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886bf2fbf16de7e200e3ebc0765fb6e4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">exec_bulk_update</a> (uint *dup_key_found)</td></tr>
<tr class="separator:a886bf2fbf16de7e200e3ebc0765fb6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6c46d66ca282a4cbd6118e4c99e03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">end_bulk_update</a> ()</td></tr>
<tr class="separator:a2bf6c46d66ca282a4cbd6118e4c99e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f9f1ca2b5efc0b41e96c6b793d9bb1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">end_bulk_delete</a> ()</td></tr>
<tr class="separator:af5f9f1ca2b5efc0b41e96c6b793d9bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0d596ff3ddc77b4f0ad990c4c4cb4b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">read_range_first</a> (const <a class="el" href="structst__key__range.html">key_range</a> *start_key, const <a class="el" href="structst__key__range.html">key_range</a> *end_key, bool eq_range, bool sorted)</td></tr>
<tr class="memdesc:a3a0d596ff3ddc77b4f0ad990c4c4cb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges. Store ranges for future calls to read_range_next.  <a href="#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">More...</a><br /></td></tr>
<tr class="separator:a3a0d596ff3ddc77b4f0ad990c4c4cb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4632aa56c9c66a57558f849f8e01271"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">read_range_next</a> ()</td></tr>
<tr class="memdesc:ae4632aa56c9c66a57558f849f8e01271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="#ae4632aa56c9c66a57558f849f8e01271">More...</a><br /></td></tr>
<tr class="separator:ae4632aa56c9c66a57558f849f8e01271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7dfb95a0da2e828ac018aa2b4abe3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">set_end_range</a> (const <a class="el" href="structst__key__range.html">key_range</a> *range, enum_range_scan_direction <a class="el" href="btr0btr_8cc.html#a942da44c6711d230377078633665e89b">direction</a>)</td></tr>
<tr class="separator:a4b7dfb95a0da2e828ac018aa2b4abe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef38e7407e87ba5d1ccde59c3e94bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">compare_key</a> (<a class="el" href="structst__key__range.html">key_range</a> *range)</td></tr>
<tr class="separator:af0ef38e7407e87ba5d1ccde59c3e94bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767345668267e3c8881fab6e351e6c8"><td class="memItemLeft" align="right" valign="top"><a id="ab767345668267e3c8881fab6e351e6c8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compare_key_icp</b> (const <a class="el" href="structst__key__range.html">key_range</a> *range) const</td></tr>
<tr class="separator:ab767345668267e3c8881fab6e351e6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab734678f90b9e7cc6b000047f7c89bb1"><td class="memItemLeft" align="right" valign="top"><a id="ab734678f90b9e7cc6b000047f7c89bb1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init</b> ()</td></tr>
<tr class="separator:ab734678f90b9e7cc6b000047f7c89bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72693b6e25765a4290f531f578bcf2eb"><td class="memItemLeft" align="right" valign="top"><a id="a72693b6e25765a4290f531f578bcf2eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ft_end</b> ()</td></tr>
<tr class="separator:a72693b6e25765a4290f531f578bcf2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109448e09ee2c456b1471b74bb9eb8e6"><td class="memItemLeft" align="right" valign="top"><a id="a109448e09ee2c456b1471b74bb9eb8e6"></a>
virtual <a class="el" href="structst__ft__info.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init_ext</b> (uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, uint inx, <a class="el" href="class_string.html">String</a> *key)</td></tr>
<tr class="separator:a109448e09ee2c456b1471b74bb9eb8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c965ae56bcceee3cf63ce0320a5d31b"><td class="memItemLeft" align="right" valign="top"><a id="a0c965ae56bcceee3cf63ce0320a5d31b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_read</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a0c965ae56bcceee3cf63ce0320a5d31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be2fa5d347252f8a28dce931654b76"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">rnd_pos_by_record</a> (uchar *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="separator:ac2be2fa5d347252f8a28dce931654b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50b704d53d715d6b0fd3534c6107d8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aff50b704d53d715d6b0fd3534c6107d8">read_first_row</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint primary_key)</td></tr>
<tr class="separator:aff50b704d53d715d6b0fd3534c6107d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730672727f9ad989e80f3732eb838a10"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a730672727f9ad989e80f3732eb838a10">restart_rnd_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uchar *pos)</td></tr>
<tr class="separator:a730672727f9ad989e80f3732eb838a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590afc40dd01fb9fc387ef1d97370f41"><td class="memItemLeft" align="right" valign="top"><a id="a590afc40dd01fb9fc387ef1d97370f41"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rnd_same</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint inx)</td></tr>
<tr class="separator:a590afc40dd01fb9fc387ef1d97370f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac874ad6fd5a2e6b97376befacb165"><td class="memItemLeft" align="right" valign="top"><a id="a33ac874ad6fd5a2e6b97376befacb165"></a>
virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>records_in_range</b> (uint inx, <a class="el" href="structst__key__range.html">key_range</a> *min_key, <a class="el" href="structst__key__range.html">key_range</a> *max_key)</td></tr>
<tr class="separator:a33ac874ad6fd5a2e6b97376befacb165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c1515e7a936fa9cbc19f93d43495b6"><td class="memItemLeft" align="right" valign="top"><a id="ad3c1515e7a936fa9cbc19f93d43495b6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (const uchar *<a class="el" href="structrecord.html">record</a>)=0</td></tr>
<tr class="separator:ad3c1515e7a936fa9cbc19f93d43495b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39a38e4a875151379cacd0da1a789c8"><td class="memItemLeft" align="right" valign="top"><a id="ab39a38e4a875151379cacd0da1a789c8"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>info</b> (uint)=0</td></tr>
<tr class="separator:ab39a38e4a875151379cacd0da1a789c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c3487f93880d33b4ef37b41c5c5fbb"><td class="memItemLeft" align="right" valign="top"><a id="a47c3487f93880d33b4ef37b41c5c5fbb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_dynamic_partition_info</b> (<a class="el" href="struct_p_a_r_t_i_t_i_o_n___s_t_a_t_s.html">PARTITION_STATS</a> *stat_info, uint part_id)</td></tr>
<tr class="separator:a47c3487f93880d33b4ef37b41c5c5fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e746c224b70d3b03b2886ecf4563394"><td class="memItemLeft" align="right" valign="top"><a id="a7e746c224b70d3b03b2886ecf4563394"></a>
virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_key_hash_value</b> (<a class="el" href="class_field.html">Field</a> **field_array)</td></tr>
<tr class="separator:a7e746c224b70d3b03b2886ecf4563394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7687330aaf0d97540db07ab436e349"><td class="memItemLeft" align="right" valign="top"><a id="a2b7687330aaf0d97540db07ab436e349"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra</b> (enum ha_extra_function operation)</td></tr>
<tr class="separator:a2b7687330aaf0d97540db07ab436e349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e72da94a7f5577f00ab5c89204ec1"><td class="memItemLeft" align="right" valign="top"><a id="a6b7e72da94a7f5577f00ab5c89204ec1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra_opt</b> (enum ha_extra_function operation, ulong cache_size)</td></tr>
<tr class="separator:a6b7e72da94a7f5577f00ab5c89204ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2428788c2437e4e33c4b390cc697f7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">start_read_removal</a> (void)</td></tr>
<tr class="separator:a3e2428788c2437e4e33c4b390cc697f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517d99c283e85e8d97460f07a781dabf"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">end_read_removal</a> (void)</td></tr>
<tr class="separator:a517d99c283e85e8d97460f07a781dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d92f647a4ca5a3b7867fa5538242a6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">was_semi_consistent_read</a> ()</td></tr>
<tr class="separator:a54d92f647a4ca5a3b7867fa5538242a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e767094bff139a26743e9314df8476"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">try_semi_consistent_read</a> (bool)</td></tr>
<tr class="separator:ab3e767094bff139a26743e9314df8476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e6fd090f73a8e7e5e94769c9a10733"><td class="memItemLeft" align="right" valign="top"><a id="a48e6fd090f73a8e7e5e94769c9a10733"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_row</b> ()</td></tr>
<tr class="separator:a48e6fd090f73a8e7e5e94769c9a10733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c625117fcff640b7af11e7018519cd"><td class="memItemLeft" align="right" valign="top"><a id="a90c625117fcff640b7af11e7018519cd"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>start_stmt</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, thr_lock_type lock_type)</td></tr>
<tr class="separator:a90c625117fcff640b7af11e7018519cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6af760a4ef09984a5cc1dc58db9a40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment</a> (ulonglong <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulonglong increment, ulonglong nb_desired_values, ulonglong *first_value, ulonglong *nb_reserved_values)</td></tr>
<tr class="separator:aaf6af760a4ef09984a5cc1dc58db9a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f9bf8ee63f3b8312fdc31be3819ede"><td class="memItemLeft" align="right" valign="top"><a id="ab6f9bf8ee63f3b8312fdc31be3819ede"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_next_insert_id</b> (ulonglong <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:ab6f9bf8ee63f3b8312fdc31be3819ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b51670b2497f01f19f587a4a969386"><td class="memItemLeft" align="right" valign="top"><a id="a15b51670b2497f01f19f587a4a969386"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>restore_auto_increment</b> (ulonglong <a class="el" href="handler_8cc.html#ae9f796d8fbc7dc812557a17547b8e69e">prev_insert_id</a>)</td></tr>
<tr class="separator:a15b51670b2497f01f19f587a4a969386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58141e7b51aaf97bdf63ea68c411f401"><td class="memItemLeft" align="right" valign="top"><a id="a58141e7b51aaf97bdf63ea68c411f401"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>update_create_info</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:a58141e7b51aaf97bdf63ea68c411f401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc92ca74cd6aca9a6070a186ced4cb"><td class="memItemLeft" align="right" valign="top"><a id="a1abc92ca74cd6aca9a6070a186ced4cb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_old_types</b> ()</td></tr>
<tr class="separator:a1abc92ca74cd6aca9a6070a186ced4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b5fa7360fc536082f495ee7e09bcba"><td class="memItemLeft" align="right" valign="top"><a id="ab1b5fa7360fc536082f495ee7e09bcba"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>assign_to_keycache</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ab1b5fa7360fc536082f495ee7e09bcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061ab331631179647ccdbd71960ba37"><td class="memItemLeft" align="right" valign="top"><a id="a0061ab331631179647ccdbd71960ba37"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>preload_keys</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a0061ab331631179647ccdbd71960ba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc45e93a1b669fa750f73a617c46bac"><td class="memItemLeft" align="right" valign="top"><a id="a8bc45e93a1b669fa750f73a617c46bac"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>indexes_are_disabled</b> (void)</td></tr>
<tr class="separator:a8bc45e93a1b669fa750f73a617c46bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2782719e44a05802e8ee37a738370bdc"><td class="memItemLeft" align="right" valign="top"><a id="a2782719e44a05802e8ee37a738370bdc"></a>
virtual char *&#160;</td><td class="memItemRight" valign="bottom"><b>update_table_comment</b> (const char *comment)</td></tr>
<tr class="separator:a2782719e44a05802e8ee37a738370bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441afeebcb5b56e598fb7f860c9247d1"><td class="memItemLeft" align="right" valign="top"><a id="a441afeebcb5b56e598fb7f860c9247d1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>append_create_info</b> (<a class="el" href="class_string.html">String</a> *packet)</td></tr>
<tr class="separator:a441afeebcb5b56e598fb7f860c9247d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda33331aacc500b1b974033cb64a869"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adda33331aacc500b1b974033cb64a869">is_fk_defined_on_table_or_index</a> (uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:adda33331aacc500b1b974033cb64a869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8712abc71df0d89559e2861c100a8e3e"><td class="memItemLeft" align="right" valign="top"><a id="a8712abc71df0d89559e2861c100a8e3e"></a>
virtual char *&#160;</td><td class="memItemRight" valign="bottom"><b>get_foreign_key_create_info</b> ()</td></tr>
<tr class="separator:a8712abc71df0d89559e2861c100a8e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baab93a22543b707e6e59b9d59810d2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">can_switch_engines</a> ()</td></tr>
<tr class="separator:a6baab93a22543b707e6e59b9d59810d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81064e61d4c08261af409fb6ee34e3ca"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a81064e61d4c08261af409fb6ee34e3ca">get_foreign_key_list</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a81064e61d4c08261af409fb6ee34e3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9187eea9999eba802ee4ae01f91dda3b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9187eea9999eba802ee4ae01f91dda3b">get_parent_foreign_key_list</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a9187eea9999eba802ee4ae01f91dda3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b038c18aeb8114376725e6f8d39871"><td class="memItemLeft" align="right" valign="top"><a id="a28b038c18aeb8114376725e6f8d39871"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>referenced_by_foreign_key</b> ()</td></tr>
<tr class="separator:a28b038c18aeb8114376725e6f8d39871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dfb73f9401996a25b9cf925db74149"><td class="memItemLeft" align="right" valign="top"><a id="a28dfb73f9401996a25b9cf925db74149"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>init_table_handle_for_HANDLER</b> ()</td></tr>
<tr class="separator:a28dfb73f9401996a25b9cf925db74149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4457d47baa6d136af65e041da4fe9e0"><td class="memItemLeft" align="right" valign="top"><a id="aa4457d47baa6d136af65e041da4fe9e0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>free_foreign_key_create_info</b> (char *str)</td></tr>
<tr class="separator:aa4457d47baa6d136af65e041da4fe9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38f5d3f1e026a0af32b5542aa5ac2f9"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">table_type</a> () const =0</td></tr>
<tr class="separator:ad38f5d3f1e026a0af32b5542aa5ac2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748d5e5b6dbbb0681cbac2ad881505c9"><td class="memItemLeft" align="right" valign="top">virtual const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext</a> () const =0</td></tr>
<tr class="separator:a748d5e5b6dbbb0681cbac2ad881505c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a347e66418fe35a07f24900bcbdce82"><td class="memItemLeft" align="right" valign="top"><a id="a8a347e66418fe35a07f24900bcbdce82"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>get_default_no_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a8a347e66418fe35a07f24900bcbdce82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4512d49169a2766f5c5b4896a9691c"><td class="memItemLeft" align="right" valign="top"><a id="abc4512d49169a2766f5c5b4896a9691c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_auto_partitions</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info)</td></tr>
<tr class="separator:abc4512d49169a2766f5c5b4896a9691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cad9d951b59dd0b705e6861dc489e7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab3cad9d951b59dd0b705e6861dc489e7">get_no_parts</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, uint *no_parts)</td></tr>
<tr class="separator:ab3cad9d951b59dd0b705e6861dc489e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46ea4bb55add228a28b24d748426aa2"><td class="memItemLeft" align="right" valign="top"><a id="aa46ea4bb55add228a28b24d748426aa2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_part_info</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info, bool early)</td></tr>
<tr class="separator:aa46ea4bb55add228a28b24d748426aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612375d87a4cbb6e7c190ea7d05cf945"><td class="memItemLeft" align="right" valign="top"><a id="a612375d87a4cbb6e7c190ea7d05cf945"></a>
virtual ulong&#160;</td><td class="memItemRight" valign="bottom"><b>index_flags</b> (uint idx, uint part, bool all_parts) const =0</td></tr>
<tr class="separator:a612375d87a4cbb6e7c190ea7d05cf945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9c5a03956913d75de1fca3af7833a"><td class="memItemLeft" align="right" valign="top"><a id="a7ee9c5a03956913d75de1fca3af7833a"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_record_length</b> () const</td></tr>
<tr class="separator:a7ee9c5a03956913d75de1fca3af7833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493c1ac62569e6cc89cbfde66fea47f3"><td class="memItemLeft" align="right" valign="top"><a id="a493c1ac62569e6cc89cbfde66fea47f3"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_keys</b> () const</td></tr>
<tr class="separator:a493c1ac62569e6cc89cbfde66fea47f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adabba96b635533f31d5e38e6d2a74c"><td class="memItemLeft" align="right" valign="top"><a id="a1adabba96b635533f31d5e38e6d2a74c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_parts</b> () const</td></tr>
<tr class="separator:a1adabba96b635533f31d5e38e6d2a74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b1d6fe7e717fe234c18915cb26e87"><td class="memItemLeft" align="right" valign="top"><a id="a9e1b1d6fe7e717fe234c18915cb26e87"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_length</b> () const</td></tr>
<tr class="separator:a9e1b1d6fe7e717fe234c18915cb26e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa0c2a89e52a27667973c1d5074dca7"><td class="memItemLeft" align="right" valign="top"><a id="a4fa0c2a89e52a27667973c1d5074dca7"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_part_length</b> () const</td></tr>
<tr class="separator:a4fa0c2a89e52a27667973c1d5074dca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a498859c2d47448100e5e703622bb"><td class="memItemLeft" align="right" valign="top"><a id="a672a498859c2d47448100e5e703622bb"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_record_length</b> () const</td></tr>
<tr class="separator:a672a498859c2d47448100e5e703622bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7b335988ea24ea8b685c4278442cf8"><td class="memItemLeft" align="right" valign="top"><a id="a9c7b335988ea24ea8b685c4278442cf8"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_keys</b> () const</td></tr>
<tr class="separator:a9c7b335988ea24ea8b685c4278442cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d5b6de2843435371dc9045403e3d07"><td class="memItemLeft" align="right" valign="top"><a id="a25d5b6de2843435371dc9045403e3d07"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_parts</b> () const</td></tr>
<tr class="separator:a25d5b6de2843435371dc9045403e3d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2216dba316fe13117f00e8d21cbdab"><td class="memItemLeft" align="right" valign="top"><a id="a0c2216dba316fe13117f00e8d21cbdab"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_length</b> () const</td></tr>
<tr class="separator:a0c2216dba316fe13117f00e8d21cbdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9209ad97772dc4c6c0398fe11296d3ac"><td class="memItemLeft" align="right" valign="top"><a id="a9209ad97772dc4c6c0398fe11296d3ac"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_part_length</b> () const</td></tr>
<tr class="separator:a9209ad97772dc4c6c0398fe11296d3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082d2a49764e8548b8104dc514877b3"><td class="memItemLeft" align="right" valign="top"><a id="ab082d2a49764e8548b8104dc514877b3"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>min_record_length</b> (uint options) const</td></tr>
<tr class="separator:ab082d2a49764e8548b8104dc514877b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a20da13aaa177f1a256e5fb63e7c78"><td class="memItemLeft" align="right" valign="top"><a id="a64a20da13aaa177f1a256e5fb63e7c78"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>low_byte_first</b> () const</td></tr>
<tr class="separator:a64a20da13aaa177f1a256e5fb63e7c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf438c8ef657577f61612ebe2e1c95a"><td class="memItemLeft" align="right" valign="top"><a id="a6cf438c8ef657577f61612ebe2e1c95a"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>checksum</b> () const</td></tr>
<tr class="separator:a6cf438c8ef657577f61612ebe2e1c95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea4b726707284210cc365ad454add03"><td class="memItemLeft" align="right" valign="top"><a id="a6ea4b726707284210cc365ad454add03"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_crashed</b> () const</td></tr>
<tr class="separator:a6ea4b726707284210cc365ad454add03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca08387779d587f8d3ea84b965ddc391"><td class="memItemLeft" align="right" valign="top"><a id="aca08387779d587f8d3ea84b965ddc391"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>auto_repair</b> () const</td></tr>
<tr class="separator:aca08387779d587f8d3ea84b965ddc391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2447668275a831bcf73b5c00818254a6"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count</a> (void) const</td></tr>
<tr class="separator:a2447668275a831bcf73b5c00818254a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2502e460566f2c4b506cc1b30eb79e0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> **<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>, enum thr_lock_type lock_type)=0</td></tr>
<tr class="separator:a2502e460566f2c4b506cc1b30eb79e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d7cf309121ec10e4150860c8caa12a"><td class="memItemLeft" align="right" valign="top">virtual uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">table_cache_type</a> ()</td></tr>
<tr class="separator:ab4d7cf309121ec10e4150860c8caa12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec87bfd95b71d14fafbb3f88569094f"><td class="memItemLeft" align="right" valign="top">virtual my_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2ec87bfd95b71d14fafbb3f88569094f">register_query_cache_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, char *table_key, uint key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)</td></tr>
<tr class="memdesc:a2ec87bfd95b71d14fafbb3f88569094f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a named table with a call back function to the query cache.  <a href="#a2ec87bfd95b71d14fafbb3f88569094f">More...</a><br /></td></tr>
<tr class="separator:a2ec87bfd95b71d14fafbb3f88569094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c0421f0cd48fdf8c3d64fb4c434a8f"><td class="memItemLeft" align="right" valign="top"><a id="ae2c0421f0cd48fdf8c3d64fb4c434a8f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>primary_key_is_clustered</b> ()</td></tr>
<tr class="separator:ae2c0421f0cd48fdf8c3d64fb4c434a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff2afe807f7e2bbdddb397ee65626ee"><td class="memItemLeft" align="right" valign="top"><a id="a4ff2afe807f7e2bbdddb397ee65626ee"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_ref</b> (const uchar *ref1, const uchar *ref2)</td></tr>
<tr class="separator:a4ff2afe807f7e2bbdddb397ee65626ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e765264bd31e0519e03e1bd53d8c6d2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">cond_push</a> (const <a class="el" href="class_item.html">Item</a> *cond)</td></tr>
<tr class="separator:a5e765264bd31e0519e03e1bd53d8c6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eb8d2966b848ec4beea5a25cba9dea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">cond_pop</a> ()</td></tr>
<tr class="separator:ac3eb8d2966b848ec4beea5a25cba9dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb554282443af443fc8aae4533e1407"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">idx_cond_push</a> (uint keyno, <a class="el" href="class_item.html">Item</a> *idx_cond)</td></tr>
<tr class="separator:a0bb554282443af443fc8aae4533e1407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc6ba204aa4d1bacc35d9d1d75ab15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">cancel_pushed_idx_cond</a> ()</td></tr>
<tr class="separator:a41cc6ba204aa4d1bacc35d9d1d75ab15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86930bf10b20ad19b3df07e07d28116e"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a86930bf10b20ad19b3df07e07d28116e">number_of_pushed_joins</a> () const</td></tr>
<tr class="separator:a86930bf10b20ad19b3df07e07d28116e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f6946109f48559e92a9e7c1b86517"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a624f6946109f48559e92a9e7c1b86517">root_of_pushed_join</a> () const</td></tr>
<tr class="separator:a624f6946109f48559e92a9e7c1b86517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef865015edc575d0a50d1a6f5b13e4a"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaef865015edc575d0a50d1a6f5b13e4a">parent_of_pushed_join</a> () const</td></tr>
<tr class="separator:aaef865015edc575d0a50d1a6f5b13e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38213f889f5312cd3e452fc34d11a201"><td class="memItemLeft" align="right" valign="top"><a id="a38213f889f5312cd3e452fc34d11a201"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_pushed</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a38213f889f5312cd3e452fc34d11a201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f56e97f4fb1faebbc23145492bf541d"><td class="memItemLeft" align="right" valign="top"><a id="a5f56e97f4fb1faebbc23145492bf541d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_next_pushed</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a5f56e97f4fb1faebbc23145492bf541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d800c8dafbc9efde9af932305529e4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">check_if_incompatible_data</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, uint table_changes)</td></tr>
<tr class="separator:a36d800c8dafbc9efde9af932305529e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67890a9deb89b9ef0128601e7687fcba"><td class="memItemLeft" align="right" valign="top">virtual enum_alter_inplace_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a67890a9deb89b9ef0128601e7687fcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecf7f9bf265e6801b625768f0f2bbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad0ecf7f9bf265e6801b625768f0f2bbe">ha_prepare_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:ad0ecf7f9bf265e6801b625768f0f2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b182710a133be9561afc149cb6aa8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a96b182710a133be9561afc149cb6aa8f">ha_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a96b182710a133be9561afc149cb6aa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec170a4aa71186f9dc17358b55587c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ec170a4aa71186f9dc17358b55587c7">ha_commit_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:a6ec170a4aa71186f9dc17358b55587c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b81b74b0b7b87de4f99ebe20c49dc44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5b81b74b0b7b87de4f99ebe20c49dc44">ha_notify_table_changed</a> ()</td></tr>
<tr class="separator:a5b81b74b0b7b87de4f99ebe20c49dc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac21f2d10c4463fb1d7e14882c6314f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key</a> ()</td></tr>
<tr class="memdesc:adac21f2d10c4463fb1d7e14882c6314f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f" title="use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY...">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key  <a href="#adac21f2d10c4463fb1d7e14882c6314f">More...</a><br /></td></tr>
<tr class="separator:adac21f2d10c4463fb1d7e14882c6314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923f2b845012582b5a343b5ede6129c1"><td class="memItemLeft" align="right" valign="top"><a id="a923f2b845012582b5a343b5ede6129c1"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>alter_table_flags</b> (uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:a923f2b845012582b5a343b5ede6129c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd7e44bc71120ace1e467ccb02ad06"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:ac8dd7e44bc71120ace1e467ccb02ad06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24fcaab09a75e81702c2e2c34fa0b62"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">delete_all_rows</a> ()</td></tr>
<tr class="separator:ac24fcaab09a75e81702c2e2c34fa0b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fdf15d81c256d3e6a9643532ff2126"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">truncate</a> ()</td></tr>
<tr class="separator:a13fdf15d81c256d3e6a9643532ff2126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e343a6e97ad5264e1fe5a70659899f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a27e343a6e97ad5264e1fe5a70659899f">reset_auto_increment</a> (ulonglong value)</td></tr>
<tr class="separator:a27e343a6e97ad5264e1fe5a70659899f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6916ee6d1e764fa795128fd46164f40d"><td class="memItemLeft" align="right" valign="top"><a id="a6916ee6d1e764fa795128fd46164f40d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a6916ee6d1e764fa795128fd46164f40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dd48aaf0c97e43f02180b45517c4c2"><td class="memItemLeft" align="right" valign="top"><a id="a85dd48aaf0c97e43f02180b45517c4c2"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>analyze</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a85dd48aaf0c97e43f02180b45517c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c1378edb4813d141f666ce2b9382a4"><td class="memItemLeft" align="right" valign="top"><a id="ac9c1378edb4813d141f666ce2b9382a4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_and_repair</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ac9c1378edb4813d141f666ce2b9382a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272e3a0622ad461a5a86c74ddb9289c6"><td class="memItemLeft" align="right" valign="top"><a id="a272e3a0622ad461a5a86c74ddb9289c6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>disable_indexes</b> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a272e3a0622ad461a5a86c74ddb9289c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22328b49eac2417561360bd00bbe8299"><td class="memItemLeft" align="right" valign="top"><a id="a22328b49eac2417561360bd00bbe8299"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>enable_indexes</b> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a22328b49eac2417561360bd00bbe8299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561768da16278d66deec08261111dbef"><td class="memItemLeft" align="right" valign="top"><a id="a561768da16278d66deec08261111dbef"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>discard_or_import_tablespace</b> (my_bool discard)</td></tr>
<tr class="separator:a561768da16278d66deec08261111dbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d474cf912188a562e9f419872031e"><td class="memItemLeft" align="right" valign="top"><a id="ac61d474cf912188a562e9f419872031e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>drop_table</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ac61d474cf912188a562e9f419872031e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741fbc5479d9ee0ccca766f3eca3703f"><td class="memItemLeft" align="right" valign="top"><a id="a741fbc5479d9ee0ccca766f3eca3703f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="ha__innodb_8cc.html#ae64f1475e9ca79d24be2a8091b9cbdd7">form</a>, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)=0</td></tr>
<tr class="separator:a741fbc5479d9ee0ccca766f3eca3703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fe1bf5cf87a258787ca67a2add8bd1"><td class="memItemLeft" align="right" valign="top"><a id="a75fe1bf5cf87a258787ca67a2add8bd1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create_handler_files</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a75fe1bf5cf87a258787ca67a2add8bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be47bbed1ce6bf15d11f786f1a7476c"><td class="memItemLeft" align="right" valign="top"><a id="a5be47bbed1ce6bf15d11f786f1a7476c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>change_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)</td></tr>
<tr class="separator:a5be47bbed1ce6bf15d11f786f1a7476c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed6471578e35fab41d3d623df55e686"><td class="memItemLeft" align="right" valign="top"><a id="a4ed6471578e35fab41d3d623df55e686"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>drop_partitions</b> (const char *path)</td></tr>
<tr class="separator:a4ed6471578e35fab41d3d623df55e686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579edf594ce51cd019654a790ff5ca64"><td class="memItemLeft" align="right" valign="top"><a id="a579edf594ce51cd019654a790ff5ca64"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rename_partitions</b> (const char *path)</td></tr>
<tr class="separator:a579edf594ce51cd019654a790ff5ca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae370a0f787c1b936e475a5762b91350c"><td class="memItemLeft" align="right" valign="top"><a id="ae370a0f787c1b936e475a5762b91350c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_ha_share_ref</b> (<a class="el" href="class_handler__share.html">Handler_share</a> **arg_ha_share)</td></tr>
<tr class="separator:ae370a0f787c1b936e475a5762b91350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a271a4a135d110cf6f22ae8ce664664"><td class="memItemLeft" align="right" valign="top"><a id="a6a271a4a135d110cf6f22ae8ce664664"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_lock_type</b> () const</td></tr>
<tr class="separator:a6a271a4a135d110cf6f22ae8ce664664"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a395bae75af9e51a116097a788b2cf57f"><td class="memItemLeft" align="right" valign="top"><a id="a395bae75af9e51a116097a788b2cf57f"></a>
<a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ht</b></td></tr>
<tr class="separator:a395bae75af9e51a116097a788b2cf57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c7037216007ba6140e6cff5162024d"><td class="memItemLeft" align="right" valign="top"><a id="a53c7037216007ba6140e6cff5162024d"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>ref</b></td></tr>
<tr class="separator:a53c7037216007ba6140e6cff5162024d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501dc41ecb010069e8bc9d035aae6aa"><td class="memItemLeft" align="right" valign="top"><a id="a7501dc41ecb010069e8bc9d035aae6aa"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>dup_ref</b></td></tr>
<tr class="separator:a7501dc41ecb010069e8bc9d035aae6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df561df4b2b6552a7b42189feb0400a"><td class="memItemLeft" align="right" valign="top"><a id="a1df561df4b2b6552a7b42189feb0400a"></a>
<a class="el" href="classha__statistics.html">ha_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stats</b></td></tr>
<tr class="separator:a1df561df4b2b6552a7b42189feb0400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec520eba79eb9f182c534e82c60ebc6"><td class="memItemLeft" align="right" valign="top"><a id="a9ec520eba79eb9f182c534e82c60ebc6"></a>
range_seq_t&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_iter</b></td></tr>
<tr class="separator:a9ec520eba79eb9f182c534e82c60ebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51e423645829d3e540c109556931fa"><td class="memItemLeft" align="right" valign="top"><a id="a2a51e423645829d3e540c109556931fa"></a>
<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_funcs</b></td></tr>
<tr class="separator:a2a51e423645829d3e540c109556931fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52372127bd238a7f622190316ba8124f"><td class="memItemLeft" align="right" valign="top"><a id="a52372127bd238a7f622190316ba8124f"></a>
<a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>multi_range_buffer</b></td></tr>
<tr class="separator:a52372127bd238a7f622190316ba8124f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a476dfe8526807dfc820c4b09f7a6d1"><td class="memItemLeft" align="right" valign="top"><a id="a1a476dfe8526807dfc820c4b09f7a6d1"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>ranges_in_seq</b></td></tr>
<tr class="separator:a1a476dfe8526807dfc820c4b09f7a6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff4dfb21c4583b55afc4fe5aba50389"><td class="memItemLeft" align="right" valign="top"><a id="adff4dfb21c4583b55afc4fe5aba50389"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_is_output_sorted</b></td></tr>
<tr class="separator:adff4dfb21c4583b55afc4fe5aba50389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2632d137c3a17fa583f08db5681e80a"><td class="memItemLeft" align="right" valign="top"><a id="af2632d137c3a17fa583f08db5681e80a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_have_range</b></td></tr>
<tr class="separator:af2632d137c3a17fa583f08db5681e80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2347edc229832e533d1fb73b236e32b"><td class="memItemLeft" align="right" valign="top"><a id="af2347edc229832e533d1fb73b236e32b"></a>
<a class="el" href="structst__key__multi__range.html">KEY_MULTI_RANGE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_cur_range</b></td></tr>
<tr class="separator:af2347edc229832e533d1fb73b236e32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d698fe9901f0f487c9618ddbb0f1be"><td class="memItemLeft" align="right" valign="top"><a id="a28d698fe9901f0f487c9618ddbb0f1be"></a>
<a class="el" href="structst__key__range.html">key_range</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>end_range</b></td></tr>
<tr class="separator:a28d698fe9901f0f487c9618ddbb0f1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186b7c7a70634a8e9758ed51708359c"><td class="memItemLeft" align="right" valign="top"><a id="a3186b7c7a70634a8e9758ed51708359c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>errkey</b></td></tr>
<tr class="separator:a3186b7c7a70634a8e9758ed51708359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5efc62f32ef66b55667fd8370ef33"><td class="memItemLeft" align="right" valign="top"><a id="a5ad5efc62f32ef66b55667fd8370ef33"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>key_used_on_scan</b></td></tr>
<tr class="separator:a5ad5efc62f32ef66b55667fd8370ef33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f2838eebffef46663c19f85d2ad2cc"><td class="memItemLeft" align="right" valign="top"><a id="a29f2838eebffef46663c19f85d2ad2cc"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>active_index</b></td></tr>
<tr class="separator:a29f2838eebffef46663c19f85d2ad2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64def328ff0ca7e391b217c2d3a758ec"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a></td></tr>
<tr class="separator:a64def328ff0ca7e391b217c2d3a758ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943005f89e7a6d5cee246e1c5b46e9ab"><td class="memItemLeft" align="right" valign="top"><a id="a943005f89e7a6d5cee246e1c5b46e9ab"></a>
<a class="el" href="structst__ft__info.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_handler</b></td></tr>
<tr class="separator:a943005f89e7a6d5cee246e1c5b46e9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745f5757f7d7d690fb30ea7df8f08d43"><td class="memItemLeft" align="right" valign="top"><a id="a745f5757f7d7d690fb30ea7df8f08d43"></a>
enum handler:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>inited</b></td></tr>
<tr class="separator:a745f5757f7d7d690fb30ea7df8f08d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd47d68a7b406d8777396a657095d5e8"><td class="memItemLeft" align="right" valign="top"><a id="afd47d68a7b406d8777396a657095d5e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>implicit_emptied</b></td></tr>
<tr class="separator:afd47d68a7b406d8777396a657095d5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2f8d7155cb44162bb4181cb09f2f3"><td class="memItemLeft" align="right" valign="top"><a id="a0ed2f8d7155cb44162bb4181cb09f2f3"></a>
const <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_cond</b></td></tr>
<tr class="separator:a0ed2f8d7155cb44162bb4181cb09f2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3d956f73649657bad389acfad5f0b"><td class="memItemLeft" align="right" valign="top"><a id="ae9b3d956f73649657bad389acfad5f0b"></a>
<a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond</b></td></tr>
<tr class="separator:ae9b3d956f73649657bad389acfad5f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc8d81143d1c9c10b976711fe44cf37"><td class="memItemLeft" align="right" valign="top"><a id="a4dc8d81143d1c9c10b976711fe44cf37"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond_keyno</b></td></tr>
<tr class="separator:a4dc8d81143d1c9c10b976711fe44cf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ab295e407d8a5c50087fed0f4fcd18"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a></td></tr>
<tr class="separator:a62ab295e407d8a5c50087fed0f4fcd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd2cafd83ae60562649bf9688aebf1"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a></td></tr>
<tr class="separator:a05dd2cafd83ae60562649bf9688aebf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1540a47a05c03724f1102aaaa623131e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_discrete__interval.html">Discrete_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">auto_inc_interval_for_cur_row</a></td></tr>
<tr class="separator:a1540a47a05c03724f1102aaaa623131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfcef0738a89138c8f41ded8da17c0a"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a></td></tr>
<tr class="separator:acdfcef0738a89138c8f41ded8da17c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e7cba3fe3bf9731a91be82983cc35"><td class="memItemLeft" align="right" valign="top">PSI_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a></td></tr>
<tr class="separator:a881e7cba3fe3bf9731a91be82983cc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af8c2b258691e5baac8dd22d19c084b37"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">index_read_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="memdesc:af8c2b258691e5baac8dd22d19c084b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="#af8c2b258691e5baac8dd22d19c084b37">More...</a><br /></td></tr>
<tr class="separator:af8c2b258691e5baac8dd22d19c084b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0c549a00023dd44682cd9452cf830"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">index_read_idx_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="memdesc:acba0c549a00023dd44682cd9452cf830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="#acba0c549a00023dd44682cd9452cf830">More...</a><br /></td></tr>
<tr class="separator:acba0c549a00023dd44682cd9452cf830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca48f687872e10a4fdc35b418d98b761"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">index_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:aca48f687872e10a4fdc35b418d98b761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab892ae78db6437119d2d25621118b7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">index_prev</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a1ab892ae78db6437119d2d25621118b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37bd518c53c966459632584c34855d0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af37bd518c53c966459632584c34855d0">index_first</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:af37bd518c53c966459632584c34855d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d62ffab7408a031b13e547eb58be09"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">index_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:aa1d62ffab7408a031b13e547eb58be09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5459b92420f74e6f88dec137e1941d22"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">index_next_same</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a5459b92420f74e6f88dec137e1941d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae069d5991214e1fdf14cc44fd865a180"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">index_read_last_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="memdesc:ae069d5991214e1fdf14cc44fd865a180"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="#ae069d5991214e1fdf14cc44fd865a180">More...</a><br /></td></tr>
<tr class="separator:ae069d5991214e1fdf14cc44fd865a180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cb9c94ca93dbfbb7e92822caba82a1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">rnd_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)=0</td></tr>
<tr class="separator:a48cb9c94ca93dbfbb7e92822caba82a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf659edd9d870e90c8974ae0eba7a082"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">rnd_pos</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uchar *pos)=0</td></tr>
<tr class="separator:adf659edd9d870e90c8974ae0eba7a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25b3931a457f1821ba55ae9cce79d98"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:ab25b3931a457f1821ba55ae9cce79d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b4c3a8fe1c89c6ccfec1f4b144754a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a90b4c3a8fe1c89c6ccfec1f4b144754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0786a5f57ccd3c97bff07b1afeae9c06"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:a0786a5f57ccd3c97bff07b1afeae9c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aaaf2105e60ca590b79fae82e48960"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed</a> ()</td></tr>
<tr class="separator:a26aaaf2105e60ca590b79fae82e48960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25b44b50ac64192d6cfef591252ed7"><td class="memItemLeft" align="right" valign="top"><a id="aad25b44b50ac64192d6cfef591252ed7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_statistic_increment</b> (ulonglong SSV::*<a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>) const</td></tr>
<tr class="separator:aad25b44b50ac64192d6cfef591252ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57260c07a7ed5d6522a02d473e8ceb1d"><td class="memItemLeft" align="right" valign="top"><a id="a57260c07a7ed5d6522a02d473e8ceb1d"></a>
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ha_data</b> (THD *) const</td></tr>
<tr class="separator:a57260c07a7ed5d6522a02d473e8ceb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df65ee64bcedb5a4b34bf752b2fab08"><td class="memItemLeft" align="right" valign="top"><a id="a9df65ee64bcedb5a4b34bf752b2fab08"></a>
THD *&#160;</td><td class="memItemRight" valign="bottom"><b>ha_thd</b> (void) const</td></tr>
<tr class="separator:a9df65ee64bcedb5a4b34bf752b2fab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69803cd29d92bfecd97212354212c516"><td class="memItemLeft" align="right" valign="top">PSI_table_share *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a69803cd29d92bfecd97212354212c516">ha_table_share_psi</a> (const <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share) const</td></tr>
<tr class="separator:a69803cd29d92bfecd97212354212c516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bf8fa32d87654794e6b1c3b3fb8d32"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">rename_table</a> (const char *<a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a>, const char *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>)</td></tr>
<tr class="separator:a58bf8fa32d87654794e6b1c3b3fb8d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53ec34116b901cc08e5a87f5ec681a6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">delete_table</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ae53ec34116b901cc08e5a87f5ec681a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccf806316a9d88a7130d70e7637e8e5"><td class="memItemLeft" align="right" valign="top"><a id="a4ccf806316a9d88a7130d70e7637e8e5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a4ccf806316a9d88a7130d70e7637e8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90af353b21f935dc95212e1cfef50452"><td class="memItemLeft" align="right" valign="top"><a id="a90af353b21f935dc95212e1cfef50452"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_last</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len)</td></tr>
<tr class="separator:a90af353b21f935dc95212e1cfef50452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf21a8ad4be872bbfe94f5cb40abca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_handler__share.html">Handler_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">get_ha_share_ptr</a> ()</td></tr>
<tr class="separator:a13bf21a8ad4be872bbfe94f5cb40abca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24470ac1d4ac336cedbe7c245d321c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">set_ha_share_ptr</a> (<a class="el" href="class_handler__share.html">Handler_share</a> *arg_ha_share)</td></tr>
<tr class="separator:ab24470ac1d4ac336cedbe7c245d321c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a39db9dc1cca31f4a3ec0e0e1d7300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">lock_shared_ha_data</a> ()</td></tr>
<tr class="separator:aa3a39db9dc1cca31f4a3ec0e0e1d7300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059bbed3de416b3bea51c69dc064e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">unlock_shared_ha_data</a> ()</td></tr>
<tr class="separator:a8059bbed3de416b3bea51c69dc064e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b094cfe680aa06a7d8b70194415aa3b"><td class="memItemLeft" align="right" valign="top"><a id="a3b094cfe680aa06a7d8b70194415aa3b"></a>
<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table_share</b></td></tr>
<tr class="separator:a3b094cfe680aa06a7d8b70194415aa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0d051d1ef534891b27612cc4ff56f7"><td class="memItemLeft" align="right" valign="top"><a id="abb0d051d1ef534891b27612cc4ff56f7"></a>
<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table</b></td></tr>
<tr class="separator:abb0d051d1ef534891b27612cc4ff56f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98743b18a24c8baef7e22a11df74d6c9"><td class="memItemLeft" align="right" valign="top"><a id="a98743b18a24c8baef7e22a11df74d6c9"></a>
Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>cached_table_flags</b></td></tr>
<tr class="separator:a98743b18a24c8baef7e22a11df74d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44b6a4c101f982cd13a344dce5a870"><td class="memItemLeft" align="right" valign="top"><a id="adf44b6a4c101f982cd13a344dce5a870"></a>
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>estimation_rows_to_insert</b></td></tr>
<tr class="separator:adf44b6a4c101f982cd13a344dce5a870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011df14ecc738037499572c304d8ee90"><td class="memItemLeft" align="right" valign="top"><a id="a011df14ecc738037499572c304d8ee90"></a>
<a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>range_key_part</b></td></tr>
<tr class="separator:a011df14ecc738037499572c304d8ee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272c3d9b40a9e7c5de20ed390d23a636"><td class="memItemLeft" align="right" valign="top"><a id="a272c3d9b40a9e7c5de20ed390d23a636"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>eq_range</b></td></tr>
<tr class="separator:a272c3d9b40a9e7c5de20ed390d23a636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a159ca294d8dafe32405e6ad546e6a4"><td class="memItemLeft" align="right" valign="top"><a id="a1a159ca294d8dafe32405e6ad546e6a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>in_range_check_pushed_down</b></td></tr>
<tr class="separator:a1a159ca294d8dafe32405e6ad546e6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8556e08dd260c7856c7b5952e316e533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8556e08dd260c7856c7b5952e316e533">mark_trx_read_write</a> ()</td></tr>
<tr class="separator:a8556e08dd260c7856c7b5952e316e533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1b2b798ea75e6663a4367f0658f6f1"><td class="memItemLeft" align="right" valign="top"><a id="a3d1b2b798ea75e6663a4367f0658f6f1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>open</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, int <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, uint test_if_locked)=0</td></tr>
<tr class="separator:a3d1b2b798ea75e6663a4367f0658f6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d762c5bae301ed92e1f393ed39d347"><td class="memItemLeft" align="right" valign="top"><a id="a71d762c5bae301ed92e1f393ed39d347"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>close</b> (void)=0</td></tr>
<tr class="separator:a71d762c5bae301ed92e1f393ed39d347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fefa98fca726c4807e5a763603ff22d"><td class="memItemLeft" align="right" valign="top"><a id="a1fefa98fca726c4807e5a763603ff22d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_init</b> (uint idx, bool sorted)</td></tr>
<tr class="separator:a1fefa98fca726c4807e5a763603ff22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec3aae2f0c2981d6c17d6a46107e67"><td class="memItemLeft" align="right" valign="top"><a id="abfec3aae2f0c2981d6c17d6a46107e67"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_end</b> ()</td></tr>
<tr class="separator:abfec3aae2f0c2981d6c17d6a46107e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddfc5530e45a9340e2de99626085da6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9ddfc5530e45a9340e2de99626085da6">rnd_init</a> (bool scan)=0</td></tr>
<tr class="separator:a9ddfc5530e45a9340e2de99626085da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590d32e2e1c26e4e9dcfc8228750b0ab"><td class="memItemLeft" align="right" valign="top"><a id="a590d32e2e1c26e4e9dcfc8228750b0ab"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rnd_end</b> ()</td></tr>
<tr class="separator:a590d32e2e1c26e4e9dcfc8228750b0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1b106e8d678dfa576110d0260c56e5"><td class="memItemLeft" align="right" valign="top"><a id="adf1b106e8d678dfa576110d0260c56e5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>write_row</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a> <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:adf1b106e8d678dfa576110d0260c56e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8f7e55649146ad116762746624b43a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4a8f7e55649146ad116762746624b43a">update_row</a> (const uchar *old_data <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)), uchar *new_data <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:a4a8f7e55649146ad116762746624b43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa6e6943768af7e1e8cc09f2448dba0"><td class="memItemLeft" align="right" valign="top"><a id="a8fa6e6943768af7e1e8cc09f2448dba0"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>delete_row</b> (const uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a> <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:a8fa6e6943768af7e1e8cc09f2448dba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1161c615e45f4bd9c285a0e3c1e332af"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1161c615e45f4bd9c285a0e3c1e332af">reset</a> ()</td></tr>
<tr class="separator:a1161c615e45f4bd9c285a0e3c1e332af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfa0934ac54d557e2dc9bd2bb634645"><td class="memItemLeft" align="right" valign="top"><a id="a8dfa0934ac54d557e2dc9bd2bb634645"></a>
virtual Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>table_flags</b> (void) const =0</td></tr>
<tr class="separator:a8dfa0934ac54d557e2dc9bd2bb634645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8a280267b411d658ee6454119d9457"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afe8a280267b411d658ee6454119d9457">external_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a> <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)), int lock_type <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:afe8a280267b411d658ee6454119d9457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c86ff21b8c2db61977f93746bb6727"><td class="memItemLeft" align="right" valign="top"><a id="ae3c86ff21b8c2db61977f93746bb6727"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>release_auto_increment</b> ()</td></tr>
<tr class="separator:ae3c86ff21b8c2db61977f93746bb6727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1642bdb1665421244f2b838861c4be3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af1642bdb1665421244f2b838861c4be3">check_for_upgrade</a> (<a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:af1642bdb1665421244f2b838861c4be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d96ec07431febfeba83276cfad98261"><td class="memItemLeft" align="right" valign="top"><a id="a0d96ec07431febfeba83276cfad98261"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>check</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a0d96ec07431febfeba83276cfad98261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889322859f50e88a643067fb706c2bf2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a889322859f50e88a643067fb706c2bf2">repair</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a889322859f50e88a643067fb706c2bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd85e3e0874cd0d4382e8c3c3ab125c"><td class="memItemLeft" align="right" valign="top"><a id="accd85e3e0874cd0d4382e8c3c3ab125c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>start_bulk_insert</b> (ha_rows rows)</td></tr>
<tr class="separator:accd85e3e0874cd0d4382e8c3c3ab125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7d63db38d9257bb09cb9b5cb436533"><td class="memItemLeft" align="right" valign="top"><a id="aca7d63db38d9257bb09cb9b5cb436533"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>end_bulk_insert</b> ()</td></tr>
<tr class="separator:aca7d63db38d9257bb09cb9b5cb436533"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adc7be2189144804352df9694dee41697"><td class="memItemLeft" align="right" valign="top"><a id="adc7be2189144804352df9694dee41697"></a>
<a class="el" href="structst__key__range.html">key_range</a>&#160;</td><td class="memItemRight" valign="bottom"><b>save_end_range</b></td></tr>
<tr class="separator:adc7be2189144804352df9694dee41697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25db78fcce70b0b1034534c1a5d11964"><td class="memItemLeft" align="right" valign="top"><a id="a25db78fcce70b0b1034534c1a5d11964"></a>
enum_range_scan_direction&#160;</td><td class="memItemRight" valign="bottom"><b>range_scan_direction</b></td></tr>
<tr class="separator:a25db78fcce70b0b1034534c1a5d11964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dcf02628357621b80f80086d8b3de8"><td class="memItemLeft" align="right" valign="top"><a id="af0dcf02628357621b80f80086d8b3de8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>key_compare_result_on_equal</b></td></tr>
<tr class="separator:af0dcf02628357621b80f80086d8b3de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391dcf2f67a2d4d48e915c3bcd6609be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a391dcf2f67a2d4d48e915c3bcd6609be">m_lock_type</a></td></tr>
<tr class="separator:a391dcf2f67a2d4d48e915c3bcd6609be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f83e0c7122ec3d276dcb0a0b940754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_handler__share.html">Handler_share</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a97f83e0c7122ec3d276dcb0a0b940754">ha_share</a></td></tr>
<tr class="separator:a97f83e0c7122ec3d276dcb0a0b940754"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a576b2e6999b5b4fbe40abb7870fe33b2"><td class="memItemLeft" align="right" valign="top"><a id="a576b2e6999b5b4fbe40abb7870fe33b2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DsMrr_impl</b></td></tr>
<tr class="separator:a576b2e6999b5b4fbe40abb7870fe33b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_sql__alloc"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_sql__alloc')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_sql__alloc.html">Sql_alloc</a></td></tr>
<tr class="memitem:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a193100cab44074df6f4f1507b333dcda"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)  throw ()</td></tr>
<tr class="separator:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a14b17bd7ec22fc7a7e5b56702e5630a6"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)  throw ()</td></tr>
<tr class="separator:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a13f2eacbb6adcee5c9ac94629e2863b3"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)  throw ()</td></tr>
<tr class="separator:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a06adbd3404f702994fd10619c41267f0"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)  throw ()</td></tr>
<tr class="separator:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a1e428ed5b826482a49b1d8a1d246a579"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a7c08622003a34134a56eccaf2d95c0b9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="ab0c7ed4b5a1eb798f3af463eb84b1e3b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a6dd86b56cecc3919504cf5e1452f2511"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The handler class is the interface for dynamically loadable storage engines. Do not add ifdefs and take care when adding or changing virtual functions to avoid vtable confusion</p>
<p>Functions in this class accept and return table columns data. Two data representation formats are used:</p><ol type="1">
<li>TableRecordFormat - Used to pass [partial] table records to/from storage engine</li>
<li>KeyTupleFormat - used to pass index search tuples (aka "keys") to storage engine. See opt_range.cc for description of this format.</li>
</ol>
<h1>TableRecordFormat </h1>
<p>[Warning: this description is work in progress and may be incomplete] The table record is stored in a fixed-size buffer:</p>
<p>record: null_bytes, column1_data, column2_data, ...</p>
<p>The offsets of the parts of the buffer are also fixed: every column has an offset to its column{i}_data, and if it is nullable it also has its own bit in null_bytes.</p>
<p>The record buffer only includes data about columns that are marked in the relevant column set (table-&gt;read_set and/or table-&gt;write_set, depending on the situation). &lt;not-sure&gt;It could be that it is required that null bits of non-present columns are set to 1&lt;/not-sure&gt;</p>
<p>VARIOUS EXCEPTIONS AND SPECIAL CASES</p>
<p>f the table has no nullable columns, then null_bytes is still present, its length is one byte &lt;not-sure&gt; which must be set to 0xFF at all times. &lt;/not-sure&gt;</p>
<p>If the table has columns of type BIT, then certain bits from those columns may be stored in null_bytes as well. Grep around for <a class="el" href="class_field__bit.html">Field_bit</a> for details.</p>
<p>For blob columns (see <a class="el" href="class_field__blob.html">Field_blob</a>), the record buffer stores length of the data, following by memory pointer to the blob data. The pointer is owned by the storage engine and is valid until the next operation.</p>
<p>If a blob column has NULL value, then its length and blob data pointer must be set to 0. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a748d5e5b6dbbb0681cbac2ad881505c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748d5e5b6dbbb0681cbac2ad881505c9">&#9670;&nbsp;</a></span>bas_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char** handler::bas_ext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If frm_error() is called then we will use this to find out what file extentions exist for the storage engine. This is also used by the default rename_table and delete_table method in <a class="el" href="handler_8cc.html" title="Handler-calling-functions. ">handler.cc</a>.</p>
<p>For engines that have two file name extentions (separate meta/index file and data file), the order of elements is relevant. First element of engine file name extentions array should be meta/index file extention. Second element - data file extention. This order is assumed by prepare_for_repair() when REPAIR <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> ... USE_FRM is issued. </p>

<p>Implemented in <a class="el" href="classha__partition.html#aad1b45cb204fe8102d7ac0b3214c8353">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a1a1a0923d91ef3355022c597fe97ba58">ha_ndbcluster</a>, <a class="el" href="classha__federated.html#ad6e566087ef70ec0679e3c49cc30dc3c">ha_federated</a>, <a class="el" href="classha__innobase.html#a678fe7a653db9708db5a37e49af65e75">ha_innobase</a>, <a class="el" href="classha__tina.html#aa0371e64ee4ed65477016939d027af3d">ha_tina</a>, <a class="el" href="classha__archive.html#a1bbc4cc03860b6cb821227340f771245">ha_archive</a>, <a class="el" href="classha__example.html#a3f8d3117cbd6d46551ca107944e0e91b">ha_example</a>, <a class="el" href="classha__myisammrg.html#a8d54f3e8a42b0b188cb2674274789157">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a31d5a4992a8d921acd2cd87964506eae">ha_myisam</a>, <a class="el" href="classha__perfschema.html#ac4048c9d253539bd1c9e84bb57852d72">ha_perfschema</a>, <a class="el" href="classha__blackhole.html#af36e08b909c98ee4bb62de2e665fad3f">ha_blackhole</a>, <a class="el" href="classha__heap.html#ad392c12df94e3da85d7030096b864ba5">ha_heap</a>, and <a class="el" href="classha__ndbinfo.html#ae7153997d64cb4e94ce23ecfb92714fb">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="ac8dd7e44bc71120ace1e467ccb02ad06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dd7e44bc71120ace1e467ccb02ad06">&#9670;&nbsp;</a></span>bulk_update_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::bulk_update_row </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is similar to update_row, however the handler doesn't need to execute the updates at this point in time. The handler can be certain that another call to bulk_update_row will occur OR a call to exec_bulk_update before the set of updates in this query is concluded.</p>
<p>Note: If HA_ERR_FOUND_DUPP_KEY is returned, the handler must read all columns of the row so MySQL can create an error message. If the columns required for the error message are not read, the error message will contain garbage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_data</td><td>Old record </td></tr>
    <tr><td class="paramname">new_data</td><td>New record </td></tr>
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a89cbc7ca67dcd89d07693186f5de7ca5">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a6baab93a22543b707e6e59b9d59810d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6baab93a22543b707e6e59b9d59810d2">&#9670;&nbsp;</a></span>can_switch_engines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::can_switch_engines </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used in ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> to check if changing storage engine is allowed.</p>
<dl class="section note"><dt>Note</dt><dd>Called without holding thr_lock.c lock.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Changing storage engine is allowed. </td></tr>
    <tr><td class="paramname">false</td><td>Changing storage engine not allowed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a8b83aeaba7dadd1b28c22457ac67f43b">ha_partition</a>, and <a class="el" href="classha__innobase.html#afd3165bcb0f9f9d6902fb11e6bac1da8">ha_innobase</a>.</p>

</div>
</div>
<a id="a41cc6ba204aa4d1bacc35d9d1d75ab15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cc6ba204aa4d1bacc35d9d1d75ab15">&#9670;&nbsp;</a></span>cancel_pushed_idx_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::cancel_pushed_idx_cond </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset information about pushed index conditions </p>

</div>
</div>
<a id="a234580f9765751ce185182dd1edc3bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234580f9765751ce185182dd1edc3bdb">&#9670;&nbsp;</a></span>check_collation_compatibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::check_collation_compatibility </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> for incompatible collation changes.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ADMIN_NEEDS_UPGRADE</td><td>Table may have data requiring upgrade. </td></tr>
    <tr><td class="paramname">0</td><td>No upgrade required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1642bdb1665421244f2b838861c4be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1642bdb1665421244f2b838861c4be3">&#9670;&nbsp;</a></span>check_for_upgrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::check_for_upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>admin commands - called from mysql_admin_table </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#af912fe341244ec80ccdf21c9b87e4e02">ha_partition</a>, and <a class="el" href="classha__archive.html#acf2e77279cfb3557b574f4bc04ec11d5">ha_archive</a>.</p>

</div>
</div>
<a id="a36d800c8dafbc9efde9af932305529e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d800c8dafbc9efde9af932305529e4">&#9670;&nbsp;</a></span>check_if_incompatible_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::check_if_incompatible_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Part of old, deprecated in-place ALTER API. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a66a9fc27dbc3652fec1fab4c7d9c077c">ha_partition</a>, <a class="el" href="classha__innobase.html#aaeb2efbc261d05d135f2c3761eacdbe9">ha_innobase</a>, <a class="el" href="classha__archive.html#a771ab38bf7a0c5dfe086d26d6861e58c">ha_archive</a>, <a class="el" href="classha__tina.html#ad0e36769ab1075b7e0c14f3f7ff9cddd">ha_tina</a>, <a class="el" href="classha__myisam.html#aa30308ae79416409f6f72a2ef924fba6">ha_myisam</a>, <a class="el" href="classha__myisammrg.html#a5c11f87e3f07c2f1829f35200fe0a88b">ha_myisammrg</a>, and <a class="el" href="classha__heap.html#a9ad4af89cf9c9286836b064d969ceb41">ha_heap</a>.</p>

</div>
</div>
<a id="a67890a9deb89b9ef0128601e7687fcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67890a9deb89b9ef0128601e7687fcba">&#9670;&nbsp;</a></span>check_if_supported_inplace_alter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_alter_inplace_result handler::check_if_supported_inplace_alter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if a storage engine supports a particular alter table in-place</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ALTER_ERROR</td><td>Unexpected error. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NOT_SUPPORTED</td><td>Not supported, must use copy. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_EXCLUSIVE_LOCK</td><td>Supported, but requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE</td><td>Supported, but requires SNW lock during main phase. Prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK</td><td>Supported, but requires SNW lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE</td><td>Supported, concurrent reads/writes allowed. However, prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK</td><td>Supported, concurrent reads/writes allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation uses the old in-place ALTER API to determine if the storage engine supports in-place ALTER or not.</dd>
<dd>
Called without holding thr_lock.c lock. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#aeeb5f75cddb82102a64ac36bfceaef57">ha_partition</a>, and <a class="el" href="classha__innobase.html#a2e45aaeee263279fdfdc1b57c82ce020">ha_innobase</a>.</p>

</div>
</div>
<a id="a4de97045e5381007565fd2b0da235c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de97045e5381007565fd2b0da235c07">&#9670;&nbsp;</a></span>column_bitmaps_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::column_bitmaps_signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MySQL signal that it changed the column bitmap. </p>
<p>Signal that the table-&gt;read_set and table-&gt;write_set table maps changed The handler is allowed to set additional bits in the above map in this call. Normally the handler should ignore all calls until we have done a <a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init()</a> or <a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init()</a>, write_row(), update_row or delete_row() as there may be several calls to this routine.</p>
<p>USAGE This is for handlers that needs to setup their own column bitmaps. Normally the handler should set up their own column bitmaps in index_init() or <a class="el" href="classhandler.html#a9ddfc5530e45a9340e2de99626085da6">rnd_init()</a> and in any <a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07" title="MySQL signal that it changed the column bitmap. ">column_bitmaps_signal()</a> call after this.</p>
<p>The handler is allowd to do changes to the bitmap after a index_init or <a class="el" href="classhandler.html#a9ddfc5530e45a9340e2de99626085da6">rnd_init()</a> call is made as after this, MySQL will not use the bitmap for any program logic checking. </p>

</div>
</div>
<a id="a0786a5f57ccd3c97bff07b1afeae9c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0786a5f57ccd3c97bff07b1afeae9c06">&#9670;&nbsp;</a></span>commit_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::commit_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Commit or rollback the changes made during <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> and <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> inside the storage engine. Note that in case of rollback the allowed level of concurrency during this operation will be the same as for <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> and thus might be higher than during <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a>. (For example, concurrent writes were blocked during prepare, but might not be during rollback).</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function with commit= true reports error, it will be called again with commit= false.</dd>
<dd>
In case of partitioning, this function might be called for rollback without <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> having been called first. Also partitioned tables sets ha_alter_info-&gt;group_commit_ctx to a NULL terminated array of the partitions handlers and if all of them are committed as one, then group_commit_ctx should be set to NULL to indicate to the partitioning handler that all partitions handlers are committed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">commit</td><td>True =&gt; Commit, False =&gt; Rollback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">ha_partition</a>, and <a class="el" href="classha__innobase.html#ab181db6334fe348fd1571ee862cee747">ha_innobase</a>.</p>

</div>
</div>
<a id="af0ef38e7407e87ba5d1ccde59c3e94bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ef38e7407e87ba5d1ccde59c3e94bb">&#9670;&nbsp;</a></span>compare_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::compare_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__key__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare if found key (in row) is over max-value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>range to compare to row. May be 0 for no range</td></tr>
  </table>
  </dd>
</dl>
<p>key.cc::key_cmp()</p>
<dl class="section return"><dt>Returns</dt><dd>The return value is SIGN(key_in_row - range_key):</dd></dl>
<ul>
<li>0 : <a class="el" href="class_key.html">Key</a> is equal to range or 'range' == 0 (no range)</li>
<li>-1 : <a class="el" href="class_key.html">Key</a> is less than range</li>
<li>1 : <a class="el" href="class_key.html">Key</a> is larger than range </li>
</ul>

</div>
</div>
<a id="ac3eb8d2966b848ec4beea5a25cba9dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3eb8d2966b848ec4beea5a25cba9dea">&#9670;&nbsp;</a></span>cond_pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::cond_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pop the top condition from the condition stack of the handler instance.</p>
<p>Pops the top if condition stack, if stack is not empty. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a0de805435e8251f27ba3394052f6b1c7">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a5e765264bd31e0519e03e1bd53d8c6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e765264bd31e0519e03e1bd53d8c6d2">&#9670;&nbsp;</a></span>cond_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_item.html">Item</a>* handler::cond_push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Push condition down to the table handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to be pushed. The condition tree must not be modified by the by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 'remainder' condition that caller must use to filter out records. NULL means the handler will not return rows that do not match the passed condition.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pushed conditions form a stack (from which one can remove the last pushed condition using cond_pop). The table handler filters out rows using (pushed_cond1 AND pushed_cond2 AND ... AND pushed_condN) or less restrictive condition, depending on handler's capabilities.</dd></dl>
<p>handler-&gt;<a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42" title="Check handler usage and reset state of file to after &#39;open&#39;. ">ha_reset()</a> call empties the condition stack. Calls to rnd_init/rnd_end, index_init/index_end etc do not affect the condition stack. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a37925498bba3ddd31b4afee378c640b1">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="ac24fcaab09a75e81702c2e2c34fa0b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24fcaab09a75e81702c2e2c34fa0b62">&#9670;&nbsp;</a></span>delete_all_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::delete_all_rows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is called to delete all rows in a table If the handler don't support this, then this function will return HA_ERR_WRONG_COMMAND and MySQL will delete the rows one by one. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#ad162b32125ed0d7fb4b5b8167ce0269d">ha_partition</a>, <a class="el" href="classha__federated.html#a7f53d2c40b274dcfb705f11be3fc9b0e">ha_federated</a>, <a class="el" href="classha__example.html#ab1d6cf958a0680f3d88c46436ce66289">ha_example</a>, <a class="el" href="classha__perfschema.html#a5dfc6f75bcdbbda6ec136f2297ab8d12">ha_perfschema</a>, <a class="el" href="classha__tina.html#ae735df6b44849bfc06c3ba437d412ad6">ha_tina</a>, <a class="el" href="classha__myisam.html#a57b271c61925ecbda72b535edb2deef6">ha_myisam</a>, and <a class="el" href="classha__heap.html#aab577dd3fecdf12c8e30daa387e6e0f5">ha_heap</a>.</p>

</div>
</div>
<a id="ae53ec34116b901cc08e5a87f5ec681a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53ec34116b901cc08e5a87f5ec681a6">&#9670;&nbsp;</a></span>delete_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete a table in the engine. Called for base as well as temporary tables.</p>
<p>Delete all files with extension from <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Base name of table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We assume that the handler may return more extensions than was actually used for the file.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If we successfully deleted at least one file from base_ext and didn't get any other errors than ENOENT </td></tr>
    <tr><td class="paramname">!0</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a4d32721908372dc62c490e14a005e03c">ha_ndbcluster</a>, <a class="el" href="classha__partition.html#aafdb3caedb579b35d9cda963b7a3c25f">ha_partition</a>, <a class="el" href="classha__example.html#ab94f006f60672e56b656710cbf0deb01">ha_example</a>, <a class="el" href="classha__innobase.html#aa9ec3c69d0250c2ef1b1c5c5bd61153d">ha_innobase</a>, <a class="el" href="classha__perfschema.html#a9529ce69617d9502e14588fd5cc295d6">ha_perfschema</a>, <a class="el" href="classha__myisam.html#a447cd3ddb5ada6cb070c4e4d68abdb1b">ha_myisam</a>, and <a class="el" href="classha__heap.html#ac0c837c00533811e1f87032602f9f86a">ha_heap</a>.</p>

</div>
</div>
<a id="af5f9f1ca2b5efc0b41e96c6b793d9bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f9f1ca2b5efc0b41e96c6b793d9bb1">&#9670;&nbsp;</a></span>end_bulk_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::end_bulk_delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute all outstanding deletes and close down the bulk delete.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#ab761a08948c878a989db3bb40450bce4">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a2bf6c46d66ca282a4cbd6118e4c99e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf6c46d66ca282a4cbd6118e4c99e03">&#9670;&nbsp;</a></span>end_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::end_bulk_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform any needed clean-up, no outstanding updates are there at the moment. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a3c3b80b72e921059f62aed3eda1db911">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a517d99c283e85e8d97460f07a781dabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517d99c283e85e8d97460f07a781dabf">&#9670;&nbsp;</a></span>end_read_removal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows handler::end_read_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End read (before write) removal and return the number of rows really written </p><dl class="section see"><dt>See also</dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a81e58b0a19c7cc7d857a3f00e039ae37">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="ae59e9a1d36d852f4dd5dd00bff5f1ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59e9a1d36d852f4dd5dd00bff5f1ae4">&#9670;&nbsp;</a></span>estimate_rows_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows handler::estimate_rows_upper_bound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return upper bound of current number of records in the table (max. of how many records one will retrieve when doing a full table scan) If upper bound is not known, HA_POS_ERROR should be returned as a max possible upper bound. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a663485370abf958b89641924402db405">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a59555b02c52fc703e99a41d3ee3a04c3">ha_ndbcluster</a>, <a class="el" href="classha__federated.html#a99f0d5d0a990a1090035d58ebcda59d0">ha_federated</a>, <a class="el" href="classha__innobase.html#a747831324f241471b06cb9db6cc4908d">ha_innobase</a>, <a class="el" href="classha__tina.html#a9e7d7de52e4888bc3768f3e889797e30">ha_tina</a>, and <a class="el" href="classha__perfschema.html#a504fefab7dd8d389b61959c1a0620ef5">ha_perfschema</a>.</p>

</div>
</div>
<a id="a886bf2fbf16de7e200e3ebc0765fb6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886bf2fbf16de7e200e3ebc0765fb6e4">&#9670;&nbsp;</a></span>exec_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::exec_bulk_update </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After this call all outstanding updates must be performed. The number of duplicate key errors are reported in the duplicate key parameter. It is allowed to continue to the batched update after this call, the handler has to wait until end_bulk_update with changing state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a5c9f552924c7168373ab0d1c2ba0e049">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="afe8a280267b411d658ee6454119d9457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8a280267b411d658ee6454119d9457">&#9670;&nbsp;</a></span>external_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::external_lock </td>
          <td>(</td>
          <td class="paramtype">THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a> &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int lock_type &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is not invoked for non-transactional temporary tables.</p>
<p>Tells the storage engine that we intend to read or write data from the table. This call is prefixed with a call to <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">handler::store_lock()</a> and is invoked only for those handler instances that stored the lock.</p>
<p>Calls to rnd_init/index_init are prefixed with this call. When table IO is complete, we call external_lock(F_UNLCK). A storage engine writer should expect that each call to ::external_lock(F_[RD|WR]LOCK is followed by a call to ::external_lock(F_UNLCK). If it is not, it is a bug in MySQL.</p>
<p>The name and signature originate from the first implementation in MyISAM, which would call fcntl to set/clear an advisory lock on the data file in this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_type</td><td>F_RDLCK, F_WRLCK, F_UNLCK</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-0 in case of failure, 0 in case of success. When lock_type is F_UNLCK, the return value is ignored. </dd></dl>

</div>
</div>
<a id="aaf6af760a4ef09984a5cc1dc58db9a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6af760a4ef09984a5cc1dc58db9a40">&#9670;&nbsp;</a></span>get_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::get_auto_increment </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>nb_desired_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>first_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>nb_reserved_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reserves an interval of auto_increment values from the handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>offset (modulus increment) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">increment</td><td>increment between calls </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nb_desired_values</td><td>how many values we want </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_value</td><td>the first value reserved by the handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_reserved_values</td><td>how many values the handler reserved</td></tr>
  </table>
  </dd>
</dl>
<p>offset and increment means that we want values to be of the form offset + N * increment, where N&gt;=0 is integer. If the function sets *first_value to ULONGLONG_MAX it means an error. If the function sets *nb_reserved_values to ULONGLONG_MAX it means it has reserved to "positive infinite". </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a7668775be94bce9d7cf799c051096380">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a68fd34df1ed1d7343038ee7865994c7d">ha_ndbcluster</a>, <a class="el" href="classha__innobase.html#a0d1226df999937e02ca1c1b0653e1a3e">ha_innobase</a>, <a class="el" href="classha__myisam.html#a43e3d7d67ada40e77a4fc074a7660254">ha_myisam</a>, <a class="el" href="classha__archive.html#a235c3e321c6941bf6e4b424affd803a5">ha_archive</a>, and <a class="el" href="classha__heap.html#a26a156b420a7f2f779aac941a03d68d4">ha_heap</a>.</p>

</div>
</div>
<a id="ad5eede0999f8273864faa40c5e181793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eede0999f8273864faa40c5e181793">&#9670;&nbsp;</a></span>get_dup_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint handler::get_dup_key </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>key if error because of duplicated keys </dd></dl>

</div>
</div>
<a id="afce8ffd064ce683481494c7503ef820c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce8ffd064ce683481494c7503ef820c">&#9670;&nbsp;</a></span>get_error_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::get_error_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an error message specific to this handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code previously returned by handler </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to <a class="el" href="class_string.html">String</a> where to add error message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this is a temporary error </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a4fb5ad51d61c07878d5626a315534497">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a31a5f675ffb30d67ba91bb1cb9ec9dc8">ha_ndbcluster</a>, <a class="el" href="classha__federated.html#ae772ee3d568e2a2feb68df57fedc1c54">ha_federated</a>, <a class="el" href="classha__innobase.html#afc4392eb1ca708975a460d244fdb9e77">ha_innobase</a>, and <a class="el" href="classha__ndbinfo.html#ab3693b75133ce5d4e4861ef5627ebbdc">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="a20878b1fb8d31b91dbf53ac963d90f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20878b1fb8d31b91dbf53ac963d90f78">&#9670;&nbsp;</a></span>get_foreign_dup_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::get_foreign_dup_key </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>child_table_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_key_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>child_key_name_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the names of the table and the key for which there was a duplicate entry in the case of HA_ERR_FOREIGN_DUPLICATE_KEY.</p>
<p>If any of the table or key name is not available this method will return false and will not change any of child_table_name or child_key_name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_table_name[out]</td><td>Table name </td></tr>
    <tr><td class="paramname">child_table_name_len[in]</td><td>Table name buffer size </td></tr>
    <tr><td class="paramname">child_key_name[out]</td><td><a class="el" href="class_key.html">Key</a> name </td></tr>
    <tr><td class="paramname">child_key_name_len[in]</td><td><a class="el" href="class_key.html">Key</a> name buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>table and key names were available and were written into the corresponding out parameters. </td></tr>
    <tr><td class="paramname">false</td><td>table and key names were not available, the out parameters were not touched. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a53715acaa5441a53f0758ed900648760">ha_innobase</a>.</p>

</div>
</div>
<a id="a81064e61d4c08261af409fb6ee34e3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81064e61d4c08261af409fb6ee34e3ca">&#9670;&nbsp;</a></span>get_foreign_key_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::get_foreign_key_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the list of foreign keys in this table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the set of foreign keys where this table is the dependent or child table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle. </td></tr>
    <tr><td class="paramname">f_key_list[out]</td><td>The list of foreign keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handler error code or zero for success. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a115f5e0b70a59aaec2fbefced8b7faa4">ha_innobase</a>.</p>

</div>
</div>
<a id="a13bf21a8ad4be872bbfe94f5cb40abca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bf21a8ad4be872bbfe94f5cb40abca">&#9670;&nbsp;</a></span>get_ha_share_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_handler__share.html">Handler_share</a> * handler::get_ha_share_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an initialized ha_share.</p>
<dl class="section return"><dt>Returns</dt><dd>Initialized ha_share </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>ha_share is not yet initialized. </td></tr>
    <tr><td class="paramname">!=</td><td>NULL previous initialized ha_share.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If not a temp table, then LOCK_ha_data must be held. </dd></dl>

</div>
</div>
<a id="a475f7fbe39f6ff0e9da2ac6c3d6c629e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475f7fbe39f6ff0e9da2ac6c3d6c629e">&#9670;&nbsp;</a></span>get_memory_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual longlong handler::get_memory_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate on the amount of memory the storage engine will use for caching data in memory. If this is unknown or the storage engine does not cache data in memory -1 is returned. </p>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a8faf78c3052b9adeec8eb41b8f23ad71">ha_innobase</a>.</p>

</div>
</div>
<a id="ab3cad9d951b59dd0b705e6861dc489e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cad9d951b59dd0b705e6861dc489e7">&#9670;&nbsp;</a></span>get_no_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::get_no_parts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>no_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get number of partitions for table in SE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>normalized path(same as open) to the table</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">no_parts</td><td>Number of partitions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>for success </td></tr>
    <tr><td class="paramname">true</td><td>for failure, for example table didn't exist in engine </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a36ca395ca5c6066f00b30a9ccedfc43d">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#ad4c8240f36397911132c71d6080c0659">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a9187eea9999eba802ee4ae01f91dda3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9187eea9999eba802ee4ae01f91dda3b">&#9670;&nbsp;</a></span>get_parent_foreign_key_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::get_parent_foreign_key_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the list of foreign keys referencing this table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the set of foreign keys where this table is the referenced or parent table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle. </td></tr>
    <tr><td class="paramname">f_key_list[out]</td><td>The list of foreign keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handler error code or zero for success. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a58fbf47cb6215228269a97efd5f50592">ha_innobase</a>.</p>

</div>
</div>
<a id="a163a360c0cd4575ae207553b8d5c918d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163a360c0cd4575ae207553b8d5c918d">&#9670;&nbsp;</a></span>get_row_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual enum row_type handler::get_row_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the row type from the storage engine. If this method returns ROW_TYPE_NOT_USED, the information in HA_CREATE_INFO should be used. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#ab4f337e2cd0e372d26af8222920a063d">ha_partition</a>, <a class="el" href="classha__archive.html#a62c4bd978dbfe751c4cc9fdb7426f59b">ha_archive</a>, <a class="el" href="classha__innobase.html#a40a3a299ed63452b5b99c27126cfb07e">ha_innobase</a>, and <a class="el" href="classha__heap.html#afb96b971dd7862e6318915dce8a6b53c">ha_heap</a>.</p>

</div>
</div>
<a id="a66cc9e4971b8e768c102398da0656a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cc9e4971b8e768c102398da0656a7f">&#9670;&nbsp;</a></span>ha_analyze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_analyze </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analyze table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::analyze() </dd></dl>

</div>
</div>
<a id="a49c8ce82a564b0cbf6340dc9b74a9c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c8ce82a564b0cbf6340dc9b74a9c23">&#9670;&nbsp;</a></span>ha_bulk_update_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_bulk_update_row </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bulk update row: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">handler::bulk_update_row()</a> </dd></dl>

</div>
</div>
<a id="ab5fb90782fea926f7a4450889d2d4a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fb90782fea926f7a4450889d2d4a93">&#9670;&nbsp;</a></span>ha_change_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_change_partitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *const&#160;</td>
          <td class="paramname"><em>copied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *const&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>pack_frm_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pack_frm_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change partitions: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::change_partitions() </dd></dl>

</div>
</div>
<a id="a56545ec9967544c80d5612f8ac9b8e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56545ec9967544c80d5612f8ac9b8e6e">&#9670;&nbsp;</a></span>ha_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_check </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>to be actually called to get '<a class="el" href="row0ins_8cc.html#af89eccd3e535f029833696f4c35f730e">check()</a>' functionality</p>
<p>Performs checks upon the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread doing CHECK <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> operation </td></tr>
    <tr><td class="paramname">check_opt</td><td>options from the parser</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ADMIN_OK</td><td>Successful upgrade </td></tr>
    <tr><td class="paramname">HA_ADMIN_NEEDS_UPGRADE</td><td>Table has structures requiring upgrade </td></tr>
    <tr><td class="paramname">HA_ADMIN_NEEDS_ALTER</td><td>Table has structures requiring ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> </td></tr>
    <tr><td class="paramname">HA_ADMIN_NOT_IMPLEMENTED</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a169d5287bdf480f8cd20f758bb2d9bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169d5287bdf480f8cd20f758bb2d9bd1">&#9670;&nbsp;</a></span>ha_check_and_repair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::ha_check_and_repair </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> and repair table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::check_and_repair() </dd></dl>

</div>
</div>
<a id="ae28824cdff2c1812e282463c908e84c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28824cdff2c1812e282463c908e84c2">&#9670;&nbsp;</a></span>ha_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close handler. </p>

</div>
</div>
<a id="a6ec170a4aa71186f9dc17358b55587c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec170a4aa71186f9dc17358b55587c7">&#9670;&nbsp;</a></span>ha_commit_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::ha_commit_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Public function wrapping the actual handler call. Allows us to enforce asserts regardless of handler implementation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> </dd></dl>

</div>
</div>
<a id="a14af5825a427ba6baac74b13223637f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14af5825a427ba6baac74b13223637f8">&#9670;&nbsp;</a></span>ha_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a table in the engine: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::create() </dd></dl>

</div>
</div>
<a id="a722462d7e71059a8ed1f43d0fb28366b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722462d7e71059a8ed1f43d0fb28366b">&#9670;&nbsp;</a></span>ha_create_handler_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_create_handler_files </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>action_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create handler files for CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a>: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::create_handler_files() </dd></dl>

</div>
</div>
<a id="a1fef228137a11565f7d52a60ad802004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fef228137a11565f7d52a60ad802004">&#9670;&nbsp;</a></span>ha_delete_all_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_delete_all_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete all rows: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">handler::delete_all_rows()</a> </dd></dl>

</div>
</div>
<a id="a28700a3bf1af24f9a31ebae51bf877db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28700a3bf1af24f9a31ebae51bf877db">&#9670;&nbsp;</a></span>ha_delete_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">handler::delete_table()</a> </dd></dl>

</div>
</div>
<a id="aeeb079b3dc59160ba828ef89b4463921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb079b3dc59160ba828ef89b4463921">&#9670;&nbsp;</a></span>ha_disable_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_disable_indexes </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable indexes: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::disable_indexes() </dd></dl>

</div>
</div>
<a id="a1f75cf982985d21907140a17521cd6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f75cf982985d21907140a17521cd6c5">&#9670;&nbsp;</a></span>ha_discard_or_import_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_discard_or_import_tablespace </td>
          <td>(</td>
          <td class="paramtype">my_bool&#160;</td>
          <td class="paramname"><em>discard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Discard or import tablespace: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::discard_or_import_tablespace() </dd></dl>

</div>
</div>
<a id="af575e947965117a3a200aec827b1a7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af575e947965117a3a200aec827b1a7c3">&#9670;&nbsp;</a></span>ha_drop_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_drop_partitions </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drop partitions: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::drop_partitions() </dd></dl>

</div>
</div>
<a id="a6bcc37ec84386f5d6cc86448781666cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcc37ec84386f5d6cc86448781666cb">&#9670;&nbsp;</a></span>ha_drop_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_drop_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drop table in the engine: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::drop_table() </dd></dl>

</div>
</div>
<a id="a36e9c53758728e07eb37cbb65ea3ab50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e9c53758728e07eb37cbb65ea3ab50">&#9670;&nbsp;</a></span>ha_enable_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_enable_indexes </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable indexes: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::enable_indexes() </dd></dl>

</div>
</div>
<a id="a30f3cbf4a769155c994ed39f76433106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f3cbf4a769155c994ed39f76433106">&#9670;&nbsp;</a></span>ha_end_bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_end_bulk_insert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End bulk insert.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Failure (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a99b5f8ae28bc5c374919396f8dcf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a99b5f8ae28bc5c374919396f8dcf08">&#9670;&nbsp;</a></span>ha_external_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_external_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These functions represent the public interface to <em>users</em> of the handler class, hence they are <em>not</em> virtual. For the inheritance interface, see the (private) functions write_row(), <a class="el" href="classhandler.html#a4a8f7e55649146ad116762746624b43a">update_row()</a>, and delete_row() below. </p>

</div>
</div>
<a id="afa6bd01057c6cdd86d2ea2ee4ea65ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6bd01057c6cdd86d2ea2ee4ea65ca3">&#9670;&nbsp;</a></span>ha_index_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End use of index.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd574a3025588e9b0cd49e0d6908e3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd574a3025588e9b0cd49e0d6908e3b8">&#9670;&nbsp;</a></span>ha_index_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_first </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the first row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af23462b249041a0db03c1c7139d76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af23462b249041a0db03c1c7139d76b">&#9670;&nbsp;</a></span>ha_index_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_init </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize use of index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index to use </td></tr>
    <tr><td class="paramname">sorted</td><td>Use sorted order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a7415f1744039a51ef15e923ef7da1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7415f1744039a51ef15e923ef7da1b">&#9670;&nbsp;</a></span>ha_index_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_last </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the last row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c99e96a8350ff577a94529be9387a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c99e96a8350ff577a94529be9387a30">&#9670;&nbsp;</a></span>ha_index_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the next row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f79360a45d50c6b558feb1c308c4157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f79360a45d50c6b558feb1c308c4157">&#9670;&nbsp;</a></span>ha_index_next_same()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_next_same </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the next same row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="class_key.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keylen</td><td>Length of key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb977dac0435158be227e45e04c8b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb977dac0435158be227e45e04c8b798">&#9670;&nbsp;</a></span>ha_index_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_prev </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the previous row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37f8c07d2ede3fb1f46fc0afb4052d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f8c07d2ede3fb1f46fc0afb4052d2c">&#9670;&nbsp;</a></span>ha_index_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read one row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="class_key.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keylen</td><td>Length of key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">find_flag</td><td>Direction/condition on key usage</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac831321e8d33958db4fd4968de932acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac831321e8d33958db4fd4968de932acf">&#9670;&nbsp;</a></span>ha_index_read_idx_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read_idx_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an index and read it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">handler::ha_index_read_map</a>. </dd></dl>

</div>
</div>
<a id="a1790fe12f8d773f27d5b4b1cb30bd7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1790fe12f8d773f27d5b4b1cb30bd7ab">&#9670;&nbsp;</a></span>ha_index_read_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read_last </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the last row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="class_key.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keylen</td><td>Length of key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a729d9c9c011527b81287574294887bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729d9c9c011527b81287574294887bf3">&#9670;&nbsp;</a></span>ha_index_read_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read [part of] row via [part of] index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer where store the data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="class_key.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keypart_map</td><td>Which part of key to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">find_flag</td><td>Direction/condition on key usage</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success (found a record, and function has set table-&gt;status to 0) </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found (function has set table-&gt;status to STATUS_NOT_FOUND) </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Positions an index cursor to the index specified in the handle. Fetches the row if available. If the key value is null, begin at the first key of the index. ha_index_read_map can be restarted without calling index_end on the previous index scan and without calling ha_index_init. In this case the ha_index_read_map is on the same index as the previous ha_index_scan. This is particularly used in conjunction with multi read ranges. </dd></dl>

</div>
</div>
<a id="a96b182710a133be9561afc149cb6aa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b182710a133be9561afc149cb6aa8f">&#9670;&nbsp;</a></span>ha_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::ha_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Public function wrapping the actual handler call. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> </dd></dl>

</div>
</div>
<a id="a5b81b74b0b7b87de4f99ebe20c49dc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b81b74b0b7b87de4f99ebe20c49dc44">&#9670;&nbsp;</a></span>ha_notify_table_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_notify_table_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Public function wrapping the actual handler call. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed()</a> </dd></dl>

</div>
</div>
<a id="ab5e02829386929734724b143391e0a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e02829386929734724b143391e0a11">&#9670;&nbsp;</a></span>ha_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>test_if_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open database-handler. </p>
<p>IMPLEMENTATION Try O_RDONLY if cannot open as O_RDWR Don't wait for locks if not HA_OPEN_WAIT_IF_LOCKED is set </p>

</div>
</div>
<a id="a980a8a7650a41fd9a05a32521826ccd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980a8a7650a41fd9a05a32521826ccd5">&#9670;&nbsp;</a></span>ha_optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_optimize </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimize table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::optimize() </dd></dl>

</div>
</div>
<a id="ad0ecf7f9bf265e6801b625768f0f2bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ecf7f9bf265e6801b625768f0f2bbe">&#9670;&nbsp;</a></span>ha_prepare_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::ha_prepare_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Public functions wrapping the actual handler call. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> </dd></dl>

</div>
</div>
<a id="a624a8892433666df834a9b6ed6b8c2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624a8892433666df834a9b6ed6b8c2dd">&#9670;&nbsp;</a></span>ha_rename_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rename_partitions </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rename partitions: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::rename_partitions() </dd></dl>

</div>
</div>
<a id="a6ee228a60527e81efd9a49ddfdd4850d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee228a60527e81efd9a49ddfdd4850d">&#9670;&nbsp;</a></span>ha_rename_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rename table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">handler::rename_table()</a> </dd></dl>

</div>
</div>
<a id="ad28d70543d9566894b5a81d25eca2e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28d70543d9566894b5a81d25eca2e8e">&#9670;&nbsp;</a></span>ha_repair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_repair </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Repair table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a889322859f50e88a643067fb706c2bf2">handler::repair()</a> </dd></dl>

</div>
</div>
<a id="a53d38f167906d8aaa9e560c71e595a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d38f167906d8aaa9e560c71e595a42">&#9670;&nbsp;</a></span>ha_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_check.html">Check</a> handler usage and reset state of file to after 'open'. </p>
<dl class="section note"><dt>Note</dt><dd>can be called regardless of it is locked or not. </dd></dl>

</div>
</div>
<a id="af68b71d64ca04789d1c6130320eaf22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68b71d64ca04789d1c6130320eaf22c">&#9670;&nbsp;</a></span>ha_reset_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_reset_auto_increment </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset auto increment: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a27e343a6e97ad5264e1fe5a70659899f">handler::reset_auto_increment()</a> </dd></dl>

</div>
</div>
<a id="ad4d9bf34ac0a004d8c5c32267f20842f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d9bf34ac0a004d8c5c32267f20842f">&#9670;&nbsp;</a></span>ha_rnd_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End use of random access.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb5c99736cb400350e007578889b8375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5c99736cb400350e007578889b8375">&#9670;&nbsp;</a></span>ha_rnd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize table for random read or scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>if true: Initialize for random scans through <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">rnd_next()</a> if false: Initialize for random reads through <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">rnd_pos()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3743f3a48e7be751dbb2691be4c992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3743f3a48e7be751dbb2691be4c992a">&#9670;&nbsp;</a></span>ha_rnd_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read next row via random scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to read the row into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcd8615219b3e692e7d484d2ba6cfa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd8615219b3e692e7d484d2ba6cfa86">&#9670;&nbsp;</a></span>ha_rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_pos </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read row via random scan from position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to read the row into </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>Position from position() call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f09a15d46c019a621b0a65bb1ec89d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f09a15d46c019a621b0a65bb1ec89d3">&#9670;&nbsp;</a></span>ha_start_bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_start_bulk_insert </td>
          <td>(</td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start bulk insert.</p>
<p>Allow the handler to optimize for multiple row insert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Estimated rows to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b3015577f49008561db1d34ae750e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3015577f49008561db1d34ae750e70">&#9670;&nbsp;</a></span>ha_table_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Table_flags handler::ha_table_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cached_table_flags is set at ha_open and ha_external_lock </p>

</div>
</div>
<a id="a69803cd29d92bfecd97212354212c516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69803cd29d92bfecd97212354212c516">&#9670;&nbsp;</a></span>ha_table_share_psi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PSI_table_share * handler::ha_table_share_psi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acquire the instrumented table information from a table share. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">share</td><td>a table share </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instrumented table share, or NULL. </dd></dl>

</div>
</div>
<a id="a25394328a49d42bb45b3b263009f02c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25394328a49d42bb45b3b263009f02c7">&#9670;&nbsp;</a></span>ha_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_truncate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">handler::truncate()</a> </dd></dl>

</div>
</div>
<a id="a0bb554282443af443fc8aae4533e1407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb554282443af443fc8aae4533e1407">&#9670;&nbsp;</a></span>idx_cond_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_item.html">Item</a>* handler::idx_cond_push </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>idx_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Push down an index condition to the handler.</p>
<p>The server will use this method to push down a condition it wants the handler to evaluate when retrieving records using a specified index. The pushed index condition will only refer to fields from this handler that is contained in the index (but it may also refer to fields in other handlers). Before the handler evaluates the condition it must read the content of the index entry into the record buffer.</p>
<p>The handler is free to decide if and how much of the condition it will take responsibility for evaluating. Based on this evaluation it should return the part of the condition it will not evaluate. If it decides to evaluate the entire condition it should return NULL. If it decides not to evaluate any part of the condition it should return a pointer to the same condition as given as argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>the index number to evaluate the condition on </td></tr>
    <tr><td class="paramname">idx_cond</td><td>the condition to be evaluated by the handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of the pushed condition that the handler decides not to evaluate </dd></dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#ae7b9900547917e786cccfc4af25bd689">ha_innobase</a>, and <a class="el" href="classha__myisam.html#a0a4b6587c8adbbac0454ca90242e5817">ha_myisam</a>.</p>

</div>
</div>
<a id="af37bd518c53c966459632584c34855d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37bd518c53c966459632584c34855d0">&#9670;&nbsp;</a></span>index_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_first </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#acc714b62d79e24a9c1d4f3db712322b1">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a1d3598345c3543f684c566f79a61cedc">ha_ndbcluster</a>, <a class="el" href="classha__example.html#abb596a4d6b592f69b315bafa1fab3a9f">ha_example</a>, <a class="el" href="classha__innobase.html#a3d74e0604e1891a2e69cb014a96f1d76">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#ae95726089e3534c74802b9a707ae874a">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a259d176aec78a7e637608719b862bf94">ha_myisam</a>, <a class="el" href="classha__heap.html#a9a2ea62e63e732b11ecfe1d1eb831731">ha_heap</a>, and <a class="el" href="classha__blackhole.html#aadb4253dc60467b964a4c075c0ff50e3">ha_blackhole</a>.</p>

</div>
</div>
<a id="aa1d62ffab7408a031b13e547eb58be09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d62ffab7408a031b13e547eb58be09">&#9670;&nbsp;</a></span>index_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_last </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a4e4defdf04378b86f231928ed21e017b">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a6f6e9347ec700ee952a998fa88ae68b2">ha_ndbcluster</a>, <a class="el" href="classha__example.html#a95a47bae4674546c23cec0555496ef73">ha_example</a>, <a class="el" href="classha__innobase.html#a0585621f565a14ca13e3655a89a1914c">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#a56d9fbf7dde43a53a81f59fe5c1a383e">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a4425362e19b462c1ca3d3ee60a5a77ce">ha_myisam</a>, <a class="el" href="classha__heap.html#a15fa3810b309cae34c576bccbd3bd9ca">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a5133c4b61a3414ba842c4968f66717fb">ha_blackhole</a>.</p>

</div>
</div>
<a id="aca48f687872e10a4fdc35b418d98b761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca48f687872e10a4fdc35b418d98b761">&#9670;&nbsp;</a></span>index_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a6a599d1fe239ff7d7dba0b3984fc8bea">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a865afdc25ee4ca42fafde872e476e0ff">ha_ndbcluster</a>, <a class="el" href="classha__federated.html#a4989425140392a0508abc9b49b8f7ce0">ha_federated</a>, <a class="el" href="classha__example.html#a87df66f67e09b05151729807f8a78ef4">ha_example</a>, <a class="el" href="classha__innobase.html#a60518f2b2bfdba02649ebcf5f3ca2545">ha_innobase</a>, <a class="el" href="classha__archive.html#aa115021aa83caaead4edff25b4acc1a4">ha_archive</a>, <a class="el" href="classha__myisammrg.html#af2f0be3c09a61929d077a8b55e78430d">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#ab653b9c69e63b3ac0cb1fb8c0f5f7753">ha_myisam</a>, <a class="el" href="classha__heap.html#a1f034193dcd653cdfa944c455e62fb01">ha_heap</a>, and <a class="el" href="classha__blackhole.html#aec21a0533f1f9d2ad7284403b04bfdfc">ha_blackhole</a>.</p>

</div>
</div>
<a id="a5459b92420f74e6f88dec137e1941d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5459b92420f74e6f88dec137e1941d22">&#9670;&nbsp;</a></span>index_next_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::index_next_same </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a2769f8f7dd54eebb15c6baa6c4651b2b">ha_partition</a>, <a class="el" href="classha__innobase.html#a6ed9c3e4225dd57c685db7916da272b6">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#a32ad50de75887e472d84f1510108e03e">ha_myisammrg</a>, and <a class="el" href="classha__myisam.html#a801fffefa2e5797960625bd4001281d8">ha_myisam</a>.</p>

</div>
</div>
<a id="a4a2ac6b2908a899c0ce230818bb7a993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2ac6b2908a899c0ce230818bb7a993">&#9670;&nbsp;</a></span>index_only_read_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double handler::index_only_read_time </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate cost of 'index only' scan for given index and number of records</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>Index number </td></tr>
    <tr><td class="paramname">records</td><td>Estimated number of records to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is assumed that we will read trough the whole key range and that all key blocks are half full (normally things are much better). It is also assumed that each time we read the next key from the index, the handler performs a random seek, thus the cost is proportional to the number of blocks read.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>Consider joining this function and <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">handler::read_time()</a> into one handler::read_time(keynr, records, ranges, bool index_only) function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Estimated cost of 'index only' scan </dd></dl>

</div>
</div>
<a id="a1ab892ae78db6437119d2d25621118b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab892ae78db6437119d2d25621118b7">&#9670;&nbsp;</a></span>index_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_prev </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a25706609cb26f778dd90cc2611b112fd">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a824559f84d7f256052f0394e9276774f">ha_ndbcluster</a>, <a class="el" href="classha__example.html#a0520a923ed00b8a3b6581c6ef0c9289a">ha_example</a>, <a class="el" href="classha__innobase.html#a11b40809d4ce6883294fceb9f9c7a8fc">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#a6d8efc85b738196d67433e8bf48bac5d">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#aaa94d8021c2e16918288ffd6a068c27c">ha_myisam</a>, <a class="el" href="classha__heap.html#a601ee2b431c6c84278015ac86aeec323">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a2ebfc02b27dcf229c538ec9989868d60">ha_blackhole</a>.</p>

</div>
</div>
<a id="acba0c549a00023dd44682cd9452cf830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba0c549a00023dd44682cd9452cf830">&#9670;&nbsp;</a></span>index_read_idx_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::index_read_idx_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#aee13430aea3946ffa6cf2c00104ba19c">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a3287fe133e918396f19004472c3b8afa">ha_ndbcluster</a>, <a class="el" href="classha__federated.html#ac0031038f6df28e7fc71b845d6822d13">ha_federated</a>, <a class="el" href="classha__myisammrg.html#a74430de7928f1d0ddf4d6d6c6676a6cd">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a08377d41e26dd58bd62ec44903ae56af">ha_myisam</a>, <a class="el" href="classha__heap.html#a4fae842f1b57b5dafbbf9126101e6e8f">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a71934e7765632f1b30ac995315c75509">ha_blackhole</a>.</p>

</div>
</div>
<a id="ae069d5991214e1fdf14cc44fd865a180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae069d5991214e1fdf14cc44fd865a180">&#9670;&nbsp;</a></span>index_read_last_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_read_last_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following functions works like index_read, but it find the last row with the current key value or prefix. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#ae28896451f43f7b821e441413936c93c">ha_partition</a>, <a class="el" href="classha__myisammrg.html#ad8d7a31dffff9b1863e2f132cb883636">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a3f34fab22c1dd2eeef05cefed61ff94b">ha_myisam</a>, <a class="el" href="classha__blackhole.html#a09f91eb4feddbc3e587266cd92a1a2d9">ha_blackhole</a>, and <a class="el" href="classha__heap.html#a7cc55428b110ab1870e5c6affb4cdd95">ha_heap</a>.</p>

</div>
</div>
<a id="af8c2b258691e5baac8dd22d19c084b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c2b258691e5baac8dd22d19c084b37">&#9670;&nbsp;</a></span>index_read_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_read_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if success (found a record, and function has set table-&gt;status to 0); non-zero if no record (function has set table-&gt;status to STATUS_NOT_FOUND). </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3">ha_partition</a>, <a class="el" href="classha__example.html#ab98885559dc77843b7854138432a724c">ha_example</a>, <a class="el" href="classha__myisammrg.html#ab2d8baf35467839a6ef3b13a81539819">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#af8a60735c7190bda43da751a57027af4">ha_myisam</a>, <a class="el" href="classha__heap.html#ae8be1750da2792fcc7e83591d67fdc14">ha_heap</a>, and <a class="el" href="classha__blackhole.html#acae99b0e884fbf6fa16f769482e619ce">ha_blackhole</a>.</p>

</div>
</div>
<a id="ab1ad6edb66592b200a7c7ac0f947dc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ad6edb66592b200a7c7ac0f947dc66">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is called after create to allow us to set up cached variables </p>

</div>
</div>
<a id="a90b4c3a8fe1c89c6ccfec1f4b144754a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b4c3a8fe1c89c6ccfec1f4b144754a">&#9670;&nbsp;</a></span>inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a>. The level of concurrency allowed during this operation depends on the return value from <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> will be called with commit= false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">ha_partition</a>, and <a class="el" href="classha__innobase.html#a6500b207c94934efcad46386b2425a66">ha_innobase</a>.</p>

</div>
</div>
<a id="a1bc56a8f3a2c01c127ad553fdf2a8c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc56a8f3a2c01c127ad553fdf2a8c18">&#9670;&nbsp;</a></span>is_fatal_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::is_fatal_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to analyse the error to see whether the error is ignorable or not, certain handlers can have more error that are ignorable than others. E.g. the partition handler can get inserts into a range where there is no partition and this is an ignorable error. HA_ERR_FOUND_DUP_UNIQUE is a special case in MyISAM that means the same thing as HA_ERR_FOUND_DUP_KEY but can in some cases lead to a slightly different error message. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a18e8ff8fce23b0ca305755e60d960cd9">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a176722dc40003b949613f8a6e253445d">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="adda33331aacc500b1b974033cb64a869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda33331aacc500b1b974033cb64a869">&#9670;&nbsp;</a></span>is_fk_defined_on_table_or_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::is_fk_defined_on_table_or_index </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If index == MAX_KEY then a check for table is made and if index &lt; MAX_KEY then a check is made if the table has foreign keys and if a foreign key uses this index (and thus the index cannot be dropped).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to check if foreign key uses it</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Foreign key defined on table or index </td></tr>
    <tr><td class="paramname">FALSE</td><td>No foreign key defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2447668275a831bcf73b5c00818254a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2447668275a831bcf73b5c00818254a6">&#9670;&nbsp;</a></span>lock_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint handler::lock_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count()</a> can return &gt; 1 if the table is MERGE or partitioned. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a34acffe19d43c2dc2570e995cf22a3d8">ha_partition</a>, and <a class="el" href="classha__myisammrg.html#aefa558e219cc6c78791fde05800a3292">ha_myisammrg</a>.</p>

</div>
</div>
<a id="aa3a39db9dc1cca31f4a3ec0e0e1d7300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a39db9dc1cca31f4a3ec0e0e1d7300">&#9670;&nbsp;</a></span>lock_shared_ha_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::lock_shared_ha_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take a lock for protecting shared handler data. </p>

</div>
</div>
<a id="a8556e08dd260c7856c7b5952e316e533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8556e08dd260c7856c7b5952e316e533">&#9670;&nbsp;</a></span>mark_trx_read_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::mark_trx_read_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function to mark a transaction read-write, if it is started. </p>

</div>
</div>
<a id="a5add40a6cd7088ffef25a3816294b624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5add40a6cd7088ffef25a3816294b624">&#9670;&nbsp;</a></span>multi_range_read_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows handler::multi_range_read_info </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get cost and other information about MRR scan over some sequence of ranges</p>
<p>Calculate estimated cost and other information about an MRR scan for some sequence of ranges.</p>
<p>The ranges themselves will be known only at execution phase. When this function is called we only know number of ranges and a (rough) E(<a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a>) within those ranges.</p>
<p>Currently this function is only called for "n-keypart singlepoint" ranges, i.e. each range is "keypart1=someconst1 AND ... AND keypartN=someconstN"</p>
<p>The flags parameter is a combination of those flags: HA_MRR_SORTED, HA_MRR_INDEX_ONLY, HA_MRR_NO_ASSOCIATION, HA_MRR_LIMITS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramname">n_ranges</td><td>Estimated number of ranges (i.e. intervals) in the range sequence. </td></tr>
    <tr><td class="paramname">n_rows</td><td>Estimated total number of records contained within all of the ranges </td></tr>
    <tr><td class="paramname">bufsz</td><td>INOUT IN: Size of the buffer available for use OUT: Size of the buffer that will be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramname">flags</td><td>INOUT A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramname">cost</td><td>OUT Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
    <tr><td class="paramname">other</td><td>Error or can't perform the requested scan </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a086247f18e144c81c2719164c8775c58">ha_innobase</a>, and <a class="el" href="classha__myisam.html#a00c48eb66edc8d8f9f5635bf2394a0fe">ha_myisam</a>.</p>

</div>
</div>
<a id="a5ee356d2340552eb121d423fc01597f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee356d2340552eb121d423fc01597f8">&#9670;&nbsp;</a></span>multi_range_read_info_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows handler::multi_range_read_info_const </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get cost and other information about MRR scan over a known list of ranges</p>
<p>Calculate estimated cost and other information about an MRR scan for given sequence of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramname">seq</td><td>Range sequence to be traversed </td></tr>
    <tr><td class="paramname">seq_init_param</td><td>First parameter for seq-&gt;<a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init()</a> </td></tr>
    <tr><td class="paramname">n_ranges_arg</td><td>Number of ranges in the sequence, or 0 if the caller can't efficiently determine it </td></tr>
    <tr><td class="paramname">bufsz</td><td>INOUT IN: Size of the buffer available for use OUT: Size of the buffer that is expected to be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramname">flags</td><td>INOUT A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramname">cost</td><td>OUT Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method (or an overriding one in a derived class) must check for thd-&gt;killed and return HA_POS_ERROR if it is not zero. This is required for a user to be able to interrupt the calculation by killing the connection/query.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_POS_ERROR</td><td>Error or the engine is unable to perform the requested scan. Values of OUT parameters are undefined. </td></tr>
    <tr><td class="paramname">other</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a7d81f0569084ce9b0de1c986e09046b3">ha_innobase</a>, and <a class="el" href="classha__myisam.html#ae4f3c7421685089c3887e24b2cf7e32b">ha_myisam</a>.</p>

</div>
</div>
<a id="a33e8899f4bae262b6b91c7284f1d946e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e8899f4bae262b6b91c7284f1d946e">&#9670;&nbsp;</a></span>multi_range_read_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::multi_range_read_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the MRR scan</p>
<p>Initialize the MRR scan. This function may do heavyweight scan initialization like row prefetching/sorting/etc (NOTE: but better not do it here as we may not need it, e.g. if we never satisfy WHERE clause on previous tables. For many implementations it would be natural to do such initializations in the first multi_read_range_next() call)</p>
<p>mode is a combination of the following flags: HA_MRR_SORTED, HA_MRR_INDEX_ONLY, HA_MRR_NO_ASSOCIATION</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>Range sequence to be traversed </td></tr>
    <tr><td class="paramname">seq_init_param</td><td>First parameter for seq-&gt;<a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init()</a> </td></tr>
    <tr><td class="paramname">n_ranges</td><td>Number of ranges in the sequence </td></tr>
    <tr><td class="paramname">mode</td><td>Flags, see the description section for the details </td></tr>
    <tr><td class="paramname">buf</td><td>INOUT: memory buffer to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>One must have called index_init() before calling this function. Several <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init()</a> calls may be made in course of one query.</dd></dl>
<p>Until WL#2623 is done (see its text, section 3.2), the following will also hold: The caller will guarantee that if "seq-&gt;init == mrr_ranges_array_init" then seq_init_param is an array of n_ranges KEY_MULTI_RANGE structures. This property will only be used by NDB handler until WL#2623 is done.</p>
<p>Buffer memory management is done according to the following scenario: The caller allocates the buffer and provides it to the callee by filling the members of HANDLER_BUFFER structure. The callee consumes all or some fraction of the provided buffer space, and sets the HANDLER_BUFFER members accordingly. The callee may use the buffer memory until the next <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init()</a> call is made, all records have been read, or until index_end() call is made, whichever comes first.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#a4517bdf2708a81551d540e9ab7efe6de">ha_innobase</a>, and <a class="el" href="classha__myisam.html#a5dc1024f4e3aa105994de1e5254f262f">ha_myisam</a>.</p>

</div>
</div>
<a id="a3419071f3d4abf183dac95ef565adfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3419071f3d4abf183dac95ef565adfff">&#9670;&nbsp;</a></span>multi_range_read_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::multi_range_read_next </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get next record in MRR scan</p>
<p>Default MRR implementation: read the next record</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_info</td><td>OUT Undefined if HA_MRR_NO_ASSOCIATION flag is in effect Otherwise, the opaque value associated with the range that contains the returned record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">other</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__innobase.html#af6b6c417a1a9dbb3d27a3edd278549b6">ha_innobase</a>, and <a class="el" href="classha__myisam.html#a33a8b29c70cf2859b1e1fe8718030abd">ha_myisam</a>.</p>

</div>
</div>
<a id="a26aaaf2105e60ca590b79fae82e48960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26aaaf2105e60ca590b79fae82e48960">&#9670;&nbsp;</a></span>notify_table_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::notify_table_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notify the storage engine that the table structure (.FRM) has been updated.</p>
<dl class="section note"><dt>Note</dt><dd>No errors are allowed during <a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a4350de763daa055bf18a26267664bda2">ha_partition</a>.</p>

</div>
</div>
<a id="a86930bf10b20ad19b3df07e07d28116e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86930bf10b20ad19b3df07e07d28116e">&#9670;&nbsp;</a></span>number_of_pushed_joins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint handler::number_of_pushed_joins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reports <a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a> included in pushed join which this handler instance is part of. ==0 -&gt; Not pushed </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a6aaba12f45b013e5dc180f40463e802a">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="aaef865015edc575d0a50d1a6f5b13e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef865015edc575d0a50d1a6f5b13e4a">&#9670;&nbsp;</a></span>parent_of_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* handler::parent_of_pushed_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this handler instance is a child in a pushed join sequence returned <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance being my parent? </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a62ab358637e99739c71e906277ccc0f4">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="ab25b3931a457f1821ba55ae9cce79d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25b3931a457f1821ba55ae9cce79d98">&#9670;&nbsp;</a></span>prepare_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::prepare_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows the storage engine to update internal structures with concurrent writes blocked. If <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter()</a> returns HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE or HA_ALTER_INPLACE_SHARED_AFTER_PREPARE, this function is called with exclusive lock otherwise the same level of locking as for <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> will be used.</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> will be called with commit= false.</dd>
<dd>
For partitioning, failing to prepare one partition, means that <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> will be called to roll back changes for all partitions. This means that <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> might be called without <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> having been called first for a given partition.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">ha_partition</a>, and <a class="el" href="classha__innobase.html#a143df4f5250198dcc51fc256d5f6e33b">ha_innobase</a>.</p>

</div>
</div>
<a id="afda4f1390385a4dc0bfd2981fee23e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda4f1390385a4dc0bfd2981fee23e6c">&#9670;&nbsp;</a></span>print_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::print_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">myf&#160;</td>
          <td class="paramname"><em>errflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print error that we got from handler function.</p>
<dl class="section note"><dt>Note</dt><dd>In case of delete table it's only safe to use the following parts of the 'table' structure:<ul>
<li>table-&gt;s-&gt;path</li>
<li>table-&gt;alias </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#afbddb8246029958806a6078b3ea71b32">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#ab4b4b9ed3726be8a4a0887785a5ed530">ha_ndbcluster</a>, and <a class="el" href="classha__perfschema.html#a896b024400f02c0c385cb2cb72e1c5d6">ha_perfschema</a>.</p>

</div>
</div>
<a id="aff50b704d53d715d6b0fd3534c6107d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff50b704d53d715d6b0fd3534c6107d8">&#9670;&nbsp;</a></span>read_first_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::read_first_row </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>primary_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read first row (only) from a table.</p>
<p>This is never called for InnoDB tables, as these table types has the HA_STATS_RECORDS_IS_EXACT set. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a184b8fcfc296599d9a82b0d36444ec30">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a3a0d596ff3ddc77b4f0ad990c4c4cb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">&#9670;&nbsp;</a></span>read_range_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::read_range_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structst__key__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__key__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read first row between two ranges. Store ranges for future calls to read_range_next. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Start key. Is 0 if no min range </td></tr>
    <tr><td class="paramname">end_key</td><td>End key. Is 0 if no max range </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Set to 1 if start_key == end_key </td></tr>
    <tr><td class="paramname">sorted</td><td>Set to 1 if result should be sorted per key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#aa0217cd2a331904f87fbfcbe4dde5800">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a4ebf9b2b84870f08b62e5e3f5465aae8">ha_ndbcluster</a>, and <a class="el" href="classha__federated.html#a4991fb1bc2aef3c9fd8047f12e04d7f5">ha_federated</a>.</p>

</div>
</div>
<a id="ae4632aa56c9c66a57558f849f8e01271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4632aa56c9c66a57558f849f8e01271">&#9670;&nbsp;</a></span>read_range_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::read_range_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read next row between two endpoints. </p>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#ae77ce0688d4d2c0451dcb930e6ca42bc">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#ac4ca12e4aa287eaf6a50c43219a1c776">ha_ndbcluster</a>, and <a class="el" href="classha__federated.html#a299953299c6e7294e728812f96f5d6de">ha_federated</a>.</p>

</div>
</div>
<a id="a061b519fb16fbff126b0e21530973c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061b519fb16fbff126b0e21530973c2e">&#9670;&nbsp;</a></span>read_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double handler::read_time </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cost of reading a set of ranges from the table using an index to access it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index number. </td></tr>
    <tr><td class="paramname">ranges</td><td>The number of ranges to be read. </td></tr>
    <tr><td class="paramname">rows</td><td>Total number of rows to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be used to calculate the total cost of scanning a table using an index by calling it using read_time(index, 1, table_size). </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#ae2cd9274cdcf243f53efc8c236bb8379">ha_partition</a>, <a class="el" href="classha__federated.html#aad5574261a4975514040717fda880555">ha_federated</a>, <a class="el" href="classha__example.html#aa1f6e594ca52107758bb02327d678514">ha_example</a>, <a class="el" href="classha__innobase.html#a4fe974cf972531fadb046018db76614e">ha_innobase</a>, and <a class="el" href="classha__heap.html#ab71934b9223c18f8cb918d7fc6164ab1">ha_heap</a>.</p>

</div>
</div>
<a id="a85c1bde4ae61f0aee31d241b0821369c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c1bde4ae61f0aee31d241b0821369c">&#9670;&nbsp;</a></span>records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows handler::records </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of rows in table. It will only be called if (table_flags() &amp; (HA_HAS_RECORDS | HA_STATS_RECORDS_IS_EXACT)) != 0 </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#ada684ff4029d92f8b693952ccb780948">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#afbffd5437c38bf4be8e08e1797324711">ha_ndbcluster</a>, <a class="el" href="classha__myisammrg.html#af04ab21ab2516804178ae0bf6474e117">ha_myisammrg</a>, and <a class="el" href="classha__archive.html#a02a15b51e423865e1fbc336a575908ab">ha_archive</a>.</p>

</div>
</div>
<a id="a2ec87bfd95b71d14fafbb3f88569094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec87bfd95b71d14fafbb3f88569094f">&#9670;&nbsp;</a></span>register_query_cache_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual my_bool handler::register_query_cache_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qc_engine_callback *&#160;</td>
          <td class="paramname"><em>engine_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>engine_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a named table with a call back function to the query cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_key</td><td>A pointer to the table name in the table cache </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_length</td><td>The length of the table name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_callback</td><td>The pointer to the storage engine call back function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_data</td><td>Storage engine specific data which could be anything</td></tr>
  </table>
  </dd>
</dl>
<p>This method offers the storage engine, the possibility to store a reference to a table name which is going to be used with query cache. The method is called each time a statement is written to the cache and can be used to verify if a specific statement is cachable. It also offers the possibility to register a generic (but static) call back function which is called each time a statement is matched against the query cache.</p>
<dl class="section note"><dt>Note</dt><dd>If engine_data supplied with this function is different from engine_data supplied with the callback function, and the callback returns FALSE, a table invalidation on the current table will occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Upon success the engine_callback will point to the storage engine call back function, if any, and engine_data will point to any storage engine data used in the specific implementation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Success </td></tr>
    <tr><td class="paramname">FALSE</td><td>The specified table or current statement should not be cached </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a4673b0434ccbcd97542e1f7636d61db2">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a678f400a15ca14442e0ad11c39748de0">ha_ndbcluster</a>, <a class="el" href="classha__innobase.html#a8935c26cd1541f91e30786806a347f0a">ha_innobase</a>, and <a class="el" href="classha__perfschema.html#a3aa5577112ec4f5c5a1d448a41865ef1">ha_perfschema</a>.</p>

</div>
</div>
<a id="a58bf8fa32d87654794e6b1c3b3fb8d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bf8fa32d87654794e6b1c3b3fb8d32">&#9670;&nbsp;</a></span>rename_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default <a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">rename_table()</a> and <a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">delete_table()</a> rename/delete files with a given name and extensions from <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext()</a>.</p>
<p>These methods can be overridden, but their default implementation provide useful functionality. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a5609bf8b91966dacc3610fc7ceffc314">ha_ndbcluster</a>, <a class="el" href="classha__partition.html#a7dbc26903dfbc0128c0d5a7e68d3681b">ha_partition</a>, <a class="el" href="classha__example.html#a90b6f129db6eccd58e19b48af23d4013">ha_example</a>, <a class="el" href="classha__perfschema.html#acc5a556a5c2152750cfd9684d371902a">ha_perfschema</a>, <a class="el" href="classha__innobase.html#abf4cb28dc4dac919ba8182b7cb176781">ha_innobase</a>, <a class="el" href="classha__myisam.html#ad5bca5020dbd78e04cd0fbf8d057f1bd">ha_myisam</a>, and <a class="el" href="classha__heap.html#a4c3d39532351159f3c98aeec60caacde">ha_heap</a>.</p>

</div>
</div>
<a id="a889322859f50e88a643067fb706c2bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889322859f50e88a643067fb706c2bf2">&#9670;&nbsp;</a></span>repair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::repair </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In this method check_opt can be modified to specify CHECK option to use to call <a class="el" href="row0ins_8cc.html#af89eccd3e535f029833696f4c35f730e">check()</a> upon the table. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#ab7908bdcad420cac9f0d696e528ba8e1">ha_partition</a>, <a class="el" href="classha__federated.html#aa897862377e201c2d900a0ecebf962c0">ha_federated</a>, <a class="el" href="classha__archive.html#a2db539ddc17d36b2eefb9212d69b1fe2">ha_archive</a>, <a class="el" href="classha__tina.html#a068c9a93ef404f5c749dd8e9f6954efe">ha_tina</a>, and <a class="el" href="classha__myisam.html#ac5db53a290f858e69aa633dd3e0da701">ha_myisam</a>.</p>

</div>
</div>
<a id="a1161c615e45f4bd9c285a0e3c1e332af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1161c615e45f4bd9c285a0e3c1e332af">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset state of file to after 'open'. This function is called after every statement for all tables used by that statement. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a0dd96d4f1ecc4e63d6afbcc6d6d4c243">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a72ae34dfc88079bca1c85bfcd718b118">ha_ndbcluster</a>, <a class="el" href="classha__federated.html#acee74699adaf25cc4531ceb2019831bf">ha_federated</a>, <a class="el" href="classha__innobase.html#a52efc99d1f7cf9d97312ff95ad6c96fb">ha_innobase</a>, <a class="el" href="classha__myisammrg.html#ac655259a0a717260b4c4bda1848f27d7">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a6ab77abb59dee9d527690d5f7ea5088e">ha_myisam</a>, and <a class="el" href="classha__heap.html#a886fb22debaa7238b8437bfb06e8c367">ha_heap</a>.</p>

</div>
</div>
<a id="a27e343a6e97ad5264e1fe5a70659899f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e343a6e97ad5264e1fe5a70659899f">&#9670;&nbsp;</a></span>reset_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::reset_auto_increment </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the auto-increment counter to the given value, i.e. the next row inserted will get the given value. HA_ERR_WRONG_COMMAND is returned by storage engines that don't support this operation. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a8c66eff39dc4dcc487709bd3b2c8aed6">ha_partition</a>, <a class="el" href="classha__innobase.html#a8418ce7f1d1353c685fc93b88f16c1d2">ha_innobase</a>, <a class="el" href="classha__myisam.html#ac441cd14b9a8b59a0e97cd55cecdc447">ha_myisam</a>, and <a class="el" href="classha__heap.html#a22061582c18bb2244dc66a49f6e2ec9b">ha_heap</a>.</p>

</div>
</div>
<a id="a730672727f9ad989e80f3732eb838a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730672727f9ad989e80f3732eb838a10">&#9670;&nbsp;</a></span>restart_rnd_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::restart_rnd_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following function is only needed for tables that may be temporary tables during joins. </p>

<p>Reimplemented in <a class="el" href="classha__myisam.html#ab9dd0844a33c5c448eac2a3d48628c3b">ha_myisam</a>.</p>

</div>
</div>
<a id="a9ddfc5530e45a9340e2de99626085da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddfc5530e45a9340e2de99626085da6">&#9670;&nbsp;</a></span>rnd_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classhandler.html#a9ddfc5530e45a9340e2de99626085da6">rnd_init()</a> can be called two times without rnd_end() in between (it only makes sense if scan=1). then the second call should prepare for the new table scan (e.g if rnd_init allocates the cursor, second call should position it to the start of the table, no need to deallocate and allocate it again </p>

<p>Implemented in <a class="el" href="classha__partition.html#a0f1716a11f635614b7772b9b0711a1ff">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#acb923144766720049d59f97cd70286fd">ha_ndbcluster</a>, <a class="el" href="classha__example.html#a79cd8e9173f71d0e28022dd8f3f32aaa">ha_example</a>, <a class="el" href="classha__federated.html#a5fde86c941ca3dbdbb59177c292de983">ha_federated</a>, <a class="el" href="classha__perfschema.html#a0f77eb11ebdd465b660f8d307a788d13">ha_perfschema</a>, <a class="el" href="classha__innobase.html#ad399dbc2e6b9cfcf788993d1bc6fb666">ha_innobase</a>, <a class="el" href="classha__tina.html#af44536b18869a0db9a0e1c27aa9501b2">ha_tina</a>, <a class="el" href="classha__archive.html#a0d73cb244d3113b8fcabcf15fd9dabe8">ha_archive</a>, <a class="el" href="classha__myisammrg.html#ac25dbafa9db24f576b6301affe7ac67a">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a2604e5da554004f881dc8196e8b6e6d9">ha_myisam</a>, <a class="el" href="classha__heap.html#acc648bd5f86d1aecfd60cd2f20cdddc0">ha_heap</a>, <a class="el" href="classha__blackhole.html#a0c308fa15a085e066ef01df0c3dc8f24">ha_blackhole</a>, and <a class="el" href="classha__ndbinfo.html#a0157ed0545e9748cccbd9b58a7178529">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="a48cb9c94ca93dbfbb7e92822caba82a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cb9c94ca93dbfbb7e92822caba82a1">&#9670;&nbsp;</a></span>rnd_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implemented in <a class="el" href="classha__partition.html#ad468c67dd2f37885994530f9e2ad2266">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#adc93bae43a800cc5ba5057b306136de1">ha_ndbcluster</a>, <a class="el" href="classha__example.html#a4e4701cddce2e721a3eaef67c2f3348f">ha_example</a>, <a class="el" href="classha__federated.html#a80469106e952f15caefe303dc4817c21">ha_federated</a>, <a class="el" href="classha__perfschema.html#a859872b267d446efee7dca19419a0f9f">ha_perfschema</a>, <a class="el" href="classha__innobase.html#a5dec515b9c0632116153a9990f980cf9">ha_innobase</a>, <a class="el" href="classha__tina.html#a72aa1d5c0d63b82a36b7290473be36c9">ha_tina</a>, <a class="el" href="classha__archive.html#a3f9f2cb49666081b08e5c79e0e31b354">ha_archive</a>, <a class="el" href="classha__myisammrg.html#aef37393dbbf339fd22ed138ad27ce2b6">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#af7afd99dacdf500f2caacd52e4572357">ha_myisam</a>, <a class="el" href="classha__heap.html#a452df8ee9a7af6ad6c10ce67c5e41e03">ha_heap</a>, <a class="el" href="classha__blackhole.html#abaf83f93ab06e57b420310453fe7ebb6">ha_blackhole</a>, and <a class="el" href="classha__ndbinfo.html#aafb71ce870019170b8949672a26387c3">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="adf659edd9d870e90c8974ae0eba7a082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf659edd9d870e90c8974ae0eba7a082">&#9670;&nbsp;</a></span>rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_pos </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implemented in <a class="el" href="classha__partition.html#a7b052173ced1b88687dafba28a170335">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a8980053ce56e386ced321a1ad88d1cc2">ha_ndbcluster</a>, <a class="el" href="classha__example.html#a3b3e340dc1b1a216d24f8e3076848d6a">ha_example</a>, <a class="el" href="classha__federated.html#a036f2954b0cd1134be69a601cacacd6a">ha_federated</a>, <a class="el" href="classha__perfschema.html#acd08aece7673996669307307bef36ed9">ha_perfschema</a>, <a class="el" href="classha__innobase.html#a77ac165a69160c94dd25349674fff74c">ha_innobase</a>, <a class="el" href="classha__tina.html#a2f8c40deceec830fcbde2fa7a1c4d9b7">ha_tina</a>, <a class="el" href="classha__archive.html#a873749f966e60f551683fc6ee022b8ba">ha_archive</a>, <a class="el" href="classha__myisammrg.html#ac19770b9b8b197700beec81bf59b089c">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#af8b066b32cf3950ecd9fdf7a0f5989ca">ha_myisam</a>, <a class="el" href="classha__heap.html#ab977e30c8e12a72220b7b8a96360f28d">ha_heap</a>, <a class="el" href="classha__blackhole.html#a08750241f4552423daed2d71e52645b9">ha_blackhole</a>, and <a class="el" href="classha__ndbinfo.html#a3c82928e6d10f1e83b118cc6fa7ce088">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="ac2be2fa5d347252f8a28dce931654b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be2fa5d347252f8a28dce931654b76">&#9670;&nbsp;</a></span>rnd_pos_by_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_pos_by_record </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function only works for handlers having HA_PRIMARY_KEY_REQUIRED_FOR_POSITION set. It will return the row with the PK given in the record argument. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a58bbc7153fa41de3b53872cb8f4b4e6e">ha_partition</a>.</p>

</div>
</div>
<a id="a624f6946109f48559e92a9e7c1b86517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624f6946109f48559e92a9e7c1b86517">&#9670;&nbsp;</a></span>root_of_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="struct_t_a_b_l_e.html">TABLE</a>* handler::root_of_pushed_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this handler instance is part of a pushed join sequence returned <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> instance being root of the pushed query? </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#af2c2492854b380092eccd19713aeec54">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a4b7dfb95a0da2e828ac018aa2b4abe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7dfb95a0da2e828ac018aa2b4abe3a">&#9670;&nbsp;</a></span>set_end_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::set_end_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structst__key__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_range_scan_direction&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the end position for a range scan. This is used for checking for when to end the range scan and by the ICP code to determine that the next record is within the current range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The end value for the range scan </td></tr>
    <tr><td class="paramname">direction</td><td>Direction of the range scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24470ac1d4ac336cedbe7c245d321c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24470ac1d4ac336cedbe7c245d321c9">&#9670;&nbsp;</a></span>set_ha_share_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::set_ha_share_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_handler__share.html">Handler_share</a> *&#160;</td>
          <td class="paramname"><em>arg_ha_share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set ha_share to be used by all instances of the same table/partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ha_share</td><td><a class="el" href="class_handler__share.html">Handler_share</a> to be shared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If not a temp table, then LOCK_ha_data must be held. </dd></dl>

</div>
</div>
<a id="acdaf7319a6498f655f8f07b1b34b12fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaf7319a6498f655f8f07b1b34b12fc">&#9670;&nbsp;</a></span>start_bulk_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::start_bulk_delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Bulk delete used by handler </td></tr>
    <tr><td class="paramname">1</td><td>Bulk delete not used, normal operation used </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#ac49c75c359eb6b1aa4a4c1d0ca31cb35">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a7488245f51aa4676c872bb0564dbe71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7488245f51aa4676c872bb0564dbe71f">&#9670;&nbsp;</a></span>start_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::start_bulk_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Bulk update used by handler </td></tr>
    <tr><td class="paramname">1</td><td>Bulk update not used, normal operation used </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#aa852a48bce2fe6fbbe70b83022d74ed2">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a3e2428788c2437e4e33c4b390cc697f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2428788c2437e4e33c4b390cc697f7">&#9670;&nbsp;</a></span>start_read_removal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::start_read_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start read (before write) removal on the current table. </p><dl class="section see"><dt>See also</dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a55b76e2e6595d838981a54951aa3f002">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a2502e460566f2c4b506cc1b30eb79e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2502e460566f2c4b506cc1b30eb79e0a">&#9670;&nbsp;</a></span>store_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a>** handler::store_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is not invoked for non-transactional temporary tables.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock()</a> can return more than one lock if the table is MERGE or partitioned.</dd>
<dd>
that one can NOT rely on table-&gt;in_use in <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock()</a>. It may refer to a different thread if called from <a class="el" href="group___locking.html#ga321511c56502643e5aecbe6ed3e43b58">mysql_lock_abort_for_thread()</a>.</dd>
<dd>
If the table is MERGE, <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock()</a> can return less locks than <a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count()</a> claimed. This can happen when the MERGE children are not attached when this is called from another thread. </dd></dl>

<p>Implemented in <a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a66a20a04ade6a21ac16a81c12d021659">ha_ndbcluster</a>, <a class="el" href="classha__federated.html#a263a380f847b47326378e9820ef66f01">ha_federated</a>, <a class="el" href="classha__example.html#a215dae75800535ccfbabd9b03c3e38ce">ha_example</a>, <a class="el" href="classha__innobase.html#ab5a9779dfd5b55feb0888a7381661f74">ha_innobase</a>, <a class="el" href="classha__perfschema.html#a5a48c39f9e54325b6784e46afccab53a">ha_perfschema</a>, <a class="el" href="classha__tina.html#a5c841f0339dd708f36db11b44c3625f9">ha_tina</a>, <a class="el" href="classha__archive.html#a02ba22069b36d6d9ede7d4cc73aec52e">ha_archive</a>, <a class="el" href="classha__myisammrg.html#a92333ad80f83576ac5aa8b4aea06ca75">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#a1102cf17fe67f172e8570d4f7f175cb2">ha_myisam</a>, <a class="el" href="classha__heap.html#ab37fd6528757763b79e8f89f241a0bbb">ha_heap</a>, <a class="el" href="classha__blackhole.html#aa8460055be373204e9c7b1467588a87a">ha_blackhole</a>, and <a class="el" href="classha__ndbinfo.html#a7169a09db353528ca14a979b01e56eb6">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="ab4d7cf309121ec10e4150860c8caa12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d7cf309121ec10e4150860c8caa12a">&#9670;&nbsp;</a></span>table_cache_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint8 handler::table_cache_type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of table for caching query </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a2b4f4002504f73ed3ae195729b95603b">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#ac3a23eb89230938663a59fcf8fbe908b">ha_ndbcluster</a>, <a class="el" href="classha__federated.html#a62c979dc05ccc6ed4c770646c9e797c0">ha_federated</a>, <a class="el" href="classha__innobase.html#ae0634d10e89122642d9278dd195bc7ea">ha_innobase</a>, <a class="el" href="classha__perfschema.html#af01c6cc89d1b0ed797886b2aa670e062">ha_perfschema</a>, and <a class="el" href="classha__ndbinfo.html#ab23949e133485226e2c90e78eb914b60">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="ad38f5d3f1e026a0af32b5542aa5ac2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38f5d3f1e026a0af32b5542aa5ac2f9">&#9670;&nbsp;</a></span>table_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* handler::table_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following can be called without an open handler </p>

<p>Implemented in <a class="el" href="classha__partition.html#a4ccd1f4c54f976848686ae866e7f9c96">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a9cdcf7225035b44c052ed7666b74fb51">ha_ndbcluster</a>, <a class="el" href="classha__federated.html#a2faf9972af40dcdd8aacde9c188fad38">ha_federated</a>, <a class="el" href="classha__innobase.html#a37c66a5e6163f68403c8fd0adb796607">ha_innobase</a>, <a class="el" href="classha__tina.html#a1754af5133195e932ccfc814b79dafb1">ha_tina</a>, <a class="el" href="classha__archive.html#ae7c0802b6a0dab8eb91648871bb7463e">ha_archive</a>, <a class="el" href="classha__myisammrg.html#ad0b19c9f2e6da7667894673ea0a007b9">ha_myisammrg</a>, <a class="el" href="classha__example.html#a49eb5c997bfa3d896eebdf5167392c43">ha_example</a>, <a class="el" href="classha__myisam.html#aa6ff0594b799751a78d54792601165c3">ha_myisam</a>, <a class="el" href="classha__perfschema.html#aef1311d6b7eb1ebae480392da67dab08">ha_perfschema</a>, <a class="el" href="classha__blackhole.html#ae9247f83054fe6172e5a049440e40fa0">ha_blackhole</a>, <a class="el" href="classha__heap.html#ab920e673ce6f2d2035c688fe84cb6e50">ha_heap</a>, and <a class="el" href="classha__ndbinfo.html#a4f8caa0e516e62ccce4a5f2a52590548">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="a13fdf15d81c256d3e6a9643532ff2126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fdf15d81c256d3e6a9643532ff2126">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::truncate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quickly remove all rows from a table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is responsible for implementing MySQL's TRUNCATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> statement, which is a DDL operation. As such, a engine can bypass certain integrity checks and in some cases avoid fine-grained locking (e.g. row locks) which would normally be required for a DELETE statement.</dd>
<dd>
Typically, truncate is not used if it can result in integrity violation. For example, truncate is not used when a foreign key references the table, but it might be used if foreign key checks are disabled.</dd>
<dd>
Engine is responsible for resetting the auto-increment counter.</dd>
<dd>
The table is locked in exclusive mode. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a42819e5cf989a23c0ade56feece2bcf4">ha_partition</a>, <a class="el" href="classha__federated.html#a3f01206bff2e25e5e94b402f2bc2f93c">ha_federated</a>, <a class="el" href="classha__example.html#af23ce7ec8e209411067e44fffbedb6e4">ha_example</a>, <a class="el" href="classha__innobase.html#a819d891b648b8846e7d58ee795799473">ha_innobase</a>, <a class="el" href="classha__perfschema.html#a6e1e1f938e994ffb49933157b5543ef0">ha_perfschema</a>, <a class="el" href="classha__archive.html#ac33753f6fd3c46340c2c640760ebcc67">ha_archive</a>, <a class="el" href="classha__myisammrg.html#aa07f201d94754c867638dfec04279d57">ha_myisammrg</a>, <a class="el" href="classha__myisam.html#ae00f44e12f5daf5cdc7b4202cae90ca1">ha_myisam</a>, <a class="el" href="classha__heap.html#a1fabad5948cd48e56aba765e9a6e695c">ha_heap</a>, and <a class="el" href="classha__blackhole.html#a9c6cadbb438dc8a0c8a190f2012b5196">ha_blackhole</a>.</p>

</div>
</div>
<a id="ab3e767094bff139a26743e9314df8476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e767094bff139a26743e9314df8476">&#9670;&nbsp;</a></span>try_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::try_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell the engine whether it should avoid unnecessary lock waits. If yes, in an UPDATE or DELETE, if the row under the cursor was locked by another transaction, the engine may try an optimistic read of the last committed row value under the cursor. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a45235c1c364a4b1ac4a2b97134f7a4b4">ha_partition</a>, and <a class="el" href="classha__innobase.html#ac3b12ebc2bb2a73404771514a047f0ab">ha_innobase</a>.</p>

</div>
</div>
<a id="a8059bbed3de416b3bea51c69dc064e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8059bbed3de416b3bea51c69dc064e79">&#9670;&nbsp;</a></span>unlock_shared_ha_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::unlock_shared_ha_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release lock for protecting ha_share. </p>

</div>
</div>
<a id="a4a8f7e55649146ad116762746624b43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8f7e55649146ad116762746624b43a">&#9670;&nbsp;</a></span>update_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::update_row </td>
          <td>(</td>
          <td class="paramtype">const uchar *old_data &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *new_data &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update a single row.</p>
<p>Note: If HA_ERR_FOUND_DUPP_KEY is returned, the handler must read all columns of the row so MySQL can create an error message. If the columns required for the error message are not read, the error message will contain garbage. </p>

</div>
</div>
<a id="adac21f2d10c4463fb1d7e14882c6314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac21f2d10c4463fb1d7e14882c6314f">&#9670;&nbsp;</a></span>use_hidden_primary_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::use_hidden_primary_key </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f" title="use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY...">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key </p>
<p><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f" title="use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY...">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key </p>

<p>Reimplemented in <a class="el" href="classha__perfschema.html#acd3f3d4d5c76e4f47aea91a099506d4c">ha_perfschema</a>.</p>

</div>
</div>
<a id="a54d92f647a4ca5a3b7867fa5538242a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d92f647a4ca5a3b7867fa5538242a6">&#9670;&nbsp;</a></span>was_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::was_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In an UPDATE or DELETE, if the row under the cursor was locked by another transaction, and the engine used an optimistic read of the last committed row value under the cursor, then the engine returns 1 from this function. MySQL must NOT try to update this optimistic value. If the optimistic value does not match the WHERE condition, MySQL can decide to skip over this row. Currently only works for InnoDB. This can be used to avoid unnecessary lock waits.</p>
<p>If this method returns nonzero, it will also signal the storage engine that the next read will be a locking re-read of the row. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a2a059c1ac08f3cd71b7087b876664e18">ha_partition</a>, and <a class="el" href="classha__innobase.html#ada1584696559d62c9f1b263189a73cbd">ha_innobase</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1540a47a05c03724f1102aaaa623131e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1540a47a05c03724f1102aaaa623131e">&#9670;&nbsp;</a></span>auto_inc_interval_for_cur_row</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_discrete__interval.html">Discrete_interval</a> handler::auto_inc_interval_for_cur_row</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interval returned by <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment()</a> and being consumed by the inserter. </p>

</div>
</div>
<a id="acdfcef0738a89138c8f41ded8da17c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfcef0738a89138c8f41ded8da17c0a">&#9670;&nbsp;</a></span>auto_inc_intervals_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint handler::auto_inc_intervals_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of reserved auto-increment intervals. Serves as a heuristic when we have no estimation of how many records the statement will insert: the more intervals we have reserved, the bigger the next one. Reset in handler::ha_release_auto_increment(). </p>

</div>
</div>
<a id="a97f83e0c7122ec3d276dcb0a0b940754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f83e0c7122ec3d276dcb0a0b940754">&#9670;&nbsp;</a></span>ha_share</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_handler__share.html">Handler_share</a>** handler::ha_share</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer where to store/retrieve the <a class="el" href="class_handler__share.html">Handler_share</a> pointer. For non partitioned handlers this is &amp;<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html#a20f65b925c665708bd19df8190115c66">TABLE_SHARE::ha_share</a>. </p>

</div>
</div>
<a id="a05dd2cafd83ae60562649bf9688aebf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dd2cafd83ae60562649bf9688aebf1">&#9670;&nbsp;</a></span>insert_id_for_cur_row</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong handler::insert_id_for_cur_row</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>insert id for the current row (<em>autogenerated</em>; if not autogenerated, it's 0). At first successful insertion, this variable is stored into THD::first_successful_insert_id_in_cur_stmt. </p>

</div>
</div>
<a id="a391dcf2f67a2d4d48e915c3bcd6609be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391dcf2f67a2d4d48e915c3bcd6609be">&#9670;&nbsp;</a></span>m_lock_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::m_lock_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The lock type set by when calling::ha_external_lock(). This is propagated down to the storage engine. The reason for also storing it here, is that when doing MRR we need to create/clone a second handler object. This cloned handler object needs to know about the lock_type used. </p>

</div>
</div>
<a id="a881e7cba3fe3bf9731a91be82983cc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881e7cba3fe3bf9731a91be82983cc35">&#9670;&nbsp;</a></span>m_psi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PSI_table* handler::m_psi</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instrumented table associated with this handler. This member should be set to NULL when no instrumentation is in place, so that linking an instrumented/non instrumented server/plugin works. For example:</p><ul>
<li>the server is compiled with the instrumentation. The server expects either NULL or valid pointers in m_psi.</li>
<li>an engine plugin is compiled without instrumentation. The plugin can not leave this pointer uninitialized, or can not leave a trash value on purpose in this pointer, as this would crash the server. </li>
</ul>

</div>
</div>
<a id="a62ab295e407d8a5c50087fed0f4fcd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ab295e407d8a5c50087fed0f4fcd18">&#9670;&nbsp;</a></span>next_insert_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong handler::next_insert_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>next_insert_id is the next value which should be inserted into the auto_increment column: in a inserting-multi-row statement (like INSERT SELECT), for the first row where the autoinc value is not specified by the statement, <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment()</a> called and asked to generate a value, next_insert_id is set to the next value, then for all other rows next_insert_id is used (and increased each time) without calling <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment()</a>. </p>

</div>
</div>
<a id="a64def328ff0ca7e391b217c2d3a758ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64def328ff0ca7e391b217c2d3a758ec">&#9670;&nbsp;</a></span>ref_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint handler::ref_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of ref (1-8 or the clustered key length) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="handler_8h_source.html">handler.h</a></li>
<li>sql/<a class="el" href="handler_8cc.html">handler.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

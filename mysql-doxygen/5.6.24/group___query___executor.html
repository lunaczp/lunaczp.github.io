<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Query Executor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query Executor</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0a77c65ecc3468365a08660d27d4fd43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga0a77c65ecc3468365a08660d27d4fd43">return_zero_rows</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>)</td></tr>
<tr class="separator:ga0a77c65ecc3468365a08660d27d4fd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35e846cbf96ca9e10788fa16c304daa6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga35e846cbf96ca9e10788fa16c304daa6">save_const_null_info</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, table_map *save_nullinfo)</td></tr>
<tr class="separator:ga35e846cbf96ca9e10788fa16c304daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9cc73c7dafc88f011d4fb70a3908436"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gaa9cc73c7dafc88f011d4fb70a3908436">restore_const_null_info</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, table_map save_nullinfo)</td></tr>
<tr class="separator:gaa9cc73c7dafc88f011d4fb70a3908436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade4a564a8e34be768074413e11ce1f64"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gade4a564a8e34be768074413e11ce1f64">do_select</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="separator:gade4a564a8e34be768074413e11ce1f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0ee35310af41ae96c1deeef16254c1"><td class="memItemLeft" align="right" valign="top">static enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga8c0ee35310af41ae96c1deeef16254c1">evaluate_join_record</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="memdesc:ga8c0ee35310af41ae96c1deeef16254c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process one row of the nested loop join.  <a href="#ga8c0ee35310af41ae96c1deeef16254c1">More...</a><br /></td></tr>
<tr class="separator:ga8c0ee35310af41ae96c1deeef16254c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c8935fa4962e33fb50fc29338af18d"><td class="memItemLeft" align="right" valign="top">static enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gab7c8935fa4962e33fb50fc29338af18d">evaluate_null_complemented_join_record</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:gab7c8935fa4962e33fb50fc29338af18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb9db5e32a169e1ccd208379582920a"><td class="memItemLeft" align="right" valign="top"><a id="ga0cb9db5e32a169e1ccd208379582920a"></a>
static enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>end_send</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr class="separator:ga0cb9db5e32a169e1ccd208379582920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfffa0450a4fd108c8980638617dd6f7"><td class="memItemLeft" align="right" valign="top"><a id="gabfffa0450a4fd108c8980638617dd6f7"></a>
static enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>end_write</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr class="separator:gabfffa0450a4fd108c8980638617dd6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f3a1c9a7f34173a723b47b25c8a620"><td class="memItemLeft" align="right" valign="top">static enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga22f3a1c9a7f34173a723b47b25c8a620">end_update</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr class="separator:ga22f3a1c9a7f34173a723b47b25c8a620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2572d6e731e9f937b673052380f0ba90"><td class="memItemLeft" align="right" valign="top">static enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga2572d6e731e9f937b673052380f0ba90">end_unique_update</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr class="separator:ga2572d6e731e9f937b673052380f0ba90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee6ba03b9da7cd3cff027b388054b8b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga1ee6ba03b9da7cd3cff027b388054b8b">copy_sum_funcs</a> (<a class="el" href="class_item__sum.html">Item_sum</a> **func_ptr, <a class="el" href="class_item__sum.html">Item_sum</a> **end_ptr)</td></tr>
<tr class="separator:ga1ee6ba03b9da7cd3cff027b388054b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga600a714a010d05f8b8150a27691b016c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga600a714a010d05f8b8150a27691b016c">join_read_system</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga600a714a010d05f8b8150a27691b016c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9af22c10e66c9a44995aaf0ff3ee8e5d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga9af22c10e66c9a44995aaf0ff3ee8e5d">join_read_const</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga9af22c10e66c9a44995aaf0ff3ee8e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999c752ca4346321796e060ebc5525b5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga999c752ca4346321796e060ebc5525b5">join_read_key</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga999c752ca4346321796e060ebc5525b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa079f8223121eb407b458d36a3c44a"><td class="memItemLeft" align="right" valign="top"><a id="gabfa079f8223121eb407b458d36a3c44a"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_always_key</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:gabfa079f8223121eb407b458d36a3c44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7374f42dbebded9897cbd98d19ea5953"><td class="memItemLeft" align="right" valign="top"><a id="ga7374f42dbebded9897cbd98d19ea5953"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_no_more_records</b> (<a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a> *info)</td></tr>
<tr class="separator:ga7374f42dbebded9897cbd98d19ea5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac462f7b8e79124cb9b034950afe68852"><td class="memItemLeft" align="right" valign="top"><a id="gac462f7b8e79124cb9b034950afe68852"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_next</b> (<a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a> *info)</td></tr>
<tr class="separator:gac462f7b8e79124cb9b034950afe68852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c51c289dcf2c12d4de79df05723dfe9"><td class="memItemLeft" align="right" valign="top"><a id="ga2c51c289dcf2c12d4de79df05723dfe9"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>test_if_quick_select</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga2c51c289dcf2c12d4de79df05723dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e50b19b07648798b4d12b65f9bf68b4"><td class="memItemLeft" align="right" valign="top"><a id="ga8e50b19b07648798b4d12b65f9bf68b4"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_next_same</b> (<a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a> *info)</td></tr>
<tr class="separator:ga8e50b19b07648798b4d12b65f9bf68b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105dab082517d22f3e59a93b9bc48246"><td class="memItemLeft" align="right" valign="top"><a id="ga105dab082517d22f3e59a93b9bc48246"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_prev</b> (<a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a> *info)</td></tr>
<tr class="separator:ga105dab082517d22f3e59a93b9bc48246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4537d9cf055dc0c4b2fb64a501b90f89"><td class="memItemLeft" align="right" valign="top"><a id="ga4537d9cf055dc0c4b2fb64a501b90f89"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_ft_read_first</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga4537d9cf055dc0c4b2fb64a501b90f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada994cf12f87b8a5947b7bd39541b49d"><td class="memItemLeft" align="right" valign="top"><a id="gada994cf12f87b8a5947b7bd39541b49d"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_ft_read_next</b> (<a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a> *info)</td></tr>
<tr class="separator:gada994cf12f87b8a5947b7bd39541b49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6229e406c4c0348768f95f0578b5d984"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga6229e406c4c0348768f95f0578b5d984">join_read_always_key_or_null</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga6229e406c4c0348768f95f0578b5d984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f10a0e81edbda0a8c635ade0da41001"><td class="memItemLeft" align="right" valign="top"><a id="ga9f10a0e81edbda0a8c635ade0da41001"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_next_same_or_null</b> (<a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a> *info)</td></tr>
<tr class="separator:ga9f10a0e81edbda0a8c635ade0da41001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a2c7da6e51b5b8692b781aab33936ee"><td class="memItemLeft" align="right" valign="top"><a id="ga6a2c7da6e51b5b8692b781aab33936ee"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>create_sort_index</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga6a2c7da6e51b5b8692b781aab33936ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e442a1a971933141700cc8399ee59ed"><td class="memItemLeft" align="right" valign="top"><a id="ga0e442a1a971933141700cc8399ee59ed"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>remove_dup_with_compare</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="struct__entry.html">entry</a>, <a class="el" href="class_field.html">Field</a> **field, ulong <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, <a class="el" href="class_item.html">Item</a> *having)</td></tr>
<tr class="separator:ga0e442a1a971933141700cc8399ee59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga158f0d41014d892900451d409070ede3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga158f0d41014d892900451d409070ede3">remove_dup_with_hash_index</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, uint field_count, <a class="el" href="class_field.html">Field</a> **first_field, ulong key_length, <a class="el" href="class_item.html">Item</a> *having)</td></tr>
<tr class="separator:ga158f0d41014d892900451d409070ede3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47249b94f6d857114347446d69e68bb8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga47249b94f6d857114347446d69e68bb8">join_read_linked_first</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga47249b94f6d857114347446d69e68bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9648b0b04e137f0fd6302cf42c7a13"><td class="memItemLeft" align="right" valign="top"><a id="gade9648b0b04e137f0fd6302cf42c7a13"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_linked_next</b> (<a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a> *info)</td></tr>
<tr class="separator:gade9648b0b04e137f0fd6302cf42c7a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95428e4e50817bb9e349ad9a84cc970f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga95428e4e50817bb9e349ad9a84cc970f">do_sj_reset</a> (<a class="el" href="class_s_j___t_m_p___t_a_b_l_e.html">SJ_TMP_TABLE</a> *sj_tbl)</td></tr>
<tr class="separator:ga95428e4e50817bb9e349ad9a84cc970f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c46741c46a49f77791faaf89cfe78ff"><td class="memItemLeft" align="right" valign="top"><a id="ga7c46741c46a49f77791faaf89cfe78ff"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_buffer_with_ref</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structst__table__ref.html">TABLE_REF</a> *tab_ref)</td></tr>
<tr class="separator:ga7c46741c46a49f77791faaf89cfe78ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc817dd0c7e9e7ba403b55f4b20a3fb"><td class="memItemLeft" align="right" valign="top"><a id="ga1cc817dd0c7e9e7ba403b55f4b20a3fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>prepare_sum_aggregators</b> (<a class="el" href="class_item__sum.html">Item_sum</a> **func_ptr, bool need_distinct)</td></tr>
<tr class="separator:ga1cc817dd0c7e9e7ba403b55f4b20a3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1125b75ed00a408f039bb83de7c480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga1b1125b75ed00a408f039bb83de7c480">setup_sum_funcs</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item__sum.html">Item_sum</a> **func_ptr)</td></tr>
<tr class="separator:ga1b1125b75ed00a408f039bb83de7c480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea4e7db5424644262ac8c840f7d256b4"><td class="memItemLeft" align="right" valign="top"><a id="gaea4e7db5424644262ac8c840f7d256b4"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>init_tmptable_sum_functions</b> (<a class="el" href="class_item__sum.html">Item_sum</a> **func_ptr)</td></tr>
<tr class="separator:gaea4e7db5424644262ac8c840f7d256b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6407387234d462d4fb0c6495aa2f0c2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gab6407387234d462d4fb0c6495aa2f0c2">update_tmptable_sum_func</a> (<a class="el" href="class_item__sum.html">Item_sum</a> **func_ptr, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *tmp_table <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:gab6407387234d462d4fb0c6495aa2f0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1574ec06f20dd00662df9c073b763f"><td class="memItemLeft" align="right" valign="top"><a id="gacf1574ec06f20dd00662df9c073b763f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>init_sum_functions</b> (<a class="el" href="class_item__sum.html">Item_sum</a> **func_ptr, <a class="el" href="class_item__sum.html">Item_sum</a> **end_ptr)</td></tr>
<tr class="separator:gacf1574ec06f20dd00662df9c073b763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d93dff633443a16273b8182d8f90a0"><td class="memItemLeft" align="right" valign="top"><a id="ga12d93dff633443a16273b8182d8f90a0"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>update_sum_func</b> (<a class="el" href="class_item__sum.html">Item_sum</a> **func_ptr)</td></tr>
<tr class="separator:ga12d93dff633443a16273b8182d8f90a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ce4c7b8a149e93d6112527d0416aa7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga83ce4c7b8a149e93d6112527d0416aa7">copy_funcs</a> (<a class="el" href="class_item.html">Item</a> **func_ptr, const THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga83ce4c7b8a149e93d6112527d0416aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f2b3b6bc0061b7be2277a7e3119fa43"><td class="memItemLeft" align="right" valign="top"><a id="ga3f2b3b6bc0061b7be2277a7e3119fa43"></a>
static enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>end_sj_materialize</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr class="separator:ga3f2b3b6bc0061b7be2277a7e3119fa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b94786e3b5175f3dd15bc0497087656"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga7b94786e3b5175f3dd15bc0497087656">update_const_equal_items</a> (<a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga7b94786e3b5175f3dd15bc0497087656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25deeac7a2e0e4cd9623bfcf539e44f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga25deeac7a2e0e4cd9623bfcf539e44f7">setup_tmptable_write_func</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="memdesc:ga25deeac7a2e0e4cd9623bfcf539e44f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup write_func of <a class="el" href="class_q_e_p__tmp__table.html" title="Class for accumulating join result in a tmp table, grouping them if necessary, and sending further...">QEP_tmp_table</a> object.  <a href="#ga25deeac7a2e0e4cd9623bfcf539e44f7">More...</a><br /></td></tr>
<tr class="separator:ga25deeac7a2e0e4cd9623bfcf539e44f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19817b01781d428b21cf4c3a3f42467b"><td class="memItemLeft" align="right" valign="top">Next_select_func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga19817b01781d428b21cf4c3a3f42467b">setup_end_select_func</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga19817b01781d428b21cf4c3a3f42467b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3f583dd255c4288df81b3ab1628a1c"><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gacb3f583dd255c4288df81b3ab1628a1c">sub_select_op</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr class="memdesc:gacb3f583dd255c4288df81b3ab1628a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate full or partial join result in operation and send operation's result further.  <a href="#gacb3f583dd255c4288df81b3ab1628a1c">More...</a><br /></td></tr>
<tr class="separator:gacb3f583dd255c4288df81b3ab1628a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c3a10fb1e79511b38573124e0ec107"><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gaf5c3a10fb1e79511b38573124e0ec107">sub_select</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr class="separator:gaf5c3a10fb1e79511b38573124e0ec107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3b77b483fa5b7bcefe0f38587480c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga4c3b77b483fa5b7bcefe0f38587480c8">do_sj_dups_weedout</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_s_j___t_m_p___t_a_b_l_e.html">SJ_TMP_TABLE</a> *sjtbl)</td></tr>
<tr class="separator:ga4c3b77b483fa5b7bcefe0f38587480c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb800e0e68d03a1b49a9cf66fda4006"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga4fb800e0e68d03a1b49a9cf66fda4006">report_handler_error</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>)</td></tr>
<tr class="separator:ga4fb800e0e68d03a1b49a9cf66fda4006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1142f17ec7f7382f97e566f23eb6531d"><td class="memItemLeft" align="right" valign="top"><a id="ga1142f17ec7f7382f97e566f23eb6531d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>safe_index_read</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga1142f17ec7f7382f97e566f23eb6531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c30d89f411ee0d12ecd4824f9aae1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga39c30d89f411ee0d12ecd4824f9aae1a">join_read_const_table</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="structst__position.html">POSITION</a> *pos)</td></tr>
<tr class="separator:ga39c30d89f411ee0d12ecd4824f9aae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ac23de91637b8c89139c7ddeb81a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga59ac23de91637b8c89139c7ddeb81a6e">join_read_key_unlock_row</a> (<a class="el" href="structst__join__table.html">st_join_table</a> *tab)</td></tr>
<tr class="separator:ga59ac23de91637b8c89139c7ddeb81a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a4e01fdaf11685248def35552484ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gae7a4e01fdaf11685248def35552484ac">join_read_last_key</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:gae7a4e01fdaf11685248def35552484ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabf4f5b27f1a96ef7d5d12606b57ba26"><td class="memItemLeft" align="right" valign="top"><a id="gaabf4f5b27f1a96ef7d5d12606b57ba26"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>join_no_more_records</b> (<a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a> *info <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:gaabf4f5b27f1a96ef7d5d12606b57ba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4478c7766644e31523194a220460a9f2"><td class="memItemLeft" align="right" valign="top"><a id="ga4478c7766644e31523194a220460a9f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_prev_same</b> (<a class="el" href="struct_r_e_a_d___r_e_c_o_r_d.html">READ_RECORD</a> *info)</td></tr>
<tr class="separator:ga4478c7766644e31523194a220460a9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac643027fd4d1f99f03055061a05b05e4"><td class="memItemLeft" align="right" valign="top"><a id="gac643027fd4d1f99f03055061a05b05e4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_init_quick_read_record</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:gac643027fd4d1f99f03055061a05b05e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde71b02635ed97c198671fff32e9154"><td class="memItemLeft" align="right" valign="top"><a id="gabde71b02635ed97c198671fff32e9154"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>read_first_record_seq</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:gabde71b02635ed97c198671fff32e9154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941e1255d38b156bbed1693a97545414"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga941e1255d38b156bbed1693a97545414">join_init_read_record</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="memdesc:ga941e1255d38b156bbed1693a97545414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare table for reading rows and read first record.  <a href="#ga941e1255d38b156bbed1693a97545414">More...</a><br /></td></tr>
<tr class="separator:ga941e1255d38b156bbed1693a97545414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa0bd7c50bcdd52a0d9e49c3985f06e3"><td class="memItemLeft" align="right" valign="top"><a id="gaaa0bd7c50bcdd52a0d9e49c3985f06e3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_materialize_derived</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:gaaa0bd7c50bcdd52a0d9e49c3985f06e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdf823c5bb814153d289d4f3c0a7c63a"><td class="memItemLeft" align="right" valign="top"><a id="gafdf823c5bb814153d289d4f3c0a7c63a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_materialize_semijoin</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:gafdf823c5bb814153d289d4f3c0a7c63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee74a413899e386bc8fc01e00b1786d"><td class="memItemLeft" align="right" valign="top"><a id="gaeee74a413899e386bc8fc01e00b1786d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_first</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:gaeee74a413899e386bc8fc01e00b1786d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf8b2e69e78e1f0e7bfa1f4432d7c3ae"><td class="memItemLeft" align="right" valign="top"><a id="gacf8b2e69e78e1f0e7bfa1f4432d7c3ae"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_last</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:gacf8b2e69e78e1f0e7bfa1f4432d7c3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5c993c8b1846da161af3022c82a734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga2a5c993c8b1846da161af3022c82a734">pick_table_access_method</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga2a5c993c8b1846da161af3022c82a734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5daf7637bb6b89ea2965089eacc33b88"><td class="memItemLeft" align="right" valign="top"><a id="ga5daf7637bb6b89ea2965089eacc33b88"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>end_send_group</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)), bool end_of_records)</td></tr>
<tr class="separator:ga5daf7637bb6b89ea2965089eacc33b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78e9746df25070df8400039a7cdb1cd6"><td class="memItemLeft" align="right" valign="top"><a id="ga78e9746df25070df8400039a7cdb1cd6"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>end_write_group</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr class="separator:ga78e9746df25070df8400039a7cdb1cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd537f9c2e403aac44384fc355f2713f"><td class="memItemLeft" align="right" valign="top"><a id="gadd537f9c2e403aac44384fc355f2713f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>compare_record</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="class_field.html">Field</a> **ptr)</td></tr>
<tr class="separator:gadd537f9c2e403aac44384fc355f2713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33bbf108cbc4c6c90812c13a7733307a"><td class="memItemLeft" align="right" valign="top"><a id="ga33bbf108cbc4c6c90812c13a7733307a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>copy_blobs</b> (<a class="el" href="class_field.html">Field</a> **ptr)</td></tr>
<tr class="separator:ga33bbf108cbc4c6c90812c13a7733307a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b55c47d65575ead94b699da7b070796"><td class="memItemLeft" align="right" valign="top"><a id="ga8b55c47d65575ead94b699da7b070796"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>free_blobs</b> (<a class="el" href="class_field.html">Field</a> **ptr)</td></tr>
<tr class="separator:ga8b55c47d65575ead94b699da7b070796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce1ad15977cc2105276ffca627a3824"><td class="memItemLeft" align="right" valign="top"><a id="ga8ce1ad15977cc2105276ffca627a3824"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_buffer_from_ref</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structst__table__ref.html">TABLE_REF</a> *ref)</td></tr>
<tr class="separator:ga8ce1ad15977cc2105276ffca627a3824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0bd2dbcf106da50227e2eb4932b588d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gaa0bd2dbcf106da50227e2eb4932b588d">make_group_fields</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *main_join, <a class="el" href="class_j_o_i_n.html">JOIN</a> *curr_join)</td></tr>
<tr class="separator:gaa0bd2dbcf106da50227e2eb4932b588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108fbed43151ab58878335fbb84503c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga108fbed43151ab58878335fbb84503c1">alloc_group_fields</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *group)</td></tr>
<tr class="separator:ga108fbed43151ab58878335fbb84503c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1389fe70c557f844809a7bd780fc545a"><td class="memItemLeft" align="right" valign="top"><a id="ga1389fe70c557f844809a7bd780fc545a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>test_if_item_cache_changed</b> (<a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_cached__item.html">Cached_item</a> &gt; &amp;list)</td></tr>
<tr class="separator:ga1389fe70c557f844809a7bd780fc545a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf6f9870d5d7d18698a9fed0295393f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gabf6f9870d5d7d18698a9fed0295393f4">setup_copy_fields</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, TMP_TABLE_PARAM *param, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;res_selected_fields, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;res_all_fields, uint elements, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields)</td></tr>
<tr class="separator:gabf6f9870d5d7d18698a9fed0295393f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85cf2346de8420668cb7988a62d43b1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga85cf2346de8420668cb7988a62d43b1c">copy_fields</a> (TMP_TABLE_PARAM *param)</td></tr>
<tr class="separator:ga85cf2346de8420668cb7988a62d43b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e985adce1ee0b0c97f2351330ba0b45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga1e985adce1ee0b0c97f2351330ba0b45">change_to_use_tmp_fields</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;res_selected_fields, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;res_all_fields, uint elements, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields)</td></tr>
<tr class="separator:ga1e985adce1ee0b0c97f2351330ba0b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27d7837289ad61f55a8649b343d2ffe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gae27d7837289ad61f55a8649b343d2ffe">change_refs_to_tmp_fields</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;res_selected_fields, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;res_all_fields, uint elements, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields)</td></tr>
<tr class="separator:gae27d7837289ad61f55a8649b343d2ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31581f58624b85919d7c6cd632157929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga31581f58624b85919d7c6cd632157929">JOIN::exec</a> ()</td></tr>
<tr class="separator:ga31581f58624b85919d7c6cd632157929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea471c270f3abb3609ab633d41770189"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gaea471c270f3abb3609ab633d41770189">JOIN::create_intermediate_table</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *tmp_table_fields, <a class="el" href="class_j_o_i_n_1_1_o_r_d_e_r__with__src.html">ORDER_with_src</a> &amp;tmp_table_group, bool save_sum_fields)</td></tr>
<tr class="separator:gaea471c270f3abb3609ab633d41770189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148b2123bee3ebd0718d334e9f109db8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga148b2123bee3ebd0718d334e9f109db8">JOIN::rollup_send_data</a> (uint idx)</td></tr>
<tr class="separator:ga148b2123bee3ebd0718d334e9f109db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c9baf548fef3d59f993a3c13575593"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga15c9baf548fef3d59f993a3c13575593">JOIN::rollup_write_data</a> (uint idx, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table)</td></tr>
<tr class="separator:ga15c9baf548fef3d59f993a3c13575593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c1673adeda51cbb4befa2faa444d10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga09c1673adeda51cbb4befa2faa444d10">JOIN::optimize_distinct</a> ()</td></tr>
<tr class="separator:ga09c1673adeda51cbb4befa2faa444d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee113ec47170e3e0d774c0a04beafc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gaeee113ec47170e3e0d774c0a04beafc3">st_join_table::prepare_scan</a> ()</td></tr>
<tr class="memdesc:gaeee113ec47170e3e0d774c0a04beafc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare table to be scanned.  <a href="#gaeee113ec47170e3e0d774c0a04beafc3">More...</a><br /></td></tr>
<tr class="separator:gaeee113ec47170e3e0d774c0a04beafc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b95762423e8b4c050503ee51c2e2a0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga0b95762423e8b4c050503ee51c2e2a0b">st_join_table::use_order</a> () const</td></tr>
<tr class="memdesc:ga0b95762423e8b4c050503ee51c2e2a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use ordering provided by chosen index?  <a href="#ga0b95762423e8b4c050503ee51c2e2a0b">More...</a><br /></td></tr>
<tr class="separator:ga0b95762423e8b4c050503ee51c2e2a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06940835e20546f1d3866b9341828e06"><td class="memItemLeft" align="right" valign="top"><a id="ga06940835e20546f1d3866b9341828e06"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>st_join_table::sort_table</b> ()</td></tr>
<tr class="separator:ga06940835e20546f1d3866b9341828e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedeb5c57d26a961a68a1bdabe11ae770"><td class="memItemLeft" align="right" valign="top"><a id="gaedeb5c57d26a961a68a1bdabe11ae770"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>st_join_table::remove_duplicates</b> ()</td></tr>
<tr class="separator:gaedeb5c57d26a961a68a1bdabe11ae770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7a6068062884e91b5500941e651a95"><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#gafc7a6068062884e91b5500941e651a95">QEP_tmp_table::put_record</a> (bool end_of_records)</td></tr>
<tr class="memdesc:gafc7a6068062884e91b5500941e651a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare table if necessary and call write_func to save record.  <a href="#gafc7a6068062884e91b5500941e651a95">More...</a><br /></td></tr>
<tr class="separator:gafc7a6068062884e91b5500941e651a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cbaa4a44140f41c161eaab87c25f473"><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___executor.html#ga1cbaa4a44140f41c161eaab87c25f473">QEP_tmp_table::end_send</a> ()</td></tr>
<tr class="memdesc:ga1cbaa4a44140f41c161eaab87c25f473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish rnd/index scan after accumulating records, switch ref_array, and send accumulated records further.  <a href="#ga1cbaa4a44140f41c161eaab87c25f473">More...</a><br /></td></tr>
<tr class="separator:ga1cbaa4a44140f41c161eaab87c25f473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga108fbed43151ab58878335fbb84503c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga108fbed43151ab58878335fbb84503c1">&#9670;&nbsp;</a></span>alloc_group_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alloc_group_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a list of buffers for saveing last group.</p>
<p>Groups are saved in reverse order for easyer check loop. </p>

</div>
</div>
<a id="gae27d7837289ad61f55a8649b343d2ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae27d7837289ad61f55a8649b343d2ffe">&#9670;&nbsp;</a></span>change_refs_to_tmp_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool change_refs_to_tmp_fields </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_selected_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change all sum_func refs to fields to point at fields in tmp table. Change all funcs to be fields in tmp table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramname">res_selected_fields</td><td>new list of items of select item list </td></tr>
    <tr><td class="paramname">res_all_fields</td><td>new list of all items </td></tr>
    <tr><td class="paramname">elements</td><td>number of elements in select item list </td></tr>
    <tr><td class="paramname">all_fields</td><td>all fields list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e985adce1ee0b0c97f2351330ba0b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e985adce1ee0b0c97f2351330ba0b45">&#9670;&nbsp;</a></span>change_to_use_tmp_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool change_to_use_tmp_fields </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_selected_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change all funcs and sum_funcs to fields in tmp table, and create new list of all items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramname">res_selected_fields</td><td>new list of items of select item list </td></tr>
    <tr><td class="paramname">res_all_fields</td><td>new list of all items </td></tr>
    <tr><td class="paramname">elements</td><td>number of elements in select item list </td></tr>
    <tr><td class="paramname">all_fields</td><td>all fields list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">!=0</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85cf2346de8420668cb7988a62d43b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85cf2346de8420668cb7988a62d43b1c">&#9670;&nbsp;</a></span>copy_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy_fields </td>
          <td>(</td>
          <td class="paramtype">TMP_TABLE_PARAM *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a copy of all simple SELECT'ed items.</p>
<p>This is done at the start of a new group so that we can retrieve these later when the group changes. </p>

</div>
</div>
<a id="ga83ce4c7b8a149e93d6112527d0416aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83ce4c7b8a149e93d6112527d0416aa7">&#9670;&nbsp;</a></span>copy_funcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool copy_funcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy result of functions to record in tmp_table.</p>
<p>Uses the thread pointer to check for errors in some of the val_xxx() methods called by the save_in_result_field() function. TODO: make the Item::val_xxx() return error code</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_ptr</td><td>array of the function Items to copy to the tmp table </td></tr>
    <tr><td class="paramname">thd</td><td>pointer to the current thread for error checking </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>if OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ee6ba03b9da7cd3cff027b388054b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ee6ba03b9da7cd3cff027b388054b8b">&#9670;&nbsp;</a></span>copy_sum_funcs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void copy_sum_funcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>end_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy result of sum functions to record in tmp_table. </p>

</div>
</div>
<a id="gaea471c270f3abb3609ab633d41770189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea471c270f3abb3609ab633d41770189">&#9670;&nbsp;</a></span>create_intermediate_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::create_intermediate_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *&#160;</td>
          <td class="paramname"><em>tmp_table_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n_1_1_o_r_d_e_r__with__src.html">ORDER_with_src</a> &amp;&#160;</td>
          <td class="paramname"><em>tmp_table_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_sum_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a temporary table to be used for processing DISTINCT/ORDER BY/GROUP BY.</p>
<dl class="section note"><dt>Note</dt><dd>Will modify <a class="el" href="class_j_o_i_n.html">JOIN</a> object wrt sort/group attributes</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>the JOIN_TAB object to attach created table to </td></tr>
    <tr><td class="paramname">tmp_table_fields</td><td><a class="el" href="class_list.html">List</a> of items that will be used to define column types of the table. </td></tr>
    <tr><td class="paramname">tmp_table_group</td><td>Group key to use for temporary table, NULL if none. </td></tr>
    <tr><td class="paramname">save_sum_fields</td><td>If true, do not replace <a class="el" href="class_item__sum.html">Item_sum</a> items in <code>tmp_fields</code> list with <a class="el" href="class_item__field.html">Item_field</a> items referring to fields in temporary table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on failure </dd></dl>

</div>
</div>
<a id="gade4a564a8e34be768074413e11ce1f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade4a564a8e34be768074413e11ce1f64">&#9670;&nbsp;</a></span>do_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int do_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a join of all tables and write it on socket or to table.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ok </td></tr>
    <tr><td class="paramname">1</td><td>if error is sent </td></tr>
    <tr><td class="paramname">-1</td><td>if error should be sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c3b77b483fa5b7bcefe0f38587480c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c3b77b483fa5b7bcefe0f38587480c8">&#9670;&nbsp;</a></span>do_sj_dups_weedout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int do_sj_dups_weedout </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_j___t_m_p___t_a_b_l_e.html">SJ_TMP_TABLE</a> *&#160;</td>
          <td class="paramname"><em>sjtbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SemiJoinDuplicateElimination: Weed out duplicate row combinations</p>
<p>SYNPOSIS <a class="el" href="group___query___executor.html#ga4c3b77b483fa5b7bcefe0f38587480c8">do_sj_dups_weedout()</a> thd Thread handle sjtbl Duplicate weedout table</p>
<p>DESCRIPTION Try storing current record combination of outer tables (i.e. their rowids) in the temporary table. This records the fact that we've seen this record combination and also tells us if we've seen it before.</p>
<p>RETURN -1 Error 1 The row combination is a duplicate (discard it) 0 The row combination is not a duplicate (continue) </p>

</div>
</div>
<a id="ga95428e4e50817bb9e349ad9a84cc970f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95428e4e50817bb9e349ad9a84cc970f">&#9670;&nbsp;</a></span>do_sj_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int do_sj_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_j___t_m_p___t_a_b_l_e.html">SJ_TMP_TABLE</a> *&#160;</td>
          <td class="paramname"><em>sj_tbl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SemiJoinDuplicateElimination: Reset the temporary table </p>

</div>
</div>
<a id="ga1cbaa4a44140f41c161eaab87c25f473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cbaa4a44140f41c161eaab87c25f473">&#9670;&nbsp;</a></span>end_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state QEP_tmp_table::end_send </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish rnd/index scan after accumulating records, switch ref_array, and send accumulated records further. </p>
<dl class="section return"><dt>Returns</dt><dd>return one of enum_nested_loop_state. </dd></dl>

<p>Implements <a class="el" href="class_q_e_p__operation.html#a4faf706cddaf3ae613fe92434776df5e">QEP_operation</a>.</p>

</div>
</div>
<a id="ga2572d6e731e9f937b673052380f0ba90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2572d6e731e9f937b673052380f0ba90">&#9670;&nbsp;</a></span>end_unique_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum_nested_loop_state end_unique_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end_of_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like end_update, but this is done with unique constraints instead of keys. </p>

</div>
</div>
<a id="ga22f3a1c9a7f34173a723b47b25c8a620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22f3a1c9a7f34173a723b47b25c8a620">&#9670;&nbsp;</a></span>end_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum_nested_loop_state end_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end_of_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Group by searching after group record and updating it if possible. </p>

</div>
</div>
<a id="ga8c0ee35310af41ae96c1deeef16254c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0ee35310af41ae96c1deeef16254c1">&#9670;&nbsp;</a></span>evaluate_join_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum_nested_loop_state evaluate_join_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process one row of the nested loop join. </p>
<p>This function will evaluate parts of WHERE/ON clauses that are applicable to the partial row on hand and in case of success submit this row to the next level of the nested loop. join_tab-&gt;return_tab may be modified to cause a return to a previous join_tab.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>- The join object </td></tr>
    <tr><td class="paramname">join_tab</td><td>- The most inner join_tab being processed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nested loop state </dd></dl>

</div>
</div>
<a id="gab7c8935fa4962e33fb50fc29338af18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c8935fa4962e33fb50fc29338af18d">&#9670;&nbsp;</a></span>evaluate_null_complemented_join_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum_nested_loop_state evaluate_null_complemented_join_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a NULL complimented partial join record and feed it to the next level of the nested loop. This function is used in case we have an OUTER join and no matching record was found. </p>

</div>
</div>
<a id="ga31581f58624b85919d7c6cd632157929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31581f58624b85919d7c6cd632157929">&#9670;&nbsp;</a></span>exec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::exec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute select, executor entry point.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000090">Todo:</a></b></dt><dd>When can we have here thd-&gt;net.report_error not zero? </dd></dl>

</div>
</div>
<a id="ga941e1255d38b156bbed1693a97545414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941e1255d38b156bbed1693a97545414">&#9670;&nbsp;</a></span>join_init_read_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int join_init_read_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare table for reading rows and read first record. </p>
<p>Prior to reading the table following tasks are done, (in the order of execution): .) derived tables are materialized .) duplicates removed (tmp tables only) .) table is sorted with filesort (both non-tmp and tmp tables) After this have been done this function resets quick select, if it's present, sets up table reading functions, and reads first record.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Ok </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6229e406c4c0348768f95f0578b5d984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6229e406c4c0348768f95f0578b5d984">&#9670;&nbsp;</a></span>join_read_always_key_or_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int join_read_always_key_or_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reading of key with key reference and one part that may be NULL. </p>

</div>
</div>
<a id="ga9af22c10e66c9a44995aaf0ff3ee8e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9af22c10e66c9a44995aaf0ff3ee8e5d">&#9670;&nbsp;</a></span>join_read_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int join_read_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a constant table when there is at most one matching row, using an index lookup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Table to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Row was found </td></tr>
    <tr><td class="paramname">-1</td><td>Row was not found </td></tr>
    <tr><td class="paramname">1</td><td>Got an error (other than row not found) during read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39c30d89f411ee0d12ecd4824f9aae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c30d89f411ee0d12ecd4824f9aae1a">&#9670;&nbsp;</a></span>join_read_const_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int join_read_const_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__position.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads content of constant table </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>table </td></tr>
    <tr><td class="paramname">pos</td><td>position of table in query plan </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok, one row was found or one NULL-complemented row was created </td></tr>
    <tr><td class="paramname">-1</td><td>ok, no row was found and no NULL-complemented row was created </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga999c752ca4346321796e060ebc5525b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga999c752ca4346321796e060ebc5525b5">&#9670;&nbsp;</a></span>join_read_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int join_read_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read row using unique key: eq_ref access method implementation</p>
<p>This is the "read_first" function for the eq_ref access method. The difference from ref access function is that it has a one-element lookup cache (see cmp_buffer_with_ref)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>JOIN_TAB of the accessed table</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>- Ok </td></tr>
    <tr><td class="paramname">-1</td><td>- Row not found </td></tr>
    <tr><td class="paramname">1</td><td>- Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59ac23de91637b8c89139c7ddeb81a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59ac23de91637b8c89139c7ddeb81a6e">&#9670;&nbsp;</a></span>join_read_key_unlock_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void join_read_key_unlock_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">st_join_table</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Since join_read_key may buffer a record, do not unlock it if it was not used in this invocation of <a class="el" href="group___query___executor.html#ga999c752ca4346321796e060ebc5525b5">join_read_key()</a>. Only count locks, thus remembering if the record was left unused, and unlock already when pruning the current value of TABLE_REF buffer. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___executor.html#ga999c752ca4346321796e060ebc5525b5">join_read_key()</a> </dd></dl>

</div>
</div>
<a id="gae7a4e01fdaf11685248def35552484ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a4e01fdaf11685248def35552484ac">&#9670;&nbsp;</a></span>join_read_last_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int join_read_last_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used when optimizing away ORDER BY in SELECT * FROM t1 WHERE a=1 ORDER BY a DESC,b DESC. </p>

</div>
</div>
<a id="ga47249b94f6d857114347446d69e68bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47249b94f6d857114347446d69e68bb8">&#9670;&nbsp;</a></span>join_read_linked_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int join_read_linked_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a table <em>assumed</em> to be included in execution of a pushed join. This is the counterpart of <a class="el" href="group___query___executor.html#ga999c752ca4346321796e060ebc5525b5">join_read_key()</a> / join_read_always_key() for child tables in a pushed join.</p>
<p>When the table access is performed as part of the pushed join, all 'linked' child colums are prefetched together with the parent row. The handler will then only format the row as required by MySQL and set 'table-&gt;status' accordingly.</p>
<p>However, there may be situations where the prepared pushed join was not executed as assumed. It is the responsibility of the handler to handle these situation by letting ::index_read_pushed() then effectively do a plain old' index_read_map(..., HA_READ_KEY_EXACT);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Table to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Row was found </td></tr>
    <tr><td class="paramname">-1</td><td>Row was not found </td></tr>
    <tr><td class="paramname">1</td><td>Got an error (other than row not found) during read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga600a714a010d05f8b8150a27691b016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga600a714a010d05f8b8150a27691b016c">&#9670;&nbsp;</a></span>join_read_system()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int join_read_system </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a constant table when there is at most one matching row, using a table scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Table to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Row was found </td></tr>
    <tr><td class="paramname">-1</td><td>Row was not found </td></tr>
    <tr><td class="paramname">1</td><td>Got an error (other than row not found) during read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0bd2dbcf106da50227e2eb4932b588d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0bd2dbcf106da50227e2eb4932b588d">&#9670;&nbsp;</a></span>make_group_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool make_group_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>main_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>curr_join</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>allocate group fields or take prepared (cached).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main_join</td><td>join of current select </td></tr>
    <tr><td class="paramname">curr_join</td><td>current join (join of current select or temporary copy of it)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09c1673adeda51cbb4befa2faa444d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09c1673adeda51cbb4befa2faa444d10">&#9670;&nbsp;</a></span>optimize_distinct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::optimize_distinct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimize distinct when used on a subset of the tables.</p>
<p>E.g.,: SELECT DISTINCT t1.a FROM t1,t2 WHERE t1.b=t2.b In this case we can stop scanning t2 when we have found one t1.a </p>

</div>
</div>
<a id="ga2a5c993c8b1846da161af3022c82a734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a5c993c8b1846da161af3022c82a734">&#9670;&nbsp;</a></span>pick_table_access_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pick_table_access_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pick the appropriate access method functions</p>
<p>Sets the functions for the selected table access method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Table reference to put access method </td></tr>
  </table>
  </dd>
</dl>
<p>Set up modified access function for children of pushed joins.</p>
<p>Is child of a pushed join operation: Replace access functions with its linked counterpart. ... Which is effectively a NOOP as the row is already fetched together with the root of the linked operation.</p>
<p>Already set to some non-default value in <a class="el" href="sql__select_8cc.html" title="mysql_select and join optimization ">sql_select.cc</a>? TODO: Move these settings into <a class="el" href="group___query___executor.html#ga2a5c993c8b1846da161af3022c82a734">pick_table_access_method()</a> also</p>

</div>
</div>
<a id="gaeee113ec47170e3e0d774c0a04beafc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeee113ec47170e3e0d774c0a04beafc3">&#9670;&nbsp;</a></span>prepare_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_TAB::prepare_scan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare table to be scanned. </p>
<p>This function is the place to do any work on the table that needs to be done before table can be scanned. Currently it only materialized derived tables and semi-joined subqueries and binds buffer for current rowid.</p>
<dl class="section return"><dt>Returns</dt><dd>false - Ok, true - error </dd></dl>

</div>
</div>
<a id="gafc7a6068062884e91b5500941e651a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7a6068062884e91b5500941e651a95">&#9670;&nbsp;</a></span>put_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state QEP_tmp_table::put_record </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end_of_records</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare table if necessary and call write_func to save record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end_of_record</td><td>the end_of_record signal to pass to the writer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return one of enum_nested_loop_state. </dd></dl>

</div>
</div>
<a id="ga158f0d41014d892900451d409070ede3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga158f0d41014d892900451d409070ede3">&#9670;&nbsp;</a></span>remove_dup_with_hash_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool remove_dup_with_hash_index </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>field_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> **&#160;</td>
          <td class="paramname"><em>first_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>having</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a hash index for each row to quickly find duplicate rows.</p>
<dl class="section note"><dt>Note</dt><dd>Note that this will not work on tables with blobs! </dd></dl>

</div>
</div>
<a id="ga4fb800e0e68d03a1b49a9cf66fda4006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb800e0e68d03a1b49a9cf66fda4006">&#9670;&nbsp;</a></span>report_handler_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int report_handler_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Help function when we get some an error from the table handler. </p>

</div>
</div>
<a id="gaa9cc73c7dafc88f011d4fb70a3908436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9cc73c7dafc88f011d4fb70a3908436">&#9670;&nbsp;</a></span>restore_const_null_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void restore_const_null_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>save_nullinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restore NULL-row info for constant tables. Used in conjunction with <a class="el" href="group___query___executor.html#ga35e846cbf96ca9e10788fa16c304daa6">save_const_null_info()</a> to restore constant table null_row and status values after temporarily marking rows as NULL. This is only done for const tables in subqueries because these values are not recalculated on next execution of the subquery.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join for which const tables have been marked as containing only NULL values </td></tr>
    <tr><td class="paramname">save_nullinfo</td><td>Const tables that had null_row=false and STATUS_NULL_ROW set when <a class="el" href="group___query___executor.html#ga35e846cbf96ca9e10788fa16c304daa6">save_const_null_info()</a> was called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>mark_as_null_row </dd>
<dd>
<a class="el" href="group___query___executor.html#ga35e846cbf96ca9e10788fa16c304daa6">save_const_null_info</a> </dd></dl>

</div>
</div>
<a id="ga0a77c65ecc3468365a08660d27d4fd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a77c65ecc3468365a08660d27d4fd43">&#9670;&nbsp;</a></span>return_zero_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void return_zero_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For some reason, e.g. due to an impossible WHERE clause, the tables cannot possibly contain any rows that will be in the result. This function is used to return with a result based on no matching rows (i.e., an empty result or one row with aggregates calculated without using rows in the case of implicit grouping) before the execution of nested loop join.</p>
<p>This function may evaluate the HAVING clause and is only meant for result sets that are empty due to an impossible HAVING clause. Do not use it if HAVING has already been evaluated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join that does not produce a row </td></tr>
    <tr><td class="paramname">fields</td><td>Fields in result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga148b2123bee3ebd0718d334e9f109db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148b2123bee3ebd0718d334e9f109db8">&#9670;&nbsp;</a></span>rollup_send_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN::rollup_send_data </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send all rollup levels higher than the current one to the client.</p>
<p><b>SAMPLE</b> </p><div class="fragment"><div class="line">SELECT <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, <a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, c SUM(<a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>) FROM t1 GROUP BY <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>,<a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a> WITH <a class="code" href="structst__rollup.html">ROLLUP</a></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Level we are on:<ul>
<li>0 = Total sum level</li>
<li>1 = First group changed (a)</li>
<li>2 = Second group changed (a,b)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>If send_data_failed() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15c9baf548fef3d59f993a3c13575593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c9baf548fef3d59f993a3c13575593">&#9670;&nbsp;</a></span>rollup_write_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN::rollup_write_data </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write all rollup levels higher than the current one to a temp table.</p>
<p><b>SAMPLE</b> </p><div class="fragment"><div class="line">SELECT <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, <a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, SUM(c) FROM t1 GROUP BY <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>,<a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a> WITH <a class="code" href="structst__rollup.html">ROLLUP</a></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Level we are on:<ul>
<li>0 = Total sum level</li>
<li>1 = First group changed (a)</li>
<li>2 = Second group changed (a,b) </li>
</ul>
</td></tr>
    <tr><td class="paramname">table</td><td>reference to temp table</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>if write_data_failed() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35e846cbf96ca9e10788fa16c304daa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35e846cbf96ca9e10788fa16c304daa6">&#9670;&nbsp;</a></span>save_const_null_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void save_const_null_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map *&#160;</td>
          <td class="paramname"><em>save_nullinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save NULL-row info for constant tables. Used in conjunction with <a class="el" href="group___query___executor.html#gaa9cc73c7dafc88f011d4fb70a3908436">restore_const_null_info()</a> to restore constant table null_row and status values after temporarily marking rows as NULL. This is only done for const tables in subqueries because these values are not recalculated on next execution of the subquery.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>The join for which const tables are about to be marked as containing only NULL values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">save_nullinfo</td><td>Const tables that have null_row=false and STATUS_NULL_ROW set are tagged in this table_map so that the value can be restored by <a class="el" href="group___query___executor.html#gaa9cc73c7dafc88f011d4fb70a3908436">restore_const_null_info()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>mark_as_null_row </dd>
<dd>
<a class="el" href="group___query___executor.html#gaa9cc73c7dafc88f011d4fb70a3908436">restore_const_null_info</a> </dd></dl>

</div>
</div>
<a id="gabf6f9870d5d7d18698a9fed0295393f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf6f9870d5d7d18698a9fed0295393f4">&#9670;&nbsp;</a></span>setup_copy_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setup_copy_fields </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMP_TABLE_PARAM *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_selected_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup copy_fields to save fields at start of new group.</p>
<p>Setup copy_fields to save fields at start of new group</p>
<p>Only FIELD_ITEM:s and FUNC_ITEM:s needs to be saved between groups. Change old item_field to use a new field with points at saved fieldvalue This function is only called before use of send_result_set_metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">param</td><td>temporary table parameters </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramname">res_selected_fields</td><td>new list of items of select item list </td></tr>
    <tr><td class="paramname">res_all_fields</td><td>new list of all items </td></tr>
    <tr><td class="paramname">elements</td><td>number of elements in select item list </td></tr>
    <tr><td class="paramname">all_fields</td><td>all fields list</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000091">Todo:</a></b></dt><dd>In most cases this result will be sent to the user. This should be changed to use copy_int or copy_real depending on how the value is to be used: In some cases this may be an argument in a group function, like: IF(ISNULL(col),0,COUNT(*))</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">!=0</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19817b01781d428b21cf4c3a3f42467b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19817b01781d428b21cf4c3a3f42467b">&#9670;&nbsp;</a></span>setup_end_select_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Next_select_func setup_end_select_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rows produced by a join sweep may end up in a temporary table or be sent to a client. Setup the function of the nested loop join algorithm which handles final fully constructed and matched records.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>join to setup the function for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end_select function to use. This function can't fail. </dd></dl>

</div>
</div>
<a id="ga1b1125b75ed00a408f039bb83de7c480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1125b75ed00a408f039bb83de7c480">&#9670;&nbsp;</a></span>setup_sum_funcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setup_sum_funcs </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call ::setup for all sum functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">func_ptr</td><td>sum function list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>ok </td></tr>
    <tr><td class="paramname">TRUE</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25deeac7a2e0e4cd9623bfcf539e44f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25deeac7a2e0e4cd9623bfcf539e44f7">&#9670;&nbsp;</a></span>setup_tmptable_write_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setup_tmptable_write_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup write_func of <a class="el" href="class_q_e_p__tmp__table.html" title="Class for accumulating join result in a tmp table, grouping them if necessary, and sending further...">QEP_tmp_table</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_tab</td><td>JOIN_TAB of a tmp table</td></tr>
  </table>
  </dd>
</dl>
<p>Function sets up write_func according to how <a class="el" href="class_q_e_p__tmp__table.html" title="Class for accumulating join result in a tmp table, grouping them if necessary, and sending further...">QEP_tmp_table</a> object that is attached to the given join_tab will be used in the query. </p>

</div>
</div>
<a id="gaf5c3a10fb1e79511b38573124e0ec107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5c3a10fb1e79511b38573124e0ec107">&#9670;&nbsp;</a></span>sub_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state sub_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end_of_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve records ends with a given beginning from the result of a join.</p>
<p>SYNPOSIS <a class="el" href="group___query___executor.html#gaf5c3a10fb1e79511b38573124e0ec107">sub_select()</a> join pointer to the structure providing all context info for the query join_tab the first next table of the execution plan to be retrieved end_records true when we need to perform final steps of retrival</p>
<p>DESCRIPTION For a given partial join record consisting of records from the tables preceding the table join_tab in the execution plan, the function retrieves all matching full records from the result set and send them to the result set stream.</p>
<dl class="section note"><dt>Note</dt><dd>The function effectively implements the final (n-k) nested loops of nested loops join algorithm, where k is the ordinal number of the join_tab table and n is the total number of tables in the join query. It performs nested loops joins with all conjunctive predicates from the where condition pushed as low to the tables as possible. E.g. for the query <div class="fragment"><div class="line">SELECT * FROM t1,t2,t3</div><div class="line">WHERE t1.a=t2.a AND t2.b=t3.b AND t1.a BETWEEN 5 AND 9</div></div><!-- fragment --> the predicate (t1.a BETWEEN 5 AND 9) will be pushed to table t1, given the selected plan prescribes to nest retrievals of the joined tables in the following order: t1,t2,t3. A pushed down predicate are attached to the table which it pushed to, at the field join_tab-&gt;cond. When executing a nested loop of level k the function runs through the rows of 'join_tab' and for each row checks the pushed condition attached to the table. If it is false the function moves to the next row of the table. If the condition is true the function recursively executes (n-k-1) remaining embedded nested loops. The situation becomes more complicated if outer joins are involved in the execution plan. In this case the pushed down predicates can be checked only at certain conditions. Suppose for the query <div class="fragment"><div class="line">SELECT * FROM t1 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> (t2,t3) ON t3.a=t1.a</div><div class="line">WHERE t1&gt;2 AND (t2.b&gt;5 OR t2.b IS NULL)</div></div><!-- fragment --> the optimizer has chosen a plan with the table order t1,t2,t3. The predicate P1=t1&gt;2 will be pushed down to the table t1, while the predicate P2=(t2.b&gt;5 OR t2.b IS NULL) will be attached to the table t2. But the second predicate can not be unconditionally tested right after a row from t2 has been read. This can be done only after the first row with t3.a=t1.a has been encountered. Thus, the second predicate P2 is supplied with a guarded value that are stored in the field 'found' of the first inner table for the outer join (table t2). When the first row with t3.a=t1.a for the current row of table t1 appears, the value becomes true. For now on the predicate is evaluated immediately after the row of table t2 has been read. When the first row with t3.a=t1.a has been encountered all conditions attached to the inner tables t2,t3 must be evaluated. Only when all of them are true the row is sent to the output stream. If not, the function returns to the lowest nest level that has a false attached condition. The predicates from on expressions are also pushed down. If in the the above example the on expression were (t3.a=t1.a AND t2.a=t1.a), then t1.a=t2.a would be pushed down to table t2, and without any guard. If after the run through all rows of table t2, the first inner table for the outer join operation, it turns out that no matches are found for the current row of t1, then current row from table t1 is complemented by nulls for t2 and t3. Then the pushed down predicates are checked for the composed row almost in the same way as it had been done for the first row with a match. The only difference is the predicates from on expressions are not checked.</dd></dl>
<dl class="section user"><dt></dt><dd><b>IMPLEMENTATION</b> </dd></dl>
<dl class="section user"><dt></dt><dd>The function forms output rows for a current partial join of k tables tables recursively. For each partial join record ending with a certain row from join_tab it calls sub_select that builds all possible matching tails from the result set. To be able check predicates conditionally items of the class <a class="el" href="class_item__func__trig__cond.html">Item_func_trig_cond</a> are employed. An object of this class is constructed from an item of class COND and a pointer to a guarding boolean variable. When the value of the guard variable is true the value of the object is the same as the value of the predicate, otherwise it's just returns true. To carry out a return to a nested loop level of join table t the pointer to t is remembered in the field 'return_tab' of the join structure. Consider the following query: <div class="fragment"><div class="line">SELECT * FROM t1,</div><div class="line">              LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a></div><div class="line">              (t2, t3 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> (t4,t5) ON t5.a=t3.a)</div><div class="line">              ON t4.<a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>=t2.<a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a></div><div class="line">   WHERE (t2.<a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>=5 OR t2.<a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a> IS NULL) AND (t4.<a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>=2 OR t4.<a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a> IS NULL)</div></div><!-- fragment --> Suppose the chosen execution plan dictates the order t1,t2,t3,t4,t5 and suppose for a given joined rows from tables t1,t2,t3 there are no rows in the result set yet. When first row from t5 that satisfies the on condition t5.a=t3.a is found, the pushed down predicate t4.b=2 OR t4.b IS NULL becomes 'activated', as well the predicate t4.a=t2.a. But the predicate (t2.b=5 OR t2.b IS NULL) can not be checked until t4.a=t2.a becomes true. In order not to re-evaluate the predicates that were already evaluated as attached pushed down predicates, a pointer to the the first most inner unmatched table is maintained in join_tab-&gt;first_unmatched. Thus, when the first row from t5 with t5.a=t3.a is found this pointer for t5 is changed from t4 to t2.</dd></dl>
<dl class="section user"><dt></dt><dd><b>STRUCTURE</b> <b>NOTES</b> </dd></dl>
<dl class="section user"><dt></dt><dd>join_tab-&gt;first_unmatched points always backwards to the first inner table of the embedding nested join, if any.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>pointer to the structure providing all context info for the query </td></tr>
    <tr><td class="paramname">join_tab</td><td>the first next table of the execution plan to be retrieved </td></tr>
    <tr><td class="paramname">end_records</td><td>true when we need to perform final steps of retrival</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return one of enum_nested_loop_state, except NESTED_LOOP_NO_MORE_ROWS. </dd></dl>

</div>
</div>
<a id="gacb3f583dd255c4288df81b3ab1628a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb3f583dd255c4288df81b3ab1628a1c">&#9670;&nbsp;</a></span>sub_select_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state sub_select_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end_of_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate full or partial join result in operation and send operation's result further. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>pointer to the structure providing all context info for the query </td></tr>
    <tr><td class="paramname">join_tab</td><td>the JOIN_TAB object to which the operation is attached </td></tr>
    <tr><td class="paramname">end_records</td><td>TRUE &lt;=&gt; all records were accumulated, send them further</td></tr>
  </table>
  </dd>
</dl>
<p>This function accumulates records, one by one, in QEP operation's buffer by calling op-&gt;put_record(). When there is no more records to save, in this case the end_of_records argument == true, function tells QEP operation to send records further by calling op-&gt;send_records(). When all records are sent this function passes 'end_of_records' signal further by calling <a class="el" href="group___query___executor.html#gaf5c3a10fb1e79511b38573124e0ec107">sub_select()</a> with end_of_records argument set to true. After that op-&gt;end_send() is called to tell QEP operation that it could end internal buffer scan.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not expected to be called when dynamic range scan is used to scan join_tab because join cache is disabled for such scan and range scans aren't used for tmp tables. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#ga1510993d68f776aedbd40bc732b94fa6">setup_join_buffering</a> For caches the function implements the algorithmic schema for <a class="el" href="structboth.html">both</a> Blocked Nested Loop Join and Batched <a class="el" href="class_key.html">Key</a> Access Join. The difference can be seen only at the <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a> <a class="el" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a> <a class="el" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a> the implementation <a class="el" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a> the put_record and send_records virtual methods for the cache object associated with the join_tab.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>return one of enum_nested_loop_state. </dd></dl>

</div>
</div>
<a id="ga7b94786e3b5175f3dd15bc0497087656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b94786e3b5175f3dd15bc0497087656">&#9670;&nbsp;</a></span>update_const_equal_items()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void update_const_equal_items </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> appearance of new constant items in multiple equalities of a condition after reading a constant table.</p>
<p>The function retrieves the cond condition and for each encountered multiple equality checks whether new constants have appeared after reading the constant (single row) table tab. If so it adjusts the multiple equality appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition whose multiple equalities are to be checked </td></tr>
    <tr><td class="paramname">table</td><td>constant table that has been read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6407387234d462d4fb0c6495aa2f0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6407387234d462d4fb0c6495aa2f0c2">&#9670;&nbsp;</a></span>update_tmptable_sum_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void update_tmptable_sum_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *tmp_table &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update record 0 in tmp_table from record 1. </p>

</div>
</div>
<a id="ga0b95762423e8b4c050503ee51c2e2a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b95762423e8b4c050503ee51c2e2a0b">&#9670;&nbsp;</a></span>use_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_TAB::use_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use ordering provided by chosen index? </p>
<p><a class="el" href="struct_check.html">Check</a> if access to this JOIN_TAB has to retrieve rows in sorted order as defined by the ordered index used to access this table. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

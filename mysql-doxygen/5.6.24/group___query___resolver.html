<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Query Resolver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query Resolver</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga46b4b5249825247fe1b32577a836d586"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#ga46b4b5249825247fe1b32577a836d586">remove_redundant_subquery_clauses</a> (st_select_lex *subq_select_lex, int hidden_group_field_count, int hidden_order_field_count, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array)</td></tr>
<tr class="separator:ga46b4b5249825247fe1b32577a836d586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga580d372d00ee3b10ec64c30fe92aa97d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#ga580d372d00ee3b10ec64c30fe92aa97d">setup_without_group</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *leaves, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields, <a class="el" href="class_item.html">Item</a> **conds, <a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="structst__order.html">ORDER</a> *group, int *hidden_group_field_count, int *hidden_order_field_count)</td></tr>
<tr class="separator:ga580d372d00ee3b10ec64c30fe92aa97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62cce1652d3ee4d87cdc71ff4edb9a9f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#ga62cce1652d3ee4d87cdc71ff4edb9a9f">resolve_subquery</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="memdesc:ga62cce1652d3ee4d87cdc71ff4edb9a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve predicate involving subquery.  <a href="#ga62cce1652d3ee4d87cdc71ff4edb9a9f">More...</a><br /></td></tr>
<tr class="separator:ga62cce1652d3ee4d87cdc71ff4edb9a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf206c0aa90dedda87347e653c8a9d5d0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#gaf206c0aa90dedda87347e653c8a9d5d0">setup_group</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields, <a class="el" href="structst__order.html">ORDER</a> *order)</td></tr>
<tr class="separator:gaf206c0aa90dedda87347e653c8a9d5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c515aaae6c408b9d55fcda8748e4db"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#ga87c515aaae6c408b9d55fcda8748e4db">match_exprs_for_only_full_group_by</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields, int hidden_group_exprs_count, int hidden_order_exprs_count, int select_exprs_count, <a class="el" href="structst__order.html">ORDER</a> *group_exprs)</td></tr>
<tr class="separator:ga87c515aaae6c408b9d55fcda8748e4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67ba0f5092d8f16edd545f8685a5f104"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#ga67ba0f5092d8f16edd545f8685a5f104">subquery_allows_materialization</a> (<a class="el" href="class_item__in__subselect.html">Item_in_subselect</a> *predicate, THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, SELECT_LEX *select_lex, const SELECT_LEX *outer)</td></tr>
<tr class="separator:ga67ba0f5092d8f16edd545f8685a5f104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8efadaea0e39c5487dfa00c1889b64dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#ga8efadaea0e39c5487dfa00c1889b64dd">fix_inner_refs</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields, SELECT_LEX *select, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="structst__order.html">ORDER</a> *group_list)</td></tr>
<tr class="separator:ga8efadaea0e39c5487dfa00c1889b64dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga543a285242f0a1c047e6884d1f713479"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#ga543a285242f0a1c047e6884d1f713479">find_order_in_list</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields, bool is_group_field)</td></tr>
<tr class="separator:ga543a285242f0a1c047e6884d1f713479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf52ba7120a7da386110998428ef6121c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#gaf52ba7120a7da386110998428ef6121c">setup_order</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields, <a class="el" href="structst__order.html">ORDER</a> *order)</td></tr>
<tr class="separator:gaf52ba7120a7da386110998428ef6121c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b65d5d2bec2545a151691d14378e118"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#ga6b65d5d2bec2545a151691d14378e118">change_group_ref</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item__func.html">Item_func</a> *expr, <a class="el" href="structst__order.html">ORDER</a> *group_list, bool *changed)</td></tr>
<tr class="separator:ga6b65d5d2bec2545a151691d14378e118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5eeef6eb5eed0d15c62f22b467f0c96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a> (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="class_j_o_i_n.html#a38273ba29a6c872841db203f65c0ce33">tables</a>, uint wind_num, <a class="el" href="class_item.html">Item</a> *<a class="el" href="class_j_o_i_n.html#a368ace8fab21583b97940d04473ee399">conds</a>, uint og_num, <a class="el" href="structst__order.html">ORDER</a> *<a class="el" href="class_j_o_i_n.html#ac06839682aae707b0e1d4fafd53abaf5">order</a>, <a class="el" href="structst__order.html">ORDER</a> *<a class="el" href="class_j_o_i_n.html#a3d04edb6e40db1022f30b8a74a154c97">group</a>, <a class="el" href="class_item.html">Item</a> *<a class="el" href="class_j_o_i_n.html#aa1a060e071f054d56be87c902addda91">having</a>, SELECT_LEX *select, SELECT_LEX_UNIT *<a class="el" href="class_j_o_i_n.html#aaf0707e5829e786c1080e3d2b3262835">unit</a>)</td></tr>
<tr class="separator:gad5eeef6eb5eed0d15c62f22b467f0c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga202f3b879a62721957f49b1e20fda8ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___resolver.html#ga202f3b879a62721957f49b1e20fda8ca">JOIN::rollup_init</a> ()</td></tr>
<tr class="separator:ga202f3b879a62721957f49b1e20fda8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6b65d5d2bec2545a151691d14378e118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b65d5d2bec2545a151691d14378e118">&#9670;&nbsp;</a></span>change_group_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool change_group_ref </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>changed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace occurences of group by fields in an expression by ref items.</p>
<p>The function replaces occurrences of group by fields in expr by ref objects for these fields unless they are under aggregate functions. The function also corrects value of the the maybe_null attribute for the items of all subexpressions containing group by fields.</p>
<p><b>EXAMPLES</b> </p><div class="fragment"><div class="line">SELECT <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>+1 FROM t1 GROUP BY <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a> WITH <a class="code" href="structst__rollup.html">ROLLUP</a></div><div class="line">SELECT SUM(<a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>)+<a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a> FROM t1 GROUP BY <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a> WITH <a class="code" href="structst__rollup.html">ROLLUP</a> </div></div><!-- fragment --><p><b>IMPLEMENTATION</b> </p>
<p>The function recursively traverses the tree of the expr expression, looks for occurrences of the group by fields that are not under aggregate functions and replaces them for the corresponding ref items.</p>
<dl class="section note"><dt>Note</dt><dd>This substitution is needed GROUP BY queries with ROLLUP if SELECT list contains expressions over group by attributes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>reference to the context </td></tr>
    <tr><td class="paramname">expr</td><td>expression to make replacement </td></tr>
    <tr><td class="paramname">group_list</td><td>list of references to group by items </td></tr>
    <tr><td class="paramname">changed</td><td>out: returns 1 if item contains a replaced field item</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000116">Todo:</a></b></dt><dd><ul>
<li>TODO: Some functions are not null-preserving. For those functions updating of the maybe_null attribute is an overkill. </li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ok </td></tr>
    <tr><td class="paramname">1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga543a285242f0a1c047e6884d1f713479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga543a285242f0a1c047e6884d1f713479">&#9670;&nbsp;</a></span>find_order_in_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool find_order_in_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_group_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resolve an ORDER BY or GROUP BY column reference.</p>
<p>Given a column reference (represented by 'order') from a GROUP BY or ORDER BY clause, find the actual column it represents. If the column being resolved is from the GROUP BY clause, the procedure searches the SELECT list 'fields' and the columns in the FROM list 'tables'. If 'order' is from the ORDER BY clause, only the SELECT list is being searched.</p>
<p>If 'order' is resolved to an <a class="el" href="class_item.html">Item</a>, then order-&gt;item is set to the found <a class="el" href="class_item.html">Item</a>. If there is no item for the found column (that is, it was resolved into a table field), order-&gt;item is 'fixed' and is added to all_fields and ref_pointer_array.</p>
<p>ref_pointer_array and all_fields are updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Pointer to current thread structure </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ref_pointer_array</td><td>All select, group and order by fields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tables</td><td><a class="el" href="class_list.html">List</a> of tables to search in (usually FROM clause) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Column reference to be resolved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fields</td><td><a class="el" href="class_list.html">List</a> of fields to search in (usually SELECT list) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">all_fields</td><td>All select, group and order by fields </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_group_field</td><td>True if order is a GROUP field, false if ORDER by field</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>if OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>if error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8efadaea0e39c5487dfa00c1889b64dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8efadaea0e39c5487dfa00c1889b64dd">&#9670;&nbsp;</a></span>fix_inner_refs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fix_inner_refs </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fix fields referenced from inner selects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">all_fields</td><td><a class="el" href="class_list.html">List</a> of all fields used in select </td></tr>
    <tr><td class="paramname">select</td><td>Current select </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>Array of references to Items used in current select </td></tr>
    <tr><td class="paramname">group_list</td><td>GROUP BY list (is NULL by default)</td></tr>
  </table>
  </dd>
</dl>
<p>The function serves 3 purposes</p>
<ul>
<li>adds fields referenced from inner query blocks to the current select list</li>
<li>Decides which class to use to reference the items (<a class="el" href="class_item__ref.html">Item_ref</a> or <a class="el" href="class_item__direct__ref.html">Item_direct_ref</a>)</li>
<li>fixes references (<a class="el" href="class_item__ref.html">Item_ref</a> objects) to these fields.</li>
</ul>
<p>If a field isn't already on the select list and the ref_pointer_array is provided then it is added to the all_fields list and the pointer to it is saved in the ref_pointer_array.</p>
<p>The class to access the outer field is determined by the following rules:</p>
<p>-#. If the outer field isn't used under an aggregate function then the <a class="el" href="class_item__ref.html">Item_ref</a> class should be used.</p>
<p>-#. If the outer field is used under an aggregate function and this function is, in turn, aggregated in the query block where the outer field was resolved or some query nested therein, then the <a class="el" href="class_item__direct__ref.html">Item_direct_ref</a> class should be used. Also it should be used if we are grouping by a subquery containing the outer field.</p>
<p>The resolution is done here and not at the fix_fields() stage as it can be done only after aggregate functions are fixed and pulled up to selects where they are to be aggregated.</p>
<p>When the class is chosen it substitutes the original field in the <a class="el" href="class_item__outer__ref.html">Item_outer_ref</a> object.</p>
<p>After this we proceed with fixing references (<a class="el" href="class_item__outer__ref.html">Item_outer_ref</a> objects) to this field from inner subqueries.</p>
<dl class="section return"><dt>Returns</dt><dd>Status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>An error occured. </td></tr>
    <tr><td class="paramname">false</td><td>OK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87c515aaae6c408b9d55fcda8748e4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87c515aaae6c408b9d55fcda8748e4db">&#9670;&nbsp;</a></span>match_exprs_for_only_full_group_by()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool match_exprs_for_only_full_group_by </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hidden_group_exprs_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hidden_order_exprs_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>select_exprs_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group_exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scans the SELECT list and ORDER BY list: for each expression, if it is not present in GROUP BY, examines the non-aggregated columns contained in the expression; if those columns are not all in GROUP BY, raise an error.</p>
<p>Examples: 1) "SELECT a+1 FROM t GROUP BY a+1" "a+1" in SELECT list was found, by <a class="el" href="group___query___resolver.html#gaf206c0aa90dedda87347e653c8a9d5d0">setup_group()</a> (exactly <a class="el" href="group___query___resolver.html#ga543a285242f0a1c047e6884d1f713479">find_order_in_list()</a>), to be the same as "a+1" in GROUP BY; as it is a GROUP BY expression, <a class="el" href="group___query___resolver.html#gaf206c0aa90dedda87347e653c8a9d5d0">setup_group()</a> has marked this expression with ALL_FIELDS_UNDEF_POS (item-&gt;marker= ALL_FIELDS_UNDEF_POS). 2) "SELECT a+1 FROM t GROUP BY a" "a+1" is not found in GROUP BY; its non-aggregated column is "a", "a" is present in GROUP BY so it's ok.</p>
<p>A "hidden" GROUP BY / ORDER BY expression is a member of GROUP BY / ORDER BY which was not found (by <a class="el" href="group___query___resolver.html#gaf52ba7120a7da386110998428ef6121c">setup_order()</a> or <a class="el" href="group___query___resolver.html#gaf206c0aa90dedda87347e653c8a9d5d0">setup_group()</a>) to be also present in the SELECT list. <a class="el" href="group___query___resolver.html#gaf52ba7120a7da386110998428ef6121c">setup_order()</a> and <a class="el" href="group___query___resolver.html#gaf206c0aa90dedda87347e653c8a9d5d0">setup_group()</a> have thus added the expression to the front of <a class="el" href="class_j_o_i_n.html#abc71e8a6e6c7fa4db00cde12ba20f654">JOIN::all_fields</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">all_fields</td><td>list of expressions, including SELECT list and hidden ORDER BY expressions </td></tr>
    <tr><td class="paramname">hidden_group_exprs_count</td><td>number of hidden GROUP BY expressions </td></tr>
    <tr><td class="paramname">hidden_order_exprs_count</td><td>number of hidden ORDER BY expressions </td></tr>
    <tr><td class="paramname">select_exprs_count</td><td>number of SELECT list expressions (there may be a gap between hidden GROUP BY expressions and SELECT list expressions) </td></tr>
    <tr><td class="paramname">group_exprs</td><td>GROUP BY expressions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if ONLY_FULL_GROUP_BY is violated. </dd></dl>

</div>
</div>
<a id="gad5eeef6eb5eed0d15c62f22b467f0c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5eeef6eb5eed0d15c62f22b467f0c96">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN::prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>wild_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>og_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>having_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX_UNIT *&#160;</td>
          <td class="paramname"><em>unit_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare of whole select (including sub queries in future).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000113">Todo:</a></b></dt><dd>Add check of calculation of GROUP functions and fields: SELECT COUNT(*)+table.col1 from table1;</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>on error </td></tr>
    <tr><td class="paramname">0</td><td>on success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46b4b5249825247fe1b32577a836d586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46b4b5249825247fe1b32577a836d586">&#9670;&nbsp;</a></span>remove_redundant_subquery_clauses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void remove_redundant_subquery_clauses </td>
          <td>(</td>
          <td class="paramtype">st_select_lex *&#160;</td>
          <td class="paramname"><em>subq_select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hidden_group_field_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hidden_order_field_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Since LIMIT is not supported for table subquery predicates (IN/ALL/EXISTS/etc), the following clauses are redundant for subqueries:</p>
<p>ORDER BY DISTINCT GROUP BY if there are no aggregate functions and no HAVING clause</p>
<p>Because redundant clauses are removed both from <a class="el" href="class_j_o_i_n.html">JOIN</a> and select_lex, the removal is permanent. Thus, it only makes sense to call this function for normal queries and on first execution of SP/PS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subq_select_lex</td><td>select_lex that is part of a subquery predicate. This object and the associated join is modified. </td></tr>
    <tr><td class="paramname">hidden_group_field_count</td><td>Number of hidden group fields added by <a class="el" href="group___query___resolver.html#gaf206c0aa90dedda87347e653c8a9d5d0">setup_group()</a>. </td></tr>
    <tr><td class="paramname">hidden_order_field_count</td><td>Number of hidden order fields added by <a class="el" href="group___query___resolver.html#gaf52ba7120a7da386110998428ef6121c">setup_order()</a>. </td></tr>
    <tr><td class="paramname">fields</td><td>Fields list from which to remove items. </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>Pointers to top level of all_fields. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62cce1652d3ee4d87cdc71ff4edb9a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62cce1652d3ee4d87cdc71ff4edb9a9f">&#9670;&nbsp;</a></span>resolve_subquery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool resolve_subquery </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve predicate involving subquery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to THD. </td></tr>
    <tr><td class="paramname">join</td><td>Join that is part of a subquery predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error.</td></tr>
  </table>
  </dd>
</dl>
<p>Perform early unconditional subquery transformations:</p><ul>
<li>Convert subquery predicate into semi-join, or</li>
<li>Mark the subquery for execution using materialization, or</li>
<li>Perform IN-&gt;EXISTS transformation, or</li>
<li>Perform more/less ALL/ANY -&gt; MIN/MAX rewrite</li>
<li>Substitute trivial scalar-context subquery with its value</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000114">Todo:</a></b></dt><dd>for PS, make the whole block execute only on the first execution</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In this case: IN (SELECT ... UNION SELECT ...), <a class="el" href="group___query___resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare()</a> is called for each of the two UNION members, and in those two calls, subq_predicate is the same, not sure this is desired (double work?).</dd></dl>

</div>
</div>
<a id="ga202f3b879a62721957f49b1e20fda8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga202f3b879a62721957f49b1e20fda8ca">&#9670;&nbsp;</a></span>rollup_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::rollup_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate memory needed for other rollup functions. </p>

</div>
</div>
<a id="gaf206c0aa90dedda87347e653c8a9d5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf206c0aa90dedda87347e653c8a9d5d0">&#9670;&nbsp;</a></span>setup_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int setup_group </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize the GROUP BY list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>We store references to all fields that was not in 'fields' here. </td></tr>
    <tr><td class="paramname">fields</td><td>All fields in the select part. Any item in 'order' that is part of these list is replaced by a pointer to this fields. </td></tr>
    <tr><td class="paramname">all_fields</td><td>Total list of all unique fields used by the select. All items in 'order' that was not part of fields will be added first to this list. </td></tr>
    <tr><td class="paramname">order</td><td>The fields we should do GROUP BY on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000115">Todo:</a></b></dt><dd>change ER_WRONG_FIELD_WITH_GROUP to more detailed ER_NON_GROUPING_FIELD_USED</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error (probably out of memory) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf52ba7120a7da386110998428ef6121c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf52ba7120a7da386110998428ef6121c">&#9670;&nbsp;</a></span>setup_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setup_order </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change order to point at item in select list.</p>
<p>If item isn't a number and doesn't exists in the select list, add it to the the field list. </p>

</div>
</div>
<a id="ga580d372d00ee3b10ec64c30fe92aa97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga580d372d00ee3b10ec64c30fe92aa97d">&#9670;&nbsp;</a></span>setup_without_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int setup_without_group </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> **&#160;</td>
          <td class="paramname"><em>conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>hidden_group_field_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>hidden_order_field_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to setup clauses without sum functions. </p>

</div>
</div>
<a id="ga67ba0f5092d8f16edd545f8685a5f104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67ba0f5092d8f16edd545f8685a5f104">&#9670;&nbsp;</a></span>subquery_allows_materialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool subquery_allows_materialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item__in__subselect.html">Item_in_subselect</a> *&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SELECT_LEX *&#160;</td>
          <td class="paramname"><em>outer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if the subquery predicate can be executed via materialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>IN subquery predicate </td></tr>
    <tr><td class="paramname">thd</td><td>THD </td></tr>
    <tr><td class="paramname">select_lex</td><td>SELECT_LEX of the subquery </td></tr>
    <tr><td class="paramname">outer</td><td>Parent SELECT_LEX (outer to subquery)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if subquery allows materialization, FALSE otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

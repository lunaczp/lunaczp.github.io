<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/ibuf0ibuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ibuf0ibuf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0mtr_8h_source.html">mtr0mtr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0fsp_8h_source.html">fsp0fsp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0types_8h_source.html">ibuf0types.h</a>&quot;</code><br />
<code>#include &quot;ibuf0ibuf.ic&quot;</code><br />
</div>
<p><a href="ibuf0ibuf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a091d43d6f84f6018b0f1b47ca0455e6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a091d43d6f84f6018b0f1b47ca0455e6b">CHANGE_BUFFER_DEFAULT_SIZE</a>&#160;&#160;&#160;(25)</td></tr>
<tr class="separator:a091d43d6f84f6018b0f1b47ca0455e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a3c533e35abdae6ab73f3661bf2c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a4c5a3c533e35abdae6ab73f3661bf2c9">ibuf_page</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>,  <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>,  <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>,  <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8h.html#ae0b4502fef62d91fd89dc5dd7c9cebc0">ibuf_page_low</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, __FILE__, __LINE__, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a4c5a3c533e35abdae6ab73f3661bf2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483a1eff3eb521dc9033560960200d98"><td class="memItemLeft" align="right" valign="top"><a id="a483a1eff3eb521dc9033560960200d98"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_HEADER_PAGE_NO</b>&#160;&#160;&#160;FSP_IBUF_HEADER_PAGE_NO</td></tr>
<tr class="separator:a483a1eff3eb521dc9033560960200d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f5285b3806532f70b99ead8bc59b80"><td class="memItemLeft" align="right" valign="top"><a id="aa8f5285b3806532f70b99ead8bc59b80"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_TREE_ROOT_PAGE_NO</b>&#160;&#160;&#160;FSP_IBUF_TREE_ROOT_PAGE_NO</td></tr>
<tr class="separator:aa8f5285b3806532f70b99ead8bc59b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dd04e35feeda223aae6b90d30aac6a"><td class="memItemLeft" align="right" valign="top"><a id="a89dd04e35feeda223aae6b90d30aac6a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_HEADER</b>&#160;&#160;&#160;PAGE_DATA</td></tr>
<tr class="separator:a89dd04e35feeda223aae6b90d30aac6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5bce87ad79cc64bf9c669854fd3f8d"><td class="memItemLeft" align="right" valign="top"><a id="a3f5bce87ad79cc64bf9c669854fd3f8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_TREE_SEG_HEADER</b>&#160;&#160;&#160;0	/* fseg <a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a> for <a class="el" href="ibuf0ibuf_8h.html#acc138f660c81dccfb4179744e640a50d">ibuf</a> tree */</td></tr>
<tr class="separator:a3f5bce87ad79cc64bf9c669854fd3f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aaeb6f2184c3557450c6a11474c3b6"><td class="memItemLeft" align="right" valign="top"><a id="ab5aaeb6f2184c3557450c6a11474c3b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_SPACE_ID</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ab5aaeb6f2184c3557450c6a11474c3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae8116a402f0f6229af7671129bfab686"><td class="memItemLeft" align="right" valign="top"><a id="ae8116a402f0f6229af7671129bfab686"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ibuf_op_t</b> { <b>IBUF_OP_INSERT</b> = 0, 
<b>IBUF_OP_DELETE_MARK</b> = 1, 
<b>IBUF_OP_DELETE</b> = 2, 
<b>IBUF_OP_COUNT</b> = 3
 }</td></tr>
<tr class="separator:ae8116a402f0f6229af7671129bfab686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee299ba777e430d36fe90fd2ecb54e0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0">ibuf_use_t</a> { <br />
&#160;&#160;<b>IBUF_USE_NONE</b> = 0, 
<b>IBUF_USE_INSERT</b>, 
<b>IBUF_USE_DELETE_MARK</b>, 
<b>IBUF_USE_INSERT_DELETE_MARK</b>, 
<br />
&#160;&#160;<b>IBUF_USE_DELETE</b>, 
<b>IBUF_USE_ALL</b>, 
<b>IBUF_USE_COUNT</b>
<br />
 }</td></tr>
<tr class="separator:aaee299ba777e430d36fe90fd2ecb54e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0f026a0cad6ac211baac812ed0ad6924"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a0f026a0cad6ac211baac812ed0ad6924">ibuf_init_at_db_start</a> (void)</td></tr>
<tr class="separator:a0f026a0cad6ac211baac812ed0ad6924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf12932ee35e8653752790ee3ae5141"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#aebf12932ee35e8653752790ee3ae5141">ibuf_max_size_update</a> (ulint new_val)</td></tr>
<tr class="separator:aebf12932ee35e8653752790ee3ae5141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef509cb3f972ec513b2e072cebc36cd0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#aef509cb3f972ec513b2e072cebc36cd0">ibuf_update_max_tablespace_id</a> (void)</td></tr>
<tr class="separator:aef509cb3f972ec513b2e072cebc36cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0878c04a73b9573382d4bce4cdb8ab6f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a0878c04a73b9573382d4bce4cdb8ab6f">ibuf_mtr_start</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a0878c04a73b9573382d4bce4cdb8ab6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b48c1b32049e52bff5ebd11f1a1bb6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a47b48c1b32049e52bff5ebd11f1a1bb6">ibuf_mtr_commit</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a47b48c1b32049e52bff5ebd11f1a1bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47a4b2eeba24112529f97c8454c5a7c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ad47a4b2eeba24112529f97c8454c5a7c">ibuf_bitmap_page_init</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ad47a4b2eeba24112529f97c8454c5a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fa1ac9abb6d51ec99ac39e3b9378d4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:ac0fa1ac9abb6d51ec99ac39e3b9378d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9b8d6c6a893191b914c6193faadcc0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a7c9b8d6c6a893191b914c6193faadcc0">ibuf_update_free_bits_if_full</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint max_ins_size, ulint increase)</td></tr>
<tr class="separator:a7c9b8d6c6a893191b914c6193faadcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6b74d1c85f5de973847a75a11192a8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a2e6b74d1c85f5de973847a75a11192a8">ibuf_update_free_bits_low</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint max_ins_size, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a2e6b74d1c85f5de973847a75a11192a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a420088ad2008b7d667fa430c044273"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a1a420088ad2008b7d667fa430c044273">ibuf_update_free_bits_zip</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a1a420088ad2008b7d667fa430c044273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bdbfd04d4c22d602d67d153b4424f3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a04bdbfd04d4c22d602d67d153b4424f3">ibuf_update_free_bits_for_two_pages_low</a> (ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block1, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block2, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a04bdbfd04d4c22d602d67d153b4424f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0369066ee09b5aff6c0f2670ce753ef5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a0369066ee09b5aff6c0f2670ce753ef5">ibuf_should_try</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint ignore_sec_unique)</td></tr>
<tr class="separator:a0369066ee09b5aff6c0f2670ce753ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b34ffd78ad961b81e7585f9e2d698da"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a2b34ffd78ad961b81e7585f9e2d698da">ibuf_inside</a> (const <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a2b34ffd78ad961b81e7585f9e2d698da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264f49b69a06c6b96a704bbbf79f4bac"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a264f49b69a06c6b96a704bbbf79f4bac">ibuf_bitmap_page</a> (ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a264f49b69a06c6b96a704bbbf79f4bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b4502fef62d91fd89dc5dd7c9cebc0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ae0b4502fef62d91fd89dc5dd7c9cebc0">ibuf_page_low</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result))</td></tr>
<tr class="separator:ae0b4502fef62d91fd89dc5dd7c9cebc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7477357b4685fcf1cf4ba5c45cdc33f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#af7477357b4685fcf1cf4ba5c45cdc33f">ibuf_free_excess_pages</a> (void)</td></tr>
<tr class="separator:af7477357b4685fcf1cf4ba5c45cdc33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab374ff907a9fca3935d9b8af22fc29"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#adab374ff907a9fca3935d9b8af22fc29">ibuf_insert</a> (ibuf_op_t <a class="el" href="ibuf0ibuf_8cc.html#a02d89caeb1f64de105ee1c3988799855">op</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:adab374ff907a9fca3935d9b8af22fc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3820e76d62e8fc272bac12e8e79bf0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a1d3820e76d62e8fc272bac12e8e79bf0">ibuf_merge_or_delete_for_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ibool update_ibuf_bitmap)</td></tr>
<tr class="separator:a1d3820e76d62e8fc272bac12e8e79bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0e59772dcccb8060cd281dd2b86f7e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a1d0e59772dcccb8060cd281dd2b86f7e">ibuf_delete_for_discarded_space</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>)</td></tr>
<tr class="separator:a1d0e59772dcccb8060cd281dd2b86f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5e4864f4d26ccde2f5fbdec64ae74f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a1d5e4864f4d26ccde2f5fbdec64ae74f">ibuf_contract_in_background</a> (table_id_t table_id, ibool full)</td></tr>
<tr class="separator:a1d5e4864f4d26ccde2f5fbdec64ae74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32ce92b83e50309a7d0733f392043a4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ab32ce92b83e50309a7d0733f392043a4">ibuf_parse_bitmap_init</a> (byte *ptr, byte *end_ptr, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ab32ce92b83e50309a7d0733f392043a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9105388eb09aaf0930146eeb58cd392d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a9105388eb09aaf0930146eeb58cd392d">ibuf_is_empty</a> (void)</td></tr>
<tr class="separator:a9105388eb09aaf0930146eeb58cd392d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1fe433b34b5033dd5aed08e83f3b9f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a4f1fe433b34b5033dd5aed08e83f3b9f">ibuf_print</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:a4f1fe433b34b5033dd5aed08e83f3b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4ab4c3e4f65b6776d5f0db44dcb6f9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a4c4ab4c3e4f65b6776d5f0db44dcb6f9">ibuf_rec_get_counter</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:a4c4ab4c3e4f65b6776d5f0db44dcb6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51c353e54046cab4436fefa4922b08e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ac51c353e54046cab4436fefa4922b08e">ibuf_close</a> (void)</td></tr>
<tr class="separator:ac51c353e54046cab4436fefa4922b08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17451e439b2b88b2e3f51b8b9f5c827e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a17451e439b2b88b2e3f51b8b9f5c827e">ibuf_check_bitmap_on_import</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, ulint space_id) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a17451e439b2b88b2e3f51b8b9f5c827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adbb87198861959d990f4ff15f902fda9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0">ibuf_use_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#adbb87198861959d990f4ff15f902fda9">ibuf_use</a></td></tr>
<tr class="separator:adbb87198861959d990f4ff15f902fda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc138f660c81dccfb4179744e640a50d"><td class="memItemLeft" align="right" valign="top">ibuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#acc138f660c81dccfb4179744e640a50d">ibuf</a></td></tr>
<tr class="separator:acc138f660c81dccfb4179744e640a50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759f782cc23b02df3f46ac7d81b50166"><td class="memItemLeft" align="right" valign="top"><a id="a759f782cc23b02df3f46ac7d81b50166"></a>
UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><b>pure</b></td></tr>
<tr class="separator:a759f782cc23b02df3f46ac7d81b50166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de1fa5a5c99bbc84b5678762a623cf3"><td class="memItemLeft" align="right" valign="top"><a id="a9de1fa5a5c99bbc84b5678762a623cf3"></a>
UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>warn_unused_result</b></td></tr>
<tr class="separator:a9de1fa5a5c99bbc84b5678762a623cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Insert buffer</p>
<p>Created 7/19/1997 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a091d43d6f84f6018b0f1b47ca0455e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091d43d6f84f6018b0f1b47ca0455e6b">&#9670;&nbsp;</a></span>CHANGE_BUFFER_DEFAULT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANGE_BUFFER_DEFAULT_SIZE&#160;&#160;&#160;(25)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default value for maximum on-disk size of change buffer in terms of percentage of the buffer pool. </p>

</div>
</div>
<a id="a4c5a3c533e35abdae6ab73f3661bf2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5a3c533e35abdae6ab73f3661bf2c9">&#9670;&nbsp;</a></span>ibuf_page</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_page</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8h.html#ae0b4502fef62d91fd89dc5dd7c9cebc0">ibuf_page_low</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, __FILE__, __LINE__, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a page is a level 2 or 3 page in the ibuf hierarchy of pages. Must not be called when recv_no_ibuf_operations==TRUE. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>tablespace identifier </td></tr>
    <tr><td class="paramname">zip_size</td><td>compressed page size in bytes, or 0 </td></tr>
    <tr><td class="paramname">page_no</td><td>page number </td></tr>
    <tr><td class="paramname">mtr</td><td>mini-transaction or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if level 2 or level 3 page </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aaee299ba777e430d36fe90fd2ecb54e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee299ba777e430d36fe90fd2ecb54e0">&#9670;&nbsp;</a></span>ibuf_use_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0">ibuf_use_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combinations of operations that can be buffered. Because the enum values are used for indexing innobase_change_buffering_values[], they should start at 0 and there should not be any gaps. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a264f49b69a06c6b96a704bbbf79f4bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264f49b69a06c6b96a704bbbf79f4bac">&#9670;&nbsp;</a></span>ibuf_bitmap_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool ibuf_bitmap_page </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a page address is an ibuf bitmap page (level 3 page) address. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if a bitmap page in: page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes; 0 for uncompressed pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad47a4b2eeba24112529f97c8454c5a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47a4b2eeba24112529f97c8454c5a7c">&#9670;&nbsp;</a></span>ibuf_bitmap_page_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_bitmap_page_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an ibuf bitmap page. in: mtr</p>
<p>Initializes an ibuf bitmap page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: bitmap page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17451e439b2b88b2e3f51b8b9f5c827e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17451e439b2b88b2e3f51b8b9f5c827e">&#9670;&nbsp;</a></span>ibuf_check_bitmap_on_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ibuf_check_bitmap_on_import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the insert buffer bitmaps on IMPORT TABLESPACE. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">space_id</td><td>in: tablespace identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac51c353e54046cab4436fefa4922b08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51c353e54046cab4436fefa4922b08e">&#9670;&nbsp;</a></span>ibuf_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes insert buffer and frees the data structures. </p>

</div>
</div>
<a id="a1d5e4864f4d26ccde2f5fbdec64ae74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5e4864f4d26ccde2f5fbdec64ae74f">&#9670;&nbsp;</a></span>ibuf_contract_in_background()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ibuf_contract_in_background </td>
          <td>(</td>
          <td class="paramtype">table_id_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contracts insert buffer trees by reading pages to the buffer pool. </p><dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined size in bytes of entries which will be merged from ibuf trees to the pages read, 0 if ibuf is empty in: TRUE if the caller wants to do a full contract based on PCT_IO(100). If FALSE then the size of contract batch is determined based on the current size of the ibuf tree.</dd></dl>
<p>Contracts insert buffer trees by reading pages to the buffer pool. </p><dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined size in bytes of entries which will be merged from ibuf trees to the pages read, 0 if ibuf is empty </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_id</td><td>in: if merge should be done only for a specific table, for all tables this should be 0 </td></tr>
    <tr><td class="paramname">full</td><td>in: TRUE if the caller wants to do a full contract based on PCT_IO(100). If FALSE then the size of contract batch is determined based on the current size of the ibuf tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d0e59772dcccb8060cd281dd2b86f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0e59772dcccb8060cd281dd2b86f7e">&#9670;&nbsp;</a></span>ibuf_delete_for_discarded_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_delete_for_discarded_space </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all entries in the insert buffer for a given space id. This is used in DISCARD TABLESPACE and IMPORT TABLESPACE. NOTE: this does not update the page free bitmaps in the space. The space will become CORRUPT when you call this function! in: space id</p>
<p>Deletes all entries in the insert buffer for a given space id. This is used in DISCARD TABLESPACE and IMPORT TABLESPACE. NOTE: this does not update the page free bitmaps in the space. The space will become CORRUPT when you call this function! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7477357b4685fcf1cf4ba5c45cdc33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7477357b4685fcf1cf4ba5c45cdc33f">&#9670;&nbsp;</a></span>ibuf_free_excess_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_free_excess_pages </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees excess pages from the ibuf free list. This function is called when an OS thread calls fsp services to allocate a new file segment, or a new page to a file segment, and the thread did not own the fsp latch before this call. </p>

</div>
</div>
<a id="a0f026a0cad6ac211baac812ed0ad6924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f026a0cad6ac211baac812ed0ad6924">&#9670;&nbsp;</a></span>ibuf_init_at_db_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_init_at_db_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the insert buffer data structure at a database startup.</p>
<p>Creates the insert buffer data structure at a database startup and initializes the data structures for the insert buffer. </p>

</div>
</div>
<a id="adab374ff907a9fca3935d9b8af22fc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab374ff907a9fca3935d9b8af22fc29">&#9670;&nbsp;</a></span>ibuf_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool ibuf_insert </td>
          <td>(</td>
          <td class="paramtype">ibuf_op_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer an operation in the insert/delete buffer, instead of doing it directly to the disk page, if this is possible. Does not do it if the index is clustered or unique. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success in: query thread</dd></dl>
<p>Buffer an operation in the insert/delete buffer, instead of doing it directly to the disk page, if this is possible. Does not do it if the index is clustered or unique. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>in: operation type </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry to insert </td></tr>
    <tr><td class="paramname">index</td><td>in: index where to insert </td></tr>
    <tr><td class="paramname">space</td><td>in: space id where to insert </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes, or 0 </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number where to insert </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b34ffd78ad961b81e7585f9e2d698da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b34ffd78ad961b81e7585f9e2d698da">&#9670;&nbsp;</a></span>ibuf_inside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool ibuf_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the current OS thread is performing an insert buffer routine.</p>
<p>For instance, a read-ahead of non-ibuf pages is forbidden by threads that are executing an insert buffer routine. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if inside an insert buffer routine </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9105388eb09aaf0930146eeb58cd392d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9105388eb09aaf0930146eeb58cd392d">&#9670;&nbsp;</a></span>ibuf_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool ibuf_is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks if the insert buffer is empty. </p><dl class="section return"><dt>Returns</dt><dd>true if empty </dd></dl>

</div>
</div>
<a id="aebf12932ee35e8653752790ee3ae5141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf12932ee35e8653752790ee3ae5141">&#9670;&nbsp;</a></span>ibuf_max_size_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_max_size_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>new_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the max_size value for ibuf. in: new value in terms of percentage of the buffer pool size</p>
<p>Updates the max_size value for ibuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_val</td><td>in: new value in terms of percentage of the buffer pool size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d3820e76d62e8fc272bac12e8e79bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3820e76d62e8fc272bac12e8e79bf0">&#9670;&nbsp;</a></span>ibuf_merge_or_delete_for_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_merge_or_delete_for_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>update_ibuf_bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When an index page is read from a disk to the buffer pool, this function applies any buffered operations to the page and deletes the entries from the insert buffer. If the page is not read, but created in the buffer pool, this function deletes its buffered entries from the insert buffer; there can exist entries for such a page if the page belonged to an index which subsequently was dropped. in: normally this is set to TRUE, but if we have deleted or are deleting the tablespace, then we naturally do not want to update a non-existent bitmap page</p>
<p>When an index page is read from a disk to the buffer pool, this function applies any buffered operations to the page and deletes the entries from the insert buffer. If the page is not read, but created in the buffer pool, this function deletes its buffered entries from the insert buffer; there can exist entries for such a page if the page belonged to an index which subsequently was dropped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: if page has been read from disk, pointer to the page x-latched, else NULL </td></tr>
    <tr><td class="paramname">space</td><td>in: space id of the index page </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number of the index page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes, or 0 </td></tr>
    <tr><td class="paramname">update_ibuf_bitmap</td><td>in: normally this is set to TRUE, but if we have deleted or are deleting the tablespace, then we naturally do not want to update a non-existent bitmap page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47b48c1b32049e52bff5ebd11f1a1bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b48c1b32049e52bff5ebd11f1a1bb6">&#9670;&nbsp;</a></span>ibuf_mtr_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_mtr_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commits an insert buffer mini-transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0878c04a73b9573382d4bce4cdb8ab6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0878c04a73b9573382d4bce4cdb8ab6f">&#9670;&nbsp;</a></span>ibuf_mtr_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_mtr_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts an insert buffer mini-transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0b4502fef62d91fd89dc5dd7c9cebc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b4502fef62d91fd89dc5dd7c9cebc0">&#9670;&nbsp;</a></span>ibuf_page_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool ibuf_page_low </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a page is a level 2 or 3 page in the ibuf hierarchy of pages. Must not be called when recv_no_ibuf_operations==TRUE. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if level 2 or level 3 page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes, or 0 </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr which will contain an x-latch to the bitmap page if the page is not one of the fixed address ibuf pages, or NULL, in which case a new transaction is created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab32ce92b83e50309a7d0733f392043a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32ce92b83e50309a7d0733f392043a4">&#9670;&nbsp;</a></span>ibuf_parse_bitmap_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* ibuf_parse_bitmap_init </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a redo log record of an ibuf bitmap page init. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL in: mtr or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">block</td><td>in: block or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f1fe433b34b5033dd5aed08e83f3b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1fe433b34b5033dd5aed08e83f3b9f">&#9670;&nbsp;</a></span>ibuf_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of ibuf. in: file where to print</p>
<p>Prints info of ibuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c4ab4c3e4f65b6776d5f0db44dcb6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4ab4c3e4f65b6776d5f0db44dcb6f9">&#9670;&nbsp;</a></span>ibuf_rec_get_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ibuf_rec_get_counter </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: ibuf record</p>
<p>Read the first two bytes from a record's fourth field (counter field in new records; something else in older records). </p><dl class="section return"><dt>Returns</dt><dd>"counter" field, or ULINT_UNDEFINED if for some reason it can't be read </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: ibuf record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0fa1ac9abb6d51ec99ac39e3b9378d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fa1ac9abb6d51ec99ac39e3b9378d4">&#9670;&nbsp;</a></span>ibuf_reset_free_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_reset_free_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the free bits of the page in the ibuf bitmap. This is done in a separate mini-transaction, hence this operation does not restrict further work to only ibuf bitmap operations, which would result if the latch to the bitmap page were kept. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to decrement or reset the bits in the bitmap in a mini-transaction that is committed before the mini-transaction that affects the free space. in: index page; free bits are set to 0 if the index is a non-clustered non-unique, and page level is 0</p>
<p>Resets the free bits of the page in the ibuf bitmap. This is done in a separate mini-transaction, hence this operation does not restrict further work to only ibuf bitmap operations, which would result if the latch to the bitmap page were kept. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to decrement or reset the bits in the bitmap in a mini-transaction that is committed before the mini-transaction that affects the free space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page; free bits are set to 0 if the index is a non-clustered non-unique, and page level is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0369066ee09b5aff6c0f2670ce753ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0369066ee09b5aff6c0f2670ce753ef5">&#9670;&nbsp;</a></span>ibuf_should_try()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool ibuf_should_try </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>ignore_sec_unique</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A basic partial test if an insert to the insert buffer could be possible and recommended. in: if != 0, we should ignore UNIQUE constraint on a secondary index when we decide </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index where to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04bdbfd04d4c22d602d67d153b4424f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bdbfd04d4c22d602d67d153b4424f3">&#9670;&nbsp;</a></span>ibuf_update_free_bits_for_two_pages_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_update_free_bits_for_two_pages_low </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the free bits for the two pages to reflect the present state. Does this in the mtr given, which means that the latching order rules virtually prevent any further operations until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the pages. in: mtr</p>
<p>Updates the free bits for the two pages to reflect the present state. Does this in the mtr given, which means that the latching order rules virtually prevent any further operations until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes; 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">block1</td><td>in: index page </td></tr>
    <tr><td class="paramname">block2</td><td>in: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c9b8d6c6a893191b914c6193faadcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9b8d6c6a893191b914c6193faadcc0">&#9670;&nbsp;</a></span>ibuf_update_free_bits_if_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_update_free_bits_if_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_ins_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>increase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the free bits of an uncompressed page in the ibuf bitmap if there is not enough free on the page any more. This is done in a separate mini-transaction, hence this operation does not restrict further work to only ibuf bitmap operations, which would result if the latch to the bitmap page were kept. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is unsafe to increment the bits in a separately committed mini-transaction, because in crash recovery, the free bits could momentarily be set too high. It is only safe to use this function for decrementing the free bits. Should more free space become available, we must not update the free bits here, because that would break crash recovery. in: upper limit for the additional space used in the latest operation, if known, or ULINT_UNDEFINED </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page to which we have added new records; the free bits are updated if the index is non-clustered and non-unique and the page level is 0, and the page becomes fuller </td></tr>
    <tr><td class="paramname">max_ins_size</td><td>in: value of maximum insert size with reorganize before the latest operation performed to the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e6b74d1c85f5de973847a75a11192a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6b74d1c85f5de973847a75a11192a8">&#9670;&nbsp;</a></span>ibuf_update_free_bits_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_update_free_bits_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_ins_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the free bits for an uncompressed page to reflect the present state. Does this in the mtr given, which means that the latching order rules virtually prevent any further operations for this OS thread until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the page. in/out: mtr</p>
<p>Updates the free bits for an uncompressed page to reflect the present state. Does this in the mtr given, which means that the latching order rules virtually prevent any further operations for this OS thread until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">max_ins_size</td><td>in: value of maximum insert size with reorganize before the latest operation performed to the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a420088ad2008b7d667fa430c044273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a420088ad2008b7d667fa430c044273">&#9670;&nbsp;</a></span>ibuf_update_free_bits_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_update_free_bits_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the free bits for a compressed page to reflect the present state. Does this in the mtr given, which means that the latching order rules virtually prevent any further operations for this OS thread until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the page. in/out: mtr</p>
<p>Updates the free bits for a compressed page to reflect the present state. Does this in the mtr given, which means that the latching order rules virtually prevent any further operations for this OS thread until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef509cb3f972ec513b2e072cebc36cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef509cb3f972ec513b2e072cebc36cd0">&#9670;&nbsp;</a></span>ibuf_update_max_tablespace_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_update_max_tablespace_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the biggest tablespace id from the high end of the insert buffer tree and updates the counter in fil_system. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="acc138f660c81dccfb4179744e640a50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc138f660c81dccfb4179744e640a50d">&#9670;&nbsp;</a></span>ibuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibuf_t* ibuf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The insert buffer control structure </p>

</div>
</div>
<a id="adbb87198861959d990f4ff15f902fda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb87198861959d990f4ff15f902fda9">&#9670;&nbsp;</a></span>ibuf_use</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0">ibuf_use_t</a> ibuf_use</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operations that can currently be buffered. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

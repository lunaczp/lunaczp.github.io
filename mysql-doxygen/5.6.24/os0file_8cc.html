<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/os/os0file.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_cb80c0dc75f8ece38b4ad1f35cb4a413.html">os</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">os0file.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="os0file_8h_source.html">os0file.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0sync_8h_source.html">os0sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0thread_8h_source.html">os0thread.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structos__aio__slot__t.html">os_aio_slot_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9b3f6d80250e3bb3d317eb67b6affc01"><td class="memItemLeft" align="right" valign="top"><a id="a9b3f6d80250e3bb3d317eb67b6affc01"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OS_FILE_N_SEEK_MUTEXES</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a9b3f6d80250e3bb3d317eb67b6affc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4cb1f015a3c421c4b41bb040966709"><td class="memItemLeft" align="right" valign="top"><a id="acf4cb1f015a3c421c4b41bb040966709"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OS_AIO_MERGE_N_CONSECUTIVE</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:acf4cb1f015a3c421c4b41bb040966709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017c8179e94249c15fa3b26d159f991c"><td class="memItemLeft" align="right" valign="top"><a id="a017c8179e94249c15fa3b26d159f991c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>USE_FILE_LOCK</b></td></tr>
<tr class="separator:a017c8179e94249c15fa3b26d159f991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3a376a8772e85386fe561821a92ebf"><td class="memItemLeft" align="right" valign="top"><a id="a6a3a376a8772e85386fe561821a92ebf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OS_FILE_PATH_SEPARATOR</b>&#160;&#160;&#160;'/'</td></tr>
<tr class="separator:a6a3a376a8772e85386fe561821a92ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af256c0bf21f39f593037cd4df4bd85cc"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#af256c0bf21f39f593037cd4df4bd85cc">os_file_get_last_error_low</a> (bool report_all_errors, bool on_error_silent)</td></tr>
<tr class="separator:af256c0bf21f39f593037cd4df4bd85cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41271c8d3e961b5ed4f48e695b5532e6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a41271c8d3e961b5ed4f48e695b5532e6">os_file_get_last_error</a> (bool report_all_errors)</td></tr>
<tr class="separator:a41271c8d3e961b5ed4f48e695b5532e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7932799ed826d659f59842d016c46da0"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a7932799ed826d659f59842d016c46da0">os_file_handle_error_cond_exit</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *operation, ibool should_exit, ibool on_error_silent)</td></tr>
<tr class="separator:a7932799ed826d659f59842d016c46da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4c9479bd4c830dbdece9bb0d25aef9"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a7c4c9479bd4c830dbdece9bb0d25aef9">os_file_handle_error</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *operation)</td></tr>
<tr class="separator:a7c4c9479bd4c830dbdece9bb0d25aef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dbd15aa32cc9c8001afeece735d839"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a16dbd15aa32cc9c8001afeece735d839">os_file_handle_error_no_exit</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *operation, ibool on_error_silent)</td></tr>
<tr class="separator:a16dbd15aa32cc9c8001afeece735d839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c6a1051f9b0cf0317d8ef415bca3ca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#af8c6a1051f9b0cf0317d8ef415bca3ca">os_file_lock</a> (int <a class="el" href="row0merge_8cc.html#a2ba07eb1dd7b9899cf7b132635a757e8">fd</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:af8c6a1051f9b0cf0317d8ef415bca3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7a0ea5c874babeeec9529437903f5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#acad7a0ea5c874babeeec9529437903f5">os_io_init_simple</a> (void)</td></tr>
<tr class="separator:acad7a0ea5c874babeeec9529437903f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ce2423ddcae3f24fa9268c6720c2dc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a26ce2423ddcae3f24fa9268c6720c2dc">os_file_create_tmpfile</a> (void)</td></tr>
<tr class="separator:a26ce2423ddcae3f24fa9268c6720c2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec72ba70b5a085ac32c8b25bc06764c5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="os0file_8h.html#a996944ca087e0aab572f2b5ea990a108">os_file_dir_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#aec72ba70b5a085ac32c8b25bc06764c5">os_file_opendir</a> (const char *dirname, ibool error_is_fatal)</td></tr>
<tr class="separator:aec72ba70b5a085ac32c8b25bc06764c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16db2c104545822153f7e8b57250307f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a16db2c104545822153f7e8b57250307f">os_file_closedir</a> (<a class="el" href="os0file_8h.html#a996944ca087e0aab572f2b5ea990a108">os_file_dir_t</a> dir)</td></tr>
<tr class="separator:a16db2c104545822153f7e8b57250307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4c24bb3f7cd4ab3ba2d999211e73ab"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a5c4c24bb3f7cd4ab3ba2d999211e73ab">os_file_readdir_next_file</a> (const char *dirname, <a class="el" href="os0file_8h.html#a996944ca087e0aab572f2b5ea990a108">os_file_dir_t</a> dir, <a class="el" href="structos__file__stat__t.html">os_file_stat_t</a> *info)</td></tr>
<tr class="separator:a5c4c24bb3f7cd4ab3ba2d999211e73ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43b662dbf0f7317129daee7f27dfa6a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ae43b662dbf0f7317129daee7f27dfa6a">os_file_create_directory</a> (const char *pathname, ibool fail_if_exists)</td></tr>
<tr class="separator:ae43b662dbf0f7317129daee7f27dfa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b920c72d51196c819eb2f0cadf362e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a55b920c72d51196c819eb2f0cadf362e">os_file_create_simple_func</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ulint create_mode, ulint access_type, ibool *success)</td></tr>
<tr class="separator:a55b920c72d51196c819eb2f0cadf362e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76da3dc0a4d6e6df1b4ed4efad7067c5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a76da3dc0a4d6e6df1b4ed4efad7067c5">os_file_create_simple_no_error_handling_func</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ulint create_mode, ulint access_type, ibool *success)</td></tr>
<tr class="separator:a76da3dc0a4d6e6df1b4ed4efad7067c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a95c7680bfb6a3d8947c3ea38234fef"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a6a95c7680bfb6a3d8947c3ea38234fef">os_file_set_nocache</a> (int <a class="el" href="row0merge_8cc.html#a2ba07eb1dd7b9899cf7b132635a757e8">fd</a> <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)), const char *file_name <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)), const char *operation_name <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:a6a95c7680bfb6a3d8947c3ea38234fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d68d3d425c62275e4777121fa13581"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a39d68d3d425c62275e4777121fa13581">os_file_create_func</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, ulint create_mode, ulint purpose, ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, ibool *success)</td></tr>
<tr class="separator:a39d68d3d425c62275e4777121fa13581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d312a3d4f9d49754afdd348aa436778"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a2d312a3d4f9d49754afdd348aa436778">os_file_delete_if_exists_func</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a2d312a3d4f9d49754afdd348aa436778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1550638b832c9fbedbc13f2b279ae60"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ae1550638b832c9fbedbc13f2b279ae60">os_file_delete_func</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ae1550638b832c9fbedbc13f2b279ae60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a348f9838926e35b66bd806fd268e41"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a5a348f9838926e35b66bd806fd268e41">os_file_rename_func</a> (const char *oldpath, const char *newpath)</td></tr>
<tr class="separator:a5a348f9838926e35b66bd806fd268e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fca485e60c95f0008b774035db1f36b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a2fca485e60c95f0008b774035db1f36b">os_file_close_func</a> (<a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:a2fca485e60c95f0008b774035db1f36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438e093038cdadce9b0aadf1a89f909f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a438e093038cdadce9b0aadf1a89f909f">os_file_get_size</a> (<a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:a438e093038cdadce9b0aadf1a89f909f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1985f8956372cc3ad5c180366609c35"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ae1985f8956372cc3ad5c180366609c35">os_file_set_size</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:ae1985f8956372cc3ad5c180366609c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e549d39193f5001490bea74205cbe7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#aa2e549d39193f5001490bea74205cbe7">os_file_set_eof</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:aa2e549d39193f5001490bea74205cbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb731f7f6bc0ded70db8ceed928df664"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#aeb731f7f6bc0ded70db8ceed928df664">os_file_fsync</a> (<a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:aeb731f7f6bc0ded70db8ceed928df664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8106305ca420e8e4cbd2510e82092c76"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a8106305ca420e8e4cbd2510e82092c76">os_file_flush_func</a> (<a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:a8106305ca420e8e4cbd2510e82092c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963be3f24c592d214852d4c81c09475f"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a963be3f24c592d214852d4c81c09475f">__attribute__</a> ((nonnull, warn_unused_result)) ssize_t os_file_pread(<a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a></td></tr>
<tr class="separator:a963be3f24c592d214852d4c81c09475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb11d364f4d14806792d0adad476028"><td class="memItemLeft" align="right" valign="top"><a id="a7cb11d364f4d14806792d0adad476028"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a7cb11d364f4d14806792d0adad476028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ccb64c320fcdc5a7ebd4cd3c365566"><td class="memItemLeft" align="right" valign="top"><a id="ab8ccb64c320fcdc5a7ebd4cd3c365566"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (sizeof(off_t)&lt;=4)</td></tr>
<tr class="separator:ab8ccb64c320fcdc5a7ebd4cd3c365566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934ed1aa6331374735f1b5b25125b8d8"><td class="memItemLeft" align="right" valign="top"><a id="a934ed1aa6331374735f1b5b25125b8d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>os_mutex_enter</b> (<a class="el" href="os0file_8cc.html#a19f031a59dad1b34009a91bc8b0f9ccf">os_file_count_mutex</a>)</td></tr>
<tr class="separator:a934ed1aa6331374735f1b5b25125b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a34e101251c7737c6fd180fcdea610d"><td class="memItemLeft" align="right" valign="top"><a id="a4a34e101251c7737c6fd180fcdea610d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MONITOR_INC</b> (MONITOR_OS_PENDING_READS)</td></tr>
<tr class="separator:a4a34e101251c7737c6fd180fcdea610d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41f74ba14097e0abedb8e2e6cbeb808"><td class="memItemLeft" align="right" valign="top"><a id="af41f74ba14097e0abedb8e2e6cbeb808"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>os_mutex_exit</b> (<a class="el" href="os0file_8cc.html#a19f031a59dad1b34009a91bc8b0f9ccf">os_file_count_mutex</a>)</td></tr>
<tr class="separator:af41f74ba14097e0abedb8e2e6cbeb808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6432201d3fc758b29e56551d458797"><td class="memItemLeft" align="right" valign="top"><a id="a9e6432201d3fc758b29e56551d458797"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>os_mutex_enter</b> (os_file_seek_mutexes[<a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>])</td></tr>
<tr class="separator:a9e6432201d3fc758b29e56551d458797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34ef8c8a43534be846844dd424342fd"><td class="memItemLeft" align="right" valign="top"><a id="ad34ef8c8a43534be846844dd424342fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (ret_offset&lt; 0)</td></tr>
<tr class="separator:ad34ef8c8a43534be846844dd424342fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eca6bc0d2b6581d4bd3f36d82fbf87"><td class="memItemLeft" align="right" valign="top"><a id="ae8eca6bc0d2b6581d4bd3f36d82fbf87"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>os_mutex_exit</b> (os_file_seek_mutexes[<a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>])</td></tr>
<tr class="separator:ae8eca6bc0d2b6581d4bd3f36d82fbf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa776d654678b4d404ae653956f488f0f"><td class="memItemLeft" align="right" valign="top"><a id="aa776d654678b4d404ae653956f488f0f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MONITOR_DEC</b> (MONITOR_OS_PENDING_READS)</td></tr>
<tr class="separator:aa776d654678b4d404ae653956f488f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3184a425ee7a9067e61d6b81c1eead49"><td class="memItemLeft" align="right" valign="top"><a id="a3184a425ee7a9067e61d6b81c1eead49"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (ret)</td></tr>
<tr class="separator:a3184a425ee7a9067e61d6b81c1eead49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bce5464964634409e3cbedc3caa66fc"><td class="memItemLeft" align="right" valign="top"><a id="a8bce5464964634409e3cbedc3caa66fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (!<a class="el" href="srv0srv_8cc.html#a3304313fad35baa12c4e00b7fca23af2">srv_read_only_mode</a>)</td></tr>
<tr class="separator:a8bce5464964634409e3cbedc3caa66fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8d296d9ca5117a813af92eb64e9c17"><td class="memItemLeft" align="right" valign="top"><a id="aac8d296d9ca5117a813af92eb64e9c17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MONITOR_INC</b> (MONITOR_OS_PENDING_WRITES)</td></tr>
<tr class="separator:aac8d296d9ca5117a813af92eb64e9c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4e68b37e6c6e583586ac97181cd793"><td class="memItemLeft" align="right" valign="top"><a id="a0f4e68b37e6c6e583586ac97181cd793"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MONITOR_DEC</b> (MONITOR_OS_PENDING_WRITES)</td></tr>
<tr class="separator:a0f4e68b37e6c6e583586ac97181cd793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a9fca261bc4e6d999ef3e76cd645c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a02a9fca261bc4e6d999ef3e76cd645c0">os_file_read_func</a> (<a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, void *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a02a9fca261bc4e6d999ef3e76cd645c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426bd41a56e5e5df1632705a7f31ed4a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a426bd41a56e5e5df1632705a7f31ed4a">os_file_read_no_error_handling_func</a> (<a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, void *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a426bd41a56e5e5df1632705a7f31ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9074411e8dcbe515d176e37e17bf2275"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a9074411e8dcbe515d176e37e17bf2275">os_file_read_string</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, char *str, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a9074411e8dcbe515d176e37e17bf2275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47fc33904c25b07286cbfa323adcde0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#af47fc33904c25b07286cbfa323adcde0">os_file_write_func</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, const void *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:af47fc33904c25b07286cbfa323adcde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00929749c1e5d29cce51953039eb80c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a00929749c1e5d29cce51953039eb80c0">os_file_status</a> (const char *path, ibool *exists, os_file_type_t *<a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:a00929749c1e5d29cce51953039eb80c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b633b0943965c12ed37d683976a26bd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a2b633b0943965c12ed37d683976a26bd">os_file_get_status</a> (const char *path, <a class="el" href="structos__file__stat__t.html">os_file_stat_t</a> *stat_info, bool check_rw_perm)</td></tr>
<tr class="separator:a2b633b0943965c12ed37d683976a26bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796715958495d83522411dc756f16b46"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a796715958495d83522411dc756f16b46">os_file_make_new_pathname</a> (const char *old_path, const char *tablename)</td></tr>
<tr class="separator:a796715958495d83522411dc756f16b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e2a4aaeed01eae50080bcf7a7698af"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a98e2a4aaeed01eae50080bcf7a7698af">os_file_make_remote_pathname</a> (const char *data_dir_path, const char *tablename, const char *extention)</td></tr>
<tr class="separator:a98e2a4aaeed01eae50080bcf7a7698af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d63b1e4fc0cd44ad040f53c664dee3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a70d63b1e4fc0cd44ad040f53c664dee3">os_file_make_data_dir_path</a> (char *data_dir_path)</td></tr>
<tr class="separator:a70d63b1e4fc0cd44ad040f53c664dee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1212f85966a94bf0a181e7d0fb8e5ef"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ae1212f85966a94bf0a181e7d0fb8e5ef">os_file_dirname</a> (const char *path)</td></tr>
<tr class="separator:ae1212f85966a94bf0a181e7d0fb8e5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e10ef16062c9d6532586545b12a34b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a90e10ef16062c9d6532586545b12a34b">os_file_create_subdirs_if_needed</a> (const char *path)</td></tr>
<tr class="separator:a90e10ef16062c9d6532586545b12a34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf5baf9188e03a273101264e2208faf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structos__aio__slot__t.html">os_aio_slot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a6cf5baf9188e03a273101264e2208faf">os_aio_array_get_nth_slot</a> (<a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *array, ulint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a6cf5baf9188e03a273101264e2208faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a910a6592a3f4d5cc901579c197d91"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a82a910a6592a3f4d5cc901579c197d91">os_aio_array_create</a> (ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, ulint n_segments)</td></tr>
<tr class="separator:a82a910a6592a3f4d5cc901579c197d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a4b7e2bb032ae84ceeacf7edc935ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a84a4b7e2bb032ae84ceeacf7edc935ca">os_aio_array_free</a> (<a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&amp;array)</td></tr>
<tr class="separator:a84a4b7e2bb032ae84ceeacf7edc935ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab267dee83ca0a23f8cfb07b46f9e8f8b"><td class="memItemLeft" align="right" valign="top"><a id="ab267dee83ca0a23f8cfb07b46f9e8f8b"></a>
UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><b>os_aio_init</b> (ulint n_per_seg, ulint n_read_segs, ulint n_write_segs, ulint n_slots_sync)</td></tr>
<tr class="separator:ab267dee83ca0a23f8cfb07b46f9e8f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9efa8325355b7221a17f2ff5f0ff8c"><td class="memItemLeft" align="right" valign="top"><a id="aee9efa8325355b7221a17f2ff5f0ff8c"></a>
UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>os_aio_free</b> (void)</td></tr>
<tr class="separator:aee9efa8325355b7221a17f2ff5f0ff8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778afaf403c4917932814ab67c6ad3c4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a778afaf403c4917932814ab67c6ad3c4">os_aio_wake_all_threads_at_shutdown</a> (void)</td></tr>
<tr class="separator:a778afaf403c4917932814ab67c6ad3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645c99d867a520f3bed3fd8fde0be672"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a645c99d867a520f3bed3fd8fde0be672">os_aio_wait_until_no_pending_writes</a> (void)</td></tr>
<tr class="separator:a645c99d867a520f3bed3fd8fde0be672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398a586107f1d936d6c5a9376be1d67d"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a398a586107f1d936d6c5a9376be1d67d">os_aio_get_segment_no_from_slot</a> (<a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *array, <a class="el" href="structos__aio__slot__t.html">os_aio_slot_t</a> *slot)</td></tr>
<tr class="separator:a398a586107f1d936d6c5a9376be1d67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798ddeab8dfd1c466f42043255ac371a"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a798ddeab8dfd1c466f42043255ac371a">os_aio_get_array_and_local_segment</a> (<a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> **array, ulint global_segment)</td></tr>
<tr class="separator:a798ddeab8dfd1c466f42043255ac371a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8dad7439366001e83bc14ab7037789"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structos__aio__slot__t.html">os_aio_slot_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#afb8dad7439366001e83bc14ab7037789">os_aio_array_reserve_slot</a> (ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *array, <a class="el" href="structfil__node__t.html">fil_node_t</a> *message1, void *message2, <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, void *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:afb8dad7439366001e83bc14ab7037789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e0ea1888e93dd5e33421bbced4384d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a09e0ea1888e93dd5e33421bbced4384d">os_aio_array_free_slot</a> (<a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *array, <a class="el" href="structos__aio__slot__t.html">os_aio_slot_t</a> *slot)</td></tr>
<tr class="separator:a09e0ea1888e93dd5e33421bbced4384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6251a944e65a2ed4582e6635d28472b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ad6251a944e65a2ed4582e6635d28472b">os_aio_simulated_wake_handler_thread</a> (ulint global_segment)</td></tr>
<tr class="separator:ad6251a944e65a2ed4582e6635d28472b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43192824cbf775b30708b1640fcf718b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a43192824cbf775b30708b1640fcf718b">os_aio_simulated_wake_handler_threads</a> (void)</td></tr>
<tr class="separator:a43192824cbf775b30708b1640fcf718b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407fed3f77bfde915187239ecbdcb6d8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a407fed3f77bfde915187239ecbdcb6d8">os_aio_simulated_put_read_threads_to_sleep</a> (void)</td></tr>
<tr class="separator:a407fed3f77bfde915187239ecbdcb6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a7833471be246b854fd4678bd5ad38"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ad0a7833471be246b854fd4678bd5ad38">os_aio_func</a> (ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, void *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, <a class="el" href="structfil__node__t.html">fil_node_t</a> *message1, void *message2)</td></tr>
<tr class="separator:ad0a7833471be246b854fd4678bd5ad38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e908cb21202ce3b81d5e3a0f86703a2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a0e908cb21202ce3b81d5e3a0f86703a2">os_aio_simulated_handle</a> (ulint global_segment, <a class="el" href="structfil__node__t.html">fil_node_t</a> **message1, void **message2, ulint *<a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:a0e908cb21202ce3b81d5e3a0f86703a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb094e4513f9d3343b237768707e4a9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a1bb094e4513f9d3343b237768707e4a9">os_aio_array_validate</a> (<a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *array)</td></tr>
<tr class="separator:a1bb094e4513f9d3343b237768707e4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27b6687db6ee3c156be9e4dfcafda12"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ad27b6687db6ee3c156be9e4dfcafda12">os_aio_validate</a> (void)</td></tr>
<tr class="separator:ad27b6687db6ee3c156be9e4dfcafda12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6866199f7c5cf6115555a47e1efc8a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ac6866199f7c5cf6115555a47e1efc8a9">os_aio_print_segment_info</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint *n_seg, <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *array)</td></tr>
<tr class="separator:ac6866199f7c5cf6115555a47e1efc8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d983e0ccd5d800df9ae92aba30f52e3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a9d983e0ccd5d800df9ae92aba30f52e3">os_aio_print_array</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *array)</td></tr>
<tr class="separator:a9d983e0ccd5d800df9ae92aba30f52e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6e6d19b3d1a89e5cc9831649a9ec27"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a5d6e6d19b3d1a89e5cc9831649a9ec27">os_aio_print</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:a5d6e6d19b3d1a89e5cc9831649a9ec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375dd606a56c3c6979107806b16d914"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ac375dd606a56c3c6979107806b16d914">os_aio_refresh_stats</a> (void)</td></tr>
<tr class="separator:ac375dd606a56c3c6979107806b16d914"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3005ab640b66ac348a554702826740b2"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a3005ab640b66ac348a554702826740b2">IO_IBUF_SEGMENT</a> = 0</td></tr>
<tr class="separator:a3005ab640b66ac348a554702826740b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4675fb2405ca3423866309be1629296"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ac4675fb2405ca3423866309be1629296">IO_LOG_SEGMENT</a> = 1</td></tr>
<tr class="separator:ac4675fb2405ca3423866309be1629296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af12437c3bc2170683b6d7a623b0be0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a7af12437c3bc2170683b6d7a623b0be0">os_innodb_umask</a> = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP</td></tr>
<tr class="separator:a7af12437c3bc2170683b6d7a623b0be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0ea98397550c0fdaa5209f39a19154"><td class="memItemLeft" align="right" valign="top"><a id="a1a0ea98397550c0fdaa5209f39a19154"></a>
UNIV_INTERN <a class="el" href="os0sync_8h.html#a21c139c6cdbef5b007a02633f2d4732a">os_ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>os_file_seek_mutexes</b> [OS_FILE_N_SEEK_MUTEXES]</td></tr>
<tr class="separator:a1a0ea98397550c0fdaa5209f39a19154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39b720a9783ad425897a0fb2016f52a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ab39b720a9783ad425897a0fb2016f52a">os_aio_print_debug</a> = FALSE</td></tr>
<tr class="separator:ab39b720a9783ad425897a0fb2016f52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a7e977c4664bfafd789accd5a83807"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a27a7e977c4664bfafd789accd5a83807">os_aio_segment_wait_events</a> = NULL</td></tr>
<tr class="separator:a27a7e977c4664bfafd789accd5a83807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d383a7b01d6cadbce8b34c5dd84d351"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a9d383a7b01d6cadbce8b34c5dd84d351">os_aio_n_segments</a> = ULINT_UNDEFINED</td></tr>
<tr class="separator:a9d383a7b01d6cadbce8b34c5dd84d351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46255dd1c1323c7382dc47ea6de0e55b"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a46255dd1c1323c7382dc47ea6de0e55b">os_aio_recommend_sleep_for_read_threads</a> = FALSE</td></tr>
<tr class="separator:a46255dd1c1323c7382dc47ea6de0e55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c55e611ac88fbf63d6d61d37dc82b3"><td class="memItemLeft" align="right" valign="top"><a id="a68c55e611ac88fbf63d6d61d37dc82b3"></a>
UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><b>os_n_file_reads</b> = 0</td></tr>
<tr class="separator:a68c55e611ac88fbf63d6d61d37dc82b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f125f44c316fe1a550f1446f56f8dac"><td class="memItemLeft" align="right" valign="top"><a id="a1f125f44c316fe1a550f1446f56f8dac"></a>
UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><b>os_bytes_read_since_printout</b> = 0</td></tr>
<tr class="separator:a1f125f44c316fe1a550f1446f56f8dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6151a432e7f177815c5d7cebfc114df"><td class="memItemLeft" align="right" valign="top"><a id="ae6151a432e7f177815c5d7cebfc114df"></a>
UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><b>os_n_file_writes</b> = 0</td></tr>
<tr class="separator:ae6151a432e7f177815c5d7cebfc114df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f11eee113434d401408d323e43ec5b"><td class="memItemLeft" align="right" valign="top"><a id="aa8f11eee113434d401408d323e43ec5b"></a>
UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><b>os_n_fsyncs</b> = 0</td></tr>
<tr class="separator:aa8f11eee113434d401408d323e43ec5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11c1bd37de305ecf3bc346012bbb784"><td class="memItemLeft" align="right" valign="top"><a id="af11c1bd37de305ecf3bc346012bbb784"></a>
UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><b>os_n_file_reads_old</b> = 0</td></tr>
<tr class="separator:af11c1bd37de305ecf3bc346012bbb784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b9a5293265def59d858380a2d2e39"><td class="memItemLeft" align="right" valign="top"><a id="aa74b9a5293265def59d858380a2d2e39"></a>
UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><b>os_n_file_writes_old</b> = 0</td></tr>
<tr class="separator:aa74b9a5293265def59d858380a2d2e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d363bd34a4ca1c77811114b07e6fef"><td class="memItemLeft" align="right" valign="top"><a id="ae8d363bd34a4ca1c77811114b07e6fef"></a>
UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><b>os_n_fsyncs_old</b> = 0</td></tr>
<tr class="separator:ae8d363bd34a4ca1c77811114b07e6fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af032372991e6fdfcd7a818163f9339d9"><td class="memItemLeft" align="right" valign="top"><a id="af032372991e6fdfcd7a818163f9339d9"></a>
UNIV_INTERN time_t&#160;</td><td class="memItemRight" valign="bottom"><b>os_last_printout</b></td></tr>
<tr class="separator:af032372991e6fdfcd7a818163f9339d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127fc5dc7e8434a309e9556d4dc4c94a"><td class="memItemLeft" align="right" valign="top"><a id="a127fc5dc7e8434a309e9556d4dc4c94a"></a>
UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><b>os_has_said_disk_full</b> = FALSE</td></tr>
<tr class="separator:a127fc5dc7e8434a309e9556d4dc4c94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f031a59dad1b34009a91bc8b0f9ccf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="os0sync_8h.html#a21c139c6cdbef5b007a02633f2d4732a">os_ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a19f031a59dad1b34009a91bc8b0f9ccf">os_file_count_mutex</a></td></tr>
<tr class="separator:a19f031a59dad1b34009a91bc8b0f9ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84df4f50e6d9ad06e77a1bca9aee299"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#aa84df4f50e6d9ad06e77a1bca9aee299">os_file_n_pending_preads</a> = 0</td></tr>
<tr class="separator:aa84df4f50e6d9ad06e77a1bca9aee299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9014f7202605010fa78e935626819644"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a9014f7202605010fa78e935626819644">os_file_n_pending_pwrites</a> = 0</td></tr>
<tr class="separator:a9014f7202605010fa78e935626819644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5466be6ac70d2b680a141a16b40078"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#abc5466be6ac70d2b680a141a16b40078">os_n_pending_writes</a> = 0</td></tr>
<tr class="separator:abc5466be6ac70d2b680a141a16b40078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd13091d80098ac72b4f0a053157a28"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a0fd13091d80098ac72b4f0a053157a28">os_n_pending_reads</a> = 0</td></tr>
<tr class="separator:a0fd13091d80098ac72b4f0a053157a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccd7535cf45ea4a389b855324c47142"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a0ccd7535cf45ea4a389b855324c47142">buf</a></td></tr>
<tr class="separator:a0ccd7535cf45ea4a389b855324c47142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d81b35641c779f299e102dad1d38772"><td class="memItemLeft" align="right" valign="top">static void ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a0d81b35641c779f299e102dad1d38772">n</a></td></tr>
<tr class="separator:a0d81b35641c779f299e102dad1d38772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6b91e619d6e5e1a8a9f7da64bc0cdb"><td class="memItemLeft" align="right" valign="top">static void ulint <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a></td></tr>
<tr class="separator:a7b6b91e619d6e5e1a8a9f7da64bc0cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f2fe7b39f814351038be04d314f70"><td class="memItemLeft" align="right" valign="top"><a id="a323f2fe7b39f814351038be04d314f70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>offs</b> = (off_t) <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a></td></tr>
<tr class="separator:a323f2fe7b39f814351038be04d314f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ec77bdca1b30e8153fc5da88f603db"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>ret</b></td></tr>
<tr class="separator:af1ec77bdca1b30e8153fc5da88f603db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e98b8a17c0aad30ba64d47b74e2a6c1"><td class="memItemLeft" align="right" valign="top"><a id="a7e98b8a17c0aad30ba64d47b74e2a6c1"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>i</b> = ((ulint) <a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>) % OS_FILE_N_SEEK_MUTEXES</td></tr>
<tr class="separator:a7e98b8a17c0aad30ba64d47b74e2a6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf6f22e3bacfd1ade8747c55bc2f5b1"><td class="memItemLeft" align="right" valign="top"><a id="afdf6f22e3bacfd1ade8747c55bc2f5b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ret_offset</b> = lseek(<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, offs, SEEK_SET)</td></tr>
<tr class="separator:afdf6f22e3bacfd1ade8747c55bc2f5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544c3fe466e421738dae463968b70ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>else</b></td></tr>
<tr class="separator:a0544c3fe466e421738dae463968b70ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b1b74f707fe9d4dea2cf520d40bcc9"><td class="memItemLeft" align="right" valign="top"><a id="a54b1b74f707fe9d4dea2cf520d40bcc9"></a>
func_exit&#160;</td><td class="memItemRight" valign="bottom"><b>__pad0__</b></td></tr>
<tr class="separator:a54b1b74f707fe9d4dea2cf520d40bcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1e9e694ab905f589be7b5f05dcc799ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a1e9e694ab905f589be7b5f05dcc799ca">os_aio_read_array</a> = NULL</td></tr>
<tr class="separator:a1e9e694ab905f589be7b5f05dcc799ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae89d8e8f508604393b49a76a9b4459b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#aae89d8e8f508604393b49a76a9b4459b">os_aio_write_array</a> = NULL</td></tr>
<tr class="separator:aae89d8e8f508604393b49a76a9b4459b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c18159f88831af48ae18685dc01f05d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a4c18159f88831af48ae18685dc01f05d">os_aio_ibuf_array</a> = NULL</td></tr>
<tr class="separator:a4c18159f88831af48ae18685dc01f05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32e8a8b4ff815c942817cd758d2b50f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#ab32e8a8b4ff815c942817cd758d2b50f">os_aio_log_array</a> = NULL</td></tr>
<tr class="separator:ab32e8a8b4ff815c942817cd758d2b50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c6d6d978e6c77efa8c74485000bb4c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="os0file_8cc.html#a93c6d6d978e6c77efa8c74485000bb4c">os_aio_sync_array</a> = NULL</td></tr>
<tr class="separator:a93c6d6d978e6c77efa8c74485000bb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The interface to the operating system file i/o primitives</p>
<p>Created 10/21/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a963be3f24c592d214852d4c81c09475f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963be3f24c592d214852d4c81c09475f">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull, warn_unused_result)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a synchronous read operation in Posix. </p><dl class="section return"><dt>Returns</dt><dd>number of bytes read, -1 if error</dd></dl>
<p>Does a synchronous write operation in Posix. </p><dl class="section return"><dt>Returns</dt><dd>number of bytes written, -1 if error </dd></dl>

</div>
</div>
<a id="a82a910a6592a3f4d5cc901579c197d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a910a6592a3f4d5cc901579c197d91">&#9670;&nbsp;</a></span>os_aio_array_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structos__aio__array__t.html">os_aio_array_t</a>* os_aio_array_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_segments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an aio wait array. Note that we return NULL in case of failure. We don't care about freeing memory here because we assume that a failure will result in server refusing to start up. </p><dl class="section return"><dt>Returns</dt><dd>own: aio array, NULL on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: maximum number of pending aio operations allowed; n must be divisible by n_segments </td></tr>
    <tr><td class="paramname">n_segments</td><td>in: number of segments in the aio array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84a4b7e2bb032ae84ceeacf7edc935ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a4b7e2bb032ae84ceeacf7edc935ca">&#9670;&nbsp;</a></span>os_aio_array_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void os_aio_array_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees an aio wait array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>in, own: array to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09e0ea1888e93dd5e33421bbced4384d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e0ea1888e93dd5e33421bbced4384d">&#9670;&nbsp;</a></span>os_aio_array_free_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void os_aio_array_free_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structos__aio__slot__t.html">os_aio_slot_t</a> *&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a slot in the aio array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>in: aio array </td></tr>
    <tr><td class="paramname">slot</td><td>in: pointer to slot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cf5baf9188e03a273101264e2208faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf5baf9188e03a273101264e2208faf">&#9670;&nbsp;</a></span>os_aio_array_get_nth_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structos__aio__slot__t.html">os_aio_slot_t</a>* os_aio_array_get_nth_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the nth slot in the aio array. </p><dl class="section return"><dt>Returns</dt><dd>pointer to slot </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>in: aio array </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the slot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb8dad7439366001e83bc14ab7037789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8dad7439366001e83bc14ab7037789">&#9670;&nbsp;</a></span>os_aio_array_reserve_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structos__aio__slot__t.html">os_aio_slot_t</a>* os_aio_array_reserve_slot </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> *&#160;</td>
          <td class="paramname"><em>message1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requests for a slot in the aio array. If no slot is available, waits until not_full-event becomes signaled. </p><dl class="section return"><dt>Returns</dt><dd>pointer to slot </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: OS_FILE_READ or OS_FILE_WRITE </td></tr>
    <tr><td class="paramname">array</td><td>in: aio array </td></tr>
    <tr><td class="paramname">message1</td><td>in: message to be passed along with the aio operation </td></tr>
    <tr><td class="paramname">message2</td><td>in: message to be passed along with the aio operation </td></tr>
    <tr><td class="paramname">file</td><td>in: file handle </td></tr>
    <tr><td class="paramname">name</td><td>in: name of the file or path as a null-terminated string </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer where to read or from which to write </td></tr>
    <tr><td class="paramname">offset</td><td>in: file offset </td></tr>
    <tr><td class="paramname">len</td><td>in: length of the block to read or write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb094e4513f9d3343b237768707e4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb094e4513f9d3343b237768707e4a9">&#9670;&nbsp;</a></span>os_aio_array_validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool os_aio_array_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validates the consistency of an aio array. </p><dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>in: aio wait array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0a7833471be246b854fd4678bd5ad38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a7833471be246b854fd4678bd5ad38">&#9670;&nbsp;</a></span>os_aio_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_aio_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> *&#160;</td>
          <td class="paramname"><em>message1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_aio(), not directly this function! Requests an asynchronous i/o operation. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if request was queued successfully, FALSE if fail </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: OS_FILE_READ or OS_FILE_WRITE </td></tr>
    <tr><td class="paramname">mode</td><td>in: OS_AIO_NORMAL, ..., possibly ORed to OS_AIO_SIMULATED_WAKE_LATER: the last flag advises this function not to wake i/o-handler threads, but the caller will do the waking explicitly later, in this way the caller can post several requests in a batch; NOTE that the batch must not be so big that it exhausts the slots in aio arrays! NOTE that a simulated batch may introduce hidden chances of deadlocks, because i/os are not actually handled until all have been posted: use with great caution! </td></tr>
    <tr><td class="paramname">name</td><td>in: name of the file or path as a null-terminated string </td></tr>
    <tr><td class="paramname">file</td><td>in: handle to a file </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer where to read or from which to write </td></tr>
    <tr><td class="paramname">offset</td><td>in: file offset where to read or write </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to read or write </td></tr>
    <tr><td class="paramname">message1</td><td>in: message for the aio handler (can be used to identify a completed aio operation); ignored if mode is OS_AIO_SYNC </td></tr>
    <tr><td class="paramname">message2</td><td>in: message for the aio handler (can be used to identify a completed aio operation); ignored if mode is OS_AIO_SYNC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a798ddeab8dfd1c466f42043255ac371a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798ddeab8dfd1c466f42043255ac371a">&#9670;&nbsp;</a></span>os_aio_get_array_and_local_segment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint os_aio_get_array_and_local_segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> **&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>global_segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates local segment number and aio array from global segment number. </p><dl class="section return"><dt>Returns</dt><dd>local segment number within the aio array </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>out: aio wait array </td></tr>
    <tr><td class="paramname">global_segment</td><td>in: global segment number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a398a586107f1d936d6c5a9376be1d67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398a586107f1d936d6c5a9376be1d67d">&#9670;&nbsp;</a></span>os_aio_get_segment_no_from_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint os_aio_get_segment_no_from_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structos__aio__slot__t.html">os_aio_slot_t</a> *&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates segment number for a slot. </p><dl class="section return"><dt>Returns</dt><dd>segment number (which is the number used by, for example, i/o-handler threads) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>in: aio wait array </td></tr>
    <tr><td class="paramname">slot</td><td>in: slot in this array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d6e6d19b3d1a89e5cc9831649a9ec27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6e6d19b3d1a89e5cc9831649a9ec27">&#9670;&nbsp;</a></span>os_aio_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_aio_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of the aio arrays. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d983e0ccd5d800df9ae92aba30f52e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d983e0ccd5d800df9ae92aba30f52e3">&#9670;&nbsp;</a></span>os_aio_print_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_aio_print_array </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info about the aio array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">array</td><td>in: aio array to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6866199f7c5cf6115555a47e1efc8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6866199f7c5cf6115555a47e1efc8a9">&#9670;&nbsp;</a></span>os_aio_print_segment_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void os_aio_print_segment_info </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints pending IO requests per segment of an aio array. We probably don't need per segment statistics but they can help us during development phase to see if the IO requests are being distributed as expected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">n_seg</td><td>in: pending IO array </td></tr>
    <tr><td class="paramname">array</td><td>in: array to process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac375dd606a56c3c6979107806b16d914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac375dd606a56c3c6979107806b16d914">&#9670;&nbsp;</a></span>os_aio_refresh_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_aio_refresh_stats </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refreshes the statistics used to print per-second averages. </p>

</div>
</div>
<a id="a0e908cb21202ce3b81d5e3a0f86703a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e908cb21202ce3b81d5e3a0f86703a2">&#9670;&nbsp;</a></span>os_aio_simulated_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_aio_simulated_handle </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>global_segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__node__t.html">fil_node_t</a> **&#160;</td>
          <td class="paramname"><em>message1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>message2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does simulated aio. This function should be called by an i/o-handler thread. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the aio operation succeeded </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_segment</td><td>in: the number of the segment in the aio arrays to wait for; segment 0 is the ibuf i/o thread, segment 1 the log i/o thread, then follow the non-ibuf read threads, and as the last are the non-ibuf write threads </td></tr>
    <tr><td class="paramname">message1</td><td>out: the messages passed with the aio request; note that also in the case where the aio operation failed, these output parameters are valid and can be used to restart the operation, for example </td></tr>
    <tr><td class="paramname">type</td><td>out: OS_FILE_WRITE or ..._READ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a407fed3f77bfde915187239ecbdcb6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407fed3f77bfde915187239ecbdcb6d8">&#9670;&nbsp;</a></span>os_aio_simulated_put_read_threads_to_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_aio_simulated_put_read_threads_to_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called if one wants to post a batch of reads and prefers an i/o-handler thread to handle them all at once later. You must call os_aio_simulated_wake_handler_threads later to ensure the threads are not left sleeping! </p>

</div>
</div>
<a id="ad6251a944e65a2ed4582e6635d28472b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6251a944e65a2ed4582e6635d28472b">&#9670;&nbsp;</a></span>os_aio_simulated_wake_handler_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void os_aio_simulated_wake_handler_thread </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>global_segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wakes up a simulated aio i/o-handler thread if it has something to do. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_segment</td><td>in: the number of the segment in the aio arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43192824cbf775b30708b1640fcf718b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43192824cbf775b30708b1640fcf718b">&#9670;&nbsp;</a></span>os_aio_simulated_wake_handler_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_aio_simulated_wake_handler_threads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wakes up simulated aio i/o-handler threads if they have something to do. </p>

</div>
</div>
<a id="ad27b6687db6ee3c156be9e4dfcafda12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27b6687db6ee3c156be9e4dfcafda12">&#9670;&nbsp;</a></span>os_aio_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_aio_validate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validates the consistency the aio system. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>

</div>
</div>
<a id="a645c99d867a520f3bed3fd8fde0be672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645c99d867a520f3bed3fd8fde0be672">&#9670;&nbsp;</a></span>os_aio_wait_until_no_pending_writes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_aio_wait_until_no_pending_writes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until there are no pending writes in os_aio_write_array. There can be other, synchronous, pending writes. </p>

</div>
</div>
<a id="a778afaf403c4917932814ab67c6ad3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778afaf403c4917932814ab67c6ad3c4">&#9670;&nbsp;</a></span>os_aio_wake_all_threads_at_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_aio_wake_all_threads_at_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wakes up all async i/o threads so that they know to exit themselves in shutdown. </p>

</div>
</div>
<a id="a2fca485e60c95f0008b774035db1f36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fca485e60c95f0008b774035db1f36b">&#9670;&nbsp;</a></span>os_file_close_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_close_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_file_close(), not directly this function! Closes a file handle. In case of error, error number can be retrieved with os_file_get_last_error. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in, own: handle to a file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16db2c104545822153f7e8b57250307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16db2c104545822153f7e8b57250307f">&#9670;&nbsp;</a></span>os_file_closedir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int os_file_closedir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a996944ca087e0aab572f2b5ea990a108">os_file_dir_t</a>&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes a directory stream. </p><dl class="section return"><dt>Returns</dt><dd>0 if success, -1 if failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>in: directory stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae43b662dbf0f7317129daee7f27dfa6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43b662dbf0f7317129daee7f27dfa6a">&#9670;&nbsp;</a></span>os_file_create_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_create_directory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>fail_if_exists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function attempts to create a directory named pathname. The new directory gets default permissions. On Unix the permissions are (0770 &amp; ~umask). If the directory exists already, nothing is done and the call succeeds, unless the fail_if_exists arguments is true. If another error occurs, such as a permission error, this does not crash, but reports the error and returns FALSE. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if call succeeds, FALSE on error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathname</td><td>in: directory name as null-terminated string </td></tr>
    <tr><td class="paramname">fail_if_exists</td><td>in: if TRUE, pre-existing directory is treated as an error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39d68d3d425c62275e4777121fa13581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d68d3d425c62275e4777121fa13581">&#9670;&nbsp;</a></span>os_file_create_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> os_file_create_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>create_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>purpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_file_create(), not directly this function! Opens an existing file or creates a new. </p><dl class="section return"><dt>Returns</dt><dd>own: handle to the file, not defined if error, error number can be retrieved with os_file_get_last_error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: name of the file or path as a null-terminated string </td></tr>
    <tr><td class="paramname">create_mode</td><td>in: create mode </td></tr>
    <tr><td class="paramname">purpose</td><td>in: OS_FILE_AIO, if asynchronous, non-buffered i/o is desired, OS_FILE_NORMAL, if any normal file; NOTE that it also depends on type, os_aio_.. and srv_.. variables whether we really use async i/o or unbuffered i/o: look in the function source code for the exact rules </td></tr>
    <tr><td class="paramname">type</td><td>in: OS_DATA_FILE or OS_LOG_FILE </td></tr>
    <tr><td class="paramname">success</td><td>out: TRUE if succeed, FALSE if error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55b920c72d51196c819eb2f0cadf362e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b920c72d51196c819eb2f0cadf362e">&#9670;&nbsp;</a></span>os_file_create_simple_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> os_file_create_simple_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>create_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>access_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_file_create_simple(), not directly this function! A simple function to open or create a file. </p><dl class="section return"><dt>Returns</dt><dd>own: handle to the file, not defined if error, error number can be retrieved with os_file_get_last_error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: name of the file or path as a null-terminated string </td></tr>
    <tr><td class="paramname">create_mode</td><td>in: create mode </td></tr>
    <tr><td class="paramname">access_type</td><td>in: OS_FILE_READ_ONLY or OS_FILE_READ_WRITE </td></tr>
    <tr><td class="paramname">success</td><td>out: TRUE if succeed, FALSE if error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76da3dc0a4d6e6df1b4ed4efad7067c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76da3dc0a4d6e6df1b4ed4efad7067c5">&#9670;&nbsp;</a></span>os_file_create_simple_no_error_handling_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a> os_file_create_simple_no_error_handling_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>create_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>access_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_file_create_simple_no_error_handling(), not directly this function! A simple function to open or create a file. </p><dl class="section return"><dt>Returns</dt><dd>own: handle to the file, not defined if error, error number can be retrieved with os_file_get_last_error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: name of the file or path as a null-terminated string </td></tr>
    <tr><td class="paramname">create_mode</td><td>in: create mode </td></tr>
    <tr><td class="paramname">access_type</td><td>in: OS_FILE_READ_ONLY, OS_FILE_READ_WRITE, or OS_FILE_READ_ALLOW_DELETE; the last option is used by a backup program reading the file </td></tr>
    <tr><td class="paramname">success</td><td>out: TRUE if succeed, FALSE if error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90e10ef16062c9d6532586545b12a34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e10ef16062c9d6532586545b12a34b">&#9670;&nbsp;</a></span>os_file_create_subdirs_if_needed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_create_subdirs_if_needed </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates all missing subdirectories along the given path. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if call succeeded FALSE otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>in: path name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26ce2423ddcae3f24fa9268c6720c2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ce2423ddcae3f24fa9268c6720c2dc">&#9670;&nbsp;</a></span>os_file_create_tmpfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN FILE* os_file_create_tmpfile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a temporary file. This function is like tmpfile(3), but the temporary file is created in the MySQL temporary directory. </p><dl class="section return"><dt>Returns</dt><dd>temporary file handle, or NULL on error </dd></dl>

</div>
</div>
<a id="ae1550638b832c9fbedbc13f2b279ae60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1550638b832c9fbedbc13f2b279ae60">&#9670;&nbsp;</a></span>os_file_delete_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool os_file_delete_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a file. The file has to be closed before calling this. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: file path as a null-terminated string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d312a3d4f9d49754afdd348aa436778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d312a3d4f9d49754afdd348aa436778">&#9670;&nbsp;</a></span>os_file_delete_if_exists_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool os_file_delete_if_exists_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a file if it exists. The file has to be closed before calling this. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: file path as a null-terminated string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1212f85966a94bf0a181e7d0fb8e5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1212f85966a94bf0a181e7d0fb8e5ef">&#9670;&nbsp;</a></span>os_file_dirname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* os_file_dirname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function os_file_dirname returns a directory component of a null-terminated pathname string. In the usual case, dirname returns the string up to, but not including, the final '/', and basename is the component following the final '/'. Trailing '/' characters are not counted as part of the pathname.</p>
<p>If path does not contain a slash, dirname returns the string ".".</p>
<p>Concatenating the string returned by dirname, a "/", and the basename yields a complete pathname.</p>
<p>The return value is a copy of the directory component of the pathname. The copy is allocated from heap. It is the caller responsibility to free it after it is no longer needed.</p>
<p>The following list of examples (taken from SUSv2) shows the strings returned by dirname and basename for different paths: </p><pre class="fragment">   path           dirname        basename
   "/usr/lib"     "/usr"         "lib"
   "/usr/"        "/"            "usr"
   "usr"          "."            "usr"
   "/"            "/"            "/"
   "."            "."            "."
   ".."           "."            ".."
</pre><dl class="section return"><dt>Returns</dt><dd>own: directory component of the pathname </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>in: pathname </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8106305ca420e8e4cbd2510e82092c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8106305ca420e8e4cbd2510e82092c76">&#9670;&nbsp;</a></span>os_file_flush_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_flush_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_file_flush(), not directly this function! Flushes the write buffers of a given file to the disk. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in, own: handle to a file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb731f7f6bc0ded70db8ceed928df664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb731f7f6bc0ded70db8ceed928df664">&#9670;&nbsp;</a></span>os_file_fsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int os_file_fsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrapper to fsync(2) that retries the call on some errors. Returns the value 0 if successful; otherwise the value -1 is returned and the global variable errno is set to indicate the error. </p><dl class="section return"><dt>Returns</dt><dd>0 if success, -1 otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: handle to a file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41271c8d3e961b5ed4f48e695b5532e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41271c8d3e961b5ed4f48e695b5532e6">&#9670;&nbsp;</a></span>os_file_get_last_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint os_file_get_last_error </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report_all_errors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the last error number if an error occurs in a file io function. The number should be retrieved before any other OS calls (because they may overwrite the error number). If the number is not known to this program, the OS error number + 100 is returned. </p><dl class="section return"><dt>Returns</dt><dd>error number, or OS error number + 100 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">report_all_errors</td><td>in: TRUE if we want an error message printed of all errors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af256c0bf21f39f593037cd4df4bd85cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af256c0bf21f39f593037cd4df4bd85cc">&#9670;&nbsp;</a></span>os_file_get_last_error_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint os_file_get_last_error_low </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report_all_errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_error_silent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the last error number if an error occurs in a file io function. The number should be retrieved before any other OS calls (because they may overwrite the error number). If the number is not known to this program, the OS error number + 100 is returned. </p><dl class="section return"><dt>Returns</dt><dd>error number, or OS error number + 100 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">report_all_errors</td><td>in: TRUE if we want an error message printed of all errors </td></tr>
    <tr><td class="paramname">on_error_silent</td><td>in: TRUE then don't print any diagnostic to the log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a438e093038cdadce9b0aadf1a89f909f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438e093038cdadce9b0aadf1a89f909f">&#9670;&nbsp;</a></span>os_file_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> os_file_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a file size. </p><dl class="section return"><dt>Returns</dt><dd>file size, or (os_offset_t) -1 on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: handle to a file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b633b0943965c12ed37d683976a26bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b633b0943965c12ed37d683976a26bd">&#9670;&nbsp;</a></span>os_file_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> os_file_get_status </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structos__file__stat__t.html">os_file_stat_t</a> *&#160;</td>
          <td class="paramname"><em>stat_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_rw_perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns information about the specified file </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>in: pathname of the file </td></tr>
    <tr><td class="paramname">stat_info</td><td>information of a file in a directory </td></tr>
    <tr><td class="paramname">check_rw_perm</td><td>in: for testing whether the file can be opened in RW mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c4c9479bd4c830dbdece9bb0d25aef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4c9479bd4c830dbdece9bb0d25aef9">&#9670;&nbsp;</a></span>os_file_handle_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool os_file_handle_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does error handling when a file operation fails. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if we should retry the operation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: name of a file or NULL </td></tr>
    <tr><td class="paramname">operation</td><td>in: operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7932799ed826d659f59842d016c46da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7932799ed826d659f59842d016c46da0">&#9670;&nbsp;</a></span>os_file_handle_error_cond_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool os_file_handle_error_cond_exit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>should_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>on_error_silent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does error handling when a file operation fails. Conditionally exits (calling exit(3)) based on should_exit value and the error type, if should_exit is TRUE then on_error_silent is ignored. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if we should retry the operation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: name of a file or NULL </td></tr>
    <tr><td class="paramname">operation</td><td>in: operation </td></tr>
    <tr><td class="paramname">should_exit</td><td>in: call exit(3) if unknown error and this parameter is TRUE </td></tr>
    <tr><td class="paramname">on_error_silent</td><td>in: if TRUE then don't print any message to the log iff it is an unknown non-fatal error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16dbd15aa32cc9c8001afeece735d839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dbd15aa32cc9c8001afeece735d839">&#9670;&nbsp;</a></span>os_file_handle_error_no_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool os_file_handle_error_no_exit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>on_error_silent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does error handling when a file operation fails. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if we should retry the operation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: name of a file or NULL </td></tr>
    <tr><td class="paramname">operation</td><td>in: operation </td></tr>
    <tr><td class="paramname">on_error_silent</td><td>in: if TRUE then don't print any message to the log. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8c6a1051f9b0cf0317d8ef415bca3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c6a1051f9b0cf0317d8ef415bca3ca">&#9670;&nbsp;</a></span>os_file_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int os_file_lock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Obtain an exclusive lock on a file. </p><dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>in: file descriptor </td></tr>
    <tr><td class="paramname">name</td><td>in: file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70d63b1e4fc0cd44ad040f53c664dee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d63b1e4fc0cd44ad040f53c664dee3">&#9670;&nbsp;</a></span>os_file_make_data_dir_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_file_make_data_dir_path </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data_dir_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reduces a null-terminated full remote path name into the path that is sent by MySQL for DATA DIRECTORY clause. It replaces the 'databasename/tablename.ibd' found at the end of the path with just 'tablename'.</p>
<p>Since the result is always smaller than the path sent in, no new memory is allocated. The caller should allocate memory for the path sent in. This function manipulates that path in place.</p>
<p>If the path format is not as expected, just return. The result is used to inform a SHOW CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_dir_path</td><td>in/out: full path/data_dir_path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a796715958495d83522411dc756f16b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796715958495d83522411dc756f16b46">&#9670;&nbsp;</a></span>os_file_make_new_pathname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* os_file_make_new_pathname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>old_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tablename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a new path name after replacing the basename in an old path with a new basename. The old_path is a full path name including the extension. The tablename is in the normal form "databasename/tablename". The new base name is found after the forward slash. Both input strings are null terminated.</p>
<p>This function allocates memory to be returned. It is the callers responsibility to free the return value after it is no longer needed.</p>
<dl class="section return"><dt>Returns</dt><dd>own: new full pathname </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_path</td><td>in: pathname </td></tr>
    <tr><td class="paramname">tablename</td><td>in: contains new base name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98e2a4aaeed01eae50080bcf7a7698af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e2a4aaeed01eae50080bcf7a7698af">&#9670;&nbsp;</a></span>os_file_make_remote_pathname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* os_file_make_remote_pathname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data_dir_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tablename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extention</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a remote path name by combining a data directory path provided in a DATA DIRECTORY clause with the tablename which is in the form 'database/tablename'. It strips the file basename (which is the tablename) found after the last directory in the path provided. The full filepath created will include the database name as a directory under the path provided. The filename is the tablename with the '.ibd' extension. All input and output strings are null-terminated.</p>
<p>This function allocates memory to be returned. It is the callers responsibility to free the return value after it is no longer needed.</p>
<dl class="section return"><dt>Returns</dt><dd>own: A full pathname; data_dir_path/databasename/tablename.ibd </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_dir_path</td><td>in: pathname </td></tr>
    <tr><td class="paramname">tablename</td><td>in: tablename </td></tr>
    <tr><td class="paramname">extention</td><td>in: file extention; ibd,cfg </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec72ba70b5a085ac32c8b25bc06764c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec72ba70b5a085ac32c8b25bc06764c5">&#9670;&nbsp;</a></span>os_file_opendir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="os0file_8h.html#a996944ca087e0aab572f2b5ea990a108">os_file_dir_t</a> os_file_opendir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>error_is_fatal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="os0file_8cc.html#aec72ba70b5a085ac32c8b25bc06764c5">os_file_opendir()</a> function opens a directory stream corresponding to the directory named by the dirname argument. The directory stream is positioned at the first entry. In both Unix and Windows we automatically skip the '.' and '..' items at the start of the directory listing. </p><dl class="section return"><dt>Returns</dt><dd>directory stream, NULL if error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirname</td><td>in: directory name; it must not contain a trailing '\' or '/' </td></tr>
    <tr><td class="paramname">error_is_fatal</td><td>in: TRUE if we should treat an error as a fatal error; if we try to open symlinks then we do not wish a fatal error if it happens not to be a directory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02a9fca261bc4e6d999ef3e76cd645c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a9fca261bc4e6d999ef3e76cd645c0">&#9670;&nbsp;</a></span>os_file_read_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_read_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_file_read(), not directly this function! Requests a synchronous positioned read operation. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if request was successful, FALSE if fail </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: handle to a file </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer where to read </td></tr>
    <tr><td class="paramname">offset</td><td>in: file offset where to read </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a426bd41a56e5e5df1632705a7f31ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426bd41a56e5e5df1632705a7f31ed4a">&#9670;&nbsp;</a></span>os_file_read_no_error_handling_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_read_no_error_handling_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_file_read_no_error_handling(), not directly this function! Requests a synchronous positioned read operation. This function does not do any error handling. In case of error it returns FALSE. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if request was successful, FALSE if fail </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: handle to a file </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer where to read </td></tr>
    <tr><td class="paramname">offset</td><td>in: file offset where to read </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9074411e8dcbe515d176e37e17bf2275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9074411e8dcbe515d176e37e17bf2275">&#9670;&nbsp;</a></span>os_file_read_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_file_read_string </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rewind file to its start, read at most size - 1 bytes from it to str, and NUL-terminate str. All errors are silently ignored. This function is mostly meant to be used with temporary files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file to read from </td></tr>
    <tr><td class="paramname">str</td><td>in: buffer where to read </td></tr>
    <tr><td class="paramname">size</td><td>in: size of buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c4c24bb3f7cd4ab3ba2d999211e73ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4c24bb3f7cd4ab3ba2d999211e73ab">&#9670;&nbsp;</a></span>os_file_readdir_next_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int os_file_readdir_next_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a996944ca087e0aab572f2b5ea990a108">os_file_dir_t</a>&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structos__file__stat__t.html">os_file_stat_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns information of the next file in the directory. We jump over the '.' and '..' entries in the directory. </p><dl class="section return"><dt>Returns</dt><dd>0 if ok, -1 if error, 1 if at the end of the directory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirname</td><td>in: directory name or path </td></tr>
    <tr><td class="paramname">dir</td><td>in: directory stream </td></tr>
    <tr><td class="paramname">info</td><td>in/out: buffer where the info is returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a348f9838926e35b66bd806fd268e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a348f9838926e35b66bd806fd268e41">&#9670;&nbsp;</a></span>os_file_rename_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_rename_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_file_rename(), not directly this function! Renames a file (can also move it to another directory). It is safest that the file is closed before calling this function. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldpath</td><td>in: old file path as a null-terminated string </td></tr>
    <tr><td class="paramname">newpath</td><td>in: new file path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2e549d39193f5001490bea74205cbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e549d39193f5001490bea74205cbe7">&#9670;&nbsp;</a></span>os_file_set_eof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_set_eof </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncates a file at its current position. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file to be truncated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a95c7680bfb6a3d8947c3ea38234fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a95c7680bfb6a3d8947c3ea38234fef">&#9670;&nbsp;</a></span>os_file_set_nocache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_file_set_nocache </td>
          <td>(</td>
          <td class="paramtype">int <a class="el" href="row0merge_8cc.html#a2ba07eb1dd7b9899cf7b132635a757e8">fd</a> &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *file_name &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *operation_name &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to disable OS caching on an opened file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__attribute__</td><td>in: file descriptor to alter </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in: used in the diagnostic message </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in: "open" or "create"; used in the diagnostic message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1985f8956372cc3ad5c180366609c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1985f8956372cc3ad5c180366609c35">&#9670;&nbsp;</a></span>os_file_set_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_set_size </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the specified number of zeros to a newly created file. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: name of the file or path as a null-terminated string </td></tr>
    <tr><td class="paramname">file</td><td>in: handle to a file </td></tr>
    <tr><td class="paramname">size</td><td>in: file size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00929749c1e5d29cce51953039eb80c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00929749c1e5d29cce51953039eb80c0">&#9670;&nbsp;</a></span>os_file_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_status </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>exists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">os_file_type_t *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> the existence and type of the given file. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if call succeeded </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>in: pathname of the file </td></tr>
    <tr><td class="paramname">exists</td><td>out: TRUE if file exists </td></tr>
    <tr><td class="paramname">type</td><td>out: type of the file (if it exists) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af47fc33904c25b07286cbfa323adcde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47fc33904c25b07286cbfa323adcde0">&#9670;&nbsp;</a></span>os_file_write_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_file_write_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a63fac270d46d4a195e833a6672729041">os_file_t</a>&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro os_file_write(), not directly this function! Requests a synchronous write operation. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if request was successful, FALSE if fail </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: name of the file or path as a null-terminated string </td></tr>
    <tr><td class="paramname">file</td><td>in: handle to a file </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer from which to write </td></tr>
    <tr><td class="paramname">offset</td><td>in: file offset where to write </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acad7a0ea5c874babeeec9529437903f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7a0ea5c874babeeec9529437903f5">&#9670;&nbsp;</a></span>os_io_init_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void os_io_init_simple </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the seek mutexes used in positioned reads and writes. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0ccd7535cf45ea4a389b855324c47142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccd7535cf45ea4a389b855324c47142">&#9670;&nbsp;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* buf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: handle to a file in: buffer where to read</p>
<p>&lt; in: handle to a file in: buffer from where to write </p>

</div>
</div>
<a id="a0544c3fe466e421738dae463968b70ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0544c3fe466e421738dae463968b70ba">&#9670;&nbsp;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">                        ret = read(<a class="code" href="row0import_8cc.html#a79854d43ae87cec96a59d17fc4141bf0">file</a>, <a class="code" href="os0file_8cc.html#a0ccd7535cf45ea4a389b855324c47142">buf</a>, (ssize_t) <a class="code" href="os0file_8cc.html#a0d81b35641c779f299e102dad1d38772">n</a>)</div><div class="ttc" id="os0file_8cc_html_a0d81b35641c779f299e102dad1d38772"><div class="ttname"><a href="os0file_8cc.html#a0d81b35641c779f299e102dad1d38772">n</a></div><div class="ttdeci">static void ulint n</div><div class="ttdef"><b>Definition:</b> os0file.cc:2341</div></div>
<div class="ttc" id="row0import_8cc_html_a79854d43ae87cec96a59d17fc4141bf0"><div class="ttname"><a href="row0import_8cc.html#a79854d43ae87cec96a59d17fc4141bf0">file</a></div><div class="ttdeci">static FILE * file</div><div class="ttdef"><b>Definition:</b> row0import.cc:3147</div></div>
<div class="ttc" id="os0file_8cc_html_a0ccd7535cf45ea4a389b855324c47142"><div class="ttname"><a href="os0file_8cc.html#a0ccd7535cf45ea4a389b855324c47142">buf</a></div><div class="ttdeci">static void * buf</div><div class="ttdef"><b>Definition:</b> os0file.cc:2341</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3005ab640b66ac348a554702826740b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3005ab640b66ac348a554702826740b2">&#9670;&nbsp;</a></span>IO_IBUF_SEGMENT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint IO_IBUF_SEGMENT = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert buffer segment id </p>

</div>
</div>
<a id="ac4675fb2405ca3423866309be1629296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4675fb2405ca3423866309be1629296">&#9670;&nbsp;</a></span>IO_LOG_SEGMENT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint IO_LOG_SEGMENT = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Log segment id </p>

</div>
</div>
<a id="a0d81b35641c779f299e102dad1d38772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d81b35641c779f299e102dad1d38772">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const void ulint n</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: number of bytes to read</p>
<p>in: number of bytes to write </p>

</div>
</div>
<a id="a7b6b91e619d6e5e1a8a9f7da64bc0cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">&#9670;&nbsp;</a></span>offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void ulint <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        off_t   offs</div></div><!-- fragment --><p>&lt; in: file offset from where to read</p>
<p>&lt; in: file offset where to write </p>

</div>
</div>
<a id="a4c18159f88831af48ae18685dc01f05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c18159f88831af48ae18685dc01f05d">&#9670;&nbsp;</a></span>os_aio_ibuf_array</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a>* os_aio_ibuf_array = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert buffer </p>

</div>
</div>
<a id="ab32e8a8b4ff815c942817cd758d2b50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32e8a8b4ff815c942817cd758d2b50f">&#9670;&nbsp;</a></span>os_aio_log_array</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a>* os_aio_log_array = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Redo log </p>

</div>
</div>
<a id="a9d383a7b01d6cadbce8b34c5dd84d351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d383a7b01d6cadbce8b34c5dd84d351">&#9670;&nbsp;</a></span>os_aio_n_segments</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint os_aio_n_segments = ULINT_UNDEFINED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of asynchronous I/O segments. Set by os_aio_init(). </p>

</div>
</div>
<a id="ab39b720a9783ad425897a0fb2016f52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39b720a9783ad425897a0fb2016f52a">&#9670;&nbsp;</a></span>os_aio_print_debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool os_aio_print_debug = FALSE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag: enable debug printout for asynchronous i/o </p>

</div>
</div>
<a id="a1e9e694ab905f589be7b5f05dcc799ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9e694ab905f589be7b5f05dcc799ca">&#9670;&nbsp;</a></span>os_aio_read_array</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a>* os_aio_read_array = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The aio arrays for non-ibuf i/o and ibuf i/o, as well as sync aio. These are NULL when the module has not yet been initialized. Reads </p>

</div>
</div>
<a id="a46255dd1c1323c7382dc47ea6de0e55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46255dd1c1323c7382dc47ea6de0e55b">&#9670;&nbsp;</a></span>os_aio_recommend_sleep_for_read_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ibool os_aio_recommend_sleep_for_read_threads = FALSE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the following is TRUE, read i/o handler threads try to wait until a batch of new read requests have been posted </p>

</div>
</div>
<a id="a27a7e977c4664bfafd789accd5a83807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a7e977c4664bfafd789accd5a83807">&#9670;&nbsp;</a></span>os_aio_segment_wait_events</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>* os_aio_segment_wait_events = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of events used in simulated aio </p>

</div>
</div>
<a id="a93c6d6d978e6c77efa8c74485000bb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c6d6d978e6c77efa8c74485000bb4c">&#9670;&nbsp;</a></span>os_aio_sync_array</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a>* os_aio_sync_array = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronous I/O </p>

</div>
</div>
<a id="aae89d8e8f508604393b49a76a9b4459b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae89d8e8f508604393b49a76a9b4459b">&#9670;&nbsp;</a></span>os_aio_write_array</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structos__aio__array__t.html">os_aio_array_t</a>* os_aio_write_array = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes </p>

</div>
</div>
<a id="a19f031a59dad1b34009a91bc8b0f9ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f031a59dad1b34009a91bc8b0f9ccf">&#9670;&nbsp;</a></span>os_file_count_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0sync_8h.html#a21c139c6cdbef5b007a02633f2d4732a">os_ib_mutex_t</a> os_file_count_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The mutex protecting the following counts of pending I/O operations </p>

</div>
</div>
<a id="aa84df4f50e6d9ad06e77a1bca9aee299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84df4f50e6d9ad06e77a1bca9aee299">&#9670;&nbsp;</a></span>os_file_n_pending_preads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint os_file_n_pending_preads = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of pending os_file_pread() operations </p>

</div>
</div>
<a id="a9014f7202605010fa78e935626819644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9014f7202605010fa78e935626819644">&#9670;&nbsp;</a></span>os_file_n_pending_pwrites</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint os_file_n_pending_pwrites = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of pending os_file_pwrite() operations </p>

</div>
</div>
<a id="a7af12437c3bc2170683b6d7a623b0be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af12437c3bc2170683b6d7a623b0be0">&#9670;&nbsp;</a></span>os_innodb_umask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint os_innodb_umask = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Umask for creating files </p>

</div>
</div>
<a id="a0fd13091d80098ac72b4f0a053157a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd13091d80098ac72b4f0a053157a28">&#9670;&nbsp;</a></span>os_n_pending_reads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os_n_pending_reads = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of pending read operations </p>

</div>
</div>
<a id="abc5466be6ac70d2b680a141a16b40078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5466be6ac70d2b680a141a16b40078">&#9670;&nbsp;</a></span>os_n_pending_writes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">os_n_pending_writes = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of pending write operations </p>

</div>
</div>
<a id="af1ec77bdca1b30e8153fc5da88f603db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ec77bdca1b30e8153fc5da88f603db">&#9670;&nbsp;</a></span>ret</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ret</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">                off_t   ret_offset</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

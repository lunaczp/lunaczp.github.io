<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/lock/lock0lock.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_a92a0f1911438c718531eeaff646b0b5.html">lock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lock0lock.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0priv_8h_source.html">lock0priv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="usr0sess_8h_source.html">usr0sess.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0purge_8h_source.html">trx0purge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0sys_8h_source.html">trx0sys.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0pars_8h_source.html">pars0pars.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0sel_8h_source.html">row0sel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0types_8h_source.html">row0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0vec_8h_source.html">ut0vec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &lt;set&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__stack__t.html">lock_stack_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a390c44e3d017379682adbfa150f2c631"><td class="memItemLeft" align="right" valign="top"><a id="a390c44e3d017379682adbfa150f2c631"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOCK_MODULE_IMPLEMENTATION</b></td></tr>
<tr class="separator:a390c44e3d017379682adbfa150f2c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70475cef2dee890261b277531173ce7"><td class="memItemLeft" align="right" valign="top"><a id="ac70475cef2dee890261b277531173ce7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOCK_MAX_N_STEPS_IN_DEADLOCK_CHECK</b>&#160;&#160;&#160;1000000</td></tr>
<tr class="separator:ac70475cef2dee890261b277531173ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb0b496a760a3ac78a572c298d3c20c"><td class="memItemLeft" align="right" valign="top"><a id="a7eb0b496a760a3ac78a572c298d3c20c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOCK_MAX_DEPTH_IN_DEADLOCK_CHECK</b>&#160;&#160;&#160;200</td></tr>
<tr class="separator:a7eb0b496a760a3ac78a572c298d3c20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734eb43a6fbe6acc07803e817dc8ac62"><td class="memItemLeft" align="right" valign="top"><a id="a734eb43a6fbe6acc07803e817dc8ac62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOCK_RELEASE_INTERVAL</b>&#160;&#160;&#160;1000</td></tr>
<tr class="separator:a734eb43a6fbe6acc07803e817dc8ac62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40562753c484b8c8b8fd9a81d02a45e"><td class="memItemLeft" align="right" valign="top"><a id="ac40562753c484b8c8b8fd9a81d02a45e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOCK_PAGE_BITMAP_MARGIN</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:ac40562753c484b8c8b8fd9a81d02a45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd8f791bb5aaaa79c0239d113ae7f8e"><td class="memItemLeft" align="right" valign="top"><a id="adcd8f791bb5aaaa79c0239d113ae7f8e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOCK_STACK_SIZE</b>&#160;&#160;&#160;OS_THREAD_MAX_N</td></tr>
<tr class="separator:adcd8f791bb5aaaa79c0239d113ae7f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eacd97c10ba9d402e9cfc92ab09c4e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0eacd97c10ba9d402e9cfc92ab09c4e4">lock_deadlock_too_deep</a>(c)</td></tr>
<tr class="separator:a0eacd97c10ba9d402e9cfc92ab09c4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b942151a21e8458664d68a9ccfc491"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>IS_LOCK_S_OR_X</b>(lock)</td></tr>
<tr class="separator:ac6b942151a21e8458664d68a9ccfc491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aaa98e1bd917f95280993475788ea6c5b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aaa98e1bd917f95280993475788ea6c5b">lock_rec_req_status</a> { <a class="el" href="lock0lock_8cc.html#aaa98e1bd917f95280993475788ea6c5ba12a47b5e4d2d01853958ecbc0513bb31">LOCK_REC_FAIL</a>, 
<a class="el" href="lock0lock_8cc.html#aaa98e1bd917f95280993475788ea6c5ba4f02aa53c8580c293151a57282bdbdd6">LOCK_REC_SUCCESS</a>, 
<a class="el" href="lock0lock_8cc.html#aaa98e1bd917f95280993475788ea6c5bab91e6212faed445182df02ef9497f066">LOCK_REC_SUCCESS_CREATED</a>
 }</td></tr>
<tr class="separator:aaa98e1bd917f95280993475788ea6c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aab92b6e71a634f6e5312366c074d1686"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aab92b6e71a634f6e5312366c074d1686">lock_deadlock_check_and_resolve</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:aab92b6e71a634f6e5312366c074d1686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f9160da82c4cef15d4eec1a0d59014"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa4f9160da82c4cef15d4eec1a0d59014">lock_rec_get_nth_bit</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>)</td></tr>
<tr class="separator:aa4f9160da82c4cef15d4eec1a0d59014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af404570474674730be01e3108d8725c3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af404570474674730be01e3108d8725c3">lock_report_trx_id_insanity</a> (<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> max_trx_id)</td></tr>
<tr class="separator:af404570474674730be01e3108d8725c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb9d1ec4975bd153f29b816e1ab1951"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a1cb9d1ec4975bd153f29b816e1ab1951">__attribute__</a> ((nonnull, warn_unused_result)) bool lock_check_trx_id_sanity(<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a></td></tr>
<tr class="separator:a1cb9d1ec4975bd153f29b816e1ab1951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b062ae162ff1ce6055d7bad39fd187"><td class="memItemLeft" align="right" valign="top"><a id="ad0b062ae162ff1ce6055d7bad39fd187"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (rec_offs_validate(<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>))</td></tr>
<tr class="separator:ad0b062ae162ff1ce6055d7bad39fd187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e123a9544d8ea2c2f879bbe031c1d1"><td class="memItemLeft" align="right" valign="top"><a id="a23e123a9544d8ea2c2f879bbe031c1d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (UNIV_UNLIKELY(!is_ok))</td></tr>
<tr class="separator:a23e123a9544d8ea2c2f879bbe031c1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad656c1c0b824748162bfd686ab1d0e59"><td class="memItemLeft" align="right" valign="top"><a id="ad656c1c0b824748162bfd686ab1d0e59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (is_ok)</td></tr>
<tr class="separator:ad656c1c0b824748162bfd686ab1d0e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac202bf2346684b96cfecca70ad64b002"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac202bf2346684b96cfecca70ad64b002">lock_clust_rec_cons_read_sees</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structread__view__t.html">read_view_t</a> *view)</td></tr>
<tr class="separator:ac202bf2346684b96cfecca70ad64b002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abece67995cb917a6ccca6cacfba18268"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#abece67995cb917a6ccca6cacfba18268">lock_sec_rec_cons_read_sees</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const <a class="el" href="structread__view__t.html">read_view_t</a> *view)</td></tr>
<tr class="separator:abece67995cb917a6ccca6cacfba18268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ad348feb00e96aec397b06dbec7c64"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a40ad348feb00e96aec397b06dbec7c64">lock_sys_create</a> (ulint n_cells)</td></tr>
<tr class="separator:a40ad348feb00e96aec397b06dbec7c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2350ce483b08686c48c19407f63da9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a9c2350ce483b08686c48c19407f63da9">lock_sys_close</a> (void)</td></tr>
<tr class="separator:a9c2350ce483b08686c48c19407f63da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6d281988732c472d3e0f7eac4d6e4e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#afd6d281988732c472d3e0f7eac4d6e4e">lock_get_size</a> (void)</td></tr>
<tr class="separator:afd6d281988732c472d3e0f7eac4d6e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ba4d837532fb8eaf414d1cbaaf6d90"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum lock_mode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae4ba4d837532fb8eaf414d1cbaaf6d90">lock_get_mode</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ae4ba4d837532fb8eaf414d1cbaaf6d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39e45b1c0a23547fa21a02c765bcd29"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac39e45b1c0a23547fa21a02c765bcd29">lock_get_wait</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ac39e45b1c0a23547fa21a02c765bcd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663621ff9b0550c0f2caa5fe6facc3e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab663621ff9b0550c0f2caa5fe6facc3e">lock_get_src_table</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *dest, enum lock_mode *<a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:ab663621ff9b0550c0f2caa5fe6facc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68837200e8d73d4a74adecbed644284c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a68837200e8d73d4a74adecbed644284c">lock_is_table_exclusive</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a68837200e8d73d4a74adecbed644284c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa923691edf4a6cdaa775da9ca6389bd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#afa923691edf4a6cdaa775da9ca6389bd">lock_set_lock_and_trx_wait</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:afa923691edf4a6cdaa775da9ca6389bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae338c146d2999b264f77019e7a30fe76"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae338c146d2999b264f77019e7a30fe76">lock_reset_lock_and_trx_wait</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ae338c146d2999b264f77019e7a30fe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419d78b85193924e945f2313a60f7ccf"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a419d78b85193924e945f2313a60f7ccf">lock_rec_get_gap</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a419d78b85193924e945f2313a60f7ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea241051962fafa069de83516f0df01"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8ea241051962fafa069de83516f0df01">lock_rec_get_rec_not_gap</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a8ea241051962fafa069de83516f0df01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc4fc3dd2500ccd00e4139c4ccba75a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aedc4fc3dd2500ccd00e4139c4ccba75a">lock_rec_get_insert_intention</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:aedc4fc3dd2500ccd00e4139c4ccba75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e367e26e46cbf73185fff7c00773762"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a2e367e26e46cbf73185fff7c00773762">lock_mode_stronger_or_eq</a> (enum lock_mode mode1, enum lock_mode mode2)</td></tr>
<tr class="separator:a2e367e26e46cbf73185fff7c00773762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07853bb83e125e4902a66d61cf24a658"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a07853bb83e125e4902a66d61cf24a658">lock_mode_compatible</a> (enum lock_mode mode1, enum lock_mode mode2)</td></tr>
<tr class="separator:a07853bb83e125e4902a66d61cf24a658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71060eddf2bdcec23b9d0cca21c2de51"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a71060eddf2bdcec23b9d0cca21c2de51">lock_rec_has_to_wait</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, ulint type_mode, const <a class="el" href="structlock__t.html">lock_t</a> *lock2, ibool lock_is_on_supremum)</td></tr>
<tr class="separator:a71060eddf2bdcec23b9d0cca21c2de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa82401a7f43bcd7ee507b462151b50"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a4fa82401a7f43bcd7ee507b462151b50">lock_has_to_wait</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock1, const <a class="el" href="structlock__t.html">lock_t</a> *lock2)</td></tr>
<tr class="separator:a4fa82401a7f43bcd7ee507b462151b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb79a43f5b92cea073f2cde49949308"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3bb79a43f5b92cea073f2cde49949308">lock_rec_get_n_bits</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a3bb79a43f5b92cea073f2cde49949308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb59e5d76d0647bfbc4096682228f3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae0cb59e5d76d0647bfbc4096682228f3">lock_rec_set_nth_bit</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>)</td></tr>
<tr class="separator:ae0cb59e5d76d0647bfbc4096682228f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac31e933724030fe1aca76ebbd1b524"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aeac31e933724030fe1aca76ebbd1b524">lock_rec_find_set_bit</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:aeac31e933724030fe1aca76ebbd1b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4bf8780dfc2730a445dcb2e894d10d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#adb4bf8780dfc2730a445dcb2e894d10d">lock_rec_reset_nth_bit</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>)</td></tr>
<tr class="separator:adb4bf8780dfc2730a445dcb2e894d10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0d0d9c1d6281cbe1a248f29d9e6dd7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6c0d0d9c1d6281cbe1a248f29d9e6dd7">lock_rec_get_next_on_page_const</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a6c0d0d9c1d6281cbe1a248f29d9e6dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e694a3a47a498c55bd09c5127b162a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad0e694a3a47a498c55bd09c5127b162a">lock_rec_get_next_on_page</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ad0e694a3a47a498c55bd09c5127b162a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2927c070cf3f5f1482a876b7fde40e03"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a2927c070cf3f5f1482a876b7fde40e03">lock_rec_get_first_on_page_addr</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a2927c070cf3f5f1482a876b7fde40e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01375d9e473384eb738bdf18b1f24afd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a01375d9e473384eb738bdf18b1f24afd">lock_rec_expl_exist_on_page</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a01375d9e473384eb738bdf18b1f24afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ae4db39ec1f10581c7b3636970f4e7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae5ae4db39ec1f10581c7b3636970f4e7">lock_rec_get_first_on_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:ae5ae4db39ec1f10581c7b3636970f4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f2ac5cbb634ee6ef9663ba8bf4bbab"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a81f2ac5cbb634ee6ef9663ba8bf4bbab">lock_rec_get_next</a> (ulint heap_no, <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a81f2ac5cbb634ee6ef9663ba8bf4bbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf1fd0b7f60894fecee9005803e62fa"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a9cf1fd0b7f60894fecee9005803e62fa">lock_rec_get_next_const</a> (ulint heap_no, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a9cf1fd0b7f60894fecee9005803e62fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c7ea975c47752cc3f2615273f33664"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a05c7ea975c47752cc3f2615273f33664">lock_rec_get_first</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no)</td></tr>
<tr class="separator:a05c7ea975c47752cc3f2615273f33664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a11bee90995105efe9a0942e37b6349"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3a11bee90995105efe9a0942e37b6349">lock_rec_bitmap_reset</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a3a11bee90995105efe9a0942e37b6349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179a520c4a10f93bc52ed52b9abb8a81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a179a520c4a10f93bc52ed52b9abb8a81">lock_rec_copy</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a179a520c4a10f93bc52ed52b9abb8a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade1802065fed76d7f256fa097307084"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aade1802065fed76d7f256fa097307084">lock_rec_get_prev</a> (const <a class="el" href="structlock__t.html">lock_t</a> *in_lock, ulint heap_no)</td></tr>
<tr class="separator:aade1802065fed76d7f256fa097307084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d7ad8612a3da20e8b11ee4b4654e3b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad2d7ad8612a3da20e8b11ee4b4654e3b">lock_table_has</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:ad2d7ad8612a3da20e8b11ee4b4654e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a191d29bbdaff834703239f4c9b922"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae0a191d29bbdaff834703239f4c9b922">lock_rec_has_expl</a> (ulint precise_mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:ae0a191d29bbdaff834703239f4c9b922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b3c827b80e8066404ef903f4407280"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a34b3c827b80e8066404ef903f4407280">lock_rec_other_has_conflicting</a> (enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a34b3c827b80e8066404ef903f4407280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f29678241bd9c3322db91ea3fc85c94"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3f29678241bd9c3322db91ea3fc85c94">lock_rec_find_similar_on_page</a> (ulint type_mode, ulint heap_no, <a class="el" href="structlock__t.html">lock_t</a> *lock, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a3f29678241bd9c3322db91ea3fc85c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d9cf52dcadcc1b217b6b3367f30f79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac5d9cf52dcadcc1b217b6b3367f30f79">lock_sec_rec_some_has_impl</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:ac5d9cf52dcadcc1b217b6b3367f30f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef81d372b4a6e02f4fc13e67a7fdb2f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#adef81d372b4a6e02f4fc13e67a7fdb2f">lock_number_of_rows_locked</a> (const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *trx_lock)</td></tr>
<tr class="separator:adef81d372b4a6e02f4fc13e67a7fdb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13184f2bbc8b127132a46bdbdaaee93c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a13184f2bbc8b127132a46bdbdaaee93c">lock_rec_create</a> (ulint type_mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, ibool caller_owns_trx_mutex)</td></tr>
<tr class="separator:a13184f2bbc8b127132a46bdbdaaee93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac045d8f54f3ae1f765109a0f2456339c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac045d8f54f3ae1f765109a0f2456339c">lock_rec_enqueue_waiting</a> (ulint type_mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:ac045d8f54f3ae1f765109a0f2456339c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0ad21b1ad09504c76685f1e32a79a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aad0ad21b1ad09504c76685f1e32a79a0">lock_rec_add_to_queue</a> (ulint type_mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, ibool caller_owns_trx_mutex)</td></tr>
<tr class="separator:aad0ad21b1ad09504c76685f1e32a79a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a4ad622cc9e5f690f70eac443efc23"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="lock0lock_8cc.html#aaa98e1bd917f95280993475788ea6c5b">lock_rec_req_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af0a4ad622cc9e5f690f70eac443efc23">lock_rec_lock_fast</a> (ibool impl, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:af0a4ad622cc9e5f690f70eac443efc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d58301a21d567272448359864b0e72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a69d58301a21d567272448359864b0e72">lock_rec_lock_slow</a> (ibool impl, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a69d58301a21d567272448359864b0e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59de8e5096cf57ff11c57d62345c70bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a59de8e5096cf57ff11c57d62345c70bd">lock_rec_lock</a> (ibool impl, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a59de8e5096cf57ff11c57d62345c70bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114997c30ec246f1aabf3ffb55dab5e7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a114997c30ec246f1aabf3ffb55dab5e7">lock_rec_has_to_wait_in_queue</a> (const <a class="el" href="structlock__t.html">lock_t</a> *wait_lock)</td></tr>
<tr class="separator:a114997c30ec246f1aabf3ffb55dab5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81303597fbce84d2814fb10f02a75cb4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a81303597fbce84d2814fb10f02a75cb4">lock_grant</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a81303597fbce84d2814fb10f02a75cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa77b9fe490eac4349341da3a689dad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7aa77b9fe490eac4349341da3a689dad">lock_rec_cancel</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a7aa77b9fe490eac4349341da3a689dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400624ff6ae565a75b2894787172c809"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a400624ff6ae565a75b2894787172c809">lock_rec_dequeue_from_page</a> (<a class="el" href="structlock__t.html">lock_t</a> *in_lock)</td></tr>
<tr class="separator:a400624ff6ae565a75b2894787172c809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb594cf2620c92acb160e0286af6bfd7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aeb594cf2620c92acb160e0286af6bfd7">lock_rec_discard</a> (<a class="el" href="structlock__t.html">lock_t</a> *in_lock)</td></tr>
<tr class="separator:aeb594cf2620c92acb160e0286af6bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4babb224a5aaab775bec465892075a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a4a4babb224a5aaab775bec465892075a">lock_rec_free_all_from_discard_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a4a4babb224a5aaab775bec465892075a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a39c043b7a0da7ad896f9c8b1784d19"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6a39c043b7a0da7ad896f9c8b1784d19">lock_rec_reset_and_release_wait</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heap_no)</td></tr>
<tr class="separator:a6a39c043b7a0da7ad896f9c8b1784d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71a1e16ac85a11e9ac1f3111f707439"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad71a1e16ac85a11e9ac1f3111f707439">lock_rec_inherit_to_gap</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heir_heap_no, ulint heap_no)</td></tr>
<tr class="separator:ad71a1e16ac85a11e9ac1f3111f707439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb009afd28d954b9ba74693b823b4ad3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#acb009afd28d954b9ba74693b823b4ad3">lock_rec_inherit_to_gap_if_gap_lock</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heir_heap_no, ulint heap_no)</td></tr>
<tr class="separator:acb009afd28d954b9ba74693b823b4ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8800d3f6097fe1058fbea7ddcff18f1f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8800d3f6097fe1058fbea7ddcff18f1f">lock_rec_move</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *receiver, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *donator, ulint receiver_heap_no, ulint donator_heap_no)</td></tr>
<tr class="separator:a8800d3f6097fe1058fbea7ddcff18f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7273b2c3c75e90408bdc5a711effc73a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7273b2c3c75e90408bdc5a711effc73a">lock_move_reorganize_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *oblock)</td></tr>
<tr class="separator:a7273b2c3c75e90408bdc5a711effc73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb43b7be638bd32fa36b7c025d636bb6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#adb43b7be638bd32fa36b7c025d636bb6">lock_move_rec_list_end</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:adb43b7be638bd32fa36b7c025d636bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e7197a446aee79574d335d277aaa84"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a23e7197a446aee79574d335d277aaa84">lock_move_rec_list_start</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const rec_t *old_end)</td></tr>
<tr class="separator:a23e7197a446aee79574d335d277aaa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd5be77aa944f96aa6ff0aeebc6eb98"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a9cd5be77aa944f96aa6ff0aeebc6eb98">lock_update_split_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="separator:a9cd5be77aa944f96aa6ff0aeebc6eb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2bdadfd1e57ddbedfc05740e884eb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a9ec2bdadfd1e57ddbedfc05740e884eb">lock_update_merge_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const rec_t *orig_succ, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="separator:a9ec2bdadfd1e57ddbedfc05740e884eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e3b8ed16aaab0770730fb554e23af2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a82e3b8ed16aaab0770730fb554e23af2">lock_update_root_raise</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *root)</td></tr>
<tr class="separator:a82e3b8ed16aaab0770730fb554e23af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc8f00508ee648886c7d51046af30d1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6cc8f00508ee648886c7d51046af30d1">lock_update_copy_and_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a6cc8f00508ee648886c7d51046af30d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5beb29b82077fbb4080d16b8214c1d57"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a5beb29b82077fbb4080d16b8214c1d57">lock_update_split_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="separator:a5beb29b82077fbb4080d16b8214c1d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742d185fcf374672c516427602f386eb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a742d185fcf374672c516427602f386eb">lock_update_merge_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block, const rec_t *orig_pred, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block)</td></tr>
<tr class="separator:a742d185fcf374672c516427602f386eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a1ced4eeb3daa98b39ee2365df8b1a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af1a1ced4eeb3daa98b39ee2365df8b1a">lock_rec_reset_and_inherit_gap_locks</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heir_heap_no, ulint heap_no)</td></tr>
<tr class="separator:af1a1ced4eeb3daa98b39ee2365df8b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d322cfc717fe99e4c5c88f7b93512e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a47d322cfc717fe99e4c5c88f7b93512e">lock_update_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, ulint heir_heap_no, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a47d322cfc717fe99e4c5c88f7b93512e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b800d596ae20af9b8b28f7a879658b4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7b800d596ae20af9b8b28f7a879658b4">lock_update_insert</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:a7b800d596ae20af9b8b28f7a879658b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd33b69b0b70f3e6643e70275550a0a7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#acd33b69b0b70f3e6643e70275550a0a7">lock_update_delete</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:acd33b69b0b70f3e6643e70275550a0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32bb2ec136f61df97fea7e90c94a7cf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad32bb2ec136f61df97fea7e90c94a7cf">lock_rec_store_on_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:ad32bb2ec136f61df97fea7e90c94a7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04f9ddc87db84d8621e853f1a3434db"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad04f9ddc87db84d8621e853f1a3434db">lock_rec_restore_from_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *donator)</td></tr>
<tr class="separator:ad04f9ddc87db84d8621e853f1a3434db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebf51c560b258971023da6814c75c9e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3ebf51c560b258971023da6814c75c9e">lock_deadlock_start_print</a> ()</td></tr>
<tr class="separator:a3ebf51c560b258971023da6814c75c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4083933abb4c7e11b3fcbca0a6d7fb8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa4083933abb4c7e11b3fcbca0a6d7fb8">lock_deadlock_fputs</a> (const char *<a class="el" href="structmsg.html">msg</a>)</td></tr>
<tr class="separator:aa4083933abb4c7e11b3fcbca0a6d7fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fb7a80748bc4151c18637baf6afa77"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a23fb7a80748bc4151c18637baf6afa77">lock_deadlock_trx_print</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, ulint max_query_len)</td></tr>
<tr class="separator:a23fb7a80748bc4151c18637baf6afa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd8d596cfb491be51c39f1bab8be695"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6cd8d596cfb491be51c39f1bab8be695">lock_deadlock_lock_print</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a6cd8d596cfb491be51c39f1bab8be695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63731d935046f872cc2ee54859cf9671"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a63731d935046f872cc2ee54859cf9671">lock_get_next_lock</a> (const <a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *ctx, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="separator:a63731d935046f872cc2ee54859cf9671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144a58113c1ddb7567b69508b4cde065"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a144a58113c1ddb7567b69508b4cde065">lock_get_first_lock</a> (const <a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *ctx, ulint *heap_no)</td></tr>
<tr class="separator:a144a58113c1ddb7567b69508b4cde065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70131aef19fe8cf6da43418b1419a60e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a70131aef19fe8cf6da43418b1419a60e">lock_deadlock_notify</a> (const <a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *ctx, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a70131aef19fe8cf6da43418b1419a60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5eb03d6fede3052a36ccff43c14b977"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa5eb03d6fede3052a36ccff43c14b977">lock_deadlock_select_victim</a> (const <a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *ctx)</td></tr>
<tr class="separator:aa5eb03d6fede3052a36ccff43c14b977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9d72cd0c0b5c4dc574f82d91374bd3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__stack__t.html">lock_stack_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a1b9d72cd0c0b5c4dc574f82d91374bd3">lock_deadlock_pop</a> (<a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *ctx)</td></tr>
<tr class="separator:a1b9d72cd0c0b5c4dc574f82d91374bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36641016a23b3b2ae76885e1044bf88"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlock__stack__t.html">lock_stack_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad36641016a23b3b2ae76885e1044bf88">lock_deadlock_push</a> (<a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *ctx, const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="separator:ad36641016a23b3b2ae76885e1044bf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea43e1e7b698b67e8d468f350b84c7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#afea43e1e7b698b67e8d468f350b84c7b">lock_deadlock_search</a> (<a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *ctx)</td></tr>
<tr class="separator:afea43e1e7b698b67e8d468f350b84c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97feac8a25aa1df891fa82e5c5525c85"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a97feac8a25aa1df891fa82e5c5525c85">lock_deadlock_joining_trx_print</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a97feac8a25aa1df891fa82e5c5525c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545f98c5b4c30da42a1b0bda5ed732df"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a545f98c5b4c30da42a1b0bda5ed732df">lock_deadlock_trx_rollback</a> (<a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *ctx)</td></tr>
<tr class="separator:a545f98c5b4c30da42a1b0bda5ed732df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184b272b7c4a2c9e49e7e973fbb2d4ed"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a184b272b7c4a2c9e49e7e973fbb2d4ed">lock_table_create</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ulint type_mode, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a184b272b7c4a2c9e49e7e973fbb2d4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae88eb4bd1862004641853bdac32e3da"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aae88eb4bd1862004641853bdac32e3da">lock_table_pop_autoinc_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:aae88eb4bd1862004641853bdac32e3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678cd8514367bc1b2b43d3df58ce5325"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a678cd8514367bc1b2b43d3df58ce5325">lock_table_remove_autoinc_lock</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a678cd8514367bc1b2b43d3df58ce5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3ef5a97ef26d0edfffcca4f4d413ed"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aab3ef5a97ef26d0edfffcca4f4d413ed">lock_table_remove_low</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:aab3ef5a97ef26d0edfffcca4f4d413ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc404f482d9124b4450bc71d73e69c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aadc404f482d9124b4450bc71d73e69c6">lock_table_enqueue_waiting</a> (ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:aadc404f482d9124b4450bc71d73e69c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d023c48cc94139eca00c9d769a310f6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a2d023c48cc94139eca00c9d769a310f6">lock_table_other_has_incompatible</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, ulint wait, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a2d023c48cc94139eca00c9d769a310f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208ea6edee519ebcc19db17c80378f78"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a208ea6edee519ebcc19db17c80378f78">lock_table</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a208ea6edee519ebcc19db17c80378f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056fa163c142cf71d21e6e3d046f060"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a1056fa163c142cf71d21e6e3d046f060">lock_table_ix_resurrect</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a1056fa163c142cf71d21e6e3d046f060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2eca8bb9a3dbb4068a6d8171cb064e6"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab2eca8bb9a3dbb4068a6d8171cb064e6">lock_table_has_to_wait_in_queue</a> (const <a class="el" href="structlock__t.html">lock_t</a> *wait_lock)</td></tr>
<tr class="separator:ab2eca8bb9a3dbb4068a6d8171cb064e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10e4db7d11e1b4a0a5d3afd17467334"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa10e4db7d11e1b4a0a5d3afd17467334">lock_table_dequeue</a> (<a class="el" href="structlock__t.html">lock_t</a> *in_lock)</td></tr>
<tr class="separator:aa10e4db7d11e1b4a0a5d3afd17467334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409999adb50ece16b81d59486af7af45"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a409999adb50ece16b81d59486af7af45">lock_rec_unlock</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, enum lock_mode lock_mode)</td></tr>
<tr class="separator:a409999adb50ece16b81d59486af7af45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8eda56dfbfc87c40fc55a96c779b32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#add8eda56dfbfc87c40fc55a96c779b32">lock_release</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:add8eda56dfbfc87c40fc55a96c779b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abfdceec128a59cd3c1ad2569bb3eaf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7abfdceec128a59cd3c1ad2569bb3eaf">lock_trx_table_locks_remove</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock_to_remove)</td></tr>
<tr class="separator:a7abfdceec128a59cd3c1ad2569bb3eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c114fec902791921c84d744e35e6f20"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a2c114fec902791921c84d744e35e6f20">lock_remove_all_on_table_for_trx</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, ibool remove_also_table_sx_locks)</td></tr>
<tr class="separator:a2c114fec902791921c84d744e35e6f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0441a5473b53bfbed8aeec335812c381"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0441a5473b53bfbed8aeec335812c381">lock_remove_recovered_trx_record_locks</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a0441a5473b53bfbed8aeec335812c381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430d15f2674ea7fb0d8cf61636192011"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a430d15f2674ea7fb0d8cf61636192011">lock_remove_all_on_table</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ibool remove_also_table_sx_locks)</td></tr>
<tr class="separator:a430d15f2674ea7fb0d8cf61636192011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf98b08ed2e93284570fc964e5b24c16"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#adf98b08ed2e93284570fc964e5b24c16">lock_table_print</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:adf98b08ed2e93284570fc964e5b24c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed491db1a4f9e54c46b5618fda1a72dd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aed491db1a4f9e54c46b5618fda1a72dd">lock_rec_print</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:aed491db1a4f9e54c46b5618fda1a72dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98a1fdd897f11f262a024ddc2574cf9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab98a1fdd897f11f262a024ddc2574cf9">lock_print_info_summary</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ibool nowait)</td></tr>
<tr class="separator:ab98a1fdd897f11f262a024ddc2574cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d8a6d0b9f2926b63ea83ec8b9633c7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a96d8a6d0b9f2926b63ea83ec8b9633c7">lock_print_info_all_transactions</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:a96d8a6d0b9f2926b63ea83ec8b9633c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f038fa965628091108d30f375ef42e2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8f038fa965628091108d30f375ef42e2">lock_rec_insert_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, ibool *<a class="el" href="btr0cur_8cc.html#aee6abb32bf6a300010a2c88fe98cc831">inherit</a>)</td></tr>
<tr class="separator:a8f038fa965628091108d30f375ef42e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6872a342e01b3ae5cc2132301afec259"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6872a342e01b3ae5cc2132301afec259">lock_rec_convert_impl_to_expl</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:a6872a342e01b3ae5cc2132301afec259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a6cd6546d2b402cdb77ce02676f310"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae4a6cd6546d2b402cdb77ce02676f310">lock_clust_rec_modify_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:ae4a6cd6546d2b402cdb77ce02676f310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2373909c1bb1ccbc7611c5bcc51bc86"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab2373909c1bb1ccbc7611c5bcc51bc86">lock_sec_rec_modify_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ab2373909c1bb1ccbc7611c5bcc51bc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d5f3bc41223f625ac09672a1ca19bf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab1d5f3bc41223f625ac09672a1ca19bf">lock_sec_rec_read_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:ab1d5f3bc41223f625ac09672a1ca19bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa600625a4fffa2b7f0a68cdd64b1ad3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:afa600625a4fffa2b7f0a68cdd64b1ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a2cbb97d47b65bd2efa1a3f094f09f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a05a2cbb97d47b65bd2efa1a3f094f09f">lock_clust_rec_read_check_and_lock_alt</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a05a2cbb97d47b65bd2efa1a3f094f09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16d93ff1543a5eb70bc252fc52410d7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af16d93ff1543a5eb70bc252fc52410d7">lock_release_autoinc_last_lock</a> (<a class="el" href="structib__vector__t.html">ib_vector_t</a> *autoinc_locks)</td></tr>
<tr class="separator:af16d93ff1543a5eb70bc252fc52410d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c508752770a8c80424e73aa7b0c70d1"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a4c508752770a8c80424e73aa7b0c70d1">lock_trx_holds_autoinc_locks</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a4c508752770a8c80424e73aa7b0c70d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0586798d137559b27f00d9212a565ed7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0586798d137559b27f00d9212a565ed7">lock_release_autoinc_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a0586798d137559b27f00d9212a565ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c17bbd1a704e818f0a9e93dcf7b0541"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3c17bbd1a704e818f0a9e93dcf7b0541">lock_get_type</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a3c17bbd1a704e818f0a9e93dcf7b0541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c9a06b5b21a1e4c04b5cafc68b6ccd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab9c9a06b5b21a1e4c04b5cafc68b6ccd">lock_get_trx_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ab9c9a06b5b21a1e4c04b5cafc68b6ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2809d68943d3e72cbfd11885126356"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ade2809d68943d3e72cbfd11885126356">lock_get_mode_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ade2809d68943d3e72cbfd11885126356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdf57695b21f5d522b265090787f5d4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a5bdf57695b21f5d522b265090787f5d4">lock_get_type_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a5bdf57695b21f5d522b265090787f5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f90ccf6fab644d41a404db1d27e948"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a88f90ccf6fab644d41a404db1d27e948">lock_get_table</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a88f90ccf6fab644d41a404db1d27e948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec13113aefe2d0c30da8e0b70d8529d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN table_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a5ec13113aefe2d0c30da8e0b70d8529d">lock_get_table_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a5ec13113aefe2d0c30da8e0b70d8529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec43fb602ff6a6cb8964d5c4c1c0d4f7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aec43fb602ff6a6cb8964d5c4c1c0d4f7">lock_get_table_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:aec43fb602ff6a6cb8964d5c4c1c0d4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad153d0b712ae422378a58151c8628efd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad153d0b712ae422378a58151c8628efd">lock_rec_get_index</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ad153d0b712ae422378a58151c8628efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0200bf5b9ee51f495a2ddf704c63ad"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3b0200bf5b9ee51f495a2ddf704c63ad">lock_rec_get_index_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a3b0200bf5b9ee51f495a2ddf704c63ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90793ee45348397c09e6eb0938fa3e4a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a90793ee45348397c09e6eb0938fa3e4a">lock_rec_get_space_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a90793ee45348397c09e6eb0938fa3e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cdf332f59754136d761b9fe0d88564"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae5cdf332f59754136d761b9fe0d88564">lock_rec_get_page_no</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ae5cdf332f59754136d761b9fe0d88564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c253640c388097559612b427162592"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a55c253640c388097559612b427162592">lock_cancel_waiting_and_release</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a55c253640c388097559612b427162592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838b492f61b92e3678c7b7be18a2f1be"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a838b492f61b92e3678c7b7be18a2f1be">lock_unlock_table_autoinc</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a838b492f61b92e3678c7b7be18a2f1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af056c93107ab266face88ec37bae94c7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af056c93107ab266face88ec37bae94c7">lock_trx_release_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:af056c93107ab266face88ec37bae94c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc6bccf13b2458e2b470264dbd7d8e6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#abdc6bccf13b2458e2b470264dbd7d8e6">lock_trx_handle_wait</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:abdc6bccf13b2458e2b470264dbd7d8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4e79640cb278627d5eae3f3d28edbe"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aee4e79640cb278627d5eae3f3d28edbe">lock_table_get_n_locks</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:aee4e79640cb278627d5eae3f3d28edbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a934d7768a7c68d802e733fcf86f1c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a97a934d7768a7c68d802e733fcf86f1c">lock_table_has_locks</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a97a934d7768a7c68d802e733fcf86f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3579e0d5ddc973a66fae09c8990e05ea"><td class="memItemLeft" align="right" valign="top">static const byte&#160;</td><td class="memItemRight" valign="bottom"><b>lock_compatibility_matrix</b> [5][5]</td></tr>
<tr class="separator:a3579e0d5ddc973a66fae09c8990e05ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c37e6a5830ee34d6670d87ccc14128f"><td class="memItemLeft" align="right" valign="top">static const byte&#160;</td><td class="memItemRight" valign="bottom"><b>lock_strength_matrix</b> [5][5]</td></tr>
<tr class="separator:a1c37e6a5830ee34d6670d87ccc14128f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0249a4de857cab870922d46e750ea9d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlock__stack__t.html">lock_stack_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af0249a4de857cab870922d46e750ea9d">lock_stack</a></td></tr>
<tr class="separator:af0249a4de857cab870922d46e750ea9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1743fff1d65daa7cd28852fcc17e5b87"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structlock__sys__t.html">lock_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a1743fff1d65daa7cd28852fcc17e5b87">lock_sys</a> = NULL</td></tr>
<tr class="separator:a1743fff1d65daa7cd28852fcc17e5b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fe78c66c5b6c3a6cbaa8216617e9ee"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a73fe78c66c5b6c3a6cbaa8216617e9ee">lock_deadlock_found</a> = FALSE</td></tr>
<tr class="separator:a73fe78c66c5b6c3a6cbaa8216617e9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58b635675c25066d014d44908f3a487"><td class="memItemLeft" align="right" valign="top">static FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab58b635675c25066d014d44908f3a487">lock_latest_err_file</a></td></tr>
<tr class="separator:ab58b635675c25066d014d44908f3a487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2b8f3cc32359d262e3cda1e86baf1a"><td class="memItemLeft" align="right" valign="top">static const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#afd2b8f3cc32359d262e3cda1e86baf1a">rec</a></td></tr>
<tr class="separator:afd2b8f3cc32359d262e3cda1e86baf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c3322144060fbce53f44a421b2ea2f"><td class="memItemLeft" align="right" valign="top">static const rec_t <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a23c3322144060fbce53f44a421b2ea2f">index</a></td></tr>
<tr class="separator:a23c3322144060fbce53f44a421b2ea2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01b6fdae5434d9daf8ec111f3ed9824"><td class="memItemLeft" align="right" valign="top">static const rec_t <a class="el" href="structdict__index__t.html">dict_index_t</a> const ulint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab01b6fdae5434d9daf8ec111f3ed9824">offsets</a></td></tr>
<tr class="separator:ab01b6fdae5434d9daf8ec111f3ed9824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1e3dbb6719a015264437d31717d5d5"><td class="memItemLeft" align="right" valign="top"><a id="a6b1e3dbb6719a015264437d31717d5d5"></a>
<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max_trx_id</b> = <a class="el" href="trx0sys_8h.html#aaf92577bb351b5b6e51fac1f36a0abd3">trx_sys_get_max_trx_id</a>()</td></tr>
<tr class="separator:a6b1e3dbb6719a015264437d31717d5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59db64306354fd5f8ad8ce431392872"><td class="memItemLeft" align="right" valign="top"><a id="ad59db64306354fd5f8ad8ce431392872"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>is_ok</b> = <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a> &lt; max_trx_id</td></tr>
<tr class="separator:ad59db64306354fd5f8ad8ce431392872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399569564ef7eba550cac366234c1105"><td class="memItemLeft" align="right" valign="top">static ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a399569564ef7eba550cac366234c1105">lock_mark_counter</a> = 0</td></tr>
<tr class="separator:a399569564ef7eba550cac366234c1105"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The transaction lock system</p>
<p>Created 5/7/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac6b942151a21e8458664d68a9ccfc491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b942151a21e8458664d68a9ccfc491">&#9670;&nbsp;</a></span>IS_LOCK_S_OR_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IS_LOCK_S_OR_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lock</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="lock0lock_8cc.html#ae4ba4d837532fb8eaf414d1cbaaf6d90">lock_get_mode</a>(lock) == LOCK_S \</div><div class="line">         || <a class="code" href="lock0lock_8cc.html#ae4ba4d837532fb8eaf414d1cbaaf6d90">lock_get_mode</a>(lock) == LOCK_X)</div><div class="ttc" id="lock0lock_8cc_html_ae4ba4d837532fb8eaf414d1cbaaf6d90"><div class="ttname"><a href="lock0lock_8cc.html#ae4ba4d837532fb8eaf414d1cbaaf6d90">lock_get_mode</a></div><div class="ttdeci">UNIV_INLINE enum lock_mode lock_get_mode(const lock_t *lock)</div><div class="ttdef"><b>Definition:</b> lock0lock.cc:666</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0eacd97c10ba9d402e9cfc92ab09c4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eacd97c10ba9d402e9cfc92ab09c4e4">&#9670;&nbsp;</a></span>lock_deadlock_too_deep</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_deadlock_too_deep</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(c-&gt;depth &gt; LOCK_MAX_DEPTH_IN_DEADLOCK_CHECK            \</div><div class="line">         || c-&gt;cost &gt; LOCK_MAX_N_STEPS_IN_DEADLOCK_CHECK)</div></div><!-- fragment --><p><a class="el" href="struct_check.html">Check</a> if the search is too deep. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aaa98e1bd917f95280993475788ea6c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa98e1bd917f95280993475788ea6c5b">&#9670;&nbsp;</a></span>lock_rec_req_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="lock0lock_8cc.html#aaa98e1bd917f95280993475788ea6c5b">lock_rec_req_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Record locking request status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaa98e1bd917f95280993475788ea6c5ba12a47b5e4d2d01853958ecbc0513bb31"></a>LOCK_REC_FAIL&#160;</td><td class="fielddoc"><p>Failed to acquire a lock </p>
</td></tr>
<tr><td class="fieldname"><a id="aaa98e1bd917f95280993475788ea6c5ba4f02aa53c8580c293151a57282bdbdd6"></a>LOCK_REC_SUCCESS&#160;</td><td class="fielddoc"><p>Succeeded in acquiring a lock (implicit or already acquired) </p>
</td></tr>
<tr><td class="fieldname"><a id="aaa98e1bd917f95280993475788ea6c5bab91e6212faed445182df02ef9497f066"></a>LOCK_REC_SUCCESS_CREATED&#160;</td><td class="fielddoc"><p>Explicitly created a new lock </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1cb9d1ec4975bd153f29b816e1ab1951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb9d1ec4975bd153f29b816e1ab1951">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull, warn_unused_result)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks that a transaction id is sensible, i.e., not in the future. </p><dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>

</div>
</div>
<a id="a55c253640c388097559612b427162592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c253640c388097559612b427162592">&#9670;&nbsp;</a></span>lock_cancel_waiting_and_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_cancel_waiting_and_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels a waiting lock request and releases possible other transactions waiting behind it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: waiting lock request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac202bf2346684b96cfecca70ad64b002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac202bf2346684b96cfecca70ad64b002">&#9670;&nbsp;</a></span>lock_clust_rec_cons_read_sees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool lock_clust_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structread__view__t.html">read_view_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that a record is seen in a consistent read. </p><dl class="section return"><dt>Returns</dt><dd>true if sees, or false if an earlier version of the record should be retrieved </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">view</td><td>in: consistent read view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4a6cd6546d2b402cdb77ce02676f310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a6cd6546d2b402cdb77ce02676f310">&#9670;&nbsp;</a></span>lock_clust_rec_modify_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate modify (update, delete mark, or delete unmark) of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record x-lock to the lock queue. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa600625a4fffa2b7f0a68cdd64b1ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa600625a4fffa2b7f0a68cdd64b1ad3">&#9670;&nbsp;</a></span>lock_clust_rec_read_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05a2cbb97d47b65bd2efa1a3f094f09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a2cbb97d47b65bd2efa1a3f094f09f">&#9670;&nbsp;</a></span>lock_clust_rec_read_check_and_lock_alt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock_alt </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. This is an alternative version of <a class="el" href="lock0lock_8cc.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock()</a> that does not require the parameter "offsets". </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab92b6e71a634f6e5312366c074d1686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab92b6e71a634f6e5312366c074d1686">&#9670;&nbsp;</a></span>lock_deadlock_check_and_resolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> lock_deadlock_check_and_resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a joining lock request results in a deadlock. If a deadlock is found this function will resolve the dadlock by choosing a victim transaction and rolling it back. It will attempt to resolve all deadlocks. The returned transaction id will be the joining transaction id or 0 if some other transaction was chosen as a victim and rolled back or no deadlock found.</p>
<dl class="section return"><dt>Returns</dt><dd>id of transaction chosen as victim or 0 in: transaction</dd></dl>
<p>Checks if a joining lock request results in a deadlock. If a deadlock is found this function will resolve the dadlock by choosing a victim transaction and rolling it back. It will attempt to resolve all deadlocks. The returned transaction id will be the joining transaction id or 0 if some other transaction was chosen as a victim and rolled back or no deadlock found.</p>
<dl class="section return"><dt>Returns</dt><dd>id of transaction chosen as victim or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock the transaction is requesting </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4083933abb4c7e11b3fcbca0a6d7fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4083933abb4c7e11b3fcbca0a6d7fb8">&#9670;&nbsp;</a></span>lock_deadlock_fputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_deadlock_fputs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a message to the deadlock file and possibly to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>in: message to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97feac8a25aa1df891fa82e5c5525c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97feac8a25aa1df891fa82e5c5525c85">&#9670;&nbsp;</a></span>lock_deadlock_joining_trx_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_deadlock_joining_trx_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print info about transaction that was rolled back. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction rolled back </td></tr>
    <tr><td class="paramname">lock</td><td>in: lock trx wants </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cd8d596cfb491be51c39f1bab8be695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd8d596cfb491be51c39f1bab8be695">&#9670;&nbsp;</a></span>lock_deadlock_lock_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_deadlock_lock_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print lock data to the deadlock file and possibly to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record or table type lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70131aef19fe8cf6da43418b1419a60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70131aef19fe8cf6da43418b1419a60e">&#9670;&nbsp;</a></span>lock_deadlock_notify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_deadlock_notify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notify that a deadlock has been detected and print the conflicting transaction info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>in: deadlock context </td></tr>
    <tr><td class="paramname">lock</td><td>in: lock causing deadlock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b9d72cd0c0b5c4dc574f82d91374bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9d72cd0c0b5c4dc574f82d91374bd3">&#9670;&nbsp;</a></span>lock_deadlock_pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__stack__t.html">lock_stack_t</a>* lock_deadlock_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pop the deadlock search state from the stack. </p><dl class="section return"><dt>Returns</dt><dd>stack slot instance that was on top of the stack. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>in/out: context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad36641016a23b3b2ae76885e1044bf88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36641016a23b3b2ae76885e1044bf88">&#9670;&nbsp;</a></span>lock_deadlock_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlock__stack__t.html">lock_stack_t</a>* lock_deadlock_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Push the deadlock search state onto the stack. </p><dl class="section return"><dt>Returns</dt><dd>slot that was used in the stack </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>in/out: context </td></tr>
    <tr><td class="paramname">lock</td><td>in: current lock </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afea43e1e7b698b67e8d468f350b84c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea43e1e7b698b67e8d468f350b84c7b">&#9670;&nbsp;</a></span>lock_deadlock_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> lock_deadlock_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks iteratively for a deadlock. Note: the joining transaction may have been granted its lock by the deadlock checks. </p><dl class="section return"><dt>Returns</dt><dd>0 if no deadlock else the victim transaction id. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>in/out: deadlock context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5eb03d6fede3052a36ccff43c14b977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5eb03d6fede3052a36ccff43c14b977">&#9670;&nbsp;</a></span>lock_deadlock_select_victim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structtrx__t.html">trx_t</a>* lock_deadlock_select_victim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Select the victim transaction that should be rolledback. </p><dl class="section return"><dt>Returns</dt><dd>victim transaction </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>in: deadlock context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ebf51c560b258971023da6814c75c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebf51c560b258971023da6814c75c9e">&#9670;&nbsp;</a></span>lock_deadlock_start_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_deadlock_start_print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>rewind(3) the file used for storing the latest detected deadlock and print a heading message to stderr if printing of all deadlocks to stderr is enabled. </p>

</div>
</div>
<a id="a23fb7a80748bc4151c18637baf6afa77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fb7a80748bc4151c18637baf6afa77">&#9670;&nbsp;</a></span>lock_deadlock_trx_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_deadlock_trx_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_query_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print transaction data to the deadlock file and possibly to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">max_query_len</td><td>in: max query length to print, or 0 to use the default max length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a545f98c5b4c30da42a1b0bda5ed732df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545f98c5b4c30da42a1b0bda5ed732df">&#9670;&nbsp;</a></span>lock_deadlock_trx_rollback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_deadlock_trx_rollback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rollback transaction selected as the victim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>in: deadlock context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a144a58113c1ddb7567b69508b4cde065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144a58113c1ddb7567b69508b4cde065">&#9670;&nbsp;</a></span>lock_get_first_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_get_first_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the first lock to search. The search starts from the current wait_lock. What we are really interested in is an edge from the current wait_lock's owning transaction to another transaction that has a lock ahead in the queue. We skip locks where the owning transaction's sub-tree has already been searched. </p><dl class="section return"><dt>Returns</dt><dd>first lock or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>in: deadlock context </td></tr>
    <tr><td class="paramname">heap_no</td><td>out: heap no if rec lock, else ULINT_UNDEFINED </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4ba4d837532fb8eaf414d1cbaaf6d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ba4d837532fb8eaf414d1cbaaf6d90">&#9670;&nbsp;</a></span>lock_get_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum lock_mode lock_get_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the mode of a lock. </p><dl class="section return"><dt>Returns</dt><dd>mode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade2809d68943d3e72cbfd11885126356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2809d68943d3e72cbfd11885126356">&#9670;&nbsp;</a></span>lock_get_mode_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_get_mode_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the mode of a lock in a human readable string. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock mode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63731d935046f872cc2ee54859cf9671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63731d935046f872cc2ee54859cf9671">&#9670;&nbsp;</a></span>lock_get_next_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_get_next_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__deadlock__ctx__t.html">lock_deadlock_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the next lock in the queue that is owned by a transaction whose sub-tree has not already been searched. </p><dl class="section return"><dt>Returns</dt><dd>next lock or NULL if at end of queue </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>in: deadlock context </td></tr>
    <tr><td class="paramname">lock</td><td>in: lock in the queue </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap no if rec lock else ULINT_UNDEFINED </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd6d281988732c472d3e0f7eac4d6e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6d281988732c472d3e0f7eac4d6e4e">&#9670;&nbsp;</a></span>lock_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_get_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of a lock struct. </p><dl class="section return"><dt>Returns</dt><dd>size in bytes </dd></dl>

</div>
</div>
<a id="ab663621ff9b0550c0f2caa5fe6facc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab663621ff9b0550c0f2caa5fe6facc3e">&#9670;&nbsp;</a></span>lock_get_src_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a>* lock_get_src_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the source table of an ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> transaction. The table must be covered by an IX or IS table lock. </p><dl class="section return"><dt>Returns</dt><dd>the source table of transaction, if it is covered by an IX or IS table lock; dest if there is no source table, and NULL if the transaction is locking more than two tables or an inconsistency is found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">dest</td><td>in: destination of ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> </td></tr>
    <tr><td class="paramname">mode</td><td>out: lock mode of the source table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88f90ccf6fab644d41a404db1d27e948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f90ccf6fab644d41a404db1d27e948">&#9670;&nbsp;</a></span>lock_get_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdict__table__t.html">dict_table_t</a>* lock_get_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the table on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec13113aefe2d0c30da8e0b70d8529d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec13113aefe2d0c30da8e0b70d8529d">&#9670;&nbsp;</a></span>lock_get_table_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN table_id_t lock_get_table_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the id of the table on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>id of the table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec43fb602ff6a6cb8964d5c4c1c0d4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec43fb602ff6a6cb8964d5c4c1c0d4f7">&#9670;&nbsp;</a></span>lock_get_table_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_get_table_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the name of the table on which the lock is. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>name of the table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9c9a06b5b21a1e4c04b5cafc68b6ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c9a06b5b21a1e4c04b5cafc68b6ccd">&#9670;&nbsp;</a></span>lock_get_trx_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> lock_get_trx_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the id of the transaction owning a lock. </p><dl class="section return"><dt>Returns</dt><dd>transaction id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c17bbd1a704e818f0a9e93dcf7b0541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c17bbd1a704e818f0a9e93dcf7b0541">&#9670;&nbsp;</a></span>lock_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_get_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the type of a lock. Non-inline version for using outside of the lock module. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_TABLE or LOCK_REC </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bdf57695b21f5d522b265090787f5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdf57695b21f5d522b265090787f5d4">&#9670;&nbsp;</a></span>lock_get_type_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_get_type_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the type of a lock in a human readable string. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac39e45b1c0a23547fa21a02c765bcd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39e45b1c0a23547fa21a02c765bcd29">&#9670;&nbsp;</a></span>lock_get_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_get_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the wait flag of a lock. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_WAIT if waiting, 0 if not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81303597fbce84d2814fb10f02a75cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81303597fbce84d2814fb10f02a75cb4">&#9670;&nbsp;</a></span>lock_grant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_grant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Grants a lock to a waiting lock request and releases the waiting transaction. The caller must hold lock_sys-&gt;mutex but not lock-&gt;trx-&gt;mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: waiting lock request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fa82401a7f43bcd7ee507b462151b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa82401a7f43bcd7ee507b462151b50">&#9670;&nbsp;</a></span>lock_has_to_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool lock_has_to_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a lock request lock1 has to wait for request lock2. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if lock1 has to wait for lock2 to be removed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock1</td><td>in: waiting lock </td></tr>
    <tr><td class="paramname">lock2</td><td>in: another lock; NOTE that it is assumed that this has a lock bit set on the same record as in lock1 if the locks are record locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68837200e8d73d4a74adecbed644284c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68837200e8d73d4a74adecbed644284c">&#9670;&nbsp;</a></span>lock_is_table_exclusive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool lock_is_table_exclusive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if the given table is exclusively "owned" by the given transaction, i.e., transaction holds LOCK_IX and possibly LOCK_AUTO_INC on the table. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if table is only locked by trx, with LOCK_IX, and possibly LOCK_AUTO_INC </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07853bb83e125e4902a66d61cf24a658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07853bb83e125e4902a66d61cf24a658">&#9670;&nbsp;</a></span>lock_mode_compatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_mode_compatible </td>
          <td>(</td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates if lock mode 1 is compatible with lock mode 2. </p><dl class="section return"><dt>Returns</dt><dd>nonzero if mode1 compatible with mode2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode1</td><td>in: lock mode </td></tr>
    <tr><td class="paramname">mode2</td><td>in: lock mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e367e26e46cbf73185fff7c00773762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e367e26e46cbf73185fff7c00773762">&#9670;&nbsp;</a></span>lock_mode_stronger_or_eq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_mode_stronger_or_eq </td>
          <td>(</td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates if lock mode 1 is stronger or equal to lock mode 2. </p><dl class="section return"><dt>Returns</dt><dd>nonzero if mode1 stronger or equal to mode2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode1</td><td>in: lock mode </td></tr>
    <tr><td class="paramname">mode2</td><td>in: lock mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb43b7be638bd32fa36b7c025d636bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb43b7be638bd32fa36b7c025d636bb6">&#9670;&nbsp;</a></span>lock_move_rec_list_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_move_rec_list_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the explicit locks on user records to another page if a record list end is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: index page to move to </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">rec</td><td>in: record on page: this is the first record moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23e7197a446aee79574d335d277aaa84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e7197a446aee79574d335d277aaa84">&#9670;&nbsp;</a></span>lock_move_rec_list_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_move_rec_list_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>old_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the explicit locks on user records to another page if a record list start is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: index page to move to </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">rec</td><td>in: record on page: this is the first record NOT copied </td></tr>
    <tr><td class="paramname">old_end</td><td>in: old previous-to-last record on new_page before the records were copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7273b2c3c75e90408bdc5a711effc73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7273b2c3c75e90408bdc5a711effc73a">&#9670;&nbsp;</a></span>lock_move_reorganize_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_move_reorganize_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>oblock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when we have reorganized a page. NOTE: we copy also the locks set on the infimum of the page; the infimum may carry locks if an update of a record is occurring on the page, and its locks were temporarily stored on the infimum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: old index page, now reorganized </td></tr>
    <tr><td class="paramname">oblock</td><td>in: copy of the old, not reorganized page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adef81d372b4a6e02f4fc13e67a7fdb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef81d372b4a6e02f4fc13e67a7fdb2f">&#9670;&nbsp;</a></span>lock_number_of_rows_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_number_of_rows_locked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *&#160;</td>
          <td class="paramname"><em>trx_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return approximate number or record locks (bits set in the bitmap) for this transaction. Since delete-marked records may be removed, the record count will not be precise. The caller must be holding lock_sys-&gt;mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_lock</td><td>in: transaction locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96d8a6d0b9f2926b63ea83ec8b9633c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d8a6d0b9f2926b63ea83ec8b9633c7">&#9670;&nbsp;</a></span>lock_print_info_all_transactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_print_info_all_transactions </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of locks for each transaction. This function assumes that the caller holds the lock mutex and more importantly it will release the lock mutex on behalf of the caller. (This should be fixed in the future). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab98a1fdd897f11f262a024ddc2574cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98a1fdd897f11f262a024ddc2574cf9">&#9670;&nbsp;</a></span>lock_print_info_summary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool lock_print_info_summary </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>nowait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of locks for all transactions. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if not able to obtain lock mutex and exits without printing info </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">nowait</td><td>in: whether to wait for the lock mutex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad0ad21b1ad09504c76685f1e32a79a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0ad21b1ad09504c76685f1e32a79a0">&#9670;&nbsp;</a></span>lock_rec_add_to_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_add_to_queue </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>caller_owns_trx_mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a record lock request in the record queue. The request is normally added as the last in the queue, but if there are no waiting lock requests on the record, and the request to be added is not a waiting request, we can reuse a suitable record lock object already existing on the same page, just setting the appropriate bit in its bitmap. This is a low-level function which does NOT check for deadlocks or lock compatibility! </p><dl class="section return"><dt>Returns</dt><dd>lock where the bit was set </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_mode</td><td>in: lock mode, wait, gap etc. flags; type is ignored and replaced by LOCK_REC </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of record </td></tr>
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
    <tr><td class="paramname">caller_owns_trx_mutex</td><td>in: TRUE if caller owns the transaction mutex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a11bee90995105efe9a0942e37b6349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a11bee90995105efe9a0942e37b6349">&#9670;&nbsp;</a></span>lock_rec_bitmap_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_bitmap_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the record lock bitmap to zero. NOTE: does not touch the wait_lock pointer in the transaction! This function is used in lock object creation and resetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aa77b9fe490eac4349341da3a689dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa77b9fe490eac4349341da3a689dad">&#9670;&nbsp;</a></span>lock_rec_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cancels a waiting record lock request and releases the waiting transaction that requested it. NOTE: does NOT check if waiting lock requests behind this one can now be granted! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: waiting record lock request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6872a342e01b3ae5cc2132301afec259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6872a342e01b3ae5cc2132301afec259">&#9670;&nbsp;</a></span>lock_rec_convert_impl_to_expl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_convert_impl_to_expl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a transaction has an implicit x-lock on a record, but no explicit x-lock set on the record, sets one for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record on page </td></tr>
    <tr><td class="paramname">index</td><td>in: index of record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a179a520c4a10f93bc52ed52b9abb8a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179a520c4a10f93bc52ed52b9abb8a81">&#9670;&nbsp;</a></span>lock_rec_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies a record lock to heap. </p><dl class="section return"><dt>Returns</dt><dd>copy of lock </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13184f2bbc8b127132a46bdbdaaee93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13184f2bbc8b127132a46bdbdaaee93c">&#9670;&nbsp;</a></span>lock_rec_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>caller_owns_trx_mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new record lock and inserts it to the lock queue. Does NOT check for deadlocks or lock compatibility! </p><dl class="section return"><dt>Returns</dt><dd>created lock </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_mode</td><td>in: lock mode and wait flag, type is ignored and replaced by LOCK_REC </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of record </td></tr>
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
    <tr><td class="paramname">caller_owns_trx_mutex</td><td>in: TRUE if caller owns trx mutex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a400624ff6ae565a75b2894787172c809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400624ff6ae565a75b2894787172c809">&#9670;&nbsp;</a></span>lock_rec_dequeue_from_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_dequeue_from_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a record lock request, waiting or granted, from the queue and grants locks to other transactions in the queue if they now are entitled to a lock. NOTE: all record locks contained in in_lock are removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_lock</td><td>in: record lock object: all record locks which are contained in this lock object are removed; transactions waiting behind will get their lock requests granted, if they are now qualified to it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb594cf2620c92acb160e0286af6bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb594cf2620c92acb160e0286af6bfd7">&#9670;&nbsp;</a></span>lock_rec_discard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_discard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a record lock request, waiting or granted, from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_lock</td><td>in: record lock object: all record locks which are contained in this lock object are removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac045d8f54f3ae1f765109a0f2456339c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac045d8f54f3ae1f765109a0f2456339c">&#9670;&nbsp;</a></span>lock_rec_enqueue_waiting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_enqueue_waiting </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueues a waiting request for a lock which cannot be granted immediately. Checks for deadlocks. </p><dl class="section return"><dt>Returns</dt><dd>DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED, or DB_SUCCESS_LOCKED_REC; DB_SUCCESS_LOCKED_REC means that there was a deadlock, but another transaction was chosen as a victim, and we got the lock immediately: no need to wait then </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_mode</td><td>in: lock mode this transaction is requesting: LOCK_S or LOCK_X, possibly ORed with LOCK_GAP or LOCK_REC_NOT_GAP, ORed with LOCK_INSERT_INTENTION if this waiting lock request is set when performing an insert of an index record </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of record </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01375d9e473384eb738bdf18b1f24afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01375d9e473384eb738bdf18b1f24afd">&#9670;&nbsp;</a></span>lock_rec_expl_exist_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_expl_exist_on_page </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if there are explicit record locks on a page. </p><dl class="section return"><dt>Returns</dt><dd>an explicit record lock on the page, or NULL if there are none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeac31e933724030fe1aca76ebbd1b524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac31e933724030fe1aca76ebbd1b524">&#9670;&nbsp;</a></span>lock_rec_find_set_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_rec_find_set_bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a set bit in a record lock bitmap. Returns ULINT_UNDEFINED, if none found. </p><dl class="section return"><dt>Returns</dt><dd>bit index == heap number of the record, or ULINT_UNDEFINED if none found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock with at least one bit set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f29678241bd9c3322db91ea3fc85c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f29678241bd9c3322db91ea3fc85c94">&#9670;&nbsp;</a></span>lock_rec_find_similar_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_find_similar_on_page </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a suitable type record lock struct by the same trx on the same page. This can be used to save space when a new record lock should be set on a page: no new struct is needed, if a suitable old is found. </p><dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_mode</td><td>in: lock type_mode field </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">lock</td><td>in: <a class="el" href="lock0lock_8cc.html#ae5ae4db39ec1f10581c7b3636970f4e7">lock_rec_get_first_on_page()</a> </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a4babb224a5aaab775bec465892075a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4babb224a5aaab775bec465892075a">&#9670;&nbsp;</a></span>lock_rec_free_all_from_discard_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_free_all_from_discard_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes record lock objects set on an index page which is discarded. This function does not move locks, or check for waiting locks, therefore the lock bitmaps must already be reset when this function is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: page to be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05c7ea975c47752cc3f2615273f33664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c7ea975c47752cc3f2615273f33664">&#9670;&nbsp;</a></span>lock_rec_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the first explicit lock request on a record. </p><dl class="section return"><dt>Returns</dt><dd>first lock, NULL if none exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5ae4db39ec1f10581c7b3636970f4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ae4db39ec1f10581c7b3636970f4e7">&#9670;&nbsp;</a></span>lock_rec_get_first_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_first_on_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the first record lock on a page, where the page is identified by a pointer to it. </p><dl class="section return"><dt>Returns</dt><dd>first lock, NULL if none exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2927c070cf3f5f1482a876b7fde40e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2927c070cf3f5f1482a876b7fde40e03">&#9670;&nbsp;</a></span>lock_rec_get_first_on_page_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_first_on_page_addr </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the first record lock on a page, where the page is identified by its file address. </p><dl class="section return"><dt>Returns</dt><dd>first lock, NULL if none exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a419d78b85193924e945f2313a60f7ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419d78b85193924e945f2313a60f7ccf">&#9670;&nbsp;</a></span>lock_rec_get_gap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_get_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the gap flag of a record lock. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_GAP or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad153d0b712ae422378a58151c8628efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad153d0b712ae422378a58151c8628efd">&#9670;&nbsp;</a></span>lock_rec_get_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structdict__index__t.html">dict_index_t</a>* lock_rec_get_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the index on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b0200bf5b9ee51f495a2ddf704c63ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0200bf5b9ee51f495a2ddf704c63ad">&#9670;&nbsp;</a></span>lock_rec_get_index_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_rec_get_index_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the name of the index on which the lock is. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>name of the index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedc4fc3dd2500ccd00e4139c4ccba75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc4fc3dd2500ccd00e4139c4ccba75a">&#9670;&nbsp;</a></span>lock_rec_get_insert_intention()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_get_insert_intention </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the waiting insert flag of a record lock. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_INSERT_INTENTION or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bb79a43f5b92cea073f2cde49949308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb79a43f5b92cea073f2cde49949308">&#9670;&nbsp;</a></span>lock_rec_get_n_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_get_n_bits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of bits in a record lock bitmap. </p><dl class="section return"><dt>Returns</dt><dd>number of bits </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81f2ac5cbb634ee6ef9663ba8bf4bbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f2ac5cbb634ee6ef9663ba8bf4bbab">&#9670;&nbsp;</a></span>lock_rec_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_next </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the next explicit lock request on a record. </p><dl class="section return"><dt>Returns</dt><dd>next lock, NULL if none exists or if heap_no == ULINT_UNDEFINED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cf1fd0b7f60894fecee9005803e62fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf1fd0b7f60894fecee9005803e62fa">&#9670;&nbsp;</a></span>lock_rec_get_next_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_next_const </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the next explicit lock request on a record. </p><dl class="section return"><dt>Returns</dt><dd>next lock, NULL if none exists or if heap_no == ULINT_UNDEFINED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0e694a3a47a498c55bd09c5127b162a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e694a3a47a498c55bd09c5127b162a">&#9670;&nbsp;</a></span>lock_rec_get_next_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_next_on_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the first or next record lock on a page. </p><dl class="section return"><dt>Returns</dt><dd>next lock, NULL if none exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: a record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c0d0d9c1d6281cbe1a248f29d9e6dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0d0d9c1d6281cbe1a248f29d9e6dd7">&#9670;&nbsp;</a></span>lock_rec_get_next_on_page_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_next_on_page_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the first or next record lock on a page. </p><dl class="section return"><dt>Returns</dt><dd>next lock, NULL if none exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: a record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4f9160da82c4cef15d4eec1a0d59014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f9160da82c4cef15d4eec1a0d59014">&#9670;&nbsp;</a></span>lock_rec_get_nth_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool lock_rec_get_nth_bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the nth bit of a record lock. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if bit set also if i == ULINT_UNDEFINED return FALSE </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
    <tr><td class="paramname">i</td><td>in: index of the bit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5cdf332f59754136d761b9fe0d88564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cdf332f59754136d761b9fe0d88564">&#9670;&nbsp;</a></span>lock_rec_get_page_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_rec_get_page_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the page number on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aade1802065fed76d7f256fa097307084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade1802065fed76d7f256fa097307084">&#9670;&nbsp;</a></span>lock_rec_get_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the previous record lock set on a record. </p><dl class="section return"><dt>Returns</dt><dd>previous lock on the same record, NULL if none exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_lock</td><td>in: record lock </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea241051962fafa069de83516f0df01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea241051962fafa069de83516f0df01">&#9670;&nbsp;</a></span>lock_rec_get_rec_not_gap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_get_rec_not_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the LOCK_REC_NOT_GAP flag of a record lock. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_REC_NOT_GAP or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90793ee45348397c09e6eb0938fa3e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90793ee45348397c09e6eb0938fa3e4a">&#9670;&nbsp;</a></span>lock_rec_get_space_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_rec_get_space_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the tablespace number on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>tablespace number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0a191d29bbdaff834703239f4c9b922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a191d29bbdaff834703239f4c9b922">&#9670;&nbsp;</a></span>lock_rec_has_expl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_has_expl </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>precise_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a transaction has a GRANTED explicit lock on rec stronger or equal to precise_mode. </p><dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">precise_mode</td><td>in: LOCK_S or LOCK_X possibly ORed to LOCK_GAP or LOCK_REC_NOT_GAP, for a supremum record we regard this always a gap type request </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71060eddf2bdcec23b9d0cca21c2de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71060eddf2bdcec23b9d0cca21c2de51">&#9670;&nbsp;</a></span>lock_rec_has_to_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool lock_rec_has_to_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>lock_is_on_supremum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a lock request for a new lock has to wait for request lock2. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if new lock has to wait for lock2 to be removed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: trx of new lock </td></tr>
    <tr><td class="paramname">type_mode</td><td>in: precise mode of the new lock to set: LOCK_S or LOCK_X, possibly ORed to LOCK_GAP or LOCK_REC_NOT_GAP, LOCK_INSERT_INTENTION </td></tr>
    <tr><td class="paramname">lock2</td><td>in: another record lock; NOTE that it is assumed that this has a lock bit set on the same record as in the new lock we are setting </td></tr>
    <tr><td class="paramname">lock_is_on_supremum</td><td>in: TRUE if we are setting the lock on the 'supremum' record of an index page: we know then that the lock request is really for a 'gap' type lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a114997c30ec246f1aabf3ffb55dab5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114997c30ec246f1aabf3ffb55dab5e7">&#9670;&nbsp;</a></span>lock_rec_has_to_wait_in_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_has_to_wait_in_queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>wait_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a waiting record lock request still has to wait in a queue. </p><dl class="section return"><dt>Returns</dt><dd>lock that is causing the wait </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_lock</td><td>in: waiting record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad71a1e16ac85a11e9ac1f3111f707439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71a1e16ac85a11e9ac1f3111f707439">&#9670;&nbsp;</a></span>lock_rec_inherit_to_gap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_inherit_to_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes a record to inherit the locks (except LOCK_INSERT_INTENTION type) of another record as gap type locks, but does not reset the lock bits of the other record. Also waiting lock requests on rec are inherited as GRANTED gap locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heir_block</td><td>in: block containing the record which inherits </td></tr>
    <tr><td class="paramname">block</td><td>in: block containing the record from which inherited; does NOT reset the locks on this record </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of the inheriting record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap_no of the donating record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb009afd28d954b9ba74693b823b4ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb009afd28d954b9ba74693b823b4ad3">&#9670;&nbsp;</a></span>lock_rec_inherit_to_gap_if_gap_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_inherit_to_gap_if_gap_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes a record to inherit the gap locks (except LOCK_INSERT_INTENTION type) of another record as gap type locks, but does not reset the lock bits of the other record. Also waiting lock requests are inherited as GRANTED gap locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of record which inherits </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap_no of record from which inherited; does NOT reset the locks on this record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f038fa965628091108d30f375ef42e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f038fa965628091108d30f375ef42e2">&#9670;&nbsp;</a></span>lock_rec_insert_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_insert_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate insert of a record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a gap x-lock to the lock queue. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">rec</td><td>in: record after which to insert </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">inherit</td><td>out: set to TRUE if the new inserted record maybe should inherit LOCK_GAP type locks from the successor record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59de8e5096cf57ff11c57d62345c70bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59de8e5096cf57ff11c57d62345c70bd">&#9670;&nbsp;</a></span>lock_rec_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_lock </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>impl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to lock the specified record in the mode requested. If not immediately possible, enqueues a waiting lock request. This is a low-level function which does NOT look at implicit locks! Checks lock compatibility within explicit locks. This function sets a normal next-key lock, or in the case of a page supremum record, a gap type lock. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>in: if TRUE, no lock is set if no wait is necessary: we assume that the caller will set an implicit lock </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode: LOCK_X or LOCK_S possibly ORed to either LOCK_GAP or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of record </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0a4ad622cc9e5f690f70eac443efc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a4ad622cc9e5f690f70eac443efc23">&#9670;&nbsp;</a></span>lock_rec_lock_fast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="lock0lock_8cc.html#aaa98e1bd917f95280993475788ea6c5b">lock_rec_req_status</a> lock_rec_lock_fast </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>impl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a fast routine for locking a record in the most common cases: there are no explicit locks on the page, or there is just one lock, owned by this transaction, and of the right type_mode. This is a low-level function which does NOT look at implicit locks! Checks lock compatibility within explicit locks. This function sets a normal next-key lock, or in the case of a page supremum record, a gap type lock. </p><dl class="section return"><dt>Returns</dt><dd>whether the locking succeeded </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>in: if TRUE, no lock is set if no wait is necessary: we assume that the caller will set an implicit lock </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode: LOCK_X or LOCK_S possibly ORed to either LOCK_GAP or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of record </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69d58301a21d567272448359864b0e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d58301a21d567272448359864b0e72">&#9670;&nbsp;</a></span>lock_rec_lock_slow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_lock_slow </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>impl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the general, and slower, routine for locking a record. This is a low-level function which does NOT look at implicit locks! Checks lock compatibility within explicit locks. This function sets a normal next-key lock, or in the case of a page supremum record, a gap type lock. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>in: if TRUE, no lock is set if no wait is necessary: we assume that the caller will set an implicit lock </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode: LOCK_X or LOCK_S possibly ORed to either LOCK_GAP or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of record </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8800d3f6097fe1058fbea7ddcff18f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8800d3f6097fe1058fbea7ddcff18f1f">&#9670;&nbsp;</a></span>lock_rec_move()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>donator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>receiver_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>donator_heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves the locks of a record to another record and resets the lock bits of the donating record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>in: buffer block containing the receiving record </td></tr>
    <tr><td class="paramname">donator</td><td>in: buffer block containing the donating record </td></tr>
    <tr><td class="paramname">receiver_heap_no</td><td>in: heap_no of the record which gets the locks; there must be no lock requests on it! </td></tr>
    <tr><td class="paramname">donator_heap_no</td><td>in: heap_no of the record which gives the locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34b3c827b80e8066404ef903f4407280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b3c827b80e8066404ef903f4407280">&#9670;&nbsp;</a></span>lock_rec_other_has_conflicting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_other_has_conflicting </td>
          <td>(</td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if some other transaction has a conflicting explicit lock request in the queue, so that we have to wait. </p><dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>in: LOCK_S or LOCK_X, possibly ORed to LOCK_GAP or LOC_REC_NOT_GAP, LOCK_INSERT_INTENTION </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">trx</td><td>in: our transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed491db1a4f9e54c46b5618fda1a72dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed491db1a4f9e54c46b5618fda1a72dd">&#9670;&nbsp;</a></span>lock_rec_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of a record lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">lock</td><td>in: record type lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1a1ced4eeb3daa98b39ee2365df8b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a1ced4eeb3daa98b39ee2365df8b1a">&#9670;&nbsp;</a></span>lock_rec_reset_and_inherit_gap_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_reset_and_inherit_gap_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the original locks on heir and replaces them with gap type locks inherited from rec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heir_block</td><td>in: block containing the record which inherits </td></tr>
    <tr><td class="paramname">block</td><td>in: block containing the record from which inherited; does NOT reset the locks on this record </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of the inheriting record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap_no of the donating record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a39c043b7a0da7ad896f9c8b1784d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a39c043b7a0da7ad896f9c8b1784d19">&#9670;&nbsp;</a></span>lock_rec_reset_and_release_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_reset_and_release_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the lock bits for a single record. Releases transactions waiting for lock requests here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb4bf8780dfc2730a445dcb2e894d10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4bf8780dfc2730a445dcb2e894d10d">&#9670;&nbsp;</a></span>lock_rec_reset_nth_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_rec_reset_nth_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the nth bit of a record lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
    <tr><td class="paramname">i</td><td>in: index of the bit which must be set to TRUE when this function is called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad04f9ddc87db84d8621e853f1a3434db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04f9ddc87db84d8621e853f1a3434db">&#9670;&nbsp;</a></span>lock_rec_restore_from_page_infimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_restore_from_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>donator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores the state of explicit lock requests on a single record, where the state was stored on the infimum of the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record whose lock state is restored </td></tr>
    <tr><td class="paramname">donator</td><td>in: page (rec is not necessarily on this page) whose infimum stored the lock state; lock bits are reset on the infimum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0cb59e5d76d0647bfbc4096682228f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cb59e5d76d0647bfbc4096682228f3">&#9670;&nbsp;</a></span>lock_rec_set_nth_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_rec_set_nth_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the nth bit of a record lock to TRUE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
    <tr><td class="paramname">i</td><td>in: index of the bit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad32bb2ec136f61df97fea7e90c94a7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32bb2ec136f61df97fea7e90c94a7cf">&#9670;&nbsp;</a></span>lock_rec_store_on_page_infimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_store_on_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores on the page infimum record the explicit locks of another record. This function is used to store the lock state of a record when it is updated and the size of the record changes in the update. The record is moved in such an update, perhaps to another page. The infimum record acts as a dummy carrier record, taking care of lock releases while the actual record is being moved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record whose lock state is stored on the infimum record of the same page; lock bits are reset on the record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409999adb50ece16b81d59486af7af45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409999adb50ece16b81d59486af7af45">&#9670;&nbsp;</a></span>lock_rec_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode lock_mode&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a granted record lock of a transaction from the queue and grants locks to other transactions waiting in the queue if they now are entitled to a lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction that has set a record lock </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add8eda56dfbfc87c40fc55a96c779b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8eda56dfbfc87c40fc55a96c779b32">&#9670;&nbsp;</a></span>lock_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases transaction locks, and releases possible other transactions waiting because of these locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af16d93ff1543a5eb70bc252fc52410d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16d93ff1543a5eb70bc252fc52410d7">&#9670;&nbsp;</a></span>lock_release_autoinc_last_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_release_autoinc_last_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__vector__t.html">ib_vector_t</a> *&#160;</td>
          <td class="paramname"><em>autoinc_locks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the last lock from the transaction's autoinc locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoinc_locks</td><td>in/out: vector of AUTOINC locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0586798d137559b27f00d9212a565ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0586798d137559b27f00d9212a565ed7">&#9670;&nbsp;</a></span>lock_release_autoinc_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_release_autoinc_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release all the transaction's autoinc locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a430d15f2674ea7fb0d8cf61636192011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430d15f2674ea7fb0d8cf61636192011">&#9670;&nbsp;</a></span>lock_remove_all_on_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_remove_all_on_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>remove_also_table_sx_locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes locks on a table to be dropped or truncated. If remove_also_table_sx_locks is TRUE then table-level S and X locks are also removed in addition to other table-level and record-level locks. No lock, that is going to be removed, is allowed to be a wait lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to be dropped or truncated </td></tr>
    <tr><td class="paramname">remove_also_table_sx_locks</td><td>in: also removes table S and X locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c114fec902791921c84d744e35e6f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c114fec902791921c84d744e35e6f20">&#9670;&nbsp;</a></span>lock_remove_all_on_table_for_trx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_remove_all_on_table_for_trx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>remove_also_table_sx_locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes locks of a transaction on a table to be dropped. If remove_also_table_sx_locks is TRUE then table-level S and X locks are also removed in addition to other table-level and record-level locks. No lock that is going to be removed is allowed to be a wait lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to be dropped </td></tr>
    <tr><td class="paramname">trx</td><td>in: a transaction </td></tr>
    <tr><td class="paramname">remove_also_table_sx_locks</td><td>in: also removes table S and X locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0441a5473b53bfbed8aeec335812c381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0441a5473b53bfbed8aeec335812c381">&#9670;&nbsp;</a></span>lock_remove_recovered_trx_record_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint lock_remove_recovered_trx_record_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove any explicit record locks held by recovering transactions on the table. </p><dl class="section return"><dt>Returns</dt><dd>number of recovered transactions examined </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: check if there are any locks held on records in this table or on the table itself </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af404570474674730be01e3108d8725c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af404570474674730be01e3108d8725c3">&#9670;&nbsp;</a></span>lock_report_trx_id_insanity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_report_trx_id_insanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>max_trx_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reports that a transaction id is insensible, i.e., in the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_id</td><td>in: trx id </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">max_trx_id</td><td>in: <a class="el" href="trx0sys_8h.html#aaf92577bb351b5b6e51fac1f36a0abd3">trx_sys_get_max_trx_id()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae338c146d2999b264f77019e7a30fe76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae338c146d2999b264f77019e7a30fe76">&#9670;&nbsp;</a></span>lock_reset_lock_and_trx_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_reset_lock_and_trx_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The back pointer to a waiting lock request in the transaction is set to NULL and the wait bit in lock type_mode is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abece67995cb917a6ccca6cacfba18268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abece67995cb917a6ccca6cacfba18268">&#9670;&nbsp;</a></span>lock_sec_rec_cons_read_sees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool lock_sec_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structread__view__t.html">read_view_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that a non-clustered index record is seen in a consistent read.</p>
<p>NOTE that a non-clustered index page contains so little information on its modifications that also in the case false, the present version of rec may be the right, but we must check this from the clustered index record.</p>
<dl class="section return"><dt>Returns</dt><dd>true if certainly sees, or false if an earlier version of the clustered index record might be needed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">view</td><td>in: consistent read view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2373909c1bb1ccbc7611c5bcc51bc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2373909c1bb1ccbc7611c5bcc51bc86">&#9670;&nbsp;</a></span>lock_sec_rec_modify_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate modify (delete mark or delete unmark) of a secondary index record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified; NOTE: as this is a secondary index, we always have to modify the clustered index record first: see the comment below </td></tr>
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread (can be NULL if BTR_NO_LOCKING_FLAG) </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1d5f3bc41223f625ac09672a1ca19bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d5f3bc41223f625ac09672a1ca19bf">&#9670;&nbsp;</a></span>lock_sec_rec_read_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="lock0lock_8cc.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock()</a>, but reads a secondary index record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5d9cf52dcadcc1b217b6b3367f30f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d9cf52dcadcc1b217b6b3367f30f79">&#9670;&nbsp;</a></span>lock_sec_rec_some_has_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> lock_sec_rec_some_has_impl </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if some transaction has an implicit x-lock on a record in a secondary index. </p><dl class="section return"><dt>Returns</dt><dd>transaction id of the transaction which has the x-lock, or 0; NOTE that this function can return false positives but never false negatives. The caller must confirm all positive results by calling trx_is_active(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record </td></tr>
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa923691edf4a6cdaa775da9ca6389bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa923691edf4a6cdaa775da9ca6389bd">&#9670;&nbsp;</a></span>lock_set_lock_and_trx_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_set_lock_and_trx_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the wait flag of a lock and the back pointer in trx to lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
    <tr><td class="paramname">trx</td><td>in/out: trx </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c2350ce483b08686c48c19407f63da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2350ce483b08686c48c19407f63da9">&#9670;&nbsp;</a></span>lock_sys_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_sys_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the lock system at database shutdown. </p>

</div>
</div>
<a id="a40ad348feb00e96aec397b06dbec7c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ad348feb00e96aec397b06dbec7c64">&#9670;&nbsp;</a></span>lock_sys_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_sys_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the lock system at database start. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_cells</td><td>in: number of slots in lock hash table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a208ea6edee519ebcc19db17c80378f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208ea6edee519ebcc19db17c80378f78">&#9670;&nbsp;</a></span>lock_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_table </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the specified database table in the mode given. If the lock cannot be granted immediately, the query thread is put to wait. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">table</td><td>in/out: database table in dictionary cache </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a184b272b7c4a2c9e49e7e973fbb2d4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184b272b7c4a2c9e49e7e973fbb2d4ed">&#9670;&nbsp;</a></span>lock_table_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_table_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a table lock object and adds it as the last in the lock queue of the table. Does NOT check for deadlocks or lock compatibility. </p><dl class="section return"><dt>Returns</dt><dd>own: new lock object </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: database table in dictionary cache </td></tr>
    <tr><td class="paramname">type_mode</td><td>in: lock mode possibly ORed with LOCK_WAIT </td></tr>
    <tr><td class="paramname">trx</td><td>in: trx </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa10e4db7d11e1b4a0a5d3afd17467334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10e4db7d11e1b4a0a5d3afd17467334">&#9670;&nbsp;</a></span>lock_table_dequeue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_table_dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a table lock request, waiting or granted, from the queue and grants locks to other transactions in the queue, if they now are entitled to a lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_lock</td><td>in/out: table lock object; transactions waiting behind will get their lock requests granted, if they are now qualified to it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadc404f482d9124b4450bc71d73e69c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc404f482d9124b4450bc71d73e69c6">&#9670;&nbsp;</a></span>lock_table_enqueue_waiting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_table_enqueue_waiting </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueues a waiting request for a table lock which cannot be granted immediately. Checks for deadlocks. </p><dl class="section return"><dt>Returns</dt><dd>DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED, or DB_SUCCESS; DB_SUCCESS means that there was a deadlock, but another transaction was chosen as a victim, and we got the lock immediately: no need to wait then </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>in: lock mode this transaction is requesting </td></tr>
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee4e79640cb278627d5eae3f3d28edbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4e79640cb278627d5eae3f3d28edbe">&#9670;&nbsp;</a></span>lock_table_get_n_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_table_get_n_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of locks on a table. </p><dl class="section return"><dt>Returns</dt><dd>number of locks </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2d7ad8612a3da20e8b11ee4b4654e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d7ad8612a3da20e8b11ee4b4654e3b">&#9670;&nbsp;</a></span>lock_table_has()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a>* lock_table_has </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a transaction has the specified table lock, or stronger. This function should only be called by the thread that owns the transaction. </p><dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97a934d7768a7c68d802e733fcf86f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a934d7768a7c68d802e733fcf86f1c">&#9670;&nbsp;</a></span>lock_table_has_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool lock_table_has_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if there are any locks (table or rec) against table. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if table has either table or record locks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: check if there are any locks held on records in this table or on the table itself </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2eca8bb9a3dbb4068a6d8171cb064e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2eca8bb9a3dbb4068a6d8171cb064e6">&#9670;&nbsp;</a></span>lock_table_has_to_wait_in_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool lock_table_has_to_wait_in_queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>wait_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if a waiting table lock request still has to wait in a queue. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if still has to wait </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_lock</td><td>in: waiting table lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1056fa163c142cf71d21e6e3d046f060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1056fa163c142cf71d21e6e3d046f060">&#9670;&nbsp;</a></span>lock_table_ix_resurrect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_table_ix_resurrect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a table IX lock object for a resurrected transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d023c48cc94139eca00c9d769a310f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d023c48cc94139eca00c9d769a310f6">&#9670;&nbsp;</a></span>lock_table_other_has_incompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a>* lock_table_other_has_incompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if other transactions have an incompatible mode lock request in the lock queue. </p><dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction, or NULL if all transactions should be included </td></tr>
    <tr><td class="paramname">wait</td><td>in: LOCK_WAIT if also waiting locks are taken into account, or 0 if not </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae88eb4bd1862004641853bdac32e3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae88eb4bd1862004641853bdac32e3da">&#9670;&nbsp;</a></span>lock_table_pop_autoinc_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_table_pop_autoinc_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops autoinc lock requests from the transaction's autoinc_locks. We handle the case where there are gaps in the array and they need to be popped off the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction that owns the AUTOINC locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf98b08ed2e93284570fc964e5b24c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf98b08ed2e93284570fc964e5b24c16">&#9670;&nbsp;</a></span>lock_table_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_table_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of a table lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">lock</td><td>in: table type lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a678cd8514367bc1b2b43d3df58ce5325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678cd8514367bc1b2b43d3df58ce5325">&#9670;&nbsp;</a></span>lock_table_remove_autoinc_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_table_remove_autoinc_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an autoinc lock request from the transaction's autoinc_locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: table lock </td></tr>
    <tr><td class="paramname">trx</td><td>in/out: transaction that owns the lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3ef5a97ef26d0edfffcca4f4d413ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3ef5a97ef26d0edfffcca4f4d413ed">&#9670;&nbsp;</a></span>lock_table_remove_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_table_remove_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a table lock request from the queue and the trx list of locks; this is a low-level function which does NOT check if waiting requests can now be granted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: table lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdc6bccf13b2458e2b470264dbd7d8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc6bccf13b2458e2b470264dbd7d8e6">&#9670;&nbsp;</a></span>lock_trx_handle_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_trx_handle_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> whether the transaction has already been rolled back because it was selected as a deadlock victim, or if it has to wait then cancel the wait lock. </p><dl class="section return"><dt>Returns</dt><dd>DB_DEADLOCK, DB_LOCK_WAIT or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: trx lock state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c508752770a8c80424e73aa7b0c70d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c508752770a8c80424e73aa7b0c70d1">&#9670;&nbsp;</a></span>lock_trx_holds_autoinc_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool lock_trx_holds_autoinc_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if a transaction holds any autoinc locks. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the transaction holds any AUTOINC locks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af056c93107ab266face88ec37bae94c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af056c93107ab266face88ec37bae94c7">&#9670;&nbsp;</a></span>lock_trx_release_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_trx_release_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a transaction's locks, and releases possible other transactions waiting because of these locks. Change the state of the transaction to TRX_STATE_COMMITTED_IN_MEMORY. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7abfdceec128a59cd3c1ad2569bb3eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abfdceec128a59cd3c1ad2569bb3eaf">&#9670;&nbsp;</a></span>lock_trx_table_locks_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_trx_table_locks_remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock_to_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes table locks of the transaction on a table to be dropped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_to_remove</td><td>in: lock to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838b492f61b92e3678c7b7be18a2f1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838b492f61b92e3678c7b7be18a2f1be">&#9670;&nbsp;</a></span>lock_unlock_table_autoinc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_unlock_table_autoinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks AUTO_INC type locks that were possibly reserved by a trx. This function should be called at the the end of an SQL statement, by the connection thread that owns the transaction (trx-&gt;mysql_thd). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cc8f00508ee648886c7d51046af30d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc8f00508ee648886c7d51046af30d1">&#9670;&nbsp;</a></span>lock_update_copy_and_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_copy_and_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is copied to another and the original page is removed from the chain of leaf pages, except if page is the root! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: index page to which copied </td></tr>
    <tr><td class="paramname">block</td><td>in: index page; NOT the root! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd33b69b0b70f3e6643e70275550a0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd33b69b0b70f3e6643e70275550a0a7">&#9670;&nbsp;</a></span>lock_update_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a record is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: the record to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d322cfc717fe99e4c5c88f7b93512e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d322cfc717fe99e4c5c88f7b93512e">&#9670;&nbsp;</a></span>lock_update_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is discarded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heir_block</td><td>in: index page which will inherit the locks </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of the record which will inherit the locks </td></tr>
    <tr><td class="paramname">block</td><td>in: index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b800d596ae20af9b8b28f7a879658b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b800d596ae20af9b8b28f7a879658b4">&#9670;&nbsp;</a></span>lock_update_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a new user record is inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: the inserted record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a742d185fcf374672c516427602f386eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742d185fcf374672c516427602f386eb">&#9670;&nbsp;</a></span>lock_update_merge_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_merge_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>orig_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is merged to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_block</td><td>in: left page to which merged </td></tr>
    <tr><td class="paramname">orig_pred</td><td>in: original predecessor of supremum on the left page before merge </td></tr>
    <tr><td class="paramname">right_block</td><td>in: merged index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ec2bdadfd1e57ddbedfc05740e884eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec2bdadfd1e57ddbedfc05740e884eb">&#9670;&nbsp;</a></span>lock_update_merge_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_merge_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>orig_succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is merged to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right_block</td><td>in: right page to which merged </td></tr>
    <tr><td class="paramname">orig_succ</td><td>in: original successor of infimum on the right page before merge </td></tr>
    <tr><td class="paramname">left_block</td><td>in: merged index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82e3b8ed16aaab0770730fb554e23af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e3b8ed16aaab0770730fb554e23af2">&#9670;&nbsp;</a></span>lock_update_root_raise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_root_raise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when the root page is copied to another in btr_root_raise_and_insert. Note that we leave lock structs on the root page, even though they do not make sense on other than leaf pages: the reason is that in a pessimistic update the infimum record of the root page will act as a dummy carrier of the locks of the record to be updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page to which copied </td></tr>
    <tr><td class="paramname">root</td><td>in: root page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5beb29b82077fbb4080d16b8214c1d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5beb29b82077fbb4080d16b8214c1d57">&#9670;&nbsp;</a></span>lock_update_split_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_split_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is split to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right_block</td><td>in: right page </td></tr>
    <tr><td class="paramname">left_block</td><td>in: left page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cd5be77aa944f96aa6ff0aeebc6eb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd5be77aa944f96aa6ff0aeebc6eb98">&#9670;&nbsp;</a></span>lock_update_split_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_split_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is split to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right_block</td><td>in: right page </td></tr>
    <tr><td class="paramname">left_block</td><td>in: left page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a23c3322144060fbce53f44a421b2ea2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c3322144060fbce53f44a421b2ea2f">&#9670;&nbsp;</a></span>index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t <a class="el" href="structdict__index__t.html">dict_index_t</a>* index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: index </p>

</div>
</div>
<a id="a3579e0d5ddc973a66fae09c8990e05ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3579e0d5ddc973a66fae09c8990e05ea">&#9670;&nbsp;</a></span>lock_compatibility_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const byte lock_compatibility_matrix[5][5]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line"> </div><div class="line">  {  TRUE,  TRUE,  TRUE,  FALSE,  TRUE},</div><div class="line">  {  TRUE,  TRUE,  FALSE, FALSE,  TRUE},</div><div class="line">  {  TRUE,  FALSE, TRUE,  FALSE,  FALSE},</div><div class="line">  {  FALSE, FALSE, FALSE, FALSE,  FALSE},</div><div class="line">  {  TRUE,  TRUE,  FALSE, FALSE,  FALSE}</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
<a id="a73fe78c66c5b6c3a6cbaa8216617e9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fe78c66c5b6c3a6cbaa8216617e9ee">&#9670;&nbsp;</a></span>lock_deadlock_found</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool lock_deadlock_found = FALSE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We store info on the latest deadlock error to this buffer. InnoDB Monitor will then fetch it and print </p>

</div>
</div>
<a id="ab58b635675c25066d014d44908f3a487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58b635675c25066d014d44908f3a487">&#9670;&nbsp;</a></span>lock_latest_err_file</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* lock_latest_err_file</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only created if !srv_read_only_mode </p>

</div>
</div>
<a id="a399569564ef7eba550cac366234c1105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399569564ef7eba550cac366234c1105">&#9670;&nbsp;</a></span>lock_mark_counter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t lock_mark_counter = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used in deadlock tracking. Protected by lock_sys-&gt;mutex. </p>

</div>
</div>
<a id="af0249a4de857cab870922d46e750ea9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0249a4de857cab870922d46e750ea9d">&#9670;&nbsp;</a></span>lock_stack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlock__stack__t.html">lock_stack_t</a>* lock_stack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stack to use during DFS search. Currently only a single stack is required because there is no parallel deadlock check. This stack is protected by the <a class="el" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">lock_sys_t::mutex</a>. </p>

</div>
</div>
<a id="a1c37e6a5830ee34d6670d87ccc14128f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c37e6a5830ee34d6670d87ccc14128f">&#9670;&nbsp;</a></span>lock_strength_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const byte lock_strength_matrix[5][5]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line"> </div><div class="line">  {  TRUE,  FALSE, FALSE,  FALSE, FALSE},</div><div class="line">  {  TRUE,  TRUE,  FALSE, FALSE,  FALSE},</div><div class="line">  {  TRUE,  FALSE, TRUE,  FALSE,  FALSE},</div><div class="line">  {  TRUE,  TRUE,  TRUE,  TRUE,   TRUE},</div><div class="line">  {  FALSE, FALSE, FALSE, FALSE,  TRUE}</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
<a id="a1743fff1d65daa7cd28852fcc17e5b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1743fff1d65daa7cd28852fcc17e5b87">&#9670;&nbsp;</a></span>lock_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structlock__sys__t.html">lock_sys_t</a>* lock_sys = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The lock system </p>

</div>
</div>
<a id="ab01b6fdae5434d9daf8ec111f3ed9824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01b6fdae5434d9daf8ec111f3ed9824">&#9670;&nbsp;</a></span>offsets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t <a class="el" href="structdict__index__t.html">dict_index_t</a> const ulint* offsets</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <span class="keywordtype">bool</span>            is_ok</div></div><!-- fragment --><p>&lt; in: rec_get_offsets(rec, index) </p>

</div>
</div>
<a id="afd2b8f3cc32359d262e3cda1e86baf1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2b8f3cc32359d262e3cda1e86baf1a">&#9670;&nbsp;</a></span>rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t* rec</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: trx id in: user record </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

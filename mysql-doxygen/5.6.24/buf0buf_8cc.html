<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/buf/buf0buf.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_19e7dc57837d445aa8a255d4d3e40a16.html">buf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0buf.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buddy_8h_source.html">buf0buddy.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0undo_8h_source.html">trx0undo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0recv_8h_source.html">log0recv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;buf0checksum.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9747edc38b3e25bfc6042350dd40e30b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a9747edc38b3e25bfc6042350dd40e30b">MONITOR_RW_COUNTER</a>(io_type,  counter)</td></tr>
<tr class="separator:a9747edc38b3e25bfc6042350dd40e30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7f96406b87de005b0234f06c369d8ad4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7f96406b87de005b0234f06c369d8ad4">buf_pool_get_oldest_modification</a> (void)</td></tr>
<tr class="separator:a7f96406b87de005b0234f06c369d8ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb02ffe09cbab0f33f013804f32ce8e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aeeb02ffe09cbab0f33f013804f32ce8e">buf_get_total_list_len</a> (ulint *LRU_len, ulint *free_len, ulint *flush_list_len)</td></tr>
<tr class="separator:aeeb02ffe09cbab0f33f013804f32ce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68fb2e98dd06f51f607d86e5e68505f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa68fb2e98dd06f51f607d86e5e68505f">buf_get_total_list_size_in_bytes</a> (<a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a> *buf_pools_list_size)</td></tr>
<tr class="separator:aa68fb2e98dd06f51f607d86e5e68505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb3cc3b0face86f802cc1e827c18c23"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a1cb3cc3b0face86f802cc1e827c18c23">buf_get_total_stat</a> (<a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> *tot_stat)</td></tr>
<tr class="separator:a1cb3cc3b0face86f802cc1e827c18c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1364bb9b989dc1f07c913b14f29a9fb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#af1364bb9b989dc1f07c913b14f29a9fb">buf_block_alloc</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="separator:af1364bb9b989dc1f07c913b14f29a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3917d4a5b0630a356a9d244886ebf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#adc3917d4a5b0630a356a9d244886ebf9">buf_page_is_zeroes</a> (const byte *read_buf, const ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>)</td></tr>
<tr class="separator:adc3917d4a5b0630a356a9d244886ebf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d1cedcc7115ef5e7518d26cc24ccbc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a97d1cedcc7115ef5e7518d26cc24ccbc">buf_page_is_corrupted</a> (bool check_lsn, const byte *read_buf, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>)</td></tr>
<tr class="separator:a97d1cedcc7115ef5e7518d26cc24ccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca58932cd0b54d76ebc8cc1521880a97"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aca58932cd0b54d76ebc8cc1521880a97">buf_page_print</a> (const byte *read_buf, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:aca58932cd0b54d76ebc8cc1521880a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945adb066f000ee33cd26fcae9d943c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a945adb066f000ee33cd26fcae9d943c5">buf_block_init</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, byte *frame)</td></tr>
<tr class="separator:a945adb066f000ee33cd26fcae9d943c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7810d870d22eb4c164c652204400ff35"><td class="memItemLeft" align="right" valign="top">static buf_chunk_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7810d870d22eb4c164c652204400ff35">buf_chunk_init</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, buf_chunk_t *chunk, ulint mem_size)</td></tr>
<tr class="separator:a7810d870d22eb4c164c652204400ff35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c83103459c7d5ed0fed83b35eaf1b6"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#af9c83103459c7d5ed0fed83b35eaf1b6">buf_chunk_not_freed</a> (buf_chunk_t *chunk)</td></tr>
<tr class="separator:af9c83103459c7d5ed0fed83b35eaf1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf95ed2818750214caab3fa60a4541a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#acaf95ed2818750214caab3fa60a4541a">buf_pool_set_sizes</a> (void)</td></tr>
<tr class="separator:acaf95ed2818750214caab3fa60a4541a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5fb64c83075bb52b4995316fd83b29"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a6f5fb64c83075bb52b4995316fd83b29">buf_pool_init_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint buf_pool_size, ulint instance_no)</td></tr>
<tr class="separator:a6f5fb64c83075bb52b4995316fd83b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cac1411711bbe034e1d6742c5ab6f63"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a5cac1411711bbe034e1d6742c5ab6f63">buf_pool_free_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="separator:a5cac1411711bbe034e1d6742c5ab6f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f5706e1f3642ff2e7c911e177faf93"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a65f5706e1f3642ff2e7c911e177faf93">buf_pool_init</a> (ulint total_size, ulint n_instances)</td></tr>
<tr class="separator:a65f5706e1f3642ff2e7c911e177faf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a32cbba300ff8f3f33bc54e47eb4360"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a0a32cbba300ff8f3f33bc54e47eb4360">buf_pool_free</a> (ulint n_instances)</td></tr>
<tr class="separator:a0a32cbba300ff8f3f33bc54e47eb4360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5358efb915e801353ddfc12178c7331b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a5358efb915e801353ddfc12178c7331b">buf_pool_clear_hash_index</a> (void)</td></tr>
<tr class="separator:a5358efb915e801353ddfc12178c7331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bae3b57524cdb851a6f188da057402"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a23bae3b57524cdb851a6f188da057402">buf_relocate</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *dpage)</td></tr>
<tr class="separator:a23bae3b57524cdb851a6f188da057402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe237828f00da332051a0c48ebe504b9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#afe237828f00da332051a0c48ebe504b9">buf_pool_watch_is_sentinel</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:afe237828f00da332051a0c48ebe504b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29161a9d08696f9e553110ebcc91e987"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a29161a9d08696f9e553110ebcc91e987">buf_pool_watch_set</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulint <a class="el" href="buf0buf_8cc.html#a590e5804107a898143baa2a68550a051">fold</a>)</td></tr>
<tr class="separator:a29161a9d08696f9e553110ebcc91e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bcc01e7526b69839c6a4eff18cbb14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#af9bcc01e7526b69839c6a4eff18cbb14">buf_pool_watch_remove</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint <a class="el" href="buf0buf_8cc.html#a590e5804107a898143baa2a68550a051">fold</a>, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *watch)</td></tr>
<tr class="separator:af9bcc01e7526b69839c6a4eff18cbb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad347338911fe564cc72f4a5f3f11a608"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ad347338911fe564cc72f4a5f3f11a608">buf_pool_watch_unset</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:ad347338911fe564cc72f4a5f3f11a608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabc341f2e6d13239c8397a0bcf98137"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aaabc341f2e6d13239c8397a0bcf98137">buf_pool_watch_occurred</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:aaabc341f2e6d13239c8397a0bcf98137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb94effb9f9c0de7b40c07a91ceee16"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a2fb94effb9f9c0de7b40c07a91ceee16">buf_page_make_young</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:a2fb94effb9f9c0de7b40c07a91ceee16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03ec3da38f4ad513f96d7d71663e7d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae03ec3da38f4ad513f96d7d71663e7d8">buf_page_make_young_if_needed</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:ae03ec3da38f4ad513f96d7d71663e7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a31add4644416c05c769e96bde6ce65"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a4a31add4644416c05c769e96bde6ce65">buf_reset_check_index_page_at_flush</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a4a31add4644416c05c769e96bde6ce65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2f5cf7e8fc097b7b8933ea29a0f14d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a6c2f5cf7e8fc097b7b8933ea29a0f14d">buf_block_try_discard_uncompressed</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a6c2f5cf7e8fc097b7b8933ea29a0f14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8580c21048bc75fc52fcf1b14f7b2d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aba8580c21048bc75fc52fcf1b14f7b2d">buf_page_get_zip</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:aba8580c21048bc75fc52fcf1b14f7b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d87b3ccb53d066f14f66b68de8e6dd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa3d87b3ccb53d066f14f66b68de8e6dd">buf_block_init_low</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:aa3d87b3ccb53d066f14f66b68de8e6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97c93aa8f9ecd83bbc579fc36640ff1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae97c93aa8f9ecd83bbc579fc36640ff1">buf_zip_decompress</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ibool <a class="el" href="row0ins_8cc.html#af89eccd3e535f029833696f4c35f730e">check</a>)</td></tr>
<tr class="separator:ae97c93aa8f9ecd83bbc579fc36640ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84a3f82b739742c17ae896c4dfa14f0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ad84a3f82b739742c17ae896c4dfa14f0">buf_block_align_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const byte *ptr)</td></tr>
<tr class="separator:ad84a3f82b739742c17ae896c4dfa14f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856825cf58c3701a4654dde470217932"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a856825cf58c3701a4654dde470217932">buf_block_align</a> (const byte *ptr)</td></tr>
<tr class="separator:a856825cf58c3701a4654dde470217932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dbf5ca3276523e70afbb7df06e71a9"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a72dbf5ca3276523e70afbb7df06e71a9">buf_pointer_is_block_field_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const void *ptr)</td></tr>
<tr class="separator:a72dbf5ca3276523e70afbb7df06e71a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cabada29220f8ab778c3d5d849772f5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a0cabada29220f8ab778c3d5d849772f5">buf_pointer_is_block_field</a> (const void *ptr)</td></tr>
<tr class="separator:a0cabada29220f8ab778c3d5d849772f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7b61b49a3db496002e995a53fca0e5"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a8f7b61b49a3db496002e995a53fca0e5">buf_block_is_uncompressed</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a8f7b61b49a3db496002e995a53fca0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d073376daf32f894c496cd3b6f61cd4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a4d073376daf32f894c496cd3b6f61cd4">buf_wait_for_read</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a4d073376daf32f894c496cd3b6f61cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35978421b8e05e91ad4f4bd48b1db416"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a35978421b8e05e91ad4f4bd48b1db416">buf_page_get_gen</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *guess, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a35978421b8e05e91ad4f4bd48b1db416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2249b3ba3868dc2afd2ebea3480a01"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a4b2249b3ba3868dc2afd2ebea3480a01">buf_page_optimistic_get</a> (ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ib_uint64_t modify_clock, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a4b2249b3ba3868dc2afd2ebea3480a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa084c3df8c4e1390fc8389cdc639e69b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa084c3df8c4e1390fc8389cdc639e69b">buf_page_get_known_nowait</a> (ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:aa084c3df8c4e1390fc8389cdc639e69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecdc5cbcd0ed4554e3dfd1dfe96d452"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a2ecdc5cbcd0ed4554e3dfd1dfe96d452">buf_page_try_get_func</a> (ulint space_id, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a2ecdc5cbcd0ed4554e3dfd1dfe96d452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36e120d41b65fc009f011a62dc107e5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#af36e120d41b65fc009f011a62dc107e5">buf_page_init_low</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:af36e120d41b65fc009f011a62dc107e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76e9a325251e583094cbbd123284bd6"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ad76e9a325251e583094cbbd123284bd6">__attribute__</a> ((nonnull)) void buf_page_init(<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool</td></tr>
<tr class="separator:ad76e9a325251e583094cbbd123284bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad525a3d88afa98a481f132787f5c6926"><td class="memItemLeft" align="right" valign="top"><a id="ad525a3d88afa98a481f132787f5c6926"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (buf_pool==<a class="el" href="buf0buf_8h.html#a38f885a522c33e61c4187d08f57f55cd">buf_pool_get</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>))</td></tr>
<tr class="separator:ad525a3d88afa98a481f132787f5c6926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3c225d2568fb2ad9552f6d1638cbfb"><td class="memItemLeft" align="right" valign="top"><a id="afc3c225d2568fb2ad9552f6d1638cbfb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="buf0buf_8h.html#af996360800fd59fb8681a329ad2575bf">buf_pool_mutex_own</a>(buf_pool))</td></tr>
<tr class="separator:afc3c225d2568fb2ad9552f6d1638cbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3878b338d2e693498235420fb1ec38e0"><td class="memItemLeft" align="right" valign="top"><a id="a3878b338d2e693498235420fb1ec38e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (mutex_own(&amp;(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>-&gt;mutex)))</td></tr>
<tr class="separator:a3878b338d2e693498235420fb1ec38e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaf44511c8a0b59fb7aa84eb93e0d4a"><td class="memItemLeft" align="right" valign="top"><a id="abaaf44511c8a0b59fb7aa84eb93e0d4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_a</b> (<a class="el" href="buf0buf_8h.html#a35d15282125fda90d3090bd4d9d96aa2">buf_block_get_state</a>(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>) !=<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aaf26cdfc58e629f98cf27da284f6cf5f9">BUF_BLOCK_FILE_PAGE</a>)</td></tr>
<tr class="separator:abaaf44511c8a0b59fb7aa84eb93e0d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7763cf202ec4a8a83bea769224556eee"><td class="memItemLeft" align="right" valign="top"><a id="a7763cf202ec4a8a83bea769224556eee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_set_file_page</b> (<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a7763cf202ec4a8a83bea769224556eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cc3ad33262be929c35d1de79f1706f"><td class="memItemLeft" align="right" valign="top"><a id="ad2cc3ad33262be929c35d1de79f1706f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_init_low</b> (<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:ad2cc3ad33262be929c35d1de79f1706f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d8f9e95ec26c22f6f7e78ae40989fb"><td class="memItemLeft" align="right" valign="top"><a id="a88d8f9e95ec26c22f6f7e78ae40989fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (hash_page==NULL)</td></tr>
<tr class="separator:a88d8f9e95ec26c22f6f7e78ae40989fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c19ec9cad158876be820266aeae93d"><td class="memItemLeft" align="right" valign="top"><a id="a47c19ec9cad158876be820266aeae93d"></a>
<a class="el" href="fsp0fsp_8cc.html#a0544c3fe466e421738dae463968b70ba">else</a>&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="buf0buf_8h.html#a48240c3ddf91fb97aa1c8387ea71a716">buf_pool_watch_is_sentinel</a>(buf_pool, hash_page))</td></tr>
<tr class="separator:a47c19ec9cad158876be820266aeae93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132d0d3ddece18cca902680a636a6089"><td class="memItemLeft" align="right" valign="top"><a id="a132d0d3ddece18cca902680a636a6089"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (!<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>-&gt;page.in_zip_hash)</td></tr>
<tr class="separator:a132d0d3ddece18cca902680a636a6089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0052aa2894763edbc59ab125807ac8"><td class="memItemLeft" align="right" valign="top"><a id="a1f0052aa2894763edbc59ab125807ac8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_d</b> (<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>-&gt;page.in_page_hash=TRUE)</td></tr>
<tr class="separator:a1f0052aa2894763edbc59ab125807ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e16af6c912d9ed273df70e39641900"><td class="memItemLeft" align="right" valign="top"><a id="ae7e16af6c912d9ed273df70e39641900"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HASH_INSERT</b> (<a class="el" href="structbuf__page__t.html">buf_page_t</a>, hash, buf_pool-&gt;page_hash, <a class="el" href="buf0buf_8cc.html#a590e5804107a898143baa2a68550a051">fold</a>, &amp;<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>-&gt;<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:ae7e16af6c912d9ed273df70e39641900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66651d7ba2b4f035c2c5d5039c4d5cde"><td class="memItemLeft" align="right" valign="top"><a id="a66651d7ba2b4f035c2c5d5039c4d5cde"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>)</td></tr>
<tr class="separator:a66651d7ba2b4f035c2c5d5039c4d5cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6424ffc76b8af1be289e341334f14905"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a6424ffc76b8af1be289e341334f14905">buf_page_init_for_read</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *<a class="el" href="row0import_8cc.html#a52482fdd3721e7db69dc740aefee8ad4">err</a>, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ibool unzip, ib_int64_t tablespace_version, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a6424ffc76b8af1be289e341334f14905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46fda4f90104f3919b4577d11caf957"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa46fda4f90104f3919b4577d11caf957">buf_page_create</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:aa46fda4f90104f3919b4577d11caf957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6373a18fab2a1df7def6fd06d0efba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#afe6373a18fab2a1df7def6fd06d0efba">buf_page_monitor</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> io_type)</td></tr>
<tr class="separator:afe6373a18fab2a1df7def6fd06d0efba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb257c0fbc6e57033c755a8934a3cb33"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#abb257c0fbc6e57033c755a8934a3cb33">buf_mark_space_corrupt</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:abb257c0fbc6e57033c755a8934a3cb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b42a085941cbde456551be2ebf514c6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a1b42a085941cbde456551be2ebf514c6">buf_page_io_complete</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:a1b42a085941cbde456551be2ebf514c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8339c235a1730c9b2c1650b8849789b"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae8339c235a1730c9b2c1650b8849789b">buf_all_freed_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="separator:ae8339c235a1730c9b2c1650b8849789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b96a1551d95ca86c218cc9b4e48e80"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a55b96a1551d95ca86c218cc9b4e48e80">buf_pool_invalidate_instance</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="separator:a55b96a1551d95ca86c218cc9b4e48e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e9d3982cda06d0032aa5dec9a3fc69"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a65e9d3982cda06d0032aa5dec9a3fc69">buf_pool_invalidate</a> (void)</td></tr>
<tr class="separator:a65e9d3982cda06d0032aa5dec9a3fc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81cf5958ac70dc03d2bd8c69b355975"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa81cf5958ac70dc03d2bd8c69b355975">buf_get_n_pending_read_ios</a> (void)</td></tr>
<tr class="separator:aa81cf5958ac70dc03d2bd8c69b355975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66718ee074230bc14001aee57e5044a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ab66718ee074230bc14001aee57e5044a">buf_get_modified_ratio_pct</a> (void)</td></tr>
<tr class="separator:ab66718ee074230bc14001aee57e5044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5418342f432074305965a75c1fedc7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a3b5418342f432074305965a75c1fedc7">buf_stats_aggregate_pool_info</a> (<a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *total_info, const <a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *pool_info)</td></tr>
<tr class="separator:a3b5418342f432074305965a75c1fedc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0657a55a27fb821febe21fd93c5e1bb7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a0657a55a27fb821febe21fd93c5e1bb7">buf_stats_get_pool_info</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint pool_id, <a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *all_pool_info)</td></tr>
<tr class="separator:a0657a55a27fb821febe21fd93c5e1bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13818c7dd5436b08f17627474a64e3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7b13818c7dd5436b08f17627474a64e3">buf_print_io_instance</a> (<a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *pool_info, FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:a7b13818c7dd5436b08f17627474a64e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20138c8871f85d710230adc053943f3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ab20138c8871f85d710230adc053943f3">buf_print_io</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:ab20138c8871f85d710230adc053943f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cb16ef6711245409a7e117e6da54e1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae7cb16ef6711245409a7e117e6da54e1">buf_refresh_io_stats</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="separator:ae7cb16ef6711245409a7e117e6da54e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6817c8278c04718851b86d4c4a613e43"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a6817c8278c04718851b86d4c4a613e43">buf_refresh_io_stats_all</a> (void)</td></tr>
<tr class="separator:a6817c8278c04718851b86d4c4a613e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9e1d761f5c154cf5c5ab26a07c6444"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a6f9e1d761f5c154cf5c5ab26a07c6444">buf_all_freed</a> (void)</td></tr>
<tr class="separator:a6f9e1d761f5c154cf5c5ab26a07c6444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12113d926b18d7fd1ffef49e5d72ea4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ac12113d926b18d7fd1ffef49e5d72ea4">buf_pool_check_no_pending_io</a> (void)</td></tr>
<tr class="separator:ac12113d926b18d7fd1ffef49e5d72ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae252c6f42e712b83871abe3faeea7093"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#ae252c6f42e712b83871abe3faeea7093">WAIT_FOR_READ</a> = 100</td></tr>
<tr class="separator:ae252c6f42e712b83871abe3faeea7093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7076240d95384c7a4b81433a490fe3c2"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a7076240d95384c7a4b81433a490fe3c2">BUF_PAGE_READ_MAX_RETRIES</a> = 100</td></tr>
<tr class="separator:a7076240d95384c7a4b81433a490fe3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9c47d1c8a057b33e90dae2ecdb168d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a1d9c47d1c8a057b33e90dae2ecdb168d">buf_pool_ptr</a></td></tr>
<tr class="separator:a1d9c47d1c8a057b33e90dae2ecdb168d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd72ce2b4bdc1d7c9b787ceb546ac13f"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#acd72ce2b4bdc1d7c9b787ceb546ac13f">space</a></td></tr>
<tr class="separator:acd72ce2b4bdc1d7c9b787ceb546ac13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd57c45a68b89b09104f911b030540bf"><td class="memItemLeft" align="right" valign="top">static ulint ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#afd57c45a68b89b09104f911b030540bf">offset</a></td></tr>
<tr class="separator:afd57c45a68b89b09104f911b030540bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590e5804107a898143baa2a68550a051"><td class="memItemLeft" align="right" valign="top">static ulint ulint ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a590e5804107a898143baa2a68550a051">fold</a></td></tr>
<tr class="separator:a590e5804107a898143baa2a68550a051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42ecdfcbc7e429d10a64c479d1e0f67"><td class="memItemLeft" align="right" valign="top">static ulint ulint ulint ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#aa42ecdfcbc7e429d10a64c479d1e0f67">zip_size</a></td></tr>
<tr class="separator:aa42ecdfcbc7e429d10a64c479d1e0f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076fae382a175611330a47d0327b150f"><td class="memItemLeft" align="right" valign="top">static ulint ulint ulint ulint <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8cc.html#a076fae382a175611330a47d0327b150f">block</a></td></tr>
<tr class="separator:a076fae382a175611330a47d0327b150f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c205b895f1b20fab4faa90b4a7d6d11"><td class="memItemLeft" align="right" valign="top"><a id="a5c205b895f1b20fab4faa90b4a7d6d11"></a>
<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lock_hash_val</b> = <a class="el" href="lock0lock_8h.html#a5f2ec292dd7525aff0dee8910ca3a99d">lock_rec_hash</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a5c205b895f1b20fab4faa90b4a7d6d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0eaff561aba96e5c4c066e183850d6"><td class="memItemLeft" align="right" valign="top"><a id="a9c0eaff561aba96e5c4c066e183850d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>hash_page</b> = <a class="el" href="buf0buf_8h.html#a82e4bd838178ed27ad3f174ac5084390">buf_page_hash_get_low</a>(buf_pool, <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, <a class="el" href="buf0buf_8cc.html#a590e5804107a898143baa2a68550a051">fold</a>)</td></tr>
<tr class="separator:a9c0eaff561aba96e5c4c066e183850d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544c3fe466e421738dae463968b70ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>else</b></td></tr>
<tr class="separator:a0544c3fe466e421738dae463968b70ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3839f91cd04f0f2cb4894e49ce3a5e1e"><td class="memItemLeft" align="right" valign="top"><a id="a3839f91cd04f0f2cb4894e49ce3a5e1e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_error</b></td></tr>
<tr class="separator:a3839f91cd04f0f2cb4894e49ce3a5e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The database buffer buf_pool</p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9747edc38b3e25bfc6042350dd40e30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9747edc38b3e25bfc6042350dd40e30b">&#9670;&nbsp;</a></span>MONITOR_RW_COUNTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MONITOR_RW_COUNTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">io_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">counter&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((io_type == <a class="code" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27a43879bd19d7f60caa87698730d08ffcd">BUF_IO_READ</a>)                       \</div><div class="line">         ? (counter##_READ)                             \</div><div class="line">         : (counter##_WRITTEN))</div><div class="ttc" id="buf0types_8h_html_a9d992d311e12fe579c419e7f98f80e27a43879bd19d7f60caa87698730d08ffcd"><div class="ttname"><a href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27a43879bd19d7f60caa87698730d08ffcd">BUF_IO_READ</a></div><div class="ttdef"><b>Definition:</b> buf0types.h:75</div></div>
</div><!-- fragment --><p>Macro to determine whether the read of write counter is used depending on the io_type </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad76e9a325251e583094cbbd123284bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76e9a325251e583094cbbd123284bd6">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inits a page to the buffer buf_pool. </p>

</div>
</div>
<a id="a6f9e1d761f5c154cf5c5ab26a07c6444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9e1d761f5c154cf5c5ab26a07c6444">&#9670;&nbsp;</a></span>buf_all_freed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_all_freed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if all pages in all buffer pools are in a replacable state. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if not </dd></dl>

</div>
</div>
<a id="ae8339c235a1730c9b2c1650b8849789b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8339c235a1730c9b2c1650b8849789b">&#9670;&nbsp;</a></span>buf_all_freed_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool buf_all_freed_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asserts that all file pages in the buffer are in a replaceable state. </p><dl class="section return"><dt>Returns</dt><dd>TRUE </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instancce </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a856825cf58c3701a4654dde470217932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856825cf58c3701a4654dde470217932">&#9670;&nbsp;</a></span>buf_block_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_align </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the block to whose frame the pointer is pointing to. </p><dl class="section return"><dt>Returns</dt><dd>pointer to block, never NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: pointer to a frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad84a3f82b739742c17ae896c4dfa14f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84a3f82b739742c17ae896c4dfa14f0">&#9670;&nbsp;</a></span>buf_block_align_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_align_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the block to whose frame the pointer is pointing to if found in this buffer pool instance. </p><dl class="section return"><dt>Returns</dt><dd>pointer to block </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer in which the block resides </td></tr>
    <tr><td class="paramname">ptr</td><td>in: pointer to a frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1364bb9b989dc1f07c913b14f29a9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1364bb9b989dc1f07c913b14f29a9fb">&#9670;&nbsp;</a></span>buf_block_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a buffer block. </p><dl class="section return"><dt>Returns</dt><dd>own: the allocated block, in state BUF_BLOCK_MEMORY </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance, or NULL for round-robin selection of the buffer pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a945adb066f000ee33cd26fcae9d943c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945adb066f000ee33cd26fcae9d943c5">&#9670;&nbsp;</a></span>buf_block_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_block_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a buffer control block when the buf_pool is created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">block</td><td>in: pointer to control block </td></tr>
    <tr><td class="paramname">frame</td><td>in: pointer to buffer frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3d87b3ccb53d066f14f66b68de8e6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d87b3ccb53d066f14f66b68de8e6dd">&#9670;&nbsp;</a></span>buf_block_init_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_init_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize some fields of a control block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block to init </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f7b61b49a3db496002e995a53fca0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7b61b49a3db496002e995a53fca0e5">&#9670;&nbsp;</a></span>buf_block_is_uncompressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool buf_block_is_uncompressed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find out if a buffer block was created by <a class="el" href="buf0buf_8cc.html#a7810d870d22eb4c164c652204400ff35">buf_chunk_init()</a>. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if "block" has been added to buf_pool-&gt;free by <a class="el" href="buf0buf_8cc.html#a7810d870d22eb4c164c652204400ff35">buf_chunk_init()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">block</td><td>in: pointer to block, not dereferenced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c2f5cf7e8fc097b7b8933ea29a0f14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2f5cf7e8fc097b7b8933ea29a0f14d">&#9670;&nbsp;</a></span>buf_block_try_discard_uncompressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_block_try_discard_uncompressed </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to discard the uncompressed frame of a compressed page. The caller should not be holding any mutexes when this function is called. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if successful, FALSE otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7810d870d22eb4c164c652204400ff35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7810d870d22eb4c164c652204400ff35">&#9670;&nbsp;</a></span>buf_chunk_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static buf_chunk_t* buf_chunk_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buf_chunk_t *&#160;</td>
          <td class="paramname"><em>chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a chunk of buffer frames. </p><dl class="section return"><dt>Returns</dt><dd>chunk, or NULL on failure </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">chunk</td><td>out: chunk of buffers </td></tr>
    <tr><td class="paramname">mem_size</td><td>in: requested size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9c83103459c7d5ed0fed83b35eaf1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c83103459c7d5ed0fed83b35eaf1b6">&#9670;&nbsp;</a></span>buf_chunk_not_freed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_chunk_not_freed </td>
          <td>(</td>
          <td class="paramtype">buf_chunk_t *&#160;</td>
          <td class="paramname"><em>chunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks that all file pages in the buffer chunk are in a replaceable state. </p><dl class="section return"><dt>Returns</dt><dd>address of a non-free block, or NULL if all freed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunk</td><td>in: chunk being checked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab66718ee074230bc14001aee57e5044a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66718ee074230bc14001aee57e5044a">&#9670;&nbsp;</a></span>buf_get_modified_ratio_pct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_get_modified_ratio_pct </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the ratio in percents of modified pages in the buffer pool / database pages in the buffer pool. </p><dl class="section return"><dt>Returns</dt><dd>modified page percentage ratio </dd></dl>

</div>
</div>
<a id="aa81cf5958ac70dc03d2bd8c69b355975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81cf5958ac70dc03d2bd8c69b355975">&#9670;&nbsp;</a></span>buf_get_n_pending_read_ios()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_get_n_pending_read_ios </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of pending buf pool read ios. </p><dl class="section return"><dt>Returns</dt><dd>number of pending read I/O operations </dd></dl>

</div>
</div>
<a id="aeeb02ffe09cbab0f33f013804f32ce8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb02ffe09cbab0f33f013804f32ce8e">&#9670;&nbsp;</a></span>buf_get_total_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_get_total_list_len </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>LRU_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>free_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>flush_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get total buffer pool statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LRU_len</td><td>out: length of all LRU lists </td></tr>
    <tr><td class="paramname">free_len</td><td>out: length of all free lists </td></tr>
    <tr><td class="paramname">flush_list_len</td><td>out: length of all flush lists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa68fb2e98dd06f51f607d86e5e68505f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68fb2e98dd06f51f607d86e5e68505f">&#9670;&nbsp;</a></span>buf_get_total_list_size_in_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_get_total_list_size_in_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pools_list_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get total list size in bytes from all buffer pools. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pools_list_size</td><td>out: list sizes in all buffer pools </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cb3cc3b0face86f802cc1e827c18c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb3cc3b0face86f802cc1e827c18c23">&#9670;&nbsp;</a></span>buf_get_total_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_get_total_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> *&#160;</td>
          <td class="paramname"><em>tot_stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get total buffer pool statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tot_stat</td><td>out: buffer pool stats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb257c0fbc6e57033c755a8934a3cb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb257c0fbc6e57033c755a8934a3cb33">&#9670;&nbsp;</a></span>buf_mark_space_corrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool buf_mark_space_corrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mark a table with the specified space pointed by bpage-&gt;space corrupted. Also remove the bpage from LRU list. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa46fda4f90104f3919b4577d11caf957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46fda4f90104f3919b4577d11caf957">&#9670;&nbsp;</a></span>buf_page_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a page to the buffer buf_pool. The page is usually not read from a file even if it cannot be found in the buffer buf_pool. This is one of the functions which perform to a block a state transition NOT_USED =&gt; FILE_PAGE (the other is buf_page_get_gen). </p><dl class="section return"><dt>Returns</dt><dd>pointer to the block, page bufferfixed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset of the page within space in units of a page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size, or 0 </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35978421b8e05e91ad4f4bd48b1db416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35978421b8e05e91ad4f4bd48b1db416">&#9670;&nbsp;</a></span>buf_page_get_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_get_gen </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the general function used to get access to a database page. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the block or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
    <tr><td class="paramname">rw_latch</td><td>in: RW_S_LATCH, RW_X_LATCH, RW_NO_LATCH </td></tr>
    <tr><td class="paramname">guess</td><td>in: guessed block or NULL </td></tr>
    <tr><td class="paramname">mode</td><td>in: BUF_GET, BUF_GET_IF_IN_POOL, BUF_PEEK_IF_IN_POOL, BUF_GET_NO_LATCH, or BUF_GET_IF_IN_POOL_OR_WATCH </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa084c3df8c4e1390fc8389cdc639e69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa084c3df8c4e1390fc8389cdc639e69b">&#9670;&nbsp;</a></span>buf_page_get_known_nowait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_page_get_known_nowait </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to get access to a known database page, when no waiting can be done. For example, if a search in an adaptive hash index leads us to this frame. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rw_latch</td><td>in: RW_S_LATCH, RW_X_LATCH </td></tr>
    <tr><td class="paramname">block</td><td>in: the known page </td></tr>
    <tr><td class="paramname">mode</td><td>in: BUF_MAKE_YOUNG or BUF_KEEP_OLD </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba8580c21048bc75fc52fcf1b14f7b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8580c21048bc75fc52fcf1b14f7b2d">&#9670;&nbsp;</a></span>buf_page_get_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_page_get_zip </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get read access to a compressed page (usually of type FIL_PAGE_TYPE_ZBLOB or FIL_PAGE_TYPE_ZBLOB2). The page must be released with <a class="el" href="buf0buf_8h.html#a6ce5d2fc2911e993640a50d360670592">buf_page_release_zip()</a>. NOTE: the page is not protected by any latch. Mutual exclusion has to be implemented at a higher level. In other words, all possible accesses to a given page through this function must be protected by the same set of mutexes or latches. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the block </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6424ffc76b8af1be289e341334f14905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6424ffc76b8af1be289e341334f14905">&#9670;&nbsp;</a></span>buf_page_init_for_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_page_init_for_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>unzip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_int64_t&#160;</td>
          <td class="paramname"><em>tablespace_version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function which inits a page for read to the buffer buf_pool. If the page is (1) already in buf_pool, or (2) if we specify to read only ibuf pages and the page is not an ibuf page, or (3) if the space is deleted or being deleted, then this function does nothing. Sets the io_fix flag to BUF_IO_READ and sets a non-recursive exclusive lock on the buffer frame. The io-handler must take care that the flag is cleared and the lock released later. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the block or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>out: DB_SUCCESS or DB_TABLESPACE_DELETED </td></tr>
    <tr><td class="paramname">mode</td><td>in: BUF_READ_IBUF_PAGES_ONLY, ... </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size, or 0 </td></tr>
    <tr><td class="paramname">unzip</td><td>in: TRUE=request uncompressed page </td></tr>
    <tr><td class="paramname">tablespace_version</td><td>in: prevents reading from a wrong version of the tablespace in case we have done DISCARD + IMPORT </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af36e120d41b65fc009f011a62dc107e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36e120d41b65fc009f011a62dc107e5">&#9670;&nbsp;</a></span>buf_page_init_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_init_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize some fields of a control block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: block to init </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b42a085941cbde456551be2ebf514c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b42a085941cbde456551be2ebf514c6">&#9670;&nbsp;</a></span>buf_page_io_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_page_io_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes an asynchronous read or write request of a file page to or from the buffer pool. </p><dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97d1cedcc7115ef5e7518d26cc24ccbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d1cedcc7115ef5e7518d26cc24ccbc">&#9670;&nbsp;</a></span>buf_page_is_corrupted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_page_is_corrupted </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>read_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a page is corrupt. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if corrupted </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">check_lsn</td><td>in: true if we need to check and complain about the LSN </td></tr>
    <tr><td class="paramname">read_buf</td><td>in: a database page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: size of compressed page; 0 for uncompressed pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc3917d4a5b0630a356a9d244886ebf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3917d4a5b0630a356a9d244886ebf9">&#9670;&nbsp;</a></span>buf_page_is_zeroes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool buf_page_is_zeroes </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>read_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a page is all zeroes. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the page is all zeroes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buf</td><td>in: a database page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: size of compressed page; 0 for uncompressed pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fb94effb9f9c0de7b40c07a91ceee16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb94effb9f9c0de7b40c07a91ceee16">&#9670;&nbsp;</a></span>buf_page_make_young()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_page_make_young </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves a page to the start of the buffer pool LRU list. This high-level function can be used to prevent an important page from slipping out of the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer block of a file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae03ec3da38f4ad513f96d7d71663e7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03ec3da38f4ad513f96d7d71663e7d8">&#9670;&nbsp;</a></span>buf_page_make_young_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_page_make_young_if_needed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves a page to the start of the buffer pool LRU list if it is too old. This high-level function can be used to prevent an important page from slipping out of the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: buffer block of a file page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe6373a18fab2a1df7def6fd06d0efba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6373a18fab2a1df7def6fd06d0efba">&#9670;&nbsp;</a></span>buf_page_monitor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_page_monitor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td>
          <td class="paramname"><em>io_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Monitor the buffer page read/write activity, and increment corresponding counter value if MONITOR_MODULE_BUF_PAGE (module_buf_page) module is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the block </td></tr>
    <tr><td class="paramname">io_type</td><td>in: io_fix types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b2249b3ba3868dc2afd2ebea3480a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2249b3ba3868dc2afd2ebea3480a01">&#9670;&nbsp;</a></span>buf_page_optimistic_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_page_optimistic_get </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>modify_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the general function used to get optimistic access to a database page. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rw_latch</td><td>in: RW_S_LATCH, RW_X_LATCH </td></tr>
    <tr><td class="paramname">block</td><td>in: guessed buffer block </td></tr>
    <tr><td class="paramname">modify_clock</td><td>in: modify clock value </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca58932cd0b54d76ebc8cc1521880a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca58932cd0b54d76ebc8cc1521880a97">&#9670;&nbsp;</a></span>buf_page_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_page_print </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>read_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a page to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buf</td><td>in: a database page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size, or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">flags</td><td>in: 0 or BUF_PAGE_PRINT_NO_CRASH or BUF_PAGE_PRINT_NO_FULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ecdc5cbcd0ed4554e3dfd1dfe96d452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecdc5cbcd0ed4554e3dfd1dfe96d452">&#9670;&nbsp;</a></span>buf_page_try_get_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_try_get_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a tablespace id and page number tries to get that page. If the page is not in the buffer pool it is not loaded and NULL is returned. Suitable for using when holding the <a class="el" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">lock_sys_t::mutex</a>. </p><dl class="section return"><dt>Returns</dt><dd>pointer to a page or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: tablespace id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cabada29220f8ab778c3d5d849772f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cabada29220f8ab778c3d5d849772f5">&#9670;&nbsp;</a></span>buf_pointer_is_block_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_pointer_is_block_field </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find out if a pointer belongs to a <a class="el" href="structbuf__block__t.html">buf_block_t</a>. It can be a pointer to the <a class="el" href="structbuf__block__t.html">buf_block_t</a> itself or a member of it </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ptr belongs to a <a class="el" href="structbuf__block__t.html">buf_block_t</a> struct </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: pointer not dereferenced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72dbf5ca3276523e70afbb7df06e71a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72dbf5ca3276523e70afbb7df06e71a9">&#9670;&nbsp;</a></span>buf_pointer_is_block_field_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool buf_pointer_is_block_field_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find out if a pointer belongs to a <a class="el" href="structbuf__block__t.html">buf_block_t</a>. It can be a pointer to the <a class="el" href="structbuf__block__t.html">buf_block_t</a> itself or a member of it. This functions checks one of the buffer pool instances. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ptr belongs to a <a class="el" href="structbuf__block__t.html">buf_block_t</a> struct </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">ptr</td><td>in: pointer not dereferenced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac12113d926b18d7fd1ffef49e5d72ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12113d926b18d7fd1ffef49e5d72ea4">&#9670;&nbsp;</a></span>buf_pool_check_no_pending_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_pool_check_no_pending_io </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that there currently are no pending i/o-operations for the buffer pool. </p><dl class="section return"><dt>Returns</dt><dd>number of pending i/o </dd></dl>

</div>
</div>
<a id="a5358efb915e801353ddfc12178c7331b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5358efb915e801353ddfc12178c7331b">&#9670;&nbsp;</a></span>buf_pool_clear_hash_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_pool_clear_hash_index </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the adaptive hash index on all pages in the buffer pool. </p>

</div>
</div>
<a id="a0a32cbba300ff8f3f33bc54e47eb4360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a32cbba300ff8f3f33bc54e47eb4360">&#9670;&nbsp;</a></span>buf_pool_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_pool_free </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_instances</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the buffer pool at shutdown. This must not be invoked before freeing all mutexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_instances</td><td>in: numbere of instances to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cac1411711bbe034e1d6742c5ab6f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cac1411711bbe034e1d6742c5ab6f63">&#9670;&nbsp;</a></span>buf_pool_free_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_free_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>free one buffer pool instance </p>

</div>
</div>
<a id="a7f96406b87de005b0234f06c369d8ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f96406b87de005b0234f06c369d8ad4">&#9670;&nbsp;</a></span>buf_pool_get_oldest_modification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN lsn_t buf_pool_get_oldest_modification </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the smallest oldest_modification lsn for any page in the pool. Returns zero if all modified pages have been flushed to disk. </p><dl class="section return"><dt>Returns</dt><dd>oldest modification in pool, zero if none </dd></dl>

</div>
</div>
<a id="a65f5706e1f3642ff2e7c911e177faf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f5706e1f3642ff2e7c911e177faf93">&#9670;&nbsp;</a></span>buf_pool_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> buf_pool_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>total_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_instances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the buffer pool. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if success, DB_ERROR if not enough memory or error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_size</td><td>in: size of the total pool in bytes </td></tr>
    <tr><td class="paramname">n_instances</td><td>in: number of instances </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f5fb64c83075bb52b4995316fd83b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5fb64c83075bb52b4995316fd83b29">&#9670;&nbsp;</a></span>buf_pool_init_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_pool_init_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>buf_pool_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>instance_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a buffer pool instance. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all goes well. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">buf_pool_size</td><td>in: size in bytes </td></tr>
    <tr><td class="paramname">instance_no</td><td>in: id of the instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65e9d3982cda06d0032aa5dec9a3fc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e9d3982cda06d0032aa5dec9a3fc69">&#9670;&nbsp;</a></span>buf_pool_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_pool_invalidate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalidates the file pages in the buffer pool when an archive recovery is completed. All the file pages buffered must be in a replaceable state when this function is called: not latched and not modified. </p>

</div>
</div>
<a id="a55b96a1551d95ca86c218cc9b4e48e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b96a1551d95ca86c218cc9b4e48e80">&#9670;&nbsp;</a></span>buf_pool_invalidate_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_invalidate_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invalidates file pages in one buffer pool instance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaf95ed2818750214caab3fa60a4541a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf95ed2818750214caab3fa60a4541a">&#9670;&nbsp;</a></span>buf_pool_set_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_set_sizes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set buffer pool size variables after resizing it </p>

</div>
</div>
<a id="afe237828f00da332051a0c48ebe504b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe237828f00da332051a0c48ebe504b9">&#9670;&nbsp;</a></span>buf_pool_watch_is_sentinel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_pool_watch_is_sentinel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a block is a sentinel for a buffer pool watch. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if a sentinel for a buffer pool watch, FALSE if not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaabc341f2e6d13239c8397a0bcf98137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabc341f2e6d13239c8397a0bcf98137">&#9670;&nbsp;</a></span>buf_pool_watch_occurred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_pool_watch_occurred </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if the page has been read in. This may only be called after buf_pool_watch_set(space,offset) has returned NULL and before invoking buf_pool_watch_unset(space,offset). </p><dl class="section return"><dt>Returns</dt><dd>FALSE if the given page was not read in, TRUE if it was </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9bcc01e7526b69839c6a4eff18cbb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bcc01e7526b69839c6a4eff18cbb14">&#9670;&nbsp;</a></span>buf_pool_watch_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_pool_watch_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>watch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the sentinel block for the watch before replacing it with a real block. buf_page_watch_clear() or buf_page_watch_occurred() will notice that the block has been replaced with the real block. </p><dl class="section return"><dt>Returns</dt><dd>reference count, to be added to the replacement block </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">fold</td><td>in: buf_page_address_fold( space, offset) </td></tr>
    <tr><td class="paramname">watch</td><td>in/out: sentinel for watch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29161a9d08696f9e553110ebcc91e987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29161a9d08696f9e553110ebcc91e987">&#9670;&nbsp;</a></span>buf_pool_watch_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_pool_watch_set </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>fold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add watch for the given page to be read in. Caller must have appropriate hash_lock for the bpage. This function may release the hash_lock and reacquire it. </p><dl class="section return"><dt>Returns</dt><dd>NULL if watch set, block if the page is in the buffer pool </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
    <tr><td class="paramname">fold</td><td>in: buf_page_address_fold(space, offset) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad347338911fe564cc72f4a5f3f11a608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad347338911fe564cc72f4a5f3f11a608">&#9670;&nbsp;</a></span>buf_pool_watch_unset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_pool_watch_unset </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop watching if the page has been read in. buf_pool_watch_set(space,offset) must have returned NULL before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab20138c8871f85d710230adc053943f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20138c8871f85d710230adc053943f3">&#9670;&nbsp;</a></span>buf_print_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_print_io </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of the buffer i/o. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in/out: buffer where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b13818c7dd5436b08f17627474a64e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b13818c7dd5436b08f17627474a64e3">&#9670;&nbsp;</a></span>buf_print_io_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_print_io_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>pool_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of the buffer i/o. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool_info</td><td>in: buffer pool info </td></tr>
    <tr><td class="paramname">file</td><td>in/out: buffer where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7cb16ef6711245409a7e117e6da54e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cb16ef6711245409a7e117e6da54e1">&#9670;&nbsp;</a></span>buf_refresh_io_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_refresh_io_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refreshes the statistics used to print per-second averages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6817c8278c04718851b86d4c4a613e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6817c8278c04718851b86d4c4a613e43">&#9670;&nbsp;</a></span>buf_refresh_io_stats_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_refresh_io_stats_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refreshes the statistics used to print per-second averages. </p>

</div>
</div>
<a id="a23bae3b57524cdb851a6f188da057402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bae3b57524cdb851a6f188da057402">&#9670;&nbsp;</a></span>buf_relocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_relocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>dpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relocate a buffer control block. Relocates the block on the LRU list and in buf_pool-&gt;page_hash. Does not relocate bpage-&gt;list. The caller must take care of relocating bpage-&gt;list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block being relocated; buf_page_get_state(bpage) must be BUF_BLOCK_ZIP_DIRTY or BUF_BLOCK_ZIP_PAGE </td></tr>
    <tr><td class="paramname">dpage</td><td>in/out: destination control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a31add4644416c05c769e96bde6ce65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a31add4644416c05c769e96bde6ce65">&#9670;&nbsp;</a></span>buf_reset_check_index_page_at_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_reset_check_index_page_at_flush </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the check_index_page_at_flush field of a page if found in the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b5418342f432074305965a75c1fedc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5418342f432074305965a75c1fedc7">&#9670;&nbsp;</a></span>buf_stats_aggregate_pool_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_stats_aggregate_pool_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>total_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>pool_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Aggregates a pool stats information with the total buffer pool stats </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_info</td><td>in/out: the buffer pool info to store aggregated result </td></tr>
    <tr><td class="paramname">pool_info</td><td>in: individual buffer pool stats info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0657a55a27fb821febe21fd93c5e1bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0657a55a27fb821febe21fd93c5e1bb7">&#9670;&nbsp;</a></span>buf_stats_get_pool_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_stats_get_pool_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pool_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>all_pool_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect buffer pool stats information for a buffer pool. Also record aggregated stats if there are more than one buffer pool in the server </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool </td></tr>
    <tr><td class="paramname">pool_id</td><td>in: buffer pool ID </td></tr>
    <tr><td class="paramname">all_pool_info</td><td>in/out: buffer pool info to fill </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d073376daf32f894c496cd3b6f61cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d073376daf32f894c496cd3b6f61cd4">&#9670;&nbsp;</a></span>buf_wait_for_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_wait_for_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for the block to be read in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae97c93aa8f9ecd83bbc579fc36640ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97c93aa8f9ecd83bbc579fc36640ff1">&#9670;&nbsp;</a></span>buf_zip_decompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_zip_decompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decompress a block. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: block </td></tr>
    <tr><td class="paramname">check</td><td>in: TRUE=verify the page checksum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a076fae382a175611330a47d0327b150f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076fae382a175611330a47d0327b150f">&#9670;&nbsp;</a></span>block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="buf0buf_8cc.html#af36e120d41b65fc009f011a62dc107e5">buf_page_init_low</a>&amp; block</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <a class="code" href="structbuf__page__t.html">buf_page_t</a>*     hash_page</div><div class="ttc" id="structbuf__page__t_html"><div class="ttname"><a href="structbuf__page__t.html">buf_page_t</a></div><div class="ttdef"><b>Definition:</b> buf0buf.h:1460</div></div>
</div><!-- fragment --><p>&lt; in/out: block to init </p>

</div>
</div>
<a id="a7076240d95384c7a4b81433a490fe3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7076240d95384c7a4b81433a490fe3c2">&#9670;&nbsp;</a></span>BUF_PAGE_READ_MAX_RETRIES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint BUF_PAGE_READ_MAX_RETRIES = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of attemtps made to read in a page in the buffer pool </p>

</div>
</div>
<a id="a1d9c47d1c8a057b33e90dae2ecdb168d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9c47d1c8a057b33e90dae2ecdb168d">&#9670;&nbsp;</a></span>buf_pool_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The buffer pools of the database </p>

</div>
</div>
<a id="a0544c3fe466e421738dae463968b70ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0544c3fe466e421738dae463968b70ba">&#9670;&nbsp;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">                fprintf(stderr,</div><div class="line">                        <span class="stringliteral">&quot;InnoDB: Error: page %lu %lu already found&quot;</span></div><div class="line">                        <span class="stringliteral">&quot; in the hash table: %p, %p\n&quot;</span>,</div><div class="line">                        (ulong) <a class="code" href="buf0buf_8cc.html#acd72ce2b4bdc1d7c9b787ceb546ac13f">space</a>,</div><div class="line">                        (ulong) <a class="code" href="buf0buf_8cc.html#afd57c45a68b89b09104f911b030540bf">offset</a>,</div><div class="line">                        (<span class="keyword">const</span> <span class="keywordtype">void</span>*) hash_page, (<span class="keyword">const</span> <span class="keywordtype">void</span>*) <a class="code" href="buf0buf_8cc.html#a076fae382a175611330a47d0327b150f">block</a>)</div><div class="ttc" id="buf0buf_8cc_html_afd57c45a68b89b09104f911b030540bf"><div class="ttname"><a href="buf0buf_8cc.html#afd57c45a68b89b09104f911b030540bf">offset</a></div><div class="ttdeci">static ulint ulint offset</div><div class="ttdef"><b>Definition:</b> buf0buf.cc:3384</div></div>
<div class="ttc" id="buf0buf_8cc_html_a076fae382a175611330a47d0327b150f"><div class="ttname"><a href="buf0buf_8cc.html#a076fae382a175611330a47d0327b150f">block</a></div><div class="ttdeci">static ulint ulint ulint ulint buf_block_t * block</div><div class="ttdef"><b>Definition:</b> buf0buf.cc:3390</div></div>
<div class="ttc" id="buf0buf_8cc_html_acd72ce2b4bdc1d7c9b787ceb546ac13f"><div class="ttname"><a href="buf0buf_8cc.html#acd72ce2b4bdc1d7c9b787ceb546ac13f">space</a></div><div class="ttdeci">static ulint space</div><div class="ttdef"><b>Definition:</b> buf0buf.cc:3384</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a590e5804107a898143baa2a68550a051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590e5804107a898143baa2a68550a051">&#9670;&nbsp;</a></span>fold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint ulint ulint fold</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: buf_page_address_fold(space,offset) </p>

</div>
</div>
<a id="afd57c45a68b89b09104f911b030540bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd57c45a68b89b09104f911b030540bf">&#9670;&nbsp;</a></span>offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const void ulint <a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        ssize_t ret</div></div><!-- fragment --><p>in: offset of the page within space in units of a page</p>
<p>in: page offset; if equal to the free limit, we try to add new extents to the space free list</p>
<p>&lt; in: file offset where to write </p>

</div>
</div>
<a id="acd72ce2b4bdc1d7c9b787ceb546ac13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd72ce2b4bdc1d7c9b787ceb546ac13f">&#9670;&nbsp;</a></span>space</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint space</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in/out: buffer pool in: space id </p>

</div>
</div>
<a id="ae252c6f42e712b83871abe3faeea7093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae252c6f42e712b83871abe3faeea7093">&#9670;&nbsp;</a></span>WAIT_FOR_READ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int WAIT_FOR_READ = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Value in microseconds </p>

</div>
</div>
<a id="aa42ecdfcbc7e429d10a64c479d1e0f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42ecdfcbc7e429d10a64c479d1e0f67">&#9670;&nbsp;</a></span>zip_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint ulint ulint ulint zip_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: compressed page size, or 0 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

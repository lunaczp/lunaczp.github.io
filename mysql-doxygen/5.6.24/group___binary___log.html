<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Binary Log</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Binary Log</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mutex__sentry.html">Mutex_sentry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread__excursion.html">Thread_excursion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinlog__stmt__cache__data.html">binlog_stmt_cache_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinlog__trx__cache__data.html">binlog_trx_cache_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinlog__cache__mngr.html">binlog_cache_mngr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1e24693cd278a03ccca7bc269375ad16"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga1e24693cd278a03ccca7bc269375ad16">enum_read_gtids_from_binlog_status</a> { <br />
&#160;&#160;<b>GOT_GTIDS</b>, 
<b>GOT_PREVIOUS_GTIDS</b>, 
<b>NO_GTIDS</b>, 
<b>ERROR</b>, 
<br />
&#160;&#160;<b>TRUNCATED</b>
<br />
 }</td></tr>
<tr class="separator:ga1e24693cd278a03ccca7bc269375ad16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga90d6e6ab825c53cc3fe0d9883dfb9501"><td class="memItemLeft" align="right" valign="top"><a id="ga90d6e6ab825c53cc3fe0d9883dfb9501"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_init</b> (void *p)</td></tr>
<tr class="separator:ga90d6e6ab825c53cc3fe0d9883dfb9501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed02522808460c9addecf632207a5ce1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaed02522808460c9addecf632207a5ce1">binlog_start_trans_and_stmt</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_log__event.html">Log_event</a> *start_event)</td></tr>
<tr class="separator:gaed02522808460c9addecf632207a5ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33a3f3a898f70da513c2c54ebcc3e6d6"><td class="memItemLeft" align="right" valign="top"><a id="ga33a3f3a898f70da513c2c54ebcc3e6d6"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_close_connection</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga33a3f3a898f70da513c2c54ebcc3e6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga675a6ef6e0ba149557d25c2daf4d5ff0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga675a6ef6e0ba149557d25c2daf4d5ff0">binlog_savepoint_set</a> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, void *sv)</td></tr>
<tr class="separator:ga675a6ef6e0ba149557d25c2daf4d5ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68bdc68788a8589e522507ca88dc8d3"><td class="memItemLeft" align="right" valign="top"><a id="gae68bdc68788a8589e522507ca88dc8d3"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_savepoint_rollback</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, void *sv)</td></tr>
<tr class="separator:gae68bdc68788a8589e522507ca88dc8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b468affd908cdb22e2a5879ea3692a1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga3b468affd908cdb22e2a5879ea3692a1">binlog_savepoint_rollback_can_release_mdl</a> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga3b468affd908cdb22e2a5879ea3692a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da95c9d936e5ea3023159e0e2c73d53"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga3da95c9d936e5ea3023159e0e2c73d53">binlog_commit</a> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool all)</td></tr>
<tr class="separator:ga3da95c9d936e5ea3023159e0e2c73d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99c2a651ebeb1e8f1d52fc01fb57029b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga99c2a651ebeb1e8f1d52fc01fb57029b">binlog_rollback</a> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool all)</td></tr>
<tr class="separator:ga99c2a651ebeb1e8f1d52fc01fb57029b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6fa264c4ad6a7e42d7289512139eb3e"><td class="memItemLeft" align="right" valign="top"><a id="gab6fa264c4ad6a7e42d7289512139eb3e"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_prepare</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool all)</td></tr>
<tr class="separator:gab6fa264c4ad6a7e42d7289512139eb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70155d349962fc0670d9216bb1c5fd73"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga70155d349962fc0670d9216bb1c5fd73">print_system_time</a> ()</td></tr>
<tr class="separator:ga70155d349962fc0670d9216bb1c5fd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308dc2e6a9f6c0f4aab2cf1c12cfc27f"><td class="memItemLeft" align="right" valign="top"><a id="ga308dc2e6a9f6c0f4aab2cf1c12cfc27f"></a>
static <a class="el" href="classbinlog__cache__mngr.html">binlog_cache_mngr</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>thd_get_cache_mngr</b> (const THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga308dc2e6a9f6c0f4aab2cf1c12cfc27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63c6fcd1b8e84116f7bcec46e7b25caa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga63c6fcd1b8e84116f7bcec46e7b25caa">check_binlog_cache_size</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga63c6fcd1b8e84116f7bcec46e7b25caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0a12298d22d080b68e55f324cd59bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga7a0a12298d22d080b68e55f324cd59bd">check_binlog_stmt_cache_size</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga7a0a12298d22d080b68e55f324cd59bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46468c405fde69f126c1bcb343c85c90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga46468c405fde69f126c1bcb343c85c90">binlog_enabled</a> ()</td></tr>
<tr class="separator:ga46468c405fde69f126c1bcb343c85c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3ceef5ceecf6e5b6ae3cf154a10ae6"><td class="memItemLeft" align="right" valign="top"><a id="ga4e3ceef5ceecf6e5b6ae3cf154a10ae6"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_trans_log_savepos</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, my_off_t *pos)</td></tr>
<tr class="separator:ga4e3ceef5ceecf6e5b6ae3cf154a10ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2545b9865ecf8c97d82d10e7ea857d1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaa2545b9865ecf8c97d82d10e7ea857d1">write_one_empty_group_to_cache</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *cache_data, <a class="el" href="struct_gtid.html">Gtid</a> gtid)</td></tr>
<tr class="separator:gaa2545b9865ecf8c97d82d10e7ea857d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d85906608487be3c3ee20ae8bb0f9e3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga3d85906608487be3c3ee20ae8bb0f9e3">write_empty_groups_to_cache</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *cache_data)</td></tr>
<tr class="separator:ga3d85906608487be3c3ee20ae8bb0f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8072c6b6890022e3919455e77017ab0d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga8072c6b6890022e3919455e77017ab0d">gtid_before_write_cache</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *cache_data)</td></tr>
<tr class="separator:ga8072c6b6890022e3919455e77017ab0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d2bcbece5df8c93fe833e0a58f06d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaa6d2bcbece5df8c93fe833e0a58f06d0">gtid_empty_group_log_and_cleanup</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:gaa6d2bcbece5df8c93fe833e0a58f06d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga116da367b88c9bc34c849864ce7e1b99"><td class="memItemLeft" align="right" valign="top"><a id="ga116da367b88c9bc34c849864ce7e1b99"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_linfo_offsets</b> (my_off_t purge_offset)</td></tr>
<tr class="separator:ga116da367b88c9bc34c849864ce7e1b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4158ea4a70f7931ad896febae6eeac09"><td class="memItemLeft" align="right" valign="top"><a id="ga4158ea4a70f7931ad896febae6eeac09"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>log_in_use</b> (const char *log_name)</td></tr>
<tr class="separator:ga4158ea4a70f7931ad896febae6eeac09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4b154d00b475dd09aca8d64b7bf2a4d"><td class="memItemLeft" align="right" valign="top"><a id="gaf4b154d00b475dd09aca8d64b7bf2a4d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>purge_error_message</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, int res)</td></tr>
<tr class="separator:gaf4b154d00b475dd09aca8d64b7bf2a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b696534d053643574f8ccf2bf5815f"><td class="memItemLeft" align="right" valign="top"><a id="ga24b696534d053643574f8ccf2bf5815f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_binlog_magic</b> (<a class="el" href="structst__io__cache.html">IO_CACHE</a> *<a class="el" href="row0log_8cc.html#a800f12bb442b5fb971fb19d203766eb4">log</a>, const char **errmsg)</td></tr>
<tr class="separator:ga24b696534d053643574f8ccf2bf5815f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79ed24f2c1a0645530426f4346470781"><td class="memItemLeft" align="right" valign="top">File&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga79ed24f2c1a0645530426f4346470781">open_binlog_file</a> (<a class="el" href="structst__io__cache.html">IO_CACHE</a> *<a class="el" href="row0log_8cc.html#a800f12bb442b5fb971fb19d203766eb4">log</a>, const char *log_file_name, const char **errmsg)</td></tr>
<tr class="separator:ga79ed24f2c1a0645530426f4346470781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25239dc38f22eeef6e1aea243af6fd9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga25239dc38f22eeef6e1aea243af6fd9a">trans_has_updated_trans_table</a> (const THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga25239dc38f22eeef6e1aea243af6fd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db7290468d8e62cd647323a0e9b5061"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga0db7290468d8e62cd647323a0e9b5061">stmt_has_updated_trans_table</a> (const THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga0db7290468d8e62cd647323a0e9b5061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad02774240e19d361a32bd35c9db60cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaad02774240e19d361a32bd35c9db60cb">ending_trans</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const bool all)</td></tr>
<tr class="separator:gaad02774240e19d361a32bd35c9db60cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a5419e22b84b8ca2f3595cbf75fa67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga80a5419e22b84b8ca2f3595cbf75fa67">ending_single_stmt_trans</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const bool all)</td></tr>
<tr class="separator:ga80a5419e22b84b8ca2f3595cbf75fa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d647f955254c565dc33abf8caabdbab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga1d647f955254c565dc33abf8caabdbab">trans_cannot_safely_rollback</a> (const THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga1d647f955254c565dc33abf8caabdbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a668f531f059316c8f17dfcecfd465"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga07a668f531f059316c8f17dfcecfd465">stmt_cannot_safely_rollback</a> (const THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga07a668f531f059316c8f17dfcecfd465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f15ff584adebd77fd1bf4ebc88a68b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga1f15ff584adebd77fd1bf4ebc88a68b6">purge_master_logs</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const char *to_log)</td></tr>
<tr class="separator:ga1f15ff584adebd77fd1bf4ebc88a68b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f8e56905c5205bb8cf6268cd203cb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga38f8e56905c5205bb8cf6268cd203cb2">purge_master_logs_before_date</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, time_t purge_time)</td></tr>
<tr class="separator:ga38f8e56905c5205bb8cf6268cd203cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ae6bafee492a4342e739018cfb6701"><td class="memItemLeft" align="right" valign="top"><a id="ga30ae6bafee492a4342e739018cfb6701"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>query_error_code</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool not_killed)</td></tr>
<tr class="separator:ga30ae6bafee492a4342e739018cfb6701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be98bfd39c79d3421a8dd968372aa8f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga2be98bfd39c79d3421a8dd968372aa8f">copy_file</a> (<a class="el" href="structst__io__cache.html">IO_CACHE</a> *<a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a>, <a class="el" href="structst__io__cache.html">IO_CACHE</a> *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>, my_off_t <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:ga2be98bfd39c79d3421a8dd968372aa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6091ef19ba4fb6819e758344298210"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga1d6091ef19ba4fb6819e758344298210">log_loaded_block</a> (<a class="el" href="structst__io__cache.html">IO_CACHE</a> *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:ga1d6091ef19ba4fb6819e758344298210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga327e9d3c600bf0899a7973444938d0e3"><td class="memItemLeft" align="right" valign="top"><a id="ga327e9d3c600bf0899a7973444938d0e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>show_binlog_events</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_m_y_s_q_l___b_i_n___l_o_g.html">MYSQL_BIN_LOG</a> *binary_log)</td></tr>
<tr class="separator:ga327e9d3c600bf0899a7973444938d0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0490669ea3aef1d30fa41d44079c8cb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga0490669ea3aef1d30fa41d44079c8cb2">mysql_show_binlog_events</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga0490669ea3aef1d30fa41d44079c8cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9d39901a8a2711103c990fdd6f00bb"><td class="memItemLeft" align="right" valign="top"><a id="gafb9d39901a8a2711103c990fdd6f00bb"></a>
static <a class="el" href="group___binary___log.html#ga1e24693cd278a03ccca7bc269375ad16">enum_read_gtids_from_binlog_status</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_gtids_from_binlog</b> (const char *filename, <a class="el" href="class_gtid__set.html">Gtid_set</a> *all_gtids, <a class="el" href="class_gtid__set.html">Gtid_set</a> *prev_gtids, <a class="el" href="struct_gtid.html">Gtid</a> *first_gtid, <a class="el" href="struct_gtid.html">Gtid</a> *last_gtid, <a class="el" href="class_sid__map.html">Sid_map</a> *sid_map, bool verify_checksum)</td></tr>
<tr class="separator:gafb9d39901a8a2711103c990fdd6f00bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf105c9f0e7937c6f81472c50b41e9e42"><td class="memItemLeft" align="right" valign="top">static ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaf105c9f0e7937c6f81472c50b41e9e42">fix_log_event_crc</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint off, uint event_len, uint length, ha_checksum *crc)</td></tr>
<tr class="separator:gaf105c9f0e7937c6f81472c50b41e9e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53bb73d56883af0d06d664f19407eac1"><td class="memItemLeft" align="right" valign="top"><a id="ga53bb73d56883af0d06d664f19407eac1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>register_binlog_handler</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool <a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:ga53bb73d56883af0d06d664f19407eac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af09c853f5dcd42347e8343a0ccbc2b"><td class="memItemLeft" align="right" valign="top"><a id="ga5af09c853f5dcd42347e8343a0ccbc2b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_stmt_cache_data::finalize</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga5af09c853f5dcd42347e8343a0ccbc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a0b36dc3c576520f72b80298791400"><td class="memItemLeft" align="right" valign="top"><a id="gac3a0b36dc3c576520f72b80298791400"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_cache_data::write_event</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_log__event.html">Log_event</a> *<a class="el" href="structevent.html">event</a>)</td></tr>
<tr class="separator:gac3a0b36dc3c576520f72b80298791400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3367fa8c1daced18065f6b9dea5385fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga3367fa8c1daced18065f6b9dea5385fe">binlog_cache_data::finalize</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_log__event.html">Log_event</a> *end_event)</td></tr>
<tr class="separator:ga3367fa8c1daced18065f6b9dea5385fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga302d2ea7bfcbea015c329edacdac6c5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga302d2ea7bfcbea015c329edacdac6c5a">binlog_cache_data::flush</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, my_off_t *bytes, bool *wrote_xid)</td></tr>
<tr class="separator:ga302d2ea7bfcbea015c329edacdac6c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d03425fee2a702a9b4dfac7b9de4b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gae0d03425fee2a702a9b4dfac7b9de4b1">binlog_trx_cache_data::truncate</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool all)</td></tr>
<tr class="separator:gae0d03425fee2a702a9b4dfac7b9de4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a543666e684f08da1cc093d5fa70ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga20a543666e684f08da1cc093d5fa70ec">Stage_manager::Mutex_queue::append</a> (THD *first)</td></tr>
<tr class="separator:ga20a543666e684f08da1cc093d5fa70ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac617a778e2de5141ba0d25ca33ccac78"><td class="memItemLeft" align="right" valign="top"><a id="gac617a778e2de5141ba0d25ca33ccac78"></a>
std::pair&lt; bool, THD * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Stage_manager::Mutex_queue::pop_front</b> ()</td></tr>
<tr class="separator:gac617a778e2de5141ba0d25ca33ccac78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a83004e5774879856189f84d00094f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga71a83004e5774879856189f84d00094f">Stage_manager::enroll_for</a> (<a class="el" href="class_stage__manager.html#a28879837525f3786d4bcb6f330f4ac69">StageID</a> stage, THD *first, <a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> *stage_mutex)</td></tr>
<tr class="separator:ga71a83004e5774879856189f84d00094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254675ae9d8f6f0a7b48d7520ab16eea"><td class="memItemLeft" align="right" valign="top">THD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga254675ae9d8f6f0a7b48d7520ab16eea">Stage_manager::Mutex_queue::fetch_and_empty</a> ()</td></tr>
<tr class="separator:ga254675ae9d8f6f0a7b48d7520ab16eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3389586ace2de50ee7606d7acc98849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gad3389586ace2de50ee7606d7acc98849">Stage_manager::clear_preempt_status</a> (THD *head)</td></tr>
<tr class="separator:gad3389586ace2de50ee7606d7acc98849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9590d29210bd03fce1b8f9effc7c2d2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga9590d29210bd03fce1b8f9effc7c2d2a">MYSQL_BIN_LOG::rollback</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool all)</td></tr>
<tr class="separator:ga9590d29210bd03fce1b8f9effc7c2d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804686ce7bfb2efc36c0e78c4c35555b"><td class="memItemLeft" align="right" valign="top"><a id="ga804686ce7bfb2efc36c0e78c4c35555b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::MYSQL_BIN_LOG</b> (uint *sync_period)</td></tr>
<tr class="separator:ga804686ce7bfb2efc36c0e78c4c35555b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8c70fe2db7fc6a5ffba006997e9064"><td class="memItemLeft" align="right" valign="top"><a id="ga2d8c70fe2db7fc6a5ffba006997e9064"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::cleanup</b> ()</td></tr>
<tr class="separator:ga2d8c70fe2db7fc6a5ffba006997e9064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e419bec25df519f933787e11e0050e"><td class="memItemLeft" align="right" valign="top"><a id="ga38e419bec25df519f933787e11e0050e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::init_pthread_objects</b> ()</td></tr>
<tr class="separator:ga38e419bec25df519f933787e11e0050e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc6f71042007e6a8cf40b5b4a95d562b"><td class="memItemLeft" align="right" valign="top"><a id="gacc6f71042007e6a8cf40b5b4a95d562b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::open_index_file</b> (const char *index_file_name_arg, const char *log_name, bool need_lock_index)</td></tr>
<tr class="separator:gacc6f71042007e6a8cf40b5b4a95d562b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8925923df0bf9cd07f7fcaf45f8db16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gab8925923df0bf9cd07f7fcaf45f8db16">MYSQL_BIN_LOG::find_first_log_not_in_gtid_set</a> (char *binlog_file_name, const <a class="el" href="class_gtid__set.html">Gtid_set</a> *gtid_set, <a class="el" href="struct_gtid.html">Gtid</a> *first_gtid, const char **errmsg)</td></tr>
<tr class="separator:gab8925923df0bf9cd07f7fcaf45f8db16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ef27d48e9ff7dbc2c0d75f481acbc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga43ef27d48e9ff7dbc2c0d75f481acbc2">MYSQL_BIN_LOG::init_gtid_sets</a> (<a class="el" href="class_gtid__set.html">Gtid_set</a> *gtid_set, <a class="el" href="class_gtid__set.html">Gtid_set</a> *lost_groups, <a class="el" href="struct_gtid.html">Gtid</a> *last_gtid, bool verify_checksum, bool need_lock, bool is_server_starting=false)</td></tr>
<tr class="separator:ga43ef27d48e9ff7dbc2c0d75f481acbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb09393ab56b2ba8a7620cbd4cb34b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga1eb09393ab56b2ba8a7620cbd4cb34b9">MYSQL_BIN_LOG::open_binlog</a> (const char *log_name, const char *new_name, enum cache_type io_cache_type_arg, ulong max_size, bool null_created, bool need_lock_index, bool need_sid_lock, <a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *extra_description_event)</td></tr>
<tr class="separator:ga1eb09393ab56b2ba8a7620cbd4cb34b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57cd148796a62181465bb25db0e236c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gab57cd148796a62181465bb25db0e236c">MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file</a> (bool need_lock_index)</td></tr>
<tr class="separator:gab57cd148796a62181465bb25db0e236c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264a159d100314afaae92b304f9cd47a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga264a159d100314afaae92b304f9cd47a">MYSQL_BIN_LOG::add_log_to_index</a> (uchar *log_file_name, int name_len, bool need_lock_index)</td></tr>
<tr class="separator:ga264a159d100314afaae92b304f9cd47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7969eb64fa91daf05966a9cc1c5a1a"><td class="memItemLeft" align="right" valign="top"><a id="ga5e7969eb64fa91daf05966a9cc1c5a1a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::get_current_log</b> (<a class="el" href="structst__log__info.html">LOG_INFO</a> *linfo)</td></tr>
<tr class="separator:ga5e7969eb64fa91daf05966a9cc1c5a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga826bbc38d9566f349fbf9e4cb6c682bc"><td class="memItemLeft" align="right" valign="top"><a id="ga826bbc38d9566f349fbf9e4cb6c682bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::raw_get_current_log</b> (<a class="el" href="structst__log__info.html">LOG_INFO</a> *linfo)</td></tr>
<tr class="separator:ga826bbc38d9566f349fbf9e4cb6c682bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e22d76ff3054cc3f3b07882ff01fc4"><td class="memItemLeft" align="right" valign="top"><a id="ga55e22d76ff3054cc3f3b07882ff01fc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::check_write_error</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga55e22d76ff3054cc3f3b07882ff01fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc5fc9619717b2ab90bdbd5197ea774d"><td class="memItemLeft" align="right" valign="top"><a id="gabc5fc9619717b2ab90bdbd5197ea774d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::set_write_error</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool is_transactional)</td></tr>
<tr class="separator:gabc5fc9619717b2ab90bdbd5197ea774d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245bb1e482896f726e11719666f2394a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga245bb1e482896f726e11719666f2394a">MYSQL_BIN_LOG::find_log_pos</a> (<a class="el" href="structst__log__info.html">LOG_INFO</a> *linfo, const char *log_name, bool need_lock_index)</td></tr>
<tr class="separator:ga245bb1e482896f726e11719666f2394a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed66e95398bcafa143ca8ad16860711"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga8ed66e95398bcafa143ca8ad16860711">MYSQL_BIN_LOG::find_next_log</a> (<a class="el" href="structst__log__info.html">LOG_INFO</a> *linfo, bool need_lock_index)</td></tr>
<tr class="separator:ga8ed66e95398bcafa143ca8ad16860711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585728a123b2a0b37d5777e79d435ccc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga585728a123b2a0b37d5777e79d435ccc">MYSQL_BIN_LOG::reset_logs</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga585728a123b2a0b37d5777e79d435ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bbd66f9464d9a83f33fdcdba20d7d99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga5bbd66f9464d9a83f33fdcdba20d7d99">MYSQL_BIN_LOG::set_crash_safe_index_file_name</a> (const char *base_file_name)</td></tr>
<tr class="separator:ga5bbd66f9464d9a83f33fdcdba20d7d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d69e1ee6b9099429bd919af752a0eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gac6d69e1ee6b9099429bd919af752a0eb">MYSQL_BIN_LOG::open_crash_safe_index_file</a> ()</td></tr>
<tr class="separator:gac6d69e1ee6b9099429bd919af752a0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5cf0683506dfdcc484155c676786860"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gad5cf0683506dfdcc484155c676786860">MYSQL_BIN_LOG::close_crash_safe_index_file</a> ()</td></tr>
<tr class="separator:gad5cf0683506dfdcc484155c676786860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f15d1126e85d2acca6e06c92ea60f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gac9f15d1126e85d2acca6e06c92ea60f1">MYSQL_BIN_LOG::purge_first_log</a> (<a class="el" href="class_relay__log__info.html">Relay_log_info</a> *rli, bool included)</td></tr>
<tr class="separator:gac9f15d1126e85d2acca6e06c92ea60f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8453da69cf16851231e33586e8992ea4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga8453da69cf16851231e33586e8992ea4">MYSQL_BIN_LOG::remove_logs_from_index</a> (<a class="el" href="structst__log__info.html">LOG_INFO</a> *linfo, bool need_update_threads)</td></tr>
<tr class="separator:ga8453da69cf16851231e33586e8992ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e04e209edd9b720574d2a34ed8fc117"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga5e04e209edd9b720574d2a34ed8fc117">MYSQL_BIN_LOG::purge_logs</a> (const char *to_log, bool included, bool need_lock_index, bool need_update_threads, ulonglong *decrease_log_space, bool auto_purge)</td></tr>
<tr class="separator:ga5e04e209edd9b720574d2a34ed8fc117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d38b4893900ea098471f69cbd4e14a"><td class="memItemLeft" align="right" valign="top"><a id="ga50d38b4893900ea098471f69cbd4e14a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::set_purge_index_file_name</b> (const char *base_file_name)</td></tr>
<tr class="separator:ga50d38b4893900ea098471f69cbd4e14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b15802f896ddf6689c06f6d847d194b"><td class="memItemLeft" align="right" valign="top"><a id="ga5b15802f896ddf6689c06f6d847d194b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::open_purge_index_file</b> (bool destroy)</td></tr>
<tr class="separator:ga5b15802f896ddf6689c06f6d847d194b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e7a42f9b759958fcb48c5fce0645fe"><td class="memItemLeft" align="right" valign="top"><a id="ga11e7a42f9b759958fcb48c5fce0645fe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::close_purge_index_file</b> ()</td></tr>
<tr class="separator:ga11e7a42f9b759958fcb48c5fce0645fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca91c2fec3e0fcfd59e3adff0549c590"><td class="memItemLeft" align="right" valign="top"><a id="gaca91c2fec3e0fcfd59e3adff0549c590"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::is_inited_purge_index_file</b> ()</td></tr>
<tr class="separator:gaca91c2fec3e0fcfd59e3adff0549c590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47bcf9a0b3e76319dcb1a39a38be5386"><td class="memItemLeft" align="right" valign="top"><a id="ga47bcf9a0b3e76319dcb1a39a38be5386"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::sync_purge_index_file</b> ()</td></tr>
<tr class="separator:ga47bcf9a0b3e76319dcb1a39a38be5386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474f73fafc4d1c1504c6a08a1b7cca02"><td class="memItemLeft" align="right" valign="top"><a id="ga474f73fafc4d1c1504c6a08a1b7cca02"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::register_purge_index_entry</b> (const char *<a class="el" href="struct__entry.html">entry</a>)</td></tr>
<tr class="separator:ga474f73fafc4d1c1504c6a08a1b7cca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2fa3a1ea5448f3e685da73d94f62505"><td class="memItemLeft" align="right" valign="top"><a id="gad2fa3a1ea5448f3e685da73d94f62505"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::register_create_index_entry</b> (const char *<a class="el" href="struct__entry.html">entry</a>)</td></tr>
<tr class="separator:gad2fa3a1ea5448f3e685da73d94f62505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9f8dd27495fec25114ccdec0917ed4a"><td class="memItemLeft" align="right" valign="top"><a id="gab9f8dd27495fec25114ccdec0917ed4a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::purge_index_entry</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, ulonglong *decrease_log_space, bool need_lock_index)</td></tr>
<tr class="separator:gab9f8dd27495fec25114ccdec0917ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac126e05bd18fabf135844faef05ff28c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gac126e05bd18fabf135844faef05ff28c">MYSQL_BIN_LOG::purge_logs_before_date</a> (time_t purge_time, bool auto_purge)</td></tr>
<tr class="separator:gac126e05bd18fabf135844faef05ff28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94f694096c1ef28962d9d7936d2d9a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga94f694096c1ef28962d9d7936d2d9a1e">MYSQL_BIN_LOG::make_log_name</a> (char *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const char *log_ident)</td></tr>
<tr class="separator:ga94f694096c1ef28962d9d7936d2d9a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac641bdabee70ba4bd377e06e1853fcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaac641bdabee70ba4bd377e06e1853fcb">MYSQL_BIN_LOG::is_active</a> (const char *log_file_name)</td></tr>
<tr class="separator:gaac641bdabee70ba4bd377e06e1853fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae455eec3547a9c58913acad74c946c60"><td class="memItemLeft" align="right" valign="top"><a id="gae455eec3547a9c58913acad74c946c60"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::new_file</b> (<a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *extra_description_event)</td></tr>
<tr class="separator:gae455eec3547a9c58913acad74c946c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285118da996c3b2d3517a06957e120d2"><td class="memItemLeft" align="right" valign="top"><a id="ga285118da996c3b2d3517a06957e120d2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::new_file_without_locking</b> (<a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *extra_description_event)</td></tr>
<tr class="separator:ga285118da996c3b2d3517a06957e120d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4787d8c74f93a27235db912039d3185"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaa4787d8c74f93a27235db912039d3185">MYSQL_BIN_LOG::new_file_impl</a> (bool need_lock, <a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *extra_description_event)</td></tr>
<tr class="separator:gaa4787d8c74f93a27235db912039d3185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bcc4a9f726eaf5708004e8b4865d7c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga8bcc4a9f726eaf5708004e8b4865d7c8">MYSQL_BIN_LOG::after_append_to_relay_log</a> (Master_info *mi)</td></tr>
<tr class="separator:ga8bcc4a9f726eaf5708004e8b4865d7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafedf5cdf2ee6e54b6c0ba12c710bbe5d"><td class="memItemLeft" align="right" valign="top"><a id="gafedf5cdf2ee6e54b6c0ba12c710bbe5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::append_event</b> (<a class="el" href="class_log__event.html">Log_event</a> *ev, Master_info *mi)</td></tr>
<tr class="separator:gafedf5cdf2ee6e54b6c0ba12c710bbe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d913d330df534c1c81a776241a526c"><td class="memItemLeft" align="right" valign="top"><a id="ga74d913d330df534c1c81a776241a526c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::append_buffer</b> (const char *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, Master_info *mi)</td></tr>
<tr class="separator:ga74d913d330df534c1c81a776241a526c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40c4dc6b0b8986a50661b28df3a6fa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gae40c4dc6b0b8986a50661b28df3a6fa3">MYSQL_BIN_LOG::flush_and_sync</a> (const bool force=false)</td></tr>
<tr class="separator:gae40c4dc6b0b8986a50661b28df3a6fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7408e146d23b953fd8e41d58a73119f"><td class="memItemLeft" align="right" valign="top"><a id="gac7408e146d23b953fd8e41d58a73119f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::start_union_events</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, query_id_t query_id_param)</td></tr>
<tr class="separator:gac7408e146d23b953fd8e41d58a73119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec4819bc9642741f8775c71225234095"><td class="memItemLeft" align="right" valign="top"><a id="gaec4819bc9642741f8775c71225234095"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::stop_union_events</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:gaec4819bc9642741f8775c71225234095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b1915a748ef2b92e65ba67dd7b9371"><td class="memItemLeft" align="right" valign="top"><a id="gaa2b1915a748ef2b92e65ba67dd7b9371"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::is_query_in_union</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, query_id_t query_id_param)</td></tr>
<tr class="separator:gaa2b1915a748ef2b92e65ba67dd7b9371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e45fa3b5e152adacb9f9899f983b2a"><td class="memItemLeft" align="right" valign="top"><a id="ga21e45fa3b5e152adacb9f9899f983b2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::update_thd_next_event_pos</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga21e45fa3b5e152adacb9f9899f983b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7c8c2cc805e99d685a0d99275d72d8"><td class="memItemLeft" align="right" valign="top"><a id="ga7d7c8c2cc805e99d685a0d99275d72d8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::flush_and_set_pending_rows_event</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_rows__log__event.html">Rows_log_event</a> *<a class="el" href="structevent.html">event</a>, bool is_transactional)</td></tr>
<tr class="separator:ga7d7c8c2cc805e99d685a0d99275d72d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c19cd666a1a517386dedd4078dd93e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga9c19cd666a1a517386dedd4078dd93e7">MYSQL_BIN_LOG::write_event</a> (<a class="el" href="class_log__event.html">Log_event</a> *event_info)</td></tr>
<tr class="separator:ga9c19cd666a1a517386dedd4078dd93e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2053b0b53a46eb5702b44966497c333f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga2053b0b53a46eb5702b44966497c333f">MYSQL_BIN_LOG::rotate</a> (bool force_rotate, bool *check_purge)</td></tr>
<tr class="separator:ga2053b0b53a46eb5702b44966497c333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff1889360685bd90b1d3ffba10ba3dba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaff1889360685bd90b1d3ffba10ba3dba">MYSQL_BIN_LOG::purge</a> ()</td></tr>
<tr class="separator:gaff1889360685bd90b1d3ffba10ba3dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f41b228c438fe7b4c710b8fdd780cfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga9f41b228c438fe7b4c710b8fdd780cfb">MYSQL_BIN_LOG::rotate_and_purge</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool force_rotate)</td></tr>
<tr class="separator:ga9f41b228c438fe7b4c710b8fdd780cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d77f5e99ad74fbd1122a9dbc3ae34e4"><td class="memItemLeft" align="right" valign="top"><a id="ga2d77f5e99ad74fbd1122a9dbc3ae34e4"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::next_file_id</b> ()</td></tr>
<tr class="separator:ga2d77f5e99ad74fbd1122a9dbc3ae34e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc26608fb4ccd54dafb0e3aa6844e927"><td class="memItemLeft" align="right" valign="top"><a id="gabc26608fb4ccd54dafb0e3aa6844e927"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::do_write_cache</b> (<a class="el" href="structst__io__cache.html">IO_CACHE</a> *cache)</td></tr>
<tr class="separator:gabc26608fb4ccd54dafb0e3aa6844e927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecc977a50e24a4f1e144d056689a645a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaecc977a50e24a4f1e144d056689a645a">MYSQL_BIN_LOG::write_incident</a> (<a class="el" href="class_incident__log__event.html">Incident_log_event</a> *ev, bool need_lock_log, bool do_flush_and_sync=true)</td></tr>
<tr class="separator:gaecc977a50e24a4f1e144d056689a645a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6023a97a6c19c5e160f9dd975136474"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gac6023a97a6c19c5e160f9dd975136474">MYSQL_BIN_LOG::write_incident</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool need_lock_log, bool do_flush_and_sync=true)</td></tr>
<tr class="separator:gac6023a97a6c19c5e160f9dd975136474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9dbdae7075b4f8bdef3b78d411d6481"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gac9dbdae7075b4f8bdef3b78d411d6481">MYSQL_BIN_LOG::write_cache</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, class <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *<a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a>)</td></tr>
<tr class="separator:gac9dbdae7075b4f8bdef3b78d411d6481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10698ebc9afd7be839f7a69b7aaac141"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga10698ebc9afd7be839f7a69b7aaac141">MYSQL_BIN_LOG::wait_for_update_relay_log</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const struct <a class="el" href="structtimespec.html">timespec</a> *timeout)</td></tr>
<tr class="separator:ga10698ebc9afd7be839f7a69b7aaac141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b625b440aaf82241200b3980d94c6a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga1b625b440aaf82241200b3980d94c6a9">MYSQL_BIN_LOG::wait_for_update_bin_log</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const struct <a class="el" href="structtimespec.html">timespec</a> *timeout)</td></tr>
<tr class="separator:ga1b625b440aaf82241200b3980d94c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81bc7bab09f91f6524dd81c8551e4cf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga81bc7bab09f91f6524dd81c8551e4cf0">MYSQL_BIN_LOG::close</a> (uint exiting)</td></tr>
<tr class="separator:ga81bc7bab09f91f6524dd81c8551e4cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1668661349520d23557e796db4a0b423"><td class="memItemLeft" align="right" valign="top"><a id="ga1668661349520d23557e796db4a0b423"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::set_max_size</b> (ulong max_size_arg)</td></tr>
<tr class="separator:ga1668661349520d23557e796db4a0b423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17a43410896c12a08f8efd45ca20217"><td class="memItemLeft" align="right" valign="top"><a id="gaf17a43410896c12a08f8efd45ca20217"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::signal_update</b> ()</td></tr>
<tr class="separator:gaf17a43410896c12a08f8efd45ca20217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44de4e3109fc4d50d4968191ab0f3544"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga44de4e3109fc4d50d4968191ab0f3544">MYSQL_BIN_LOG::open_binlog</a> (const char *opt_name)</td></tr>
<tr class="separator:ga44de4e3109fc4d50d4968191ab0f3544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e829bf97dfac49c3b05a2cbdbaf7cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga22e829bf97dfac49c3b05a2cbdbaf7cb">MYSQL_BIN_LOG::close</a> ()</td></tr>
<tr class="separator:ga22e829bf97dfac49c3b05a2cbdbaf7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4789039161947fff76fa8250b120b7e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga4789039161947fff76fa8250b120b7e3">MYSQL_BIN_LOG::prepare</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool all)</td></tr>
<tr class="separator:ga4789039161947fff76fa8250b120b7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fdcfcfb5d2c85ca2a114ad2115b20e"><td class="memItemLeft" align="right" valign="top">enum_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga94fdcfcfb5d2c85ca2a114ad2115b20e">MYSQL_BIN_LOG::commit</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool all)</td></tr>
<tr class="separator:ga94fdcfcfb5d2c85ca2a114ad2115b20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a085c1b3fdcd74c31ba5696bfd9ee4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, my_off_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gab2a085c1b3fdcd74c31ba5696bfd9ee4">MYSQL_BIN_LOG::flush_thread_caches</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:gab2a085c1b3fdcd74c31ba5696bfd9ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ee4ac7f05b621d323a8c4a9247a6a93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga2ee4ac7f05b621d323a8c4a9247a6a93">MYSQL_BIN_LOG::process_flush_stage_queue</a> (my_off_t *total_bytes_var, bool *rotate_var, THD **out_queue_var)</td></tr>
<tr class="separator:ga2ee4ac7f05b621d323a8c4a9247a6a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529497249f578f2883d9eb7d5285b294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga529497249f578f2883d9eb7d5285b294">MYSQL_BIN_LOG::process_commit_stage_queue</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, THD *queue)</td></tr>
<tr class="separator:ga529497249f578f2883d9eb7d5285b294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b5c7f3024156be25bf9307337d6da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gab1b5c7f3024156be25bf9307337d6da1">MYSQL_BIN_LOG::process_after_commit_stage_queue</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, THD *first)</td></tr>
<tr class="separator:gab1b5c7f3024156be25bf9307337d6da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b00ef1d7ca1528f087235067db6d680"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga6b00ef1d7ca1528f087235067db6d680">MYSQL_BIN_LOG::change_stage</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_stage__manager.html#a28879837525f3786d4bcb6f330f4ac69">Stage_manager::StageID</a> stage, THD *queue, <a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> *leave, <a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> *enter)</td></tr>
<tr class="separator:ga6b00ef1d7ca1528f087235067db6d680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196855bd8dc3ae6f20d7aad07fbb6669"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga196855bd8dc3ae6f20d7aad07fbb6669">MYSQL_BIN_LOG::flush_cache_to_file</a> (my_off_t *flush_end_pos)</td></tr>
<tr class="separator:ga196855bd8dc3ae6f20d7aad07fbb6669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1391801107de083a2914147c8b9a67"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga7a1391801107de083a2914147c8b9a67">MYSQL_BIN_LOG::sync_binlog_file</a> (bool force)</td></tr>
<tr class="separator:ga7a1391801107de083a2914147c8b9a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd29f8c2a08de52c54203e0f6092799"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga7dd29f8c2a08de52c54203e0f6092799">MYSQL_BIN_LOG::finish_commit</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga7dd29f8c2a08de52c54203e0f6092799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd6e1e70093afedf97ac7266268db0fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gadd6e1e70093afedf97ac7266268db0fe">MYSQL_BIN_LOG::ordered_commit</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, bool all, bool skip_commit=false)</td></tr>
<tr class="separator:gadd6e1e70093afedf97ac7266268db0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e843aafa062a4ab987d5ff75d450c41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#ga0e843aafa062a4ab987d5ff75d450c41">MYSQL_BIN_LOG::recover</a> (<a class="el" href="structst__io__cache.html">IO_CACHE</a> *<a class="el" href="row0log_8cc.html#a800f12bb442b5fb971fb19d203766eb4">log</a>, <a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *fdle, my_off_t *valid_pos)</td></tr>
<tr class="separator:ga0e843aafa062a4ab987d5ff75d450c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae92e0e5d90048ee1fe7b36dd71ec3074"><td class="memItemLeft" align="right" valign="top"><a id="gae92e0e5d90048ee1fe7b36dd71ec3074"></a>
static ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>limit_unsafe_suppression_start_time</b> = 0</td></tr>
<tr class="separator:gae92e0e5d90048ee1fe7b36dd71ec3074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga295a7704ac3d0d712a3770bf39db89ef"><td class="memItemLeft" align="right" valign="top"><a id="ga295a7704ac3d0d712a3770bf39db89ef"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>unsafe_warning_suppression_is_activated</b> = false</td></tr>
<tr class="separator:ga295a7704ac3d0d712a3770bf39db89ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0988699c8e00d55dbf5ed4adaa15b5c"><td class="memItemLeft" align="right" valign="top"><a id="gaa0988699c8e00d55dbf5ed4adaa15b5c"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>limit_unsafe_warning_count</b> = 0</td></tr>
<tr class="separator:gaa0988699c8e00d55dbf5ed4adaa15b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4fddbf155aa32ed2e618ad5e8ab23d"><td class="memItemLeft" align="right" valign="top"><a id="gabc4fddbf155aa32ed2e618ad5e8ab23d"></a>
static <a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_hton</b></td></tr>
<tr class="separator:gabc4fddbf155aa32ed2e618ad5e8ab23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5449116d5d93490b34525853da65eac"><td class="memItemLeft" align="right" valign="top"><a id="gac5449116d5d93490b34525853da65eac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>opt_binlog_order_commits</b> = true</td></tr>
<tr class="separator:gac5449116d5d93490b34525853da65eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d28cf3c8664bf92f1fbe1d8ba04ef0"><td class="memItemLeft" align="right" valign="top"><a id="ga41d28cf3c8664bf92f1fbe1d8ba04ef0"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>log_bin_index</b> = 0</td></tr>
<tr class="separator:ga41d28cf3c8664bf92f1fbe1d8ba04ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dbf1a49cfaae776fd9052568c40a6ba"><td class="memItemLeft" align="right" valign="top"><a id="ga5dbf1a49cfaae776fd9052568c40a6ba"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>log_bin_basename</b> = 0</td></tr>
<tr class="separator:ga5dbf1a49cfaae776fd9052568c40a6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e016d5a4032854dc75a4feeb3b7a91"><td class="memItemLeft" align="right" valign="top"><a id="ga70e016d5a4032854dc75a4feeb3b7a91"></a>
<a class="el" href="class_m_y_s_q_l___b_i_n___l_o_g.html">MYSQL_BIN_LOG</a> mysql_bin_log &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sync_binlog_period</b></td></tr>
<tr class="separator:ga70e016d5a4032854dc75a4feeb3b7a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaac494267a37cf670b0219ce23ef63e3"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___binary___log.html#gaaac494267a37cf670b0219ce23ef63e3">g_stage_name</a> []</td></tr>
<tr class="separator:gaaac494267a37cf670b0219ce23ef63e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ecc9c0253b423bc48289c779e9c010"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structst__mysql__storage__engine.html">st_mysql_storage_engine</a>&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_storage_engine</b></td></tr>
<tr class="separator:gaf6ecc9c0253b423bc48289c779e9c010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga1e24693cd278a03ccca7bc269375ad16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e24693cd278a03ccca7bc269375ad16">&#9670;&nbsp;</a></span>enum_read_gtids_from_binlog_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___binary___log.html#ga1e24693cd278a03ccca7bc269375ad16">enum_read_gtids_from_binlog_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads GTIDs from the given binlog file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File to read from. </td></tr>
    <tr><td class="paramname">all_gtids</td><td>If not NULL, then the GTIDs from the <a class="el" href="class_previous__gtids__log__event.html">Previous_gtids_log_event</a> and from all Gtid_log_events are stored in this object. </td></tr>
    <tr><td class="paramname">prev_gtids</td><td>If not NULL, then the GTIDs from the Previous_gtids_log_events are stored in this object. </td></tr>
    <tr><td class="paramname">first_gtid</td><td>If not NULL, then the first GTID information from the file will be stored in this object. </td></tr>
    <tr><td class="paramname">last_gtid</td><td>If not NULL, then the last GTID information from the file will be stored in this object. </td></tr>
    <tr><td class="paramname">sid_map</td><td>The sid_map object to use in the rpl_sidno generation of the <a class="el" href="class_gtid__log__event.html">Gtid_log_event</a>. If lock is needed in the sid_map, the caller must hold it. </td></tr>
    <tr><td class="paramname">verify_checksum</td><td>Set to true to verify event checksums.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">GOT_GTIDS</td><td>The file was successfully read and it contains both Gtid_log_events and Previous_gtids_log_events. </td></tr>
    <tr><td class="paramname">GOT_PREVIOUS_GTIDS</td><td>The file was successfully read and it contains Previous_gtids_log_events but no Gtid_log_events. </td></tr>
    <tr><td class="paramname">NO_GTIDS</td><td>The file was successfully read and it does not contain GTID events. </td></tr>
    <tr><td class="paramname">ERROR</td><td>Out of memory, or the file contains GTID events when GTID_MODE = OFF, or the file is malformed (e.g., contains Gtid_log_events but no <a class="el" href="class_previous__gtids__log__event.html">Previous_gtids_log_event</a>). </td></tr>
    <tr><td class="paramname">TRUNCATED</td><td>The file was truncated before the end of the first <a class="el" href="class_previous__gtids__log__event.html">Previous_gtids_log_event</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga264a159d100314afaae92b304f9cd47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga264a159d100314afaae92b304f9cd47a">&#9670;&nbsp;</a></span>add_log_to_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::add_log_to_index </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>log_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>log_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append log file name to index file.</p>
<ul>
<li>To make crash safe, we copy all the content of index file to crash safe index file firstly and then append the log file name to the crash safe index file. Finally move the crash safe index file to index file.</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8bcc4a9f726eaf5708004e8b4865d7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bcc4a9f726eaf5708004e8b4865d7c8">&#9670;&nbsp;</a></span>after_append_to_relay_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::after_append_to_relay_log </td>
          <td>(</td>
          <td class="paramtype">Master_info *&#160;</td>
          <td class="paramname"><em>mi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after an event has been written to the relay log by the IO thread. This flushes and possibly syncs the file (according to the sync options), rotates the file if it has grown over the limit, and finally calls signal_update().</p>
<dl class="section note"><dt>Note</dt><dd>The caller must hold LOCK_log before invoking this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Master_info for the IO thread. </td></tr>
    <tr><td class="paramname">need_data_lock</td><td>If true, mi-&gt;data_lock will be acquired if a rotation is needed. Otherwise, mi-&gt;data_lock must be held by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>success </td></tr>
    <tr><td class="paramname">true</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20a543666e684f08da1cc093d5fa70ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a543666e684f08da1cc093d5fa70ec">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Stage_manager::Mutex_queue::append </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>first</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a linked list of threads to the queue </p>

</div>
</div>
<a id="ga3da95c9d936e5ea3023159e0e2c73d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3da95c9d936e5ea3023159e0e2c73d53">&#9670;&nbsp;</a></span>binlog_commit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int binlog_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>hton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called once after each statement.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>This function is currently not used any more and will eventually be eliminated. The real commit job is done in the <a class="el" href="group___binary___log.html#ga94fdcfcfb5d2c85ca2a114ad2115b20e">MYSQL_BIN_LOG::commit</a> function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___binary___log.html#ga94fdcfcfb5d2c85ca2a114ad2115b20e">MYSQL_BIN_LOG::commit</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hton</td><td>The binlog handlerton. </td></tr>
    <tr><td class="paramname">thd</td><td>The client thread that executes the transaction. </td></tr>
    <tr><td class="paramname">all</td><td>This is <code>true</code> if this is a real transaction commit, and  otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>handlerton::commit </dd></dl>

</div>
</div>
<a id="ga46468c405fde69f126c1bcb343c85c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46468c405fde69f126c1bcb343c85c90">&#9670;&nbsp;</a></span>binlog_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool binlog_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> whether binlog_hton has valid slot and enabled </p>

</div>
</div>
<a id="ga99c2a651ebeb1e8f1d52fc01fb57029b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c2a651ebeb1e8f1d52fc01fb57029b">&#9670;&nbsp;</a></span>binlog_rollback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int binlog_rollback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>hton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called when a transaction or a statement is rolled back. </p>

</div>
</div>
<a id="ga3b468affd908cdb22e2a5879ea3692a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b468affd908cdb22e2a5879ea3692a1">&#9670;&nbsp;</a></span>binlog_savepoint_rollback_can_release_mdl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool binlog_savepoint_rollback_can_release_mdl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>hton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> whether binlog state allows to safely release MDL locks after rollback to savepoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hton</td><td>The binlog handlerton. </td></tr>
    <tr><td class="paramname">thd</td><td>The client thread that executes the transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - It is safe to release MDL locks. false - If it is not. </dd></dl>

</div>
</div>
<a id="ga675a6ef6e0ba149557d25c2daf4d5ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga675a6ef6e0ba149557d25c2daf4d5ff0">&#9670;&nbsp;</a></span>binlog_savepoint_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int binlog_savepoint_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>hton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>How do we handle this (unlikely but legal) case: <pre class="fragment">  [transaction] + [update to non-trans table] + [rollback to savepoint] ?
</pre> The problem occurs when a savepoint is before the update to the non-transactional table. Then when there's a rollback to the savepoint, if we simply truncate the binlog cache, we lose the part of the binlog cache where the update is. If we want to not lose it, we need to write the SAVEPOINT command and the ROLLBACK TO SAVEPOINT command to the binlog cache. The latter is easy: it's just write at the end of the binlog cache, but the former should be <em>inserted</em> to the place where the user called SAVEPOINT. The solution is that when the user calls SAVEPOINT, we write it to the binlog cache (so no need to later insert it). As transactions are never intermixed in the binary log (i.e. they are serialized), we won't have conflicts with savepoint names when using mysqlbinlog or in the slave SQL thread. Then when ROLLBACK TO SAVEPOINT is called, if we updated some non-transactional table, we don't truncate the binlog cache but instead write ROLLBACK TO SAVEPOINT to it; otherwise we truncate the binlog cache (which will chop the SAVEPOINT command from the binlog cache, which is good as in that case there is no need to have it in the binlog). </dd></dl>

</div>
</div>
<a id="gaed02522808460c9addecf632207a5ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed02522808460c9addecf632207a5ce1">&#9670;&nbsp;</a></span>binlog_start_trans_and_stmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int binlog_start_trans_and_stmt </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_log__event.html">Log_event</a> *&#160;</td>
          <td class="paramname"><em>start_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to start a statement and optionally a transaction for the binary log.</p>
<p>This function does three things:</p><ul>
<li>Starts a transaction if not in autocommit mode or if a BEGIN statement has been seen.</li>
<li>Start a statement transaction to allow us to truncate the cache.</li>
<li><p class="startli">Save the currrent binlog position so that we can roll back the statement by truncating the cache.</p>
<p class="startli">We only update the saved position if the old one was undefined, the reason is that there are some cases (e.g., for CREATE-SELECT) where the position is saved twice (e.g., both in select_create::prepare() and THD::binlog_write_table_map()) , but we should use the first. This means that calls to this function can be used to start the statement before the first table map event, to include some extra events.</p>
</li>
</ul>
<p>Note however that IMMEDIATE_LOGGING implies that the statement is written without BEGIN/COMMIT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread variable </td></tr>
    <tr><td class="paramname">start_event</td><td>The first event requested to be written into the binary log </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6b00ef1d7ca1528f087235067db6d680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b00ef1d7ca1528f087235067db6d680">&#9670;&nbsp;</a></span>change_stage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::change_stage </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_stage__manager.html#a28879837525f3786d4bcb6f330f4ac69">Stage_manager::StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>leave_mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>enter_mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enter a stage of the ordered commit procedure.</p>
<p>Entering is stage is done by:</p>
<ul>
<li>Atomically enqueueing a queue of processes (which is just one for the first phase).</li>
<li>If the queue was empty, the thread is the leader for that stage and it should process the entire queue for that stage.</li>
<li>If the queue was not empty, the thread is a follower and can go waiting for the commit to finish.</li>
</ul>
<p>The function will lock the stage mutex if it was designated the leader for the phase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session structure </td></tr>
    <tr><td class="paramname">stage</td><td>The stage to enter </td></tr>
    <tr><td class="paramname">queue</td><td>Queue of threads to enqueue for the stage </td></tr>
    <tr><td class="paramname">stage_mutex</td><td>Mutex for the stage</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The thread should "bail out" and go waiting for the commit to finish </td></tr>
    <tr><td class="paramname">false</td><td>The thread is the leader for the stage and should do the processing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63c6fcd1b8e84116f7bcec46e7b25caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63c6fcd1b8e84116f7bcec46e7b25caa">&#9670;&nbsp;</a></span>check_binlog_cache_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_binlog_cache_size </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the BINLOG_CACHE_SIZE's value is greater than MAX_BINLOG_CACHE_SIZE. If this happens, the BINLOG_CACHE_SIZE is set to MAX_BINLOG_CACHE_SIZE. </p>

</div>
</div>
<a id="ga7a0a12298d22d080b68e55f324cd59bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a0a12298d22d080b68e55f324cd59bd">&#9670;&nbsp;</a></span>check_binlog_stmt_cache_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_binlog_stmt_cache_size </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the BINLOG_STMT_CACHE_SIZE's value is greater than MAX_BINLOG_STMT_CACHE_SIZE. If this happens, the BINLOG_STMT_CACHE_SIZE is set to MAX_BINLOG_STMT_CACHE_SIZE. </p>

</div>
</div>
<a id="gad3389586ace2de50ee7606d7acc98849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3389586ace2de50ee7606d7acc98849">&#9670;&nbsp;</a></span>clear_preempt_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Stage_manager::clear_preempt_status </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method ensures the follower's execution path can be preempted by the leader's thread. Preempt status of <code>head</code> follower is checked to engange the leader into waiting when set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>THD* of a follower thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22e829bf97dfac49c3b05a2cbdbaf7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22e829bf97dfac49c3b05a2cbdbaf7cb">&#9670;&nbsp;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is called on shutdown, after ha_panic. </p>

<p>Implements <a class="el" href="class_t_c___l_o_g.html">TC_LOG</a>.</p>

</div>
</div>
<a id="ga81bc7bab09f91f6524dd81c8551e4cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81bc7bab09f91f6524dd81c8551e4cf0">&#9670;&nbsp;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::close </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>exiting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the log file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exiting</td><td>Bitmask for one or more of the following bits:<ul>
<li>LOG_CLOSE_INDEX : if we should close the index file</li>
<li>LOG_CLOSE_TO_BE_OPENED : if we intend to call open at once after close.</li>
<li>LOG_CLOSE_STOP_EVENT : write a 'stop' event to the log</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>One can do an open on the object at once after doing a close. The internal structures are not freed until cleanup() is called </dd></dl>

</div>
</div>
<a id="gad5cf0683506dfdcc484155c676786860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5cf0683506dfdcc484155c676786860">&#9670;&nbsp;</a></span>close_crash_safe_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::close_crash_safe_index_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the crash safe index file.</p>
<dl class="section note"><dt>Note</dt><dd>The crash safe file is just closed, is not deleted. Because it is moved to index file later on. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94fdcfcfb5d2c85ca2a114ad2115b20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94fdcfcfb5d2c85ca2a114ad2115b20e">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TC_LOG::enum_result MYSQL_BIN_LOG::commit </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Commit the transaction in the transaction coordinator.</p>
<p>This function will commit the sessions transaction in the binary log and in the storage engines (by calling <code>ha_commit_low</code>). If the transaction was successfully logged (or not successfully unlogged) but the commit in the engines did not succed, there is a risk of inconsistency between the engines and the binary log.</p>
<p>For binary log group commit, the commit is separated into three parts:</p>
<ol type="1">
<li>First part consists of filling the necessary caches and finalizing them (if they need to be finalized). After this, nothing is added to any of the caches.</li>
<li>Second part execute an ordered flush and commit. This will be done using the group commit functionality in ordered_commit.</li>
<li>Third part checks any errors resulting from the ordered commit and handles them appropriately.</li>
</ol>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">1</td><td>error, transaction was neither logged nor committed </td></tr>
    <tr><td class="paramname">2</td><td>error, transaction was logged but not committed </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_t_c___l_o_g.html#a3f9ef43db745a798f8b361eb0b93ff22">TC_LOG</a>.</p>

</div>
</div>
<a id="ga2be98bfd39c79d3421a8dd968372aa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2be98bfd39c79d3421a8dd968372aa8f">&#9670;&nbsp;</a></span>copy_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool copy_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">my_off_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy content of 'from' file from offset to 'to' file.</p>
<ul>
<li>We do the copy outside of the IO_CACHE as the cache buffers would just make things slower and more complicated. In most cases the copy loop should only do one read.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>File to copy. </td></tr>
    <tr><td class="paramname">to</td><td>File to copy to. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in 'from' file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80a5419e22b84b8ca2f3595cbf75fa67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a5419e22b84b8ca2f3595cbf75fa67">&#9670;&nbsp;</a></span>ending_single_stmt_trans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ending_single_stmt_trans </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks if a single statement transaction is about to commit or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
    <tr><td class="paramname">all</td><td>Committing a transaction (i.e. TRUE) or a statement (i.e. FALSE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if committing a single statement transaction, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="gaad02774240e19d361a32bd35c9db60cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad02774240e19d361a32bd35c9db60cb">&#9670;&nbsp;</a></span>ending_trans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ending_trans </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks if a transaction, either a multi-statement or a single statement transaction is about to commit or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
    <tr><td class="paramname">all</td><td>Committing a transaction (i.e. TRUE) or a statement (i.e. FALSE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if committing a transaction, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ga71a83004e5774879856189f84d00094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a83004e5774879856189f84d00094f">&#9670;&nbsp;</a></span>enroll_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Stage_manager::enroll_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_stage__manager.html#a28879837525f3786d4bcb6f330f4ac69">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___thread__instrumentation.html#ga5303924710bf8356ede41ee68bca276f">mysql_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>stage_mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enroll a set of sessions for a stage.</p>
<p>This will queue the session thread for writing and flushing.</p>
<p>If the thread being queued is assigned as stage leader, it will return immediately.</p>
<p>If wait_if_follower is true the thread is not the stage leader, the thread will be wait for the queue to be processed by the leader before it returns. In DBUG-ON version the follower marks is preempt status as ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Stage identifier for the queue to append to. </td></tr>
    <tr><td class="paramname">first</td><td>Queue to append. </td></tr>
    <tr><td class="paramname">stage_mutex</td><td>Pointer to the currently held stage mutex, or NULL if we're not in a stage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Thread is stage leader. </td></tr>
    <tr><td class="paramname">false</td><td>Thread was not stage leader and processing has been done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga254675ae9d8f6f0a7b48d7520ab16eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga254675ae9d8f6f0a7b48d7520ab16eea">&#9670;&nbsp;</a></span>fetch_and_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">THD * Stage_manager::Mutex_queue::fetch_and_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetch the entire queue for a stage.</p>
<p>This will fetch the entire queue in one go. </p>

</div>
</div>
<a id="ga3367fa8c1daced18065f6b9dea5385fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3367fa8c1daced18065f6b9dea5385fe">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binlog_cache_data::finalize </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_log__event.html">Log_event</a> *&#160;</td>
          <td class="paramname"><em>end_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function finalizes the cache preparing for commit or rollback.</p>
<p>The function just writes all the necessary events to the cache but does not flush the data to the binary log file. That is the role of the <a class="el" href="group___binary___log.html#ga302d2ea7bfcbea015c329edacdac6c5a">binlog_cache_data::flush</a> function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___binary___log.html#ga302d2ea7bfcbea015c329edacdac6c5a">binlog_cache_data::flush</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread whose transaction should be flushed </td></tr>
    <tr><td class="paramname">cache_data</td><td>Pointer to the cache </td></tr>
    <tr><td class="paramname">end_ev</td><td>The end event either commit/rollback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if an error pops up when flushing the cache. </dd></dl>

</div>
</div>
<a id="gab8925923df0bf9cd07f7fcaf45f8db16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8925923df0bf9cd07f7fcaf45f8db16">&#9670;&nbsp;</a></span>find_first_log_not_in_gtid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::find_first_log_not_in_gtid_set </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>binlog_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>gtid_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_gtid.html">Gtid</a> *&#160;</td>
          <td class="paramname"><em>first_gtid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the oldest binary log that contains any GTID that is not in the given gtid set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">binlog_file_name,the</td><td>file name of oldest binary log found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gtid_set,the</td><td>given gtid set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_gtid,the</td><td>first GTID information from the binary log file returned at binlog_file_name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg,the</td><td>error message outputted, which is left untouched if the function returns false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error. </dd></dl>

</div>
</div>
<a id="ga245bb1e482896f726e11719666f2394a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga245bb1e482896f726e11719666f2394a">&#9670;&nbsp;</a></span>find_log_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::find_log_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__log__info.html">LOG_INFO</a> *&#160;</td>
          <td class="paramname"><em>linfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the position in the log-index-file for the given log name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">linfo</td><td>The found log file name will be stored here, along with the byte offset of the next log file name in the index file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">log_name</td><td>Filename to find in the index file, or NULL if we want to read the first entry. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">need_lock_index</td><td>If false, this function acquires LOCK_index; otherwise the lock should already be held by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On systems without the truncate function the file will end with one or more empty lines. These will be ignored when reading the file.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">LOG_INFO_EOF</td><td>End of log-index-file found </td></tr>
    <tr><td class="paramname">LOG_INFO_IO</td><td>Got IO error while reading file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ed66e95398bcafa143ca8ad16860711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ed66e95398bcafa143ca8ad16860711">&#9670;&nbsp;</a></span>find_next_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::find_next_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__log__info.html">LOG_INFO</a> *&#160;</td>
          <td class="paramname"><em>linfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the position in the log-index-file for the given log name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">linfo</td><td>The filename will be stored here, along with the byte offset of the next filename in the index file.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">need_lock_index</td><td>If true, LOCK_index will be acquired; otherwise it should already be held by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Before calling this function, one has to call <a class="el" href="group___binary___log.html#ga245bb1e482896f726e11719666f2394a">find_log_pos()</a> to set up 'linfo'</li>
<li>Mutex needed because we need to make sure the file pointer does not move from under our feet</li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">LOG_INFO_EOF</td><td>End of log-index-file found </td></tr>
    <tr><td class="paramname">LOG_INFO_IO</td><td>Got IO error while reading file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7dd29f8c2a08de52c54203e0f6092799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dd29f8c2a08de52c54203e0f6092799">&#9670;&nbsp;</a></span>finish_commit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::finish_commit </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function executed when leaving <code>ordered_commit</code>.</p>
<p>This function contain the necessary code for fetching the error code, doing post-commit checks, and wrapping up the commit if necessary.</p>
<p>It is typically called when enter_stage indicates that the thread should bail out, and also when the ultimate leader thread finishes executing <code>ordered_commit</code>.</p>
<p>It is typically used in this manner: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (enter_stage(<a class="code" href="ha__innodb_8cc.html#aea88fef23e96c7bd104198a0ec7e6423">thd</a>, Thread_queue::FLUSH_STAGE, <a class="code" href="ha__innodb_8cc.html#aea88fef23e96c7bd104198a0ec7e6423">thd</a>, &amp;LOCK_log))</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group___binary___log.html#ga7dd29f8c2a08de52c54203e0f6092799">finish_commit</a>(<a class="code" href="ha__innodb_8cc.html#aea88fef23e96c7bd104198a0ec7e6423">thd</a>);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Error code if the session commit failed, or zero on success. </dd></dl>

</div>
</div>
<a id="gaf105c9f0e7937c6f81472c50b41e9e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf105c9f0e7937c6f81472c50b41e9e42">&#9670;&nbsp;</a></span>fix_log_event_crc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulong fix_log_event_crc </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>event_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_checksum *&#160;</td>
          <td class="paramname"><em>crc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate checksum of possibly a part of an event containing at least the whole common header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the pointer to trans cache's buffer </td></tr>
    <tr><td class="paramname">off</td><td>the offset of the beginning of the event in the buffer </td></tr>
    <tr><td class="paramname">event_len</td><td>no-checksum length of the event </td></tr>
    <tr><td class="paramname">length</td><td>the current size of the buffer</td></tr>
    <tr><td class="paramname">crc</td><td>[in-out] the checksum</td></tr>
  </table>
  </dd>
</dl>
<p>Event size in incremented by <code>BINLOG_CHECKSUM_LEN</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 or number of unprocessed yet bytes of the event excluding the checksum part. </dd></dl>

</div>
</div>
<a id="ga302d2ea7bfcbea015c329edacdac6c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga302d2ea7bfcbea015c329edacdac6c5a">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binlog_cache_data::flush </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">my_off_t *&#160;</td>
          <td class="paramname"><em>bytes_written</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>wrote_xid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush caches to the binary log.</p>
<p>If the cache is finalized, the cache will be flushed to the binary log file. If the cache is not finalized, nothing will be done.</p>
<p>If flushing fails for any reason, an error will be reported and the cache will be reset. Flushing can fail in two circumstances:</p>
<ul>
<li>It was not possible to write the cache to the file. In this case, it does not make sense to keep the cache.</li>
<li>The cache was successfully written to disk but post-flush actions (such as binary log rotation) failed. In this case, the cache is already written to disk and there is no reason to keep it.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___binary___log.html#ga3367fa8c1daced18065f6b9dea5385fe">binlog_cache_data::finalize</a> </dd></dl>

</div>
</div>
<a id="gae40c4dc6b0b8986a50661b28df3a6fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40c4dc6b0b8986a50661b28df3a6fa3">&#9670;&nbsp;</a></span>flush_and_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::flush_and_sync </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush binlog cache and synchronize to disk.</p>
<p>This function flushes events in binlog cache to binary log file, it will do synchronizing according to the setting of system variable 'sync_binlog'. If file is synchronized, <code>synced</code> will be set to 1, otherwise 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">synced</td><td>if not NULL, set to 1 if file is synchronized, otherwise 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>if TRUE, ignores the 'sync_binlog' and synchronizes the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">other</td><td>Failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga196855bd8dc3ae6f20d7aad07fbb6669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga196855bd8dc3ae6f20d7aad07fbb6669">&#9670;&nbsp;</a></span>flush_cache_to_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::flush_cache_to_file </td>
          <td>(</td>
          <td class="paramtype">my_off_t *&#160;</td>
          <td class="paramname"><em>end_pos_var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush the I/O cache to file.</p>
<p>Flush the binary log to the binlog file if any byte where written and signal that the binary log file has been updated if the flush succeeds. </p>

</div>
</div>
<a id="gab2a085c1b3fdcd74c31ba5696bfd9ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2a085c1b3fdcd74c31ba5696bfd9ee4">&#9670;&nbsp;</a></span>flush_thread_caches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, my_off_t &gt; MYSQL_BIN_LOG::flush_thread_caches </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush caches for session.</p>
<dl class="section note"><dt>Note</dt><dd><code>set_trans_pos</code> is called with a pointer to the file name that the binary log currently use and a rotation will change the contents of the variable.</dd></dl>
<p>The position is used when calling the after_flush, after_commit, and after_rollback hooks, but these have been placed so that they occur before a rotation is executed.</p>
<p>It is the responsibility of any plugin that use this position to copy it if they need it after the hook has returned. </p>

</div>
</div>
<a id="ga8072c6b6890022e3919455e77017ab0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8072c6b6890022e3919455e77017ab0d">&#9670;&nbsp;</a></span>gtid_before_write_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int gtid_before_write_cache </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *&#160;</td>
          <td class="paramname"><em>cache_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Move this function into the cache class? </dd></dl>

</div>
</div>
<a id="gaa6d2bcbece5df8c93fe833e0a58f06d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6d2bcbece5df8c93fe833e0a58f06d0">&#9670;&nbsp;</a></span>gtid_empty_group_log_and_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gtid_empty_group_log_and_cleanup </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function logs an empty group with GTID and performs cleanup. Its logic wrt GTID is equivalent to one of <a class="el" href="group___binary___log.html#ga3da95c9d936e5ea3023159e0e2c73d53">binlog_commit()</a>. It's called at the end of statement execution in case <a class="el" href="group___binary___log.html#ga3da95c9d936e5ea3023159e0e2c73d53">binlog_commit()</a> was skipped. Such cases are due ineffective binlogging incl an empty group re-execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if an error pops up. </dd></dl>

</div>
</div>
<a id="ga43ef27d48e9ff7dbc2c0d75f481acbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43ef27d48e9ff7dbc2c0d75f481acbc2">&#9670;&nbsp;</a></span>init_gtid_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::init_gtid_sets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>gtid_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>lost_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_gtid.html">Gtid</a> *&#160;</td>
          <td class="paramname"><em>last_gtid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server_starting</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the set of all GTIDs in the binary log, and the set of all lost GTIDs in the binary log, and stores each set in respective argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gtid_set</td><td>Will be filled with all GTIDs in this binary log. </td></tr>
    <tr><td class="paramname">lost_groups</td><td>Will be filled with all GTIDs in the <a class="el" href="class_previous__gtids__log__event.html">Previous_gtids_log_event</a> of the first binary log that has a <a class="el" href="class_previous__gtids__log__event.html">Previous_gtids_log_event</a>. </td></tr>
    <tr><td class="paramname">last_gtid</td><td>Will be filled with the last availble GTID information in the binary/relay log files. </td></tr>
    <tr><td class="paramname">verify_checksum</td><td>If true, checksums will be checked. </td></tr>
    <tr><td class="paramname">need_lock</td><td>If true, LOCK_log, LOCK_index, and global_sid_lock-&gt;wrlock are acquired; otherwise they are asserted to be taken already. </td></tr>
    <tr><td class="paramname">is_server_starting</td><td>True if the server is starting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error. </dd></dl>

</div>
</div>
<a id="gaac641bdabee70ba4bd377e06e1853fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac641bdabee70ba4bd377e06e1853fcb">&#9670;&nbsp;</a></span>is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::is_active </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_file_name_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if we are writing/reading to the given log file. </p>

</div>
</div>
<a id="ga1d6091ef19ba4fb6819e758344298210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d6091ef19ba4fb6819e758344298210">&#9670;&nbsp;</a></span>log_loaded_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int log_loaded_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load data's io cache specific hook to be executed before a chunk of data is being read into the cache's buffer The fuction instantianates and writes into the binlog replication events along LOAD DATA processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>pointer to io-cache </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">1</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94f694096c1ef28962d9d7936d2d9a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f694096c1ef28962d9d7936d2d9a1e">&#9670;&nbsp;</a></span>make_log_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::make_log_name </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_ident</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new log file name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buf of at least FN_REFLEN where new name is stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If file name will be longer then FN_REFLEN it will be truncated </dd></dl>

</div>
</div>
<a id="gab57cd148796a62181465bb25db0e236c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab57cd148796a62181465bb25db0e236c">&#9670;&nbsp;</a></span>move_crash_safe_index_file_to_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move crash safe index file to index file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">need_lock_index</td><td>If true, LOCK_index will be acquired; otherwise it should already be held.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0490669ea3aef1d30fa41d44079c8cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0490669ea3aef1d30fa41d44079c8cb2">&#9670;&nbsp;</a></span>mysql_show_binlog_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysql_show_binlog_events </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute a SHOW BINLOG EVENTS statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to THD object for the client thread executing the statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>success </td></tr>
    <tr><td class="paramname">TRUE</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4787d8c74f93a27235db912039d3185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4787d8c74f93a27235db912039d3185">&#9670;&nbsp;</a></span>new_file_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::new_file_impl </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *&#160;</td>
          <td class="paramname"><em>extra_description_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start writing to a new log file or reopen the old file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">need_lock_log</td><td>If true, this function acquires LOCK_log; otherwise the caller should already have acquired it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">nonzero</td><td>- error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The new file name is stored last in the index file </dd></dl>

</div>
</div>
<a id="ga44de4e3109fc4d50d4968191ab0f3544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44de4e3109fc4d50d4968191ab0f3544">&#9670;&nbsp;</a></span>open_binlog() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::open_binlog </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>keep in-memory list of prepared transactions (add to list in <a class="el" href="row0log_8cc.html#a800f12bb442b5fb971fb19d203766eb4">log()</a>, remove on unlog()) and copy it to the new binlog if rotated but let's check the behaviour of tc_log_page_waits first! </dd></dl>

</div>
</div>
<a id="ga1eb09393ab56b2ba8a7620cbd4cb34b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eb09393ab56b2ba8a7620cbd4cb34b9">&#9670;&nbsp;</a></span>open_binlog() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::open_binlog </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum cache_type&#160;</td>
          <td class="paramname"><em>io_cache_type_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>max_size_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>null_created_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_sid_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *&#160;</td>
          <td class="paramname"><em>extra_description_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new binary log. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_name</td><td>Name of binlog </td></tr>
    <tr><td class="paramname">new_name</td><td>Name of binlog, too. todo: what's the difference between new_name and log_name? </td></tr>
    <tr><td class="paramname">io_cache_type_arg</td><td>Specifies how the IO cache is opened: read-only or read-write. </td></tr>
    <tr><td class="paramname">max_size</td><td>The size at which this binlog will be rotated. </td></tr>
    <tr><td class="paramname">null_created</td><td>If false, and a <a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> is written, then the <a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> will have the timestamp 0. Otherwise, it the timestamp will be the time when the event was written to the log. </td></tr>
    <tr><td class="paramname">need_lock_index</td><td>If true, LOCK_index is acquired; otherwise LOCK_index must be taken by the caller. </td></tr>
    <tr><td class="paramname">need_sid_lock</td><td>If true, the read lock on global_sid_lock will be acquired. Otherwise, the caller must hold the read lock on global_sid_lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Open a (new) binlog file.</p>
<ul>
<li>Open the log file and the index file. Register the new file name in it</li>
<li>When calling this when the file is in use, you must have a locks on LOCK_log and LOCK_index.</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>: although this was introduced to appease valgrind when injecting emulated faults using fault_injection_registering_index it may be good to consider what actually happens when open_purge_index_file succeeds but register or sync fails.</dd></dl>
<p>Perhaps we might need the code below in MYSQL_LOG_BIN::cleanup for "real life" purposes as well?</p>

</div>
</div>
<a id="ga79ed24f2c1a0645530426f4346470781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79ed24f2c1a0645530426f4346470781">&#9670;&nbsp;</a></span>open_binlog_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">File open_binlog_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a single binary log file for reading. </p>

</div>
</div>
<a id="gac6d69e1ee6b9099429bd919af752a0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6d69e1ee6b9099429bd919af752a0eb">&#9670;&nbsp;</a></span>open_crash_safe_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::open_crash_safe_index_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a (new) crash safe index file.</p>
<dl class="section note"><dt>Note</dt><dd>The crash safe index file is a special file used for guaranteeing index file crash safe. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd6e1e70093afedf97ac7266268db0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd6e1e70093afedf97ac7266268db0fe">&#9670;&nbsp;</a></span>ordered_commit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::ordered_commit </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_commit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush and commit the transaction.</p>
<p>This will execute an ordered flush and commit of all outstanding transactions and is the main function for the binary log group commit logic. The function performs the ordered commit in two phases.</p>
<p>The first phase flushes the caches to the binary log and under LOCK_log and marks all threads that were flushed as not pending.</p>
<p>The second phase executes under LOCK_commit and commits all transactions in order.</p>
<p>The procedure is:</p>
<ol type="1">
<li>Queue ourselves for flushing.</li>
<li>Grab the log lock, which might result is blocking if the mutex is already held by another thread.</li>
<li>If we were not committed while waiting for the lock<ol type="a">
<li>Fetch the queue</li>
<li>For each thread in the queue: a. Attach to it b. Flush the caches, saving any error code</li>
<li>Flush and sync (depending on the value of sync_binlog).</li>
<li>Signal that the binary log was updated</li>
</ol>
</li>
<li>Release the log lock</li>
<li>Grab the commit lock<ol type="a">
<li>For each thread in the queue: a. If there were no error when flushing and the transaction shall be committed:<ul>
<li>Commit the transaction, saving the result of executing the commit.</li>
</ul>
</li>
</ol>
</li>
<li>Release the commit lock</li>
<li>Call purge, if any of the committed thread requested a purge.</li>
<li>Return with the saved error code</li>
</ol>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>The use of <code>skip_commit</code> is a hack that we use since the <code><a class="el" href="class_t_c___l_o_g.html">TC_LOG</a></code> Interface does not contain functions to handle savepoints. Once the binary log is eliminated as a handlerton and the <code><a class="el" href="class_t_c___l_o_g.html">TC_LOG</a></code> interface is extended with savepoint handling, this parameter can be removed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session to commit transaction for </td></tr>
    <tr><td class="paramname">all</td><td>This is <code>true</code> if this is a real transaction commit, and <code>false</code> otherwise. </td></tr>
    <tr><td class="paramname">skip_commit</td><td>This is <code>true</code> if the call to <code>ha_commit_low</code> should be skipped (it is handled by the caller somehow) and <code>false</code> otherwise (the normal case). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4789039161947fff76fa8250b120b7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4789039161947fff76fa8250b120b7e3">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::prepare </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Log a prepare record of the transaction to the storage engines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session to log transaction record for.</td></tr>
    <tr><td class="paramname">all</td><td><code>true</code> if an explicit commit or an implicit commit for a statement, <code>false</code> if an internal commit of the statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code on failure, zero on success. </dd></dl>

<p>Implements <a class="el" href="class_t_c___l_o_g.html#ab968f1e200f370127c3dcd0302d00968">TC_LOG</a>.</p>

</div>
</div>
<a id="ga70155d349962fc0670d9216bb1c5fd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70155d349962fc0670d9216bb1c5fd73">&#9670;&nbsp;</a></span>print_system_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void print_system_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print system time. </p>

</div>
</div>
<a id="gab1b5c7f3024156be25bf9307337d6da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1b5c7f3024156be25bf9307337d6da1">&#9670;&nbsp;</a></span>process_after_commit_stage_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::process_after_commit_stage_queue </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Process after commit for a sequence of sessions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The "master" thread </td></tr>
    <tr><td class="paramname">first</td><td>First thread in the queue of threads to commit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga529497249f578f2883d9eb7d5285b294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga529497249f578f2883d9eb7d5285b294">&#9670;&nbsp;</a></span>process_commit_stage_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::process_commit_stage_queue </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Commit a sequence of sessions.</p>
<p>This function commit an entire queue of sessions starting with the session in <code>first</code>. If there were an error in the flushing part of the ordered commit, the error code is passed in and all the threads are marked accordingly (but not committed).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___binary___log.html#gadd6e1e70093afedf97ac7266268db0fe">MYSQL_BIN_LOG::ordered_commit</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The "master" thread </td></tr>
    <tr><td class="paramname">first</td><td>First thread in the queue of threads to commit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ee4ac7f05b621d323a8c4a9247a6a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ee4ac7f05b621d323a8c4a9247a6a93">&#9670;&nbsp;</a></span>process_flush_stage_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::process_flush_stage_queue </td>
          <td>(</td>
          <td class="paramtype">my_off_t *&#160;</td>
          <td class="paramname"><em>total_bytes_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>rotate_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD **&#160;</td>
          <td class="paramname"><em>out_queue_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute the flush stage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_bytes_var</td><td>Pointer to variable that will be set to total number of bytes flushed, or NULL.</td></tr>
    <tr><td class="paramname">rotate_var</td><td>Pointer to variable that will be set to true if binlog rotation should be performed after releasing locks. If rotate is not necessary, the variable will not be touched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code on error, zero on success </dd></dl>

</div>
</div>
<a id="gaff1889360685bd90b1d3ffba10ba3dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff1889360685bd90b1d3ffba10ba3dba">&#9670;&nbsp;</a></span>purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::purge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method executes logs purging routine.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nonzero</td><td>- error in rotating routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9f15d1126e85d2acca6e06c92ea60f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9f15d1126e85d2acca6e06c92ea60f1">&#9670;&nbsp;</a></span>purge_first_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::purge_first_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_relay__log__info.html">Relay_log_info</a> *&#160;</td>
          <td class="paramname"><em>rli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>included</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete relay log files prior to rli-&gt;group_relay_log_name (i.e. all logs which are not involved in a non-finished group (transaction)), remove them from the index file and start on next relay log.</p>
<p>IMPLEMENTATION</p>
<ul>
<li>You must hold rli-&gt;data_lock before calling this function, since it writes group_relay_log_pos and similar fields of <a class="el" href="class_relay__log__info.html">Relay_log_info</a>.</li>
<li>Protects index file with LOCK_index</li>
<li>Delete relevant relay log files</li>
<li>Copy all file names after these ones to the front of the index file</li>
<li>If the OS has truncate, truncate the file, else fill it with <br />
'</li>
<li>Read the next file name from the index file and store in rli-&gt;linfo</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rli</td><td>Relay log information </td></tr>
    <tr><td class="paramname">included</td><td>If false, all relay logs that are strictly before rli-&gt;group_relay_log_name are deleted ; if true, the latter is deleted too (i.e. all relay logs read by the SQL slave thread are deleted).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This is only called from the slave SQL thread when it has read all commands from a relay log and want to switch to a new relay log.</li>
<li>When this happens, we can be in an active transaction as a transaction can span over two relay logs (although it is always written as a single block to the master's binary log, hence cannot span over two master's binary logs).</li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">LOG_INFO_EOF</td><td>End of log-index-file found </td></tr>
    <tr><td class="paramname">LOG_INFO_SEEK</td><td>Could not allocate IO cache </td></tr>
    <tr><td class="paramname">LOG_INFO_IO</td><td>Got IO error while reading file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e04e209edd9b720574d2a34ed8fc117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e04e209edd9b720574d2a34ed8fc117">&#9670;&nbsp;</a></span>purge_logs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::purge_logs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>included</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_update_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>decrease_log_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_purge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all logs before the given log from disk and from the index file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_log</td><td>Delete all log file name before this file. </td></tr>
    <tr><td class="paramname">included</td><td>If true, to_log is deleted too. </td></tr>
    <tr><td class="paramname">need_lock_index</td><td></td></tr>
    <tr><td class="paramname">need_update_threads</td><td>If we want to update the log coordinates of all threads. False for relay logs, true otherwise. </td></tr>
    <tr><td class="paramname">freed_log_space</td><td>If not null, decrement this variable of the amount of log space freed </td></tr>
    <tr><td class="paramname">auto_purge</td><td>True if this is an automatic purge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If any of the logs before the deleted one is in use, only purge logs up to this one.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">LOG_INFO_EOF</td><td>to_log not found LOG_INFO_EMFILE too many files opened LOG_INFO_FATAL if any other than ENOENT error from <a class="el" href="group___file__instrumentation.html#ga670a5fedb5cc20f70f05e1e6c46af479">mysql_file_stat()</a> or <a class="el" href="group___file__instrumentation.html#ga7de236e28d52a083a5329cd42d4df526">mysql_file_delete()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac126e05bd18fabf135844faef05ff28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac126e05bd18fabf135844faef05ff28c">&#9670;&nbsp;</a></span>purge_logs_before_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::purge_logs_before_date </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>purge_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_purge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all logs before the given file date from disk and from the index file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread pointer </td></tr>
    <tr><td class="paramname">purge_time</td><td>Delete all log files before given date. </td></tr>
    <tr><td class="paramname">auto_purge</td><td>True if this is an automatic purge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If any of the logs before the deleted one is in use, only purge logs up to this one.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">LOG_INFO_PURGE_NO_ROTATE</td><td>Binary file that can't be rotated LOG_INFO_FATAL if any other than ENOENT error from <a class="el" href="group___file__instrumentation.html#ga670a5fedb5cc20f70f05e1e6c46af479">mysql_file_stat()</a> or <a class="el" href="group___file__instrumentation.html#ga7de236e28d52a083a5329cd42d4df526">mysql_file_delete()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f15ff584adebd77fd1bf4ebc88a68b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f15ff584adebd77fd1bf4ebc88a68b6">&#9670;&nbsp;</a></span>purge_master_logs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool purge_master_logs </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute a PURGE BINARY LOGS TO &lt;log&gt; command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to THD object for the client thread executing the statement.</td></tr>
    <tr><td class="paramname">to_log</td><td>Name of the last log to purge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>success </td></tr>
    <tr><td class="paramname">TRUE</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38f8e56905c5205bb8cf6268cd203cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38f8e56905c5205bb8cf6268cd203cb2">&#9670;&nbsp;</a></span>purge_master_logs_before_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool purge_master_logs_before_date </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>purge_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute a PURGE BINARY LOGS BEFORE &lt;date&gt; command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to THD object for the client thread executing the statement.</td></tr>
    <tr><td class="paramname">purge_time</td><td>Date before which logs should be purged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>success </td></tr>
    <tr><td class="paramname">TRUE</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e843aafa062a4ab987d5ff75d450c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e843aafa062a4ab987d5ff75d450c41">&#9670;&nbsp;</a></span>recover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::recover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__io__cache.html">IO_CACHE</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> *&#160;</td>
          <td class="paramname"><em>fdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">my_off_t *&#160;</td>
          <td class="paramname"><em>valid_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MYSQLD server recovers from last crashed binlog.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>IO_CACHE of the crashed binlog. </td></tr>
    <tr><td class="paramname">fdle</td><td><a class="el" href="class_format__description__log__event.html">Format_description_log_event</a> of the crashed binlog. </td></tr>
    <tr><td class="paramname">valid_pos</td><td>The position of the last valid transaction or event(non-transaction) of the crashed binlog.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8453da69cf16851231e33586e8992ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8453da69cf16851231e33586e8992ea4">&#9670;&nbsp;</a></span>remove_logs_from_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::remove_logs_from_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__log__info.html">LOG_INFO</a> *&#160;</td>
          <td class="paramname"><em>log_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_update_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove logs from index file.</p>
<ul>
<li>To make crash safe, we copy the content of index file from index_file_start_offset recored in log_info to crash safe index file firstly and then move the crash safe index file to index file.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linfo</td><td>Store here the found log file name and position to the NEXT log file name in the index file.</td></tr>
    <tr><td class="paramname">need_update_threads</td><td>If we want to update the log coordinates of all threads. False for relay logs, true otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">LOG_INFO_IO</td><td>Got IO error while reading/writing file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga585728a123b2a0b37d5777e79d435ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585728a123b2a0b37d5777e79d435ccc">&#9670;&nbsp;</a></span>reset_logs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::reset_logs </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes files, as part of a RESET MASTER or RESET SLAVE statement, by deleting all logs refered to in the index file. Then, it starts writing to a new log file.</p>
<p>The new index file will only contain this file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If not called from slave thread, write start event to new log</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9590d29210bd03fce1b8f9effc7c2d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9590d29210bd03fce1b8f9effc7c2d2a">&#9670;&nbsp;</a></span>rollback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::rollback </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a rollback record of the transaction to the binary log.</p>
<p>For binary log group commit, the rollback is separated into three parts:</p>
<ol type="1">
<li>First part consists of filling the necessary caches and finalizing them (if they need to be finalized). After a cache is finalized, nothing can be added to the cache.</li>
<li><p class="startli">Second part execute an ordered flush and commit. This will be done using the group commit functionality in <code>ordered_commit</code>.</p>
<p class="startli">Since we roll back the transaction early, we call <code>ordered_commit</code> with the <code>skip_commit</code> flag set. The <code>ha_commit_low</code> call inside <code>ordered_commit</code> will then not be called.</p>
</li>
<li>Third part checks any errors resulting from the flush and handles them appropriately.</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___binary___log.html#gadd6e1e70093afedf97ac7266268db0fe">MYSQL_BIN_LOG::ordered_commit</a> </dd>
<dd>
<a class="el" href="handler_8cc.html#a4a77fdd0e1d6bee79e29e7495c7d752a">ha_commit_low</a> </dd>
<dd>
ha_rollback_low</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session to commit </td></tr>
    <tr><td class="paramname">all</td><td>This is <code>true</code> if this is a real transaction rollback, and  otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code, or zero if there were no error. </dd></dl>

<p>Implements <a class="el" href="class_t_c___l_o_g.html#abf637f1bbf02c6f8e4f69aa2f5e2d362">TC_LOG</a>.</p>

</div>
</div>
<a id="ga2053b0b53a46eb5702b44966497c333f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2053b0b53a46eb5702b44966497c333f">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::rotate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_rotate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>check_purge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method executes rotation when LOCK_log is already acquired by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force_rotate</td><td>caller can request the log rotation </td></tr>
    <tr><td class="paramname">check_purge</td><td>is set to true if rotation took place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If rotation fails, for instance the server was unable to create a new log file, we still try to write an incident event to the current log.</dd>
<dd>
The caller must hold LOCK_log when invoking this function.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nonzero</td><td>- error in rotating routine. </td></tr>
  </table>
  </dd>
</dl>
<p>Be conservative... There are possible lost events (eg, failing to log the <a class="el" href="class_execute__load__query__log__event.html">Execute_load_query_log_event</a> on a LOAD DATA while using a non-transactional table)!</p>
<p>We give it a shot and try to write an incident event anyway to the current log.</p>

</div>
</div>
<a id="ga9f41b228c438fe7b4c710b8fdd780cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f41b228c438fe7b4c710b8fdd780cfb">&#9670;&nbsp;</a></span>rotate_and_purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::rotate_and_purge </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_rotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method is a shortcut of <code><a class="el" href="group___binary___log.html#ga2053b0b53a46eb5702b44966497c333f">rotate()</a></code> and <code><a class="el" href="group___binary___log.html#gaff1889360685bd90b1d3ffba10ba3dba">purge()</a></code>. LOCK_log is acquired prior to rotate and is released after it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force_rotate</td><td>caller can request the log rotation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nonzero</td><td>- error in rotating routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5bbd66f9464d9a83f33fdcdba20d7d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bbd66f9464d9a83f33fdcdba20d7d99">&#9670;&nbsp;</a></span>set_crash_safe_index_file_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::set_crash_safe_index_file_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the name of crash safe index file.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07a668f531f059316c8f17dfcecfd465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07a668f531f059316c8f17dfcecfd465">&#9670;&nbsp;</a></span>stmt_cannot_safely_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stmt_cannot_safely_rollback </td>
          <td>(</td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks if current statement cannot be rollded back safely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if cannot be safely rolled back, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga0db7290468d8e62cd647323a0e9b5061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db7290468d8e62cd647323a0e9b5061">&#9670;&nbsp;</a></span>stmt_has_updated_trans_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stmt_has_updated_trans_table </td>
          <td>(</td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks if a transactional table was updated by the current statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a transactional table was updated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga7a1391801107de083a2914147c8b9a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a1391801107de083a2914147c8b9a67">&#9670;&nbsp;</a></span>sync_binlog_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, bool &gt; MYSQL_BIN_LOG::sync_binlog_file </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call fsync() to sync the file to disk. </p>

</div>
</div>
<a id="ga1d647f955254c565dc33abf8caabdbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d647f955254c565dc33abf8caabdbab">&#9670;&nbsp;</a></span>trans_cannot_safely_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trans_cannot_safely_rollback </td>
          <td>(</td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks if a transaction cannot be rolled back safely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if cannot be safely rolled back, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga25239dc38f22eeef6e1aea243af6fd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25239dc38f22eeef6e1aea243af6fd9a">&#9670;&nbsp;</a></span>trans_has_updated_trans_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trans_has_updated_trans_table </td>
          <td>(</td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks if a transactional table was updated by the current transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a transactional table was updated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gae0d03425fee2a702a9b4dfac7b9de4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d03425fee2a702a9b4dfac7b9de4b1">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binlog_trx_cache_data::truncate </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function truncates the transactional cache upon committing or rolling back either a transaction or a statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread whose transaction should be flushed </td></tr>
    <tr><td class="paramname">cache_mngr</td><td>Pointer to the cache data to be flushed </td></tr>
    <tr><td class="paramname">all</td><td><code>true</code> means truncate the transaction, otherwise the statement must be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if an error pops up when truncating the transactional cache. </dd></dl>

</div>
</div>
<a id="ga1b625b440aaf82241200b3980d94c6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b625b440aaf82241200b3980d94c6a9">&#9670;&nbsp;</a></span>wait_for_update_bin_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::wait_for_update_bin_log </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtimespec.html">timespec</a> *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until we get a signal that the binary log has been updated. Applies to master only.</p>
<p>NOTES </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>a THD struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>a pointer to a timespec; NULL means to wait w/o timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if got signalled on update </td></tr>
    <tr><td class="paramname">non-0</td><td>if wait timeout elapsed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>LOCK_log must be taken before calling this function. LOCK_log is being released while the thread is waiting. LOCK_log is released by the caller. </dd></dl>

</div>
</div>
<a id="ga10698ebc9afd7be839f7a69b7aaac141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10698ebc9afd7be839f7a69b7aaac141">&#9670;&nbsp;</a></span>wait_for_update_relay_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::wait_for_update_relay_log </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtimespec.html">timespec</a> *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until we get a signal that the relay log has been updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>a pointer to a timespec; NULL means to wait w/o timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if got signalled on update </td></tr>
    <tr><td class="paramname">non-0</td><td>if wait timeout elapsed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>One must have a lock on LOCK_log before calling this function. </dd></dl>

</div>
</div>
<a id="gac9dbdae7075b4f8bdef3b78d411d6481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9dbdae7075b4f8bdef3b78d411d6481">&#9670;&nbsp;</a></span>write_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_cache </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *&#160;</td>
          <td class="paramname"><em>binlog_cache_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a cached log entry to the binary log.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread variable </td></tr>
    <tr><td class="paramname">cache</td><td>The cache to copy to the binlog </td></tr>
    <tr><td class="paramname">incident</td><td>Defines if an incident event should be created to notify that some non-transactional changes did not get into the binlog. </td></tr>
    <tr><td class="paramname">prepared</td><td>Defines if a transaction is part of a 2-PC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We only come here if there is something in the cache. </dd>
<dd>
The thing in the cache is always a complete transaction. </dd>
<dd>
'cache' needs to be reinitialized after this functions returns. </dd></dl>

</div>
</div>
<a id="ga3d85906608487be3c3ee20ae8bb0f9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d85906608487be3c3ee20ae8bb0f9e3">&#9670;&nbsp;</a></span>write_empty_groups_to_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int write_empty_groups_to_cache </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *&#160;</td>
          <td class="paramname"><em>cache_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes all GTIDs that the thread owns to the stmt/trx cache, if the GTID is not already in the cache.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Move this function into the cache class?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD object for the thread that owns the cache. </td></tr>
    <tr><td class="paramname">cache_data</td><td>The cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c19cd666a1a517386dedd4078dd93e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c19cd666a1a517386dedd4078dd93e7">&#9670;&nbsp;</a></span>write_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_log__event.html">Log_event</a> *&#160;</td>
          <td class="paramname"><em>event_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write an event to the binary log. </p>

</div>
</div>
<a id="gac6023a97a6c19c5e160f9dd975136474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6023a97a6c19c5e160f9dd975136474">&#9670;&nbsp;</a></span>write_incident() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_incident </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_flush_and_sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an incident event and writes it to the binary log.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread variable </td></tr>
    <tr><td class="paramname">ev</td><td>Incident event to be written </td></tr>
    <tr><td class="paramname">lock</td><td>If the binary lock should be locked or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>error </td></tr>
    <tr><td class="paramname">1</td><td>success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaecc977a50e24a4f1e144d056689a645a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecc977a50e24a4f1e144d056689a645a">&#9670;&nbsp;</a></span>write_incident() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_incident </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_incident__log__event.html">Incident_log_event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_flush_and_sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes an incident event to the binary log.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>Incident event to be written </td></tr>
    <tr><td class="paramname">need_lock_log</td><td>If true, will acquire LOCK_log; otherwise the caller should already have acquired LOCK_log.  If true, will call <a class="el" href="group___binary___log.html#gae40c4dc6b0b8986a50661b28df3a6fa3">flush_and_sync()</a>, <a class="el" href="group___binary___log.html#ga2053b0b53a46eb5702b44966497c333f">rotate()</a> and <a class="el" href="group___binary___log.html#gaff1889360685bd90b1d3ffba10ba3dba">purge()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>error </td></tr>
    <tr><td class="paramname">true</td><td>success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2545b9865ecf8c97d82d10e7ea857d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2545b9865ecf8c97d82d10e7ea857d1">&#9670;&nbsp;</a></span>write_one_empty_group_to_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int write_one_empty_group_to_cache </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *&#160;</td>
          <td class="paramname"><em>cache_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_gtid.html">Gtid</a>&#160;</td>
          <td class="paramname"><em>gtid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given GTID exists in the <a class="el" href="class_group__cache.html">Group_cache</a>. If not, add it as an empty group.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Move this function into the cache class?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD object that owns the <a class="el" href="class_group__cache.html">Group_cache</a> </td></tr>
    <tr><td class="paramname">cache_data</td><td><a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> object for the cache </td></tr>
    <tr><td class="paramname">gtid</td><td>GTID to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaf6ecc9c0253b423bc48289c779e9c010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ecc9c0253b423bc48289c779e9c010">&#9670;&nbsp;</a></span>binlog_storage_engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structst__mysql__storage__engine.html">st_mysql_storage_engine</a> binlog_storage_engine</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{ MYSQL_HANDLERTON_INTERFACE_VERSION }</div></div><!-- fragment -->
</div>
</div>
<a id="gaaac494267a37cf670b0219ce23ef63e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaac494267a37cf670b0219ce23ef63e3">&#9670;&nbsp;</a></span>g_stage_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* g_stage_name[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">  <span class="stringliteral">&quot;FLUSH&quot;</span>,</div><div class="line">  <span class="stringliteral">&quot;SYNC&quot;</span>,</div><div class="line">  <span class="stringliteral">&quot;COMMIT&quot;</span>,</div><div class="line">}</div></div><!-- fragment --><p>Names for the stages. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

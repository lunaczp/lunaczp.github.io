<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/rem/rem0cmp.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_14327b2b3dfe3c7977184a0f4c16a29d.html">rem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rem0cmp.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="handler0alter_8h_source.html">handler0alter.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6989690f2f2ed312474d167b6cbf6f4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a6989690f2f2ed312474d167b6cbf6f4b">innobase_mysql_cmp</a> (int mysql_type, uint charset_number, const unsigned char *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, unsigned int a_length, const unsigned char *<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, unsigned int b_length)</td></tr>
<tr class="separator:a6989690f2f2ed312474d167b6cbf6f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1e4e0db0c9d7a5d77ac2ce108cc3e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#aba1e4e0db0c9d7a5d77ac2ce108cc3e1">innobase_mysql_cmp_prefix</a> (int mysql_type, uint charset_number, const unsigned char *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, unsigned int a_length, const unsigned char *<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, unsigned int b_length)</td></tr>
<tr class="separator:aba1e4e0db0c9d7a5d77ac2ce108cc3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1919aa3eae2935c32de596e0d081a284"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a1919aa3eae2935c32de596e0d081a284">cmp_collate</a> (ulint code)</td></tr>
<tr class="separator:a1919aa3eae2935c32de596e0d081a284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316d726c7bf00d498126ad993d219bb5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a316d726c7bf00d498126ad993d219bb5">cmp_cols_are_equal</a> (const <a class="el" href="structdict__col__t.html">dict_col_t</a> *col1, const <a class="el" href="structdict__col__t.html">dict_col_t</a> *col2, ibool <a class="el" href="dict0load_8cc.html#a3fac4efac7823b3e26c17321965b0abe">check_charsets</a>)</td></tr>
<tr class="separator:a316d726c7bf00d498126ad993d219bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f63fb4f74b6e7de9cabaa736cc1162"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a85f63fb4f74b6e7de9cabaa736cc1162">cmp_whole_field</a> (ulint mtype, ulint prtype, const byte *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, unsigned int a_length, const byte *<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, unsigned int b_length)</td></tr>
<tr class="separator:a85f63fb4f74b6e7de9cabaa736cc1162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bd0af9d92c8b181d18ca8a9150010d"><td class="memItemLeft" align="right" valign="top"><a id="a71bd0af9d92c8b181d18ca8a9150010d"></a>
UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_dfield_dfield_like_prefix</b> (<a class="el" href="structdfield__t.html">dfield_t</a> *dfield1, <a class="el" href="structdfield__t.html">dfield_t</a> *dfield2)</td></tr>
<tr class="separator:a71bd0af9d92c8b181d18ca8a9150010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422260c380ab6a686f20826a98a23dfd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a422260c380ab6a686f20826a98a23dfd">cmp_data_data_slow</a> (ulint mtype, ulint prtype, const byte *data1, ulint len1, const byte *data2, ulint len2)</td></tr>
<tr class="separator:a422260c380ab6a686f20826a98a23dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcc048d13591d01a74f82a682f17a2f"><td class="memItemLeft" align="right" valign="top"><a id="a3dcc048d13591d01a74f82a682f17a2f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_data_data_slow_varchar</b> (const byte *lhs, ulint lhs_len, const byte *rhs, ulint rhs_len)</td></tr>
<tr class="separator:a3dcc048d13591d01a74f82a682f17a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8696769d9c00fb4d6bf2f7ada9536bfd"><td class="memItemLeft" align="right" valign="top"><a id="a8696769d9c00fb4d6bf2f7ada9536bfd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_data_data_slow_like_prefix</b> (const byte *lhs, ulint len1, const byte *rhs, ulint len2)</td></tr>
<tr class="separator:a8696769d9c00fb4d6bf2f7ada9536bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6b27ae12870d661577595db43c09b0"><td class="memItemLeft" align="right" valign="top"><a id="aca6b27ae12870d661577595db43c09b0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_data_data_slow_like_suffix</b> (const byte *data1 UNIV_UNUSED, ulint len1 UNIV_UNUSED, const byte *data2 UNIV_UNUSED, ulint len2 UNIV_UNUSED)</td></tr>
<tr class="separator:aca6b27ae12870d661577595db43c09b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6431ac517af9b5ce89bc52b9198a4aa"><td class="memItemLeft" align="right" valign="top"><a id="af6431ac517af9b5ce89bc52b9198a4aa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_data_data_slow_like_substr</b> (const byte *data1 UNIV_UNUSED, ulint len1 UNIV_UNUSED, const byte *data2 UNIV_UNUSED, ulint len2 UNIV_UNUSED)</td></tr>
<tr class="separator:af6431ac517af9b5ce89bc52b9198a4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf161f25561127b8802aef1002056c6d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#adf161f25561127b8802aef1002056c6d">cmp_dtuple_rec_with_match_low</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *dtuple, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint n_cmp, ulint *matched_fields, ulint *matched_bytes)</td></tr>
<tr class="separator:adf161f25561127b8802aef1002056c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1f4cb7795cc69202a686c7df3e0899"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#abb1f4cb7795cc69202a686c7df3e0899">cmp_dtuple_rec</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *dtuple, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:abb1f4cb7795cc69202a686c7df3e0899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3424e39d698a8a0cfc1239cba151142"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#ac3424e39d698a8a0cfc1239cba151142">cmp_dtuple_is_prefix_of_rec</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *dtuple, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:ac3424e39d698a8a0cfc1239cba151142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135b13662db6ba71f4c5020992be6f37"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a135b13662db6ba71f4c5020992be6f37">__attribute__</a> ((nonnull, warn_unused_result)) int cmp_rec_rec_simple_field(const rec_t *rec1</td></tr>
<tr class="separator:a135b13662db6ba71f4c5020992be6f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f33fe62f73759c57058c14b6c1c047"><td class="memItemLeft" align="right" valign="top"><a id="ad8f33fe62f73759c57058c14b6c1c047"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (!<a class="el" href="rem0rec_8h.html#a6e9de4805c43ce39725f863c3ba05a52">rec_offs_nth_extern</a>(<a class="el" href="rem0cmp_8cc.html#a71d198eced29f8a0bf32fe7984d24f18">offsets1</a>, <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>))</td></tr>
<tr class="separator:ad8f33fe62f73759c57058c14b6c1c047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611773c6e9a557510315a86f5b93d035"><td class="memItemLeft" align="right" valign="top"><a id="a611773c6e9a557510315a86f5b93d035"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (!<a class="el" href="rem0rec_8h.html#a6e9de4805c43ce39725f863c3ba05a52">rec_offs_nth_extern</a>(<a class="el" href="rem0cmp_8cc.html#aa5aa65b1aea265428fb8c392a643adc1">offsets2</a>, <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>))</td></tr>
<tr class="separator:a611773c6e9a557510315a86f5b93d035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727092ae77ffde4ee03415991c20ca03"><td class="memItemLeft" align="right" valign="top"><a id="a727092ae77ffde4ee03415991c20ca03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (rec1_f_len==UNIV_SQL_NULL||rec2_f_len==UNIV_SQL_NULL)</td></tr>
<tr class="separator:a727092ae77ffde4ee03415991c20ca03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8102e04ab0ad72059c77dd29153cabf0"><td class="memItemLeft" align="right" valign="top"><a id="a8102e04ab0ad72059c77dd29153cabf0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (col-&gt;mtype &gt;=DATA_FLOAT||(col-&gt;mtype==DATA_BLOB &amp;&amp;!(col-&gt;prtype &amp;DATA_BINARY_TYPE) &amp;&amp;<a class="el" href="data0type_8h.html#a8ac81464f1bd3fae8e2799ad604acfff">dtype_get_charset_coll</a>(col-&gt;prtype) !=DATA_MYSQL_LATIN1_SWEDISH_CHARSET_COLL))</td></tr>
<tr class="separator:a8102e04ab0ad72059c77dd29153cabf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588fd93a1b23744019d688a2edaf6fd2"><td class="memItemLeft" align="right" valign="top"><a id="a588fd93a1b23744019d688a2edaf6fd2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (ulint cur_bytes=0;;cur_bytes++, rec1_b_ptr++, rec2_b_ptr++)</td></tr>
<tr class="separator:a588fd93a1b23744019d688a2edaf6fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec8b73aa5f6e77b9cb4cb05714f3ec7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a1ec8b73aa5f6e77b9cb4cb05714f3ec7">cmp_rec_rec_simple</a> (const rec_t *rec1, const rec_t *<a class="el" href="rem0cmp_8cc.html#aa8e8b75d129ba2c89a078148118c155c">rec2</a>, const ulint *<a class="el" href="rem0cmp_8cc.html#a71d198eced29f8a0bf32fe7984d24f18">offsets1</a>, const ulint *<a class="el" href="rem0cmp_8cc.html#aa5aa65b1aea265428fb8c392a643adc1">offsets2</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, struct <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a1ec8b73aa5f6e77b9cb4cb05714f3ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b38439ecf1948d959188524aa3a30e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a20b38439ecf1948d959188524aa3a30e">cmp_rec_rec_with_match</a> (const rec_t *rec1, const rec_t *<a class="el" href="rem0cmp_8cc.html#aa8e8b75d129ba2c89a078148118c155c">rec2</a>, const ulint *<a class="el" href="rem0cmp_8cc.html#a71d198eced29f8a0bf32fe7984d24f18">offsets1</a>, const ulint *<a class="el" href="rem0cmp_8cc.html#aa5aa65b1aea265428fb8c392a643adc1">offsets2</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ibool nulls_unequal, ulint *matched_fields, ulint *matched_bytes)</td></tr>
<tr class="separator:a20b38439ecf1948d959188524aa3a30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa8e8b75d129ba2c89a078148118c155c"><td class="memItemLeft" align="right" valign="top">static const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#aa8e8b75d129ba2c89a078148118c155c">rec2</a></td></tr>
<tr class="separator:aa8e8b75d129ba2c89a078148118c155c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d198eced29f8a0bf32fe7984d24f18"><td class="memItemLeft" align="right" valign="top">static const rec_t const ulint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a71d198eced29f8a0bf32fe7984d24f18">offsets1</a></td></tr>
<tr class="separator:a71d198eced29f8a0bf32fe7984d24f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5aa65b1aea265428fb8c392a643adc1"><td class="memItemLeft" align="right" valign="top">static const rec_t const ulint const ulint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#aa5aa65b1aea265428fb8c392a643adc1">offsets2</a></td></tr>
<tr class="separator:aa5aa65b1aea265428fb8c392a643adc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959a93e068c526d1424bdd21f0c8617c"><td class="memItemLeft" align="right" valign="top">static const rec_t const ulint const ulint const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#a959a93e068c526d1424bdd21f0c8617c">index</a></td></tr>
<tr class="separator:a959a93e068c526d1424bdd21f0c8617c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf63825de21da8cc15933ed25c7966d5"><td class="memItemLeft" align="right" valign="top">static const rec_t const ulint const ulint const <a class="el" href="structdict__index__t.html">dict_index_t</a> ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rem0cmp_8cc.html#aaf63825de21da8cc15933ed25c7966d5">n</a></td></tr>
<tr class="separator:aaf63825de21da8cc15933ed25c7966d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d3cb138e283733c6e7975f91550eea"><td class="memItemLeft" align="right" valign="top"><a id="a88d3cb138e283733c6e7975f91550eea"></a>
const byte *&#160;</td><td class="memItemRight" valign="bottom"><b>rec2_b_ptr</b> = rec_get_nth_field(<a class="el" href="rem0cmp_8cc.html#aa8e8b75d129ba2c89a078148118c155c">rec2</a>, <a class="el" href="rem0cmp_8cc.html#aa5aa65b1aea265428fb8c392a643adc1">offsets2</a>, <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, &amp;rec2_f_len)</td></tr>
<tr class="separator:a88d3cb138e283733c6e7975f91550eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1f88035f59b76483089eb3682191e4"><td class="memItemLeft" align="right" valign="top"><a id="a5a1f88035f59b76483089eb3682191e4"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>rec1_f_len</b></td></tr>
<tr class="separator:a5a1f88035f59b76483089eb3682191e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e288a2bf0111e81eda8a085d48f3999"><td class="memItemLeft" align="right" valign="top"><a id="a3e288a2bf0111e81eda8a085d48f3999"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>rec2_f_len</b></td></tr>
<tr class="separator:a3e288a2bf0111e81eda8a085d48f3999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6866730506473b9147f555b4df687e95"><td class="memItemLeft" align="right" valign="top"><a id="a6866730506473b9147f555b4df687e95"></a>
const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>col</b> = <a class="el" href="dict0dict_8h.html#a9019f37f41a28c0284fe6751e73b44ab">dict_index_get_nth_col</a>(<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:a6866730506473b9147f555b4df687e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a036a90b0347d5034165963e0ca47f"><td class="memItemLeft" align="right" valign="top"><a id="ac7a036a90b0347d5034165963e0ca47f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rec1_b_ptr</b> = rec_get_nth_field(rec1, <a class="el" href="rem0cmp_8cc.html#a71d198eced29f8a0bf32fe7984d24f18">offsets1</a>, <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, &amp;rec1_f_len)</td></tr>
<tr class="separator:ac7a036a90b0347d5034165963e0ca47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Comparison services for records</p>
<p>Created 7/1/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a135b13662db6ba71f4c5020992be6f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135b13662db6ba71f4c5020992be6f37">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull, warn_unused_result)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two physical record fields. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if rec1 field is greater than rec2 </td></tr>
    <tr><td class="paramname">-1</td><td>if rec1 field is less than rec2 </td></tr>
    <tr><td class="paramname">0</td><td>if rec1 field equals to rec2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1919aa3eae2935c32de596e0d081a284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1919aa3eae2935c32de596e0d081a284">&#9670;&nbsp;</a></span>cmp_collate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint cmp_collate </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the character code so that it is ordered appropriately for the language. This is only used for the latin1 char set. MySQL does the comparisons for other char sets. </p><dl class="section return"><dt>Returns</dt><dd>collation order position </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>in: code of a character stored in database record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a316d726c7bf00d498126ad993d219bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316d726c7bf00d498126ad993d219bb5">&#9670;&nbsp;</a></span>cmp_cols_are_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool cmp_cols_are_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>col2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>check_charsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if two columns are equal for comparison purposes. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the columns are considered equal in comparisons </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col1</td><td>in: column 1 </td></tr>
    <tr><td class="paramname">col2</td><td>in: column 2 </td></tr>
    <tr><td class="paramname">check_charsets</td><td>in: whether to check charsets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a422260c380ab6a686f20826a98a23dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422260c380ab6a686f20826a98a23dfd">&#9670;&nbsp;</a></span>cmp_data_data_slow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int cmp_data_data_slow </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>prtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to compare two data fields for which we know the data type. </p><dl class="section return"><dt>Returns</dt><dd>1, 0, -1, if data1 is greater, equal, less than data2, respectively </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtype</td><td>in: main type </td></tr>
    <tr><td class="paramname">prtype</td><td>in: precise type </td></tr>
    <tr><td class="paramname">data1</td><td>in: data field (== a pointer to a memory buffer) </td></tr>
    <tr><td class="paramname">len1</td><td>in: data field length or UNIV_SQL_NULL </td></tr>
    <tr><td class="paramname">data2</td><td>in: data field (== a pointer to a memory buffer) </td></tr>
    <tr><td class="paramname">len2</td><td>in: data field length or UNIV_SQL_NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3424e39d698a8a0cfc1239cba151142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3424e39d698a8a0cfc1239cba151142">&#9670;&nbsp;</a></span>cmp_dtuple_is_prefix_of_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool cmp_dtuple_is_prefix_of_rec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>dtuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a dtuple is a prefix of a record. The last field in dtuple is allowed to be a prefix of the corresponding field in the record. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if prefix </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtuple</td><td>in: data tuple </td></tr>
    <tr><td class="paramname">rec</td><td>in: physical record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb1f4cb7795cc69202a686c7df3e0899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1f4cb7795cc69202a686c7df3e0899">&#9670;&nbsp;</a></span>cmp_dtuple_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int cmp_dtuple_rec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>dtuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares a data tuple to a physical record. </p><dl class="section see"><dt>See also</dt><dd>cmp_dtuple_rec_with_match </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>1, 0, -1, if dtuple is greater, equal, less than rec, respectively </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtuple</td><td>in: data tuple </td></tr>
    <tr><td class="paramname">rec</td><td>in: physical record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf161f25561127b8802aef1002056c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf161f25561127b8802aef1002056c6d">&#9670;&nbsp;</a></span>cmp_dtuple_rec_with_match_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int cmp_dtuple_rec_with_match_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>dtuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>matched_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>matched_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to compare a data tuple to a physical record. Only dtuple-&gt;n_fields_cmp first fields are taken into account for the data tuple! If we denote by n = n_fields_cmp, then rec must have either m &gt;= n fields, or it must differ from dtuple in some of the m fields rec has. If rec has an externally stored field we do not compare it but return with value 0 if such a comparison should be made. </p><dl class="section return"><dt>Returns</dt><dd>1, 0, -1, if dtuple is greater, equal, less than rec, respectively, when only the common first fields are compared, or until the first externally stored field in rec </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtuple</td><td>in: data tuple </td></tr>
    <tr><td class="paramname">rec</td><td>in: physical record which differs from dtuple in some of the common fields, or which has an equal number or more fields than dtuple </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">n_cmp</td><td>in: number of fields to compare </td></tr>
    <tr><td class="paramname">matched_fields</td><td>in/out: number of already completely matched fields; when function returns, contains the value for current comparison </td></tr>
    <tr><td class="paramname">matched_bytes</td><td>in/out: number of already matched bytes within the first field not completely matched; when function returns, contains the value for current comparison </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ec8b73aa5f6e77b9cb4cb05714f3ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec8b73aa5f6e77b9cb4cb05714f3ec7">&#9670;&nbsp;</a></span>cmp_rec_rec_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int cmp_rec_rec_simple </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two physical records that contain the same number of columns, none of which are stored externally. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if rec1 (including non-ordering columns) is greater than rec2 </td></tr>
    <tr><td class="paramname">-1</td><td>if rec1 (including non-ordering columns) is less than rec2 </td></tr>
    <tr><td class="paramname">0</td><td>if rec1 is a duplicate of rec2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec1</td><td>in: physical record </td></tr>
    <tr><td class="paramname">rec2</td><td>in: physical record </td></tr>
    <tr><td class="paramname">offsets1</td><td>in: rec_get_offsets(rec1, ...) </td></tr>
    <tr><td class="paramname">offsets2</td><td>in: rec_get_offsets(rec2, ...) </td></tr>
    <tr><td class="paramname">index</td><td>in: data dictionary index </td></tr>
    <tr><td class="paramname">table</td><td>in: MySQL table, for reporting duplicate key value if applicable, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b38439ecf1948d959188524aa3a30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b38439ecf1948d959188524aa3a30e">&#9670;&nbsp;</a></span>cmp_rec_rec_with_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int cmp_rec_rec_with_match </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>nulls_unequal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>matched_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>matched_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to compare two physical records. Only the common first fields are compared, and if an externally stored field is encountered, then 0 is returned. </p><dl class="section return"><dt>Returns</dt><dd>1, 0, -1 if rec1 is greater, equal, less, respectively </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec1</td><td>in: physical record </td></tr>
    <tr><td class="paramname">rec2</td><td>in: physical record </td></tr>
    <tr><td class="paramname">offsets1</td><td>in: rec_get_offsets(rec1, index) </td></tr>
    <tr><td class="paramname">offsets2</td><td>in: rec_get_offsets(rec2, index) </td></tr>
    <tr><td class="paramname">index</td><td>in: data dictionary index </td></tr>
    <tr><td class="paramname">matched_fields</td><td>in/out: number of already completely matched fields; when the function returns, contains the value the for current comparison </td></tr>
    <tr><td class="paramname">matched_bytes</td><td>in/out: number of already matched bytes within the first field not completely matched; when the function returns, contains the value for the current comparison </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85f63fb4f74b6e7de9cabaa736cc1162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f63fb4f74b6e7de9cabaa736cc1162">&#9670;&nbsp;</a></span>cmp_whole_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cmp_whole_field </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>prtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Innobase uses this function to compare two data fields for which the data type is such that we must compare whole fields or call MySQL to do the comparison </p><dl class="section return"><dt>Returns</dt><dd>1, 0, -1, if a is greater, equal, less than b, respectively </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtype</td><td>in: main type </td></tr>
    <tr><td class="paramname">prtype</td><td>in: precise type </td></tr>
    <tr><td class="paramname">a</td><td>in: data field </td></tr>
    <tr><td class="paramname">a_length</td><td>in: data field length, not UNIV_SQL_NULL </td></tr>
    <tr><td class="paramname">b</td><td>in: data field </td></tr>
    <tr><td class="paramname">b_length</td><td>in: data field length, not UNIV_SQL_NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6989690f2f2ed312474d167b6cbf6f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6989690f2f2ed312474d167b6cbf6f4b">&#9670;&nbsp;</a></span>innobase_mysql_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int innobase_mysql_cmp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mysql_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>charset_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to compare two data fields for which the data type is such that we must use MySQL code to compare them. The prototype here must be a copy of the one in ha_innobase.cc! </p><dl class="section return"><dt>Returns</dt><dd>1, 0, -1, if a is greater, equal, less than b, respectively in: data field length, not UNIV_SQL_NULL</dd></dl>
<p>InnoDB uses this function to compare two data fields for which the data type is such that we must use MySQL code to compare them. NOTE that the prototype of this function is in <a class="el" href="rem0cmp_8cc.html">rem0cmp.cc</a> in InnoDB source code! If you change this function, remember to update the prototype there! </p><dl class="section return"><dt>Returns</dt><dd>1, 0, -1, if a is greater, equal, less than b, respectively</dd></dl>
<p>InnoDB uses this function to compare two data fields for which the data type is such that we must use MySQL code to compare them. </p><dl class="section return"><dt>Returns</dt><dd>1, 0, -1, if a is greater, equal, less than b, respectively </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mysql_type</td><td>in: MySQL type </td></tr>
    <tr><td class="paramname">charset_number</td><td>in: number of the charset </td></tr>
    <tr><td class="paramname">a</td><td>in: data field </td></tr>
    <tr><td class="paramname">a_length</td><td>in: data field length, not UNIV_SQL_NULL </td></tr>
    <tr><td class="paramname">b</td><td>in: data field </td></tr>
    <tr><td class="paramname">b_length</td><td>in: data field length, not UNIV_SQL_NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba1e4e0db0c9d7a5d77ac2ce108cc3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1e4e0db0c9d7a5d77ac2ce108cc3e1">&#9670;&nbsp;</a></span>innobase_mysql_cmp_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int innobase_mysql_cmp_prefix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mysql_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>charset_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to compare two data fields for which the data type is such that we must use MySQL code to compare them. The prototype here must be a copy of the one in ha_innobase.cc! </p><dl class="section return"><dt>Returns</dt><dd>1, 0, -1, if a is greater, equal, less than b, respectively in: data field length, not UNIV_SQL_NULL</dd></dl>
<p>InnoDB uses this function to compare two data fields for which the data type is such that we must use MySQL code to compare them. NOTE that the prototype of this function is in rem0cmp.c in InnoDB source code! If you change this function, remember to update the prototype there! </p><dl class="section return"><dt>Returns</dt><dd>1, 0, -1, if a is greater, equal, less than b, respectively </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mysql_type</td><td>in: MySQL type </td></tr>
    <tr><td class="paramname">charset_number</td><td>in: number of the charset </td></tr>
    <tr><td class="paramname">a</td><td>in: data field </td></tr>
    <tr><td class="paramname">a_length</td><td>in: data field length, not UNIV_SQL_NULL </td></tr>
    <tr><td class="paramname">b</td><td>in: data field </td></tr>
    <tr><td class="paramname">b_length</td><td>in: data field length, not UNIV_SQL_NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a959a93e068c526d1424bdd21f0c8617c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959a93e068c526d1424bdd21f0c8617c">&#9670;&nbsp;</a></span>index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t const ulint const ulint const <a class="el" href="structdict__index__t.html">dict_index_t</a>* index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: data dictionary index </p>

</div>
</div>
<a id="aaf63825de21da8cc15933ed25c7966d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf63825de21da8cc15933ed25c7966d5">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t const ulint const ulint const <a class="el" href="structdict__index__t.html">dict_index_t</a> ulint n</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <span class="keyword">const</span> byte*     rec1_b_ptr</div></div><!-- fragment --><p>&lt; in: field to compare </p>

</div>
</div>
<a id="a71d198eced29f8a0bf32fe7984d24f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d198eced29f8a0bf32fe7984d24f18">&#9670;&nbsp;</a></span>offsets1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint * offsets1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: rec_get_offsets(rec1, ...) </p>

</div>
</div>
<a id="aa5aa65b1aea265428fb8c392a643adc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5aa65b1aea265428fb8c392a643adc1">&#9670;&nbsp;</a></span>offsets2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t const ulint const ulint* offsets2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: rec_get_offsets(rec2, ...) </p>

</div>
</div>
<a id="aa8e8b75d129ba2c89a078148118c155c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e8b75d129ba2c89a078148118c155c">&#9670;&nbsp;</a></span>rec2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t* rec2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: physical record in: physical record </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

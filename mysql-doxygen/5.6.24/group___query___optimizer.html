<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Query Optimizer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query Optimizer</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_o_n_d___c_m_p.html">COND_CMP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_key__field.html">Key_field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used when finding key fields.  <a href="struct_key__field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_plan__change__watchdog.html">Plan_change_watchdog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga58297bde0da4187801e718c29d5d6b5e"><td class="memItemLeft" align="right" valign="top"><a id="ga58297bde0da4187801e718c29d5d6b5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KEY_OPTIMIZE_EXISTS</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga58297bde0da4187801e718c29d5d6b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0658a5d9673135da1c2f6463f0537405"><td class="memItemLeft" align="right" valign="top"><a id="ga0658a5d9673135da1c2f6463f0537405"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KEY_OPTIMIZE_REF_OR_NULL</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga0658a5d9673135da1c2f6463f0537405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8976c581bb885405f6b19a1753e6e6dd"><td class="memItemLeft" align="right" valign="top"><a id="ga8976c581bb885405f6b19a1753e6e6dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ICP_COND_USES_INDEX_ONLY</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ga8976c581bb885405f6b19a1753e6e6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga82e4c2e1b6bd1e3dfde9d13c5dc9fe9d"><td class="memItemLeft" align="right" valign="top"><a id="ga82e4c2e1b6bd1e3dfde9d13c5dc9fe9d"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>add_flag_field_to_join_cache</b> (uchar *str, uint length, <a class="el" href="structst__cache__field.html">CACHE_FIELD</a> **field)</td></tr>
<tr class="separator:ga82e4c2e1b6bd1e3dfde9d13c5dc9fe9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ebd062fe6e28002c3dc85bf1c6ed2b"><td class="memItemLeft" align="right" valign="top"><a id="ga17ebd062fe6e28002c3dc85bf1c6ed2b"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>add_table_data_fields_to_join_cache</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="structst__bitmap.html">MY_BITMAP</a> *field_set, uint *field_cnt, <a class="el" href="structst__cache__field.html">CACHE_FIELD</a> **<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, uint *field_ptr_cnt, <a class="el" href="structst__cache__field.html">CACHE_FIELD</a> ***descr_ptr)</td></tr>
<tr class="separator:ga17ebd062fe6e28002c3dc85bf1c6ed2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b25b7a558d93cdb4032e1cf6d99b5f"><td class="memItemLeft" align="right" valign="top"><a id="ga33b25b7a558d93cdb4032e1cf6d99b5f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>bka_skip_index_tuple</b> (range_seq_t rseq, char *range_info)</td></tr>
<tr class="separator:ga33b25b7a558d93cdb4032e1cf6d99b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ec2eaab0315a5a2becabf070a865a9"><td class="memItemLeft" align="right" valign="top"><a id="ga65ec2eaab0315a5a2becabf070a865a9"></a>
static range_seq_t&#160;</td><td class="memItemRight" valign="bottom"><b>bka_range_seq_init</b> (void *init_param, uint n_ranges, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:ga65ec2eaab0315a5a2becabf070a865a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3454ce3d4804daa2770ff076a8d7d751"><td class="memItemLeft" align="right" valign="top"><a id="ga3454ce3d4804daa2770ff076a8d7d751"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>bka_range_seq_next</b> (range_seq_t rseq, <a class="el" href="structst__key__multi__range.html">KEY_MULTI_RANGE</a> *range)</td></tr>
<tr class="separator:ga3454ce3d4804daa2770ff076a8d7d751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b7c5eadd966f57497989413824ae88"><td class="memItemLeft" align="right" valign="top"><a id="ga85b7c5eadd966f57497989413824ae88"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>bka_range_seq_skip_record</b> (range_seq_t rseq, char *range_info, uchar *rowid)</td></tr>
<tr class="separator:ga85b7c5eadd966f57497989413824ae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6f5241b818125f3a72972c8c20ba8d"><td class="memItemLeft" align="right" valign="top"><a id="ga4a6f5241b818125f3a72972c8c20ba8d"></a>
static range_seq_t&#160;</td><td class="memItemRight" valign="bottom"><b>bka_unique_range_seq_init</b> (void *init_param, uint n_ranges, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:ga4a6f5241b818125f3a72972c8c20ba8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5716e477a8f4c114b84a687bcae53ed2"><td class="memItemLeft" align="right" valign="top"><a id="ga5716e477a8f4c114b84a687bcae53ed2"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>bka_unique_range_seq_next</b> (range_seq_t rseq, <a class="el" href="structst__key__multi__range.html">KEY_MULTI_RANGE</a> *range)</td></tr>
<tr class="separator:ga5716e477a8f4c114b84a687bcae53ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680df66a735d887e732db77b06bd302d"><td class="memItemLeft" align="right" valign="top"><a id="ga680df66a735d887e732db77b06bd302d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>bka_unique_range_seq_skip_record</b> (range_seq_t rseq, char *range_info, uchar *rowid)</td></tr>
<tr class="separator:ga680df66a735d887e732db77b06bd302d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6cc23518eeeaf6a66bec11f23ccecd3"><td class="memItemLeft" align="right" valign="top"><a id="gab6cc23518eeeaf6a66bec11f23ccecd3"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>bka_unique_skip_index_tuple</b> (range_seq_t rseq, char *range_info)</td></tr>
<tr class="separator:gab6cc23518eeeaf6a66bec11f23ccecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae283571a1e38e5f3260f36027afdc148"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gae283571a1e38e5f3260f36027afdc148">make_join_statistics</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *leaves, <a class="el" href="class_item.html">Item</a> *conds, <a class="el" href="class_mem__root__array.html">Key_use_array</a> *keyuse, bool first_optimization)</td></tr>
<tr class="separator:gae283571a1e38e5f3260f36027afdc148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b0c1fe8bf704242bb61acaa40a81fb4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga2b0c1fe8bf704242bb61acaa40a81fb4">optimize_semijoin_nests_for_materialization</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="separator:ga2b0c1fe8bf704242bb61acaa40a81fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ca5e962b784c066559515c5286e6c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga76ca5e962b784c066559515c5286e6c5">calculate_materialization_costs</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *sj_nest, uint n_tables, <a class="el" href="struct_semijoin__mat__optimize.html">Semijoin_mat_optimize</a> *sjm)</td></tr>
<tr class="separator:ga76ca5e962b784c066559515c5286e6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae451c9059e4079180d6c88b5f903ec78"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gae451c9059e4079180d6c88b5f903ec78">make_outerjoin_info</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="separator:gae451c9059e4079180d6c88b5f903ec78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7e768b9cfa47758fbaf11d1b878898"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga9b7e768b9cfa47758fbaf11d1b878898">make_join_select</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="class_item.html">Item</a> *item)</td></tr>
<tr class="separator:ga9b7e768b9cfa47758fbaf11d1b878898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fa24dcc32ac483c17625d748cc09d9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga93fa24dcc32ac483c17625d748cc09d9">list_contains_unique_index</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, bool(*find_func)(<a class="el" href="class_field.html">Field</a> *, void *), void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>)</td></tr>
<tr class="separator:ga93fa24dcc32ac483c17625d748cc09d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f21fed3a20651b87cac72bbb304b33c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga3f21fed3a20651b87cac72bbb304b33c">find_field_in_item_list</a> (<a class="el" href="class_field.html">Field</a> *field, void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>)</td></tr>
<tr class="separator:ga3f21fed3a20651b87cac72bbb304b33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac97c3001abc54d7c0fd18d26601d4fdf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gac97c3001abc54d7c0fd18d26601d4fdf">find_field_in_order_list</a> (<a class="el" href="class_field.html">Field</a> *field, void *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>)</td></tr>
<tr class="separator:gac97c3001abc54d7c0fd18d26601d4fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ed4c89159febd52c19c9f64e68709b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structst__order.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gab8ed4c89159febd52c19c9f64e68709b">create_distinct_group</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;all_fields, bool *all_order_by_fields_used)</td></tr>
<tr class="separator:gab8ed4c89159febd52c19c9f64e68709b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60338e02a4512db7d658add6f008fd2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga60338e02a4512db7d658add6f008fd2e">get_sort_by_table</a> (<a class="el" href="structst__order.html">ORDER</a> *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, <a class="el" href="structst__order.html">ORDER</a> *<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>)</td></tr>
<tr class="separator:ga60338e02a4512db7d658add6f008fd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55d30d32086560224c62b7c237f79e1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gac55d30d32086560224c62b7c237f79e1">add_ref_to_table_cond</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:gac55d30d32086560224c62b7c237f79e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76cb6108cc02fa4d53fb8cf473ddf291"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga76cb6108cc02fa4d53fb8cf473ddf291">remove_additional_cond</a> (<a class="el" href="class_item.html">Item</a> *conds)</td></tr>
<tr class="separator:ga76cb6108cc02fa4d53fb8cf473ddf291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437d0af0465d8ebf56f66f8e2ecfd926"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga437d0af0465d8ebf56f66f8e2ecfd926">simplify_joins</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *join_list, <a class="el" href="class_item.html">Item</a> *conds, bool top, bool in_sj, <a class="el" href="class_item.html">Item</a> **new_conds, uint *changelog=NULL)</td></tr>
<tr class="separator:ga437d0af0465d8ebf56f66f8e2ecfd926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00996fa73375b70c9e2a55a9e24620a0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga00996fa73375b70c9e2a55a9e24620a0">record_join_nest_info</a> (st_select_lex *select, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>)</td></tr>
<tr class="separator:ga00996fa73375b70c9e2a55a9e24620a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa0a23c55c6f007481261b1b22e78d1"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gadaa0a23c55c6f007481261b1b22e78d1">build_bitmap_for_nested_joins</a> (<a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *join_list, uint first_unused)</td></tr>
<tr class="separator:gadaa0a23c55c6f007481261b1b22e78d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade27e5590663fce22ead93ccc5a2162b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structst__order.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gade27e5590663fce22ead93ccc5a2162b">remove_const</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *first_order, <a class="el" href="class_item.html">Item</a> *cond, bool change_list, bool *simple_order, const char *clause_type)</td></tr>
<tr class="separator:gade27e5590663fce22ead93ccc5a2162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37680cb5520f709a0adaad5f81cc1c37"><td class="memItemLeft" align="right" valign="top"><a id="ga37680cb5520f709a0adaad5f81cc1c37"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>save_index_subquery_explain_info</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, <a class="el" href="class_item.html">Item</a> *where)</td></tr>
<tr class="separator:ga37680cb5520f709a0adaad5f81cc1c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c540754bd726695a5a7e36952136f3d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga1c540754bd726695a5a7e36952136f3d">trace_table_dependencies</a> (<a class="el" href="class_opt__trace__context.html">Opt_trace_context</a> *trace, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tabs, uint table_count)</td></tr>
<tr class="separator:ga1c540754bd726695a5a7e36952136f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28477ddc155910db0971a61f1cf6bd66"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga28477ddc155910db0971a61f1cf6bd66">update_ref_and_keys</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_mem__root__array.html">Key_use_array</a> *keyuse, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, uint <a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, <a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *cond_equal, table_map normal_tables, SELECT_LEX *select_lex, <a class="el" href="structst__sargable__param.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="separator:ga28477ddc155910db0971a61f1cf6bd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec74b2258a6fa694f7c1e4cca9242b2f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaec74b2258a6fa694f7c1e4cca9242b2f">pull_out_semijoin_tables</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="separator:gaec74b2258a6fa694f7c1e4cca9242b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b3161d639edbd3a8ce6b8d5bbf0e03"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gad5b3161d639edbd3a8ce6b8d5bbf0e03">set_position</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, uint idx, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="class_key__use.html">Key_use</a> *key)</td></tr>
<tr class="separator:gad5b3161d639edbd3a8ce6b8d5bbf0e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc625b885fcfa2fa058cce5480ea989b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gabc625b885fcfa2fa058cce5480ea989b">add_group_and_distinct_keys</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:gabc625b885fcfa2fa058cce5480ea989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd357c5516871a35204aea908c95d350"><td class="memItemLeft" align="right" valign="top">static ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gabd357c5516871a35204aea908c95d350">get_quick_record_count</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_s_q_l___s_e_l_e_c_t.html">SQL_SELECT</a> *select, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *keys, ha_rows <a class="el" href="ibuf0ibuf_8cc.html#a2dfd6b5310e6dd7028210bb6a8d13549">limit</a>)</td></tr>
<tr class="memdesc:gabd357c5516871a35204aea908c95d350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns estimated number of rows that could be fetched by given select.  <a href="#gabd357c5516871a35204aea908c95d350">More...</a><br /></td></tr>
<tr class="separator:gabd357c5516871a35204aea908c95d350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c26ae2d2f1f34ea900c5c713a32854"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gab9c26ae2d2f1f34ea900c5c713a32854">optimize_keyuse</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="class_mem__root__array.html">Key_use_array</a> *keyuse_array)</td></tr>
<tr class="separator:gab9c26ae2d2f1f34ea900c5c713a32854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b9bbbdd9f30e10d54f2bcdbf8589f2"><td class="memItemLeft" align="right" valign="top"><a id="gaf3b9bbbdd9f30e10d54f2bcdbf8589f2"></a>
static <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>make_cond_for_table_from_pred</b> (<a class="el" href="class_item.html">Item</a> *root_cond, <a class="el" href="class_item.html">Item</a> *cond, table_map <a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, table_map used_table, bool exclude_expensive_cond)</td></tr>
<tr class="separator:gaf3b9bbbdd9f30e10d54f2bcdbf8589f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5943531e04254b574e4e0f9aa77b82"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga4e5943531e04254b574e4e0f9aa77b82">only_eq_ref_tables</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *order, table_map <a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, table_map *cached_eq_ref_tables, table_map *eq_ref_tables)</td></tr>
<tr class="separator:ga4e5943531e04254b574e4e0f9aa77b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54a15a3b027af8533c100d5c0fa218f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga54a15a3b027af8533c100d5c0fa218f5">reset_nj_counters</a> (<a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *join_list)</td></tr>
<tr class="separator:ga54a15a3b027af8533c100d5c0fa218f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9652206431848c00d81533336a424c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_item__equal.html">Item_equal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gab9652206431848c00d81533336a424c6">find_item_equal</a> (<a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *cond_equal, <a class="el" href="class_field.html">Field</a> *field, bool *inherited_fl)</td></tr>
<tr class="separator:gab9652206431848c00d81533336a424c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d1175177356bf1c9b05e9104d28c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_item__field.html">Item_field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga67d1175177356bf1c9b05e9104d28c5b">get_best_field</a> (<a class="el" href="class_item__field.html">Item_field</a> *item_field, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *cond_equal)</td></tr>
<tr class="separator:ga67d1175177356bf1c9b05e9104d28c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f38c840626fc6f58b10876246a50cfa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga2f38c840626fc6f58b10876246a50cfa">check_simple_equality</a> (<a class="el" href="class_item.html">Item</a> *left_item, <a class="el" href="class_item.html">Item</a> *right_item, <a class="el" href="class_item.html">Item</a> *item, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *cond_equal)</td></tr>
<tr class="separator:ga2f38c840626fc6f58b10876246a50cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86286130cb5f18c54b9387ccc74cd3c5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga86286130cb5f18c54b9387ccc74cd3c5">check_row_equality</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item.html">Item</a> *left_row, <a class="el" href="class_item__row.html">Item_row</a> *right_row, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *cond_equal, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *eq_list)</td></tr>
<tr class="separator:ga86286130cb5f18c54b9387ccc74cd3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cdf3c010b4cf2965bf44a492978ae9f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga7cdf3c010b4cf2965bf44a492978ae9f">check_equality</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item.html">Item</a> *item, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *cond_equal, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *eq_list)</td></tr>
<tr class="separator:ga7cdf3c010b4cf2965bf44a492978ae9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e32afb6ec083c342da20ea3843952cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga7e32afb6ec083c342da20ea3843952cc">build_equal_items_for_cond</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *inherited, bool do_inherit)</td></tr>
<tr class="separator:ga7e32afb6ec083c342da20ea3843952cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b7012eda6c33a9a9e734948853a334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaa6b7012eda6c33a9a9e734948853a334">build_equal_items</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *inherited, bool do_inherit, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *join_list, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> **cond_equal_ref)</td></tr>
<tr class="separator:gaa6b7012eda6c33a9a9e734948853a334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952d22693874e3582c89615bdb73934c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga952d22693874e3582c89615bdb73934c">compare_fields_by_table_order</a> (<a class="el" href="class_item__field.html">Item_field</a> *field1, <a class="el" href="class_item__field.html">Item_field</a> *field2, void *table_join_idx)</td></tr>
<tr class="separator:ga952d22693874e3582c89615bdb73934c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cabb45db6dff4142c28674dbe0c3ce4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga6cabb45db6dff4142c28674dbe0c3ce4">eliminate_item_equal</a> (<a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *upper_levels, <a class="el" href="class_item__equal.html">Item_equal</a> *item_equal)</td></tr>
<tr class="separator:ga6cabb45db6dff4142c28674dbe0c3ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253393c0747cf378b9cefa109662bd17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga253393c0747cf378b9cefa109662bd17">substitute_for_best_equal_field</a> (<a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *cond_equal, void *table_join_idx)</td></tr>
<tr class="separator:ga253393c0747cf378b9cefa109662bd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba0bcac59dbb9d57fd0ed4bd0411383"><td class="memItemLeft" align="right" valign="top"><a id="ga5ba0bcac59dbb9d57fd0ed4bd0411383"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>change_cond_ref_to_const</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_i___list.html">I_List</a>&lt; <a class="el" href="class_c_o_n_d___c_m_p.html">COND_CMP</a> &gt; *save_list, <a class="el" href="class_item.html">Item</a> *and_father, <a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="class_item.html">Item</a> *field, <a class="el" href="class_item.html">Item</a> *value)</td></tr>
<tr class="separator:ga5ba0bcac59dbb9d57fd0ed4bd0411383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4c7ca93851a1b4e2c2e40d550c61ac"><td class="memItemLeft" align="right" valign="top"><a id="gacc4c7ca93851a1b4e2c2e40d550c61ac"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_cond_constants</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_i___list.html">I_List</a>&lt; <a class="el" href="class_c_o_n_d___c_m_p.html">COND_CMP</a> &gt; *save_list, <a class="el" href="class_item.html">Item</a> *and_father, <a class="el" href="class_item.html">Item</a> *cond)</td></tr>
<tr class="separator:gacc4c7ca93851a1b4e2c2e40d550c61ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81ebfe4ef44f9496582b436835f4680c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga81ebfe4ef44f9496582b436835f4680c">update_depend_map</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="separator:ga81ebfe4ef44f9496582b436835f4680c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53565c3d7314221955132811e5ca9cb7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga53565c3d7314221955132811e5ca9cb7">update_depend_map</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *order)</td></tr>
<tr class="separator:ga53565c3d7314221955132811e5ca9cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf7d0c085b6fa2c810619adfcc8cfd9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaaaf7d0c085b6fa2c810619adfcc8cfd9">semijoin_types_allow_materialization</a> (<a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *sj_nest)</td></tr>
<tr class="memdesc:gaaaf7d0c085b6fa2c810619adfcc8cfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_check.html">Check</a> if semijoin's compared types allow materialization.  <a href="#gaaaf7d0c085b6fa2c810619adfcc8cfd9">More...</a><br /></td></tr>
<tr class="separator:gaaaf7d0c085b6fa2c810619adfcc8cfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce828ba4b61290915dcd3737335244e"><td class="memItemLeft" align="right" valign="top"><a id="gabce828ba4b61290915dcd3737335244e"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>get_tmp_table_rec_length</b> (<a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="structitems.html">items</a>)</td></tr>
<tr class="separator:gabce828ba4b61290915dcd3737335244e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774dd8254e1c2ed55a9adf69e4657046"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga774dd8254e1c2ed55a9adf69e4657046">add_not_null_conds</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="separator:ga774dd8254e1c2ed55a9adf69e4657046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652bf7109dfbe0fdd7deb75c05c0a7a3"><td class="memItemLeft" align="right" valign="top"><a id="ga652bf7109dfbe0fdd7deb75c05c0a7a3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>uses_index_fields_only</b> (<a class="el" href="class_item.html">Item</a> *item, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *tbl, uint keyno, bool other_tbls_ok)</td></tr>
<tr class="separator:ga652bf7109dfbe0fdd7deb75c05c0a7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafead1855cd652b84fb35639c73064ab8"><td class="memItemLeft" align="right" valign="top"><a id="gafead1855cd652b84fb35639c73064ab8"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>find_eq_ref_candidate</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, table_map sj_inner_tables)</td></tr>
<tr class="separator:gafead1855cd652b84fb35639c73064ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de27fe9f2c08ca72261a3eb995c5b76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_key__field.html">Key_field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga1de27fe9f2c08ca72261a3eb995c5b76">merge_key_fields</a> (<a class="el" href="struct_key__field.html">Key_field</a> *start, <a class="el" href="struct_key__field.html">Key_field</a> *new_fields, <a class="el" href="struct_key__field.html">Key_field</a> *end, uint and_level)</td></tr>
<tr class="separator:ga1de27fe9f2c08ca72261a3eb995c5b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9cd2ffd854fd4ed7ee4205cfb1f36c"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gacf9cd2ffd854fd4ed7ee4205cfb1f36c">get_semi_join_select_list_index</a> (<a class="el" href="class_field.html">Field</a> *field)</td></tr>
<tr class="separator:gacf9cd2ffd854fd4ed7ee4205cfb1f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5798d039ab240f96c90d30e0819b9b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaa5798d039ab240f96c90d30e0819b9b0">warn_index_not_applicable</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, const <a class="el" href="class_field.html">Field</a> *field, const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> cant_use_index)</td></tr>
<tr class="memdesc:gaa5798d039ab240f96c90d30e0819b9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If EXPLAIN EXTENDED, add warning that an index cannot be used for ref access.  <a href="#gaa5798d039ab240f96c90d30e0819b9b0">More...</a><br /></td></tr>
<tr class="separator:gaa5798d039ab240f96c90d30e0819b9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51521ef9ae68c5305be5d9ef2a643a5d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga51521ef9ae68c5305be5d9ef2a643a5d">add_key_field</a> (<a class="el" href="struct_key__field.html">Key_field</a> **key_fields, uint and_level, <a class="el" href="class_item__func.html">Item_func</a> *cond, <a class="el" href="class_field.html">Field</a> *field, bool eq_func, <a class="el" href="class_item.html">Item</a> **value, uint num_values, table_map usable_tables, <a class="el" href="structst__sargable__param.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="separator:ga51521ef9ae68c5305be5d9ef2a643a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125ad0b958d2c3716bbb8431fde578f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga125ad0b958d2c3716bbb8431fde578f7">add_key_equal_fields</a> (<a class="el" href="struct_key__field.html">Key_field</a> **key_fields, uint and_level, <a class="el" href="class_item__func.html">Item_func</a> *cond, <a class="el" href="class_item__field.html">Item_field</a> *field_item, bool eq_func, <a class="el" href="class_item.html">Item</a> **val, uint num_values, table_map usable_tables, <a class="el" href="structst__sargable__param.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="separator:ga125ad0b958d2c3716bbb8431fde578f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga155464f8c15576de13e9aba1e6ca875a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga155464f8c15576de13e9aba1e6ca875a">is_local_field</a> (<a class="el" href="class_item.html">Item</a> *field)</td></tr>
<tr class="separator:ga155464f8c15576de13e9aba1e6ca875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8fd926476b01bc4fc5e2c5fc168503"><td class="memItemLeft" align="right" valign="top"><a id="ga5d8fd926476b01bc4fc5e2c5fc168503"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>add_key_fields</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="struct_key__field.html">Key_field</a> **key_fields, uint *and_level, <a class="el" href="class_item.html">Item</a> *cond, table_map usable_tables, <a class="el" href="structst__sargable__param.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="separator:ga5d8fd926476b01bc4fc5e2c5fc168503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bbcf94e4ec6f957ea1252d7b8326021"><td class="memItemLeft" align="right" valign="top"><a id="ga6bbcf94e4ec6f957ea1252d7b8326021"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_key_part</b> (<a class="el" href="class_mem__root__array.html">Key_use_array</a> *keyuse_array, <a class="el" href="struct_key__field.html">Key_field</a> *key_field)</td></tr>
<tr class="separator:ga6bbcf94e4ec6f957ea1252d7b8326021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b9eae08492d6440923b7eacbc5b988"><td class="memItemLeft" align="right" valign="top"><a id="ga60b9eae08492d6440923b7eacbc5b988"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>add_ft_keys</b> (<a class="el" href="class_mem__root__array.html">Key_use_array</a> *keyuse_array, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *stat, <a class="el" href="class_item.html">Item</a> *cond, table_map usable_tables)</td></tr>
<tr class="separator:ga60b9eae08492d6440923b7eacbc5b988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8e86438dcfdcd9a058ea67d1dbce1e"><td class="memItemLeft" align="right" valign="top"><a id="gadc8e86438dcfdcd9a058ea67d1dbce1e"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>sort_keyuse</b> (<a class="el" href="class_key__use.html">Key_use</a> *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, <a class="el" href="class_key__use.html">Key_use</a> *<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>)</td></tr>
<tr class="separator:gadc8e86438dcfdcd9a058ea67d1dbce1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ae2b7951796321b26f684edf7b8239"><td class="memItemLeft" align="right" valign="top"><a id="gaf4ae2b7951796321b26f684edf7b8239"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>add_key_fields_for_nj</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *nested_join_table, <a class="el" href="struct_key__field.html">Key_field</a> **end, uint *and_level, <a class="el" href="structst__sargable__param.html">SARGABLE_PARAM</a> **sargables)</td></tr>
<tr class="separator:gaf4ae2b7951796321b26f684edf7b8239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa992e841315769954816105b951d3e17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaa992e841315769954816105b951d3e17">is_indexed_agg_distinct</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item__field.html">Item_field</a> &gt; *out_args)</td></tr>
<tr class="separator:gaa992e841315769954816105b951d3e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a2f6510062aadbe683719e51560a3ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga1a2f6510062aadbe683719e51560a3ff">trace_indices_added_group_distinct</a> (<a class="el" href="class_opt__trace__context.html">Opt_trace_context</a> *trace, const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> new_keys, const char *cause)</td></tr>
<tr class="separator:ga1a2f6510062aadbe683719e51560a3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5efe6ddb0de3a2b43f36c3330354e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mem__root__array.html">Key_use_array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga7a5efe6ddb0de3a2b43f36c3330354e7">create_keyuse_for_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, uint keyparts, <a class="el" href="class_item__field.html">Item_field</a> **<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; outer_exprs)</td></tr>
<tr class="separator:ga7a5efe6ddb0de3a2b43f36c3330354e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849187ffe748146555424fe615634bf1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga849187ffe748146555424fe615634bf1">add_found_match_trig_cond</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *root_tab)</td></tr>
<tr class="separator:ga849187ffe748146555424fe615634bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82cbeb58f7f5ba4a462e691b7e075578"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga82cbeb58f7f5ba4a462e691b7e075578">pushdown_on_conditions</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *last_tab)</td></tr>
<tr class="separator:ga82cbeb58f7f5ba4a462e691b7e075578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4231701511c7ec9b277fde326e8080e"><td class="memItemLeft" align="right" valign="top"><a id="gaa4231701511c7ec9b277fde326e8080e"></a>
static <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>part_of_refkey</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="class_field.html">Field</a> *field)</td></tr>
<tr class="separator:gaa4231701511c7ec9b277fde326e8080e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b8ed924bc1ecabf570961a7d6a7d3b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga82b8ed924bc1ecabf570961a7d6a7d3b">test_if_ref</a> (<a class="el" href="class_item.html">Item</a> *root_cond, <a class="el" href="class_item__field.html">Item_field</a> *left_item, <a class="el" href="class_item.html">Item</a> *right_item)</td></tr>
<tr class="separator:ga82b8ed924bc1ecabf570961a7d6a7d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad58027047f122daabf2ab024b274897"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaad58027047f122daabf2ab024b274897">replace_subcondition</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="class_item.html">Item</a> **tree, <a class="el" href="class_item.html">Item</a> *old_cond, <a class="el" href="class_item.html">Item</a> *new_cond, bool do_fix_fields)</td></tr>
<tr class="separator:gaad58027047f122daabf2ab024b274897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c6b8c0022136aa6063985e12b324b28"><td class="memItemLeft" align="right" valign="top"><a id="ga9c6b8c0022136aa6063985e12b324b28"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>subq_sj_candidate_cmp</b> (<a class="el" href="class_item__exists__subselect.html">Item_exists_subselect</a> *const *el1, <a class="el" href="class_item__exists__subselect.html">Item_exists_subselect</a> *const *el2)</td></tr>
<tr class="separator:ga9c6b8c0022136aa6063985e12b324b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1356dc46e8771b71069a02ca83c72279"><td class="memItemLeft" align="right" valign="top"><a id="ga1356dc46e8771b71069a02ca83c72279"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>fix_list_after_tbl_changes</b> (st_select_lex *parent_select, st_select_lex *removed_select, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *tlist)</td></tr>
<tr class="separator:ga1356dc46e8771b71069a02ca83c72279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7207e4c2b811db6a803fde5e3ca73e80"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga7207e4c2b811db6a803fde5e3ca73e80">convert_subquery_to_semijoin</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *parent_join, <a class="el" href="class_item__exists__subselect.html">Item_exists_subselect</a> *subq_pred)</td></tr>
<tr class="separator:ga7207e4c2b811db6a803fde5e3ca73e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf2fb3248e5d013e6a74b29dd9e7429"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaedf2fb3248e5d013e6a74b29dd9e7429">make_cond_for_table</a> (<a class="el" href="class_item.html">Item</a> *cond, table_map <a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, table_map used_table, bool exclude_expensive_cond)</td></tr>
<tr class="separator:gaedf2fb3248e5d013e6a74b29dd9e7429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6581c041c0e0f1f0f681536e0ca35dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gad6581c041c0e0f1f0f681536e0ca35dc">eq_ref_table</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *start_order, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, table_map *cached_eq_ref_tables, table_map *eq_ref_tables)</td></tr>
<tr class="separator:gad6581c041c0e0f1f0f681536e0ca35dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae977f888923f3443e09345a10bbee9a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaae977f888923f3443e09345a10bbee9a">duplicate_order</a> (const <a class="el" href="structst__order.html">ORDER</a> *first_order, const <a class="el" href="structst__order.html">ORDER</a> *possible_dup)</td></tr>
<tr class="separator:gaae977f888923f3443e09345a10bbee9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e8bc785b0cfb6f2269f566283e239f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga5e8bc785b0cfb6f2269f566283e239f7">optimize_cond</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item.html">Item</a> *conds, <a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> **cond_equal, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *join_list, bool build_equalities, Item::cond_result *cond_value)</td></tr>
<tr class="separator:ga5e8bc785b0cfb6f2269f566283e239f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8383a2cc774094f3750e4f02514c02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaee8383a2cc774094f3750e4f02514c02">internal_remove_eq_conds</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item.html">Item</a> *cond, Item::cond_result *cond_value)</td></tr>
<tr class="separator:gaee8383a2cc774094f3750e4f02514c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba67ab6a59be99d1ae4d29ff674feebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaba67ab6a59be99d1ae4d29ff674feebc">remove_eq_conds</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_item.html">Item</a> *cond, Item::cond_result *cond_value)</td></tr>
<tr class="separator:gaba67ab6a59be99d1ae4d29ff674feebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa22943cfab7f83bbaa4d8b65533ead60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_item__cond__and.html">Item_cond_and</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaa22943cfab7f83bbaa4d8b65533ead60">create_cond_for_const_ref</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:gaa22943cfab7f83bbaa4d8b65533ead60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34118cfe3438321eb175c855298cead0"><td class="memItemLeft" align="right" valign="top"><a id="ga34118cfe3438321eb175c855298cead0"></a>
static <a class="el" href="classstore__key.html">store_key</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_store_key</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_key__use.html">Key_use</a> *keyuse, table_map used_tables, <a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *key_part, uchar *key_buff, uint maybe_null)</td></tr>
<tr class="separator:ga34118cfe3438321eb175c855298cead0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fc6278226cdb15849ecfd9c3af07b00"><td class="memItemLeft" align="right" valign="top"><a id="ga0fc6278226cdb15849ecfd9c3af07b00"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>const_expression_in_where</b> (<a class="el" href="class_item.html">Item</a> *conds, <a class="el" href="class_item.html">Item</a> *item, <a class="el" href="class_item.html">Item</a> **comp_item)</td></tr>
<tr class="separator:ga0fc6278226cdb15849ecfd9c3af07b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0c3fdb07be77d705feaf3f8f51164f"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gafd0c3fdb07be77d705feaf3f8f51164f">find_shortest_key</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *usable_keys)</td></tr>
<tr class="separator:gafd0c3fdb07be77d705feaf3f8f51164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf45084f9f7f12e1368aa2f07811033f2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaf45084f9f7f12e1368aa2f07811033f2">test_if_cheaper_ordering</a> (const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> usable_keys, int key, ha_rows select_limit, int *new_key, int *new_key_direction, ha_rows *new_select_limit, uint *new_used_key_parts=NULL, uint *saved_best_key_parts=NULL)</td></tr>
<tr class="separator:gaf45084f9f7f12e1368aa2f07811033f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a30c7eaa937772da0fdc2af376b8925"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga6a30c7eaa937772da0fdc2af376b8925">join_buffer_alg</a> (const THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:ga6a30c7eaa937772da0fdc2af376b8925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33316853c1b52be9f18b13e4a37bb4fb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga33316853c1b52be9f18b13e4a37bb4fb">push_index_cond</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, uint keyno, bool other_tbls_ok, <a class="el" href="class_opt__trace__object.html">Opt_trace_object</a> *trace_obj)</td></tr>
<tr class="separator:ga33316853c1b52be9f18b13e4a37bb4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9015b581d8214425649d273f3e12090"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gad9015b581d8214425649d273f3e12090">handle_select</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, select_result *result, ulong setup_tables_done_option)</td></tr>
<tr class="separator:gad9015b581d8214425649d273f3e12090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410e1c85b186cd5520a7d21930ead6e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga410e1c85b186cd5520a7d21930ead6e5">types_allow_materialization</a> (<a class="el" href="class_item.html">Item</a> *outer, <a class="el" href="class_item.html">Item</a> *inner)</td></tr>
<tr class="memdesc:ga410e1c85b186cd5520a7d21930ead6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_check.html">Check</a> if two items are compatible wrt. materialization.  <a href="#ga410e1c85b186cd5520a7d21930ead6e5">More...</a><br /></td></tr>
<tr class="separator:ga410e1c85b186cd5520a7d21930ead6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga683fa9f64c971af8a34e9711877a82ee"><td class="memItemLeft" align="right" valign="top"><a id="ga683fa9f64c971af8a34e9711877a82ee"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>sj_table_is_included</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:ga683fa9f64c971af8a34e9711877a82ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga011b405ebbd3b60eda4eb936dea9c2c2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga011b405ebbd3b60eda4eb936dea9c2c2">might_do_join_buffering</a> (uint <a class="el" href="group___query___optimizer.html#ga6a30c7eaa937772da0fdc2af376b8925">join_buffer_alg</a>, const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *sj_tab)</td></tr>
<tr class="separator:ga011b405ebbd3b60eda4eb936dea9c2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd6d91b682441f4991964f9b3ef828c9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gadd6d91b682441f4991964f9b3ef828c9">setup_semijoin_dups_elimination</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, ulonglong options, uint no_jbuf_after)</td></tr>
<tr class="separator:gadd6d91b682441f4991964f9b3ef828c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2581670e2e142b312e64ba314181980"><td class="memItemLeft" align="right" valign="top"><a id="gae2581670e2e142b312e64ba314181980"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy_sj_tmp_tables</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="separator:gae2581670e2e142b312e64ba314181980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0bbbe120736860a73919679044834f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga7e0bbbe120736860a73919679044834f">clear_sj_tmp_tables</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="separator:ga7e0bbbe120736860a73919679044834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a5dd8427d34c4218f75a814d513249"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gac4a5dd8427d34c4218f75a814d513249">mysql_prepare_select</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, uint wild_num, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_item.html">Item</a> *conds, uint og_num, <a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="structst__order.html">ORDER</a> *group, <a class="el" href="class_item.html">Item</a> *having, ulonglong select_options, select_result *result, SELECT_LEX_UNIT *unit, SELECT_LEX *select_lex, bool *free_join)</td></tr>
<tr class="separator:gac4a5dd8427d34c4218f75a814d513249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d77b10aa34ec6307edb04ccafd8483"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga80d77b10aa34ec6307edb04ccafd8483">mysql_execute_select</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, SELECT_LEX *select_lex, bool free_join)</td></tr>
<tr class="separator:ga80d77b10aa34ec6307edb04ccafd8483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac201f6bcc85fbd7e04997dda1c83e5b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gac201f6bcc85fbd7e04997dda1c83e5b1">mysql_select</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *<a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, uint wild_num, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, <a class="el" href="class_item.html">Item</a> *conds, <a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; *order, <a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; *group, <a class="el" href="class_item.html">Item</a> *having, ulonglong select_options, select_result *result, SELECT_LEX_UNIT *unit, SELECT_LEX *select_lex)</td></tr>
<tr class="separator:gac201f6bcc85fbd7e04997dda1c83e5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ca922593fe6b15db19791f8133f407"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gab0ca922593fe6b15db19791f8133f407">calc_used_field_length</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:gab0ca922593fe6b15db19791f8133f407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b518fb7975676afc7395b412e803368"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga3b518fb7975676afc7395b412e803368">create_ref_for_key</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *j, <a class="el" href="class_key__use.html">Key_use</a> *org_keyuse, table_map used_tables)</td></tr>
<tr class="separator:ga3b518fb7975676afc7395b412e803368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c0a5624f789fb0bf0c5fc5ec057de9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gad3c0a5624f789fb0bf0c5fc5ec057de9">and_conditions</a> (<a class="el" href="class_item.html">Item</a> **e1, <a class="el" href="class_item.html">Item</a> *e2)</td></tr>
<tr class="separator:gad3c0a5624f789fb0bf0c5fc5ec057de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada7f25e97254e2d750e0a4c342dff519"><td class="memItemLeft" align="right" valign="top"><a id="gada7f25e97254e2d750e0a4c342dff519"></a>
static <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>make_cond_for_index</b> (<a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, uint keyno, bool other_tbls_ok)</td></tr>
<tr class="separator:gada7f25e97254e2d750e0a4c342dff519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7f2f6ab05ccb685726a77994db1c2f"><td class="memItemLeft" align="right" valign="top"><a id="gace7f2f6ab05ccb685726a77994db1c2f"></a>
static <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>make_cond_remainder</b> (<a class="el" href="class_item.html">Item</a> *cond, bool exclude_index)</td></tr>
<tr class="separator:gace7f2f6ab05ccb685726a77994db1c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd23841ab58559a18c93333a909ec1d5"><td class="memItemLeft" align="right" valign="top"><a id="gabd23841ab58559a18c93333a909ec1d5"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_join_cache_denial</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:gabd23841ab58559a18c93333a909ec1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0283c484bf5fee7f5b6650d9e05020f7"><td class="memItemLeft" align="right" valign="top"><a id="ga0283c484bf5fee7f5b6650d9e05020f7"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>revise_cache_usage</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:ga0283c484bf5fee7f5b6650d9e05020f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1510993d68f776aedbd40bc732b94fa6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga1510993d68f776aedbd40bc732b94fa6">setup_join_buffering</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="class_j_o_i_n.html">JOIN</a> *join, ulonglong options, uint no_jbuf_after, bool *icp_other_tables_ok)</td></tr>
<tr class="separator:ga1510993d68f776aedbd40bc732b94fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77fc941f20e42c089b99ab1641646828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga77fc941f20e42c089b99ab1641646828">make_join_readinfo</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, ulonglong options, uint no_jbuf_after)</td></tr>
<tr class="separator:ga77fc941f20e42c089b99ab1641646828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1351457ee30a4e67786117e50413541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaf1351457ee30a4e67786117e50413541">error_if_full_join</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join)</td></tr>
<tr class="separator:gaf1351457ee30a4e67786117e50413541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc980a72c17c8442fab87af085697d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gadbc980a72c17c8442fab87af085697d4">simple_remove_const</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="class_item.html">Item</a> *where)</td></tr>
<tr class="separator:gadbc980a72c17c8442fab87af085697d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9775006f4314dcf9220d712c56e505f"><td class="memItemLeft" align="right" valign="top"><a id="gac9775006f4314dcf9220d712c56e505f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_if_equality_guarantees_uniqueness</b> (<a class="el" href="class_item.html">Item</a> *l, <a class="el" href="class_item.html">Item</a> *r)</td></tr>
<tr class="separator:gac9775006f4314dcf9220d712c56e505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8706f8b371ef7de9fd2e50b886a8a3d9"><td class="memItemLeft" align="right" valign="top"><a id="ga8706f8b371ef7de9fd2e50b886a8a3d9"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (<a class="el" href="class_item.html">Item</a> *i1, <a class="el" href="class_item.html">Item</a> *i2, <a class="el" href="class_field.html">Field</a> *f2)</td></tr>
<tr class="separator:ga8706f8b371ef7de9fd2e50b886a8a3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8478e8df214dcc332c84d24ebe3f0785"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga8478e8df214dcc332c84d24ebe3f0785">const_expression_in_where</a> (<a class="el" href="class_item.html">Item</a> *cond, <a class="el" href="class_item.html">Item</a> *comp_item, <a class="el" href="class_field.html">Field</a> *comp_field, <a class="el" href="class_item.html">Item</a> **const_item)</td></tr>
<tr class="separator:ga8478e8df214dcc332c84d24ebe3f0785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96dc524565684a4e258c98f5b7fd1541"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga96dc524565684a4e258c98f5b7fd1541">test_if_order_by_key</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, uint idx, uint *used_key_parts)</td></tr>
<tr class="separator:ga96dc524565684a4e258c98f5b7fd1541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8d854a364ab749539a9363619acf99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga4a8d854a364ab749539a9363619acf99">is_subkey</a> (<a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *key_part, <a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *ref_key_part, <a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *ref_key_part_end)</td></tr>
<tr class="separator:ga4a8d854a364ab749539a9363619acf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c7525857d6d4c3c486dd5985d81675f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga5c7525857d6d4c3c486dd5985d81675f">is_ref_or_null_optimized</a> (const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, uint ref_key)</td></tr>
<tr class="separator:ga5c7525857d6d4c3c486dd5985d81675f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43cd92bbdb313a0bec082f717a4f5ee"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gae43cd92bbdb313a0bec082f717a4f5ee">test_if_subkey</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, uint ref, uint ref_key_parts, const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *usable_keys)</td></tr>
<tr class="separator:gae43cd92bbdb313a0bec082f717a4f5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a304484212b5489e8e995539493dd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga14a304484212b5489e8e995539493dd0">test_if_skip_sort_order</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="structst__order.html">ORDER</a> *order, ha_rows select_limit, const bool no_changes, const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *map, const char *clause_type)</td></tr>
<tr class="separator:ga14a304484212b5489e8e995539493dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61bf73cb2d42b343f9e6306b5d5e56ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga61bf73cb2d42b343f9e6306b5d5e56ec">count_field_types</a> (SELECT_LEX *select_lex, TMP_TABLE_PARAM *param, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="rem0rec_8cc.html#a18b60f4abb9035f6a2d6b87f0ff336b9">fields</a>, bool reset_with_sum_func)</td></tr>
<tr class="separator:ga61bf73cb2d42b343f9e6306b5d5e56ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5a2e1822e2131fcfbe6501a8a97525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga4d5a2e1822e2131fcfbe6501a8a97525">test_if_subpart</a> (<a class="el" href="structst__order.html">ORDER</a> *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, <a class="el" href="structst__order.html">ORDER</a> *<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>)</td></tr>
<tr class="separator:ga4d5a2e1822e2131fcfbe6501a8a97525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa978828bfe7be091fb76e1c5da80d644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaa978828bfe7be091fb76e1c5da80d644">calc_group_buffer</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *group)</td></tr>
<tr class="separator:gaa978828bfe7be091fb76e1c5da80d644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59080a3acd829efcf18fc56d51df215c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga59080a3acd829efcf18fc56d51df215c">free_underlaid_joins</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, SELECT_LEX *select)</td></tr>
<tr class="separator:ga59080a3acd829efcf18fc56d51df215c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e83c73f6271bc56ebedaa2e8d3ec5ad"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga5e83c73f6271bc56ebedaa2e8d3ec5ad">get_index_for_order</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="class_s_q_l___s_e_l_e_c_t.html">SQL_SELECT</a> *select, ha_rows <a class="el" href="ibuf0ibuf_8cc.html#a2dfd6b5310e6dd7028210bb6a8d13549">limit</a>, bool *need_sort, bool *reverse)</td></tr>
<tr class="separator:ga5e83c73f6271bc56ebedaa2e8d3ec5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf1b1ecda6374b7b3a32b5454d09876"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gadbf1b1ecda6374b7b3a32b5454d09876">actual_key_parts</a> (<a class="el" href="structst__key.html">KEY</a> *key_info)</td></tr>
<tr class="separator:gadbf1b1ecda6374b7b3a32b5454d09876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174d79a5aef2a8abd1caec143b42837e"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga174d79a5aef2a8abd1caec143b42837e">actual_key_flags</a> (<a class="el" href="structst__key.html">KEY</a> *key_info)</td></tr>
<tr class="separator:ga174d79a5aef2a8abd1caec143b42837e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52eaf58ec1438c6d387b55e4035e504"><td class="memItemLeft" align="right" valign="top"><a id="gaa52eaf58ec1438c6d387b55e4035e504"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::calc_record_fields</b> ()</td></tr>
<tr class="separator:gaa52eaf58ec1438c6d387b55e4035e504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64e01213d7f5f755d1ff689d5e46fd8"><td class="memItemLeft" align="right" valign="top"><a id="gaa64e01213d7f5f755d1ff689d5e46fd8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::alloc_fields</b> (uint external_fields)</td></tr>
<tr class="separator:gaa64e01213d7f5f755d1ff689d5e46fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631f7419905d1b8199d14f5fd11926d4"><td class="memItemLeft" align="right" valign="top"><a id="ga631f7419905d1b8199d14f5fd11926d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::create_flag_fields</b> ()</td></tr>
<tr class="separator:ga631f7419905d1b8199d14f5fd11926d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ab87ee19d6e92561f80933563bb147"><td class="memItemLeft" align="right" valign="top"><a id="gab3ab87ee19d6e92561f80933563bb147"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::create_remaining_fields</b> (bool all_read_fields)</td></tr>
<tr class="separator:gab3ab87ee19d6e92561f80933563bb147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e30ba1b4cfa2fd22aaf1c5bac90b7e"><td class="memItemLeft" align="right" valign="top"><a id="ga81e30ba1b4cfa2fd22aaf1c5bac90b7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::set_constants</b> ()</td></tr>
<tr class="separator:ga81e30ba1b4cfa2fd22aaf1c5bac90b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5932344e1185abf63788970856f45766"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga5932344e1185abf63788970856f45766">JOIN_CACHE::alloc_buffer</a> ()</td></tr>
<tr class="separator:ga5932344e1185abf63788970856f45766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dbb0f8b69dc30985e0d9a0ff94121f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gab3dbb0f8b69dc30985e0d9a0ff94121f">JOIN_CACHE_BNL::init</a> ()</td></tr>
<tr class="separator:gab3dbb0f8b69dc30985e0d9a0ff94121f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga327376f63198bf31a770fb89242d49aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga327376f63198bf31a770fb89242d49aa">JOIN_CACHE_BKA::init</a> ()</td></tr>
<tr class="separator:ga327376f63198bf31a770fb89242d49aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700b94ef76d1152d7ea4816ec7b46299"><td class="memItemLeft" align="right" valign="top"><a id="ga700b94ef76d1152d7ea4816ec7b46299"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::check_emb_key_usage</b> ()</td></tr>
<tr class="separator:ga700b94ef76d1152d7ea4816ec7b46299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8661280e3da40b2c581ec758c50e1979"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga8661280e3da40b2c581ec758c50e1979">JOIN_CACHE_BKA::aux_buffer_incr</a> ()</td></tr>
<tr class="separator:ga8661280e3da40b2c581ec758c50e1979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef7343f0416360c14c6134867b347c83"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaef7343f0416360c14c6134867b347c83">JOIN_CACHE_BKA::aux_buffer_min_size</a> () const</td></tr>
<tr class="separator:gaef7343f0416360c14c6134867b347c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552f68c5d61c00714ca823ff05cd7847"><td class="memItemLeft" align="right" valign="top"><a id="ga552f68c5d61c00714ca823ff05cd7847"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::skip_index_tuple</b> (range_seq_t rseq, char *range_info)</td></tr>
<tr class="separator:ga552f68c5d61c00714ca823ff05cd7847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264fccad2a1ea9271e785cb8e38432ca"><td class="memItemLeft" align="right" valign="top"><a id="ga264fccad2a1ea9271e785cb8e38432ca"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::write_record_data</b> (uchar *<a class="el" href="structlink.html">link</a>, bool *is_full)</td></tr>
<tr class="separator:ga264fccad2a1ea9271e785cb8e38432ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54e309ac7f0fd377d7a422ea54f59f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8">JOIN_CACHE::reset_cache</a> (bool for_writing)</td></tr>
<tr class="memdesc:gad54e309ac7f0fd377d7a422ea54f59f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the join buffer for reading/writing: default implementation.  <a href="#gad54e309ac7f0fd377d7a422ea54f59f8">More...</a><br /></td></tr>
<tr class="separator:gad54e309ac7f0fd377d7a422ea54f59f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d55336d67514ad78878149c80528e33"><td class="memItemLeft" align="right" valign="top"><a id="ga6d55336d67514ad78878149c80528e33"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::put_record_in_cache</b> ()</td></tr>
<tr class="separator:ga6d55336d67514ad78878149c80528e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7ee01f20498b51114e1afb40806685"><td class="memItemLeft" align="right" valign="top"><a id="ga6f7ee01f20498b51114e1afb40806685"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::get_record</b> ()</td></tr>
<tr class="separator:ga6f7ee01f20498b51114e1afb40806685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb8c25ca124e9aeaddf1442c6167e87"><td class="memItemLeft" align="right" valign="top"><a id="gaccb8c25ca124e9aeaddf1442c6167e87"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::get_record_by_pos</b> (uchar *rec_ptr)</td></tr>
<tr class="separator:gaccb8c25ca124e9aeaddf1442c6167e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7955ae39f556d0141a6eb11e03a4b1e"><td class="memItemLeft" align="right" valign="top"><a id="gab7955ae39f556d0141a6eb11e03a4b1e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::get_match_flag_by_pos</b> (uchar *rec_ptr)</td></tr>
<tr class="separator:gab7955ae39f556d0141a6eb11e03a4b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c8bd509fba4099611e8a7b01c115d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga20c8bd509fba4099611e8a7b01c115d8">JOIN_CACHE::read_some_record_fields</a> ()</td></tr>
<tr class="separator:ga20c8bd509fba4099611e8a7b01c115d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa19cecc5eccee0ff1285c62769daf39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gafa19cecc5eccee0ff1285c62769daf39">JOIN_CACHE::read_some_flag_fields</a> ()</td></tr>
<tr class="separator:gafa19cecc5eccee0ff1285c62769daf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6967798983487fe2f83ed405b5b2d1f4"><td class="memItemLeft" align="right" valign="top"><a id="ga6967798983487fe2f83ed405b5b2d1f4"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::read_record_field</b> (<a class="el" href="structst__cache__field.html">CACHE_FIELD</a> *copy, bool last_record)</td></tr>
<tr class="separator:ga6967798983487fe2f83ed405b5b2d1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b36ae5a54a63d5fb2fe863a036aa08"><td class="memItemLeft" align="right" valign="top"><a id="ga66b36ae5a54a63d5fb2fe863a036aa08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::read_referenced_field</b> (<a class="el" href="structst__cache__field.html">CACHE_FIELD</a> *copy, uchar *rec_ptr, uint *<a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>)</td></tr>
<tr class="separator:ga66b36ae5a54a63d5fb2fe863a036aa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb269cde39ce62236de5b481296de21"><td class="memItemLeft" align="right" valign="top"><a id="gafbb269cde39ce62236de5b481296de21"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::skip_record_if_match</b> ()</td></tr>
<tr class="separator:gafbb269cde39ce62236de5b481296de21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3feda29f01cc03251f55a0b00511d7a"><td class="memItemLeft" align="right" valign="top"><a id="gae3feda29f01cc03251f55a0b00511d7a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::restore_last_record</b> ()</td></tr>
<tr class="separator:gae3feda29f01cc03251f55a0b00511d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66879154541707521bc3d07829084c2e"><td class="memItemLeft" align="right" valign="top"><a id="ga66879154541707521bc3d07829084c2e"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::join_records</b> (bool skip_last)</td></tr>
<tr class="separator:ga66879154541707521bc3d07829084c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05271c0a916273b7f8b934fbaab623bd"><td class="memItemLeft" align="right" valign="top"><a id="ga05271c0a916273b7f8b934fbaab623bd"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BNL::join_matching_records</b> (bool skip_last)</td></tr>
<tr class="separator:ga05271c0a916273b7f8b934fbaab623bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac37078c046dbe5b782dec454fe2da4"><td class="memItemLeft" align="right" valign="top"><a id="gafac37078c046dbe5b782dec454fe2da4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::set_match_flag_if_none</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *first_inner, uchar *rec_ptr)</td></tr>
<tr class="separator:gafac37078c046dbe5b782dec454fe2da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774240988bd63b547442150fd459e6d2"><td class="memItemLeft" align="right" valign="top"><a id="ga774240988bd63b547442150fd459e6d2"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::generate_full_extensions</b> (uchar *rec_ptr)</td></tr>
<tr class="separator:ga774240988bd63b547442150fd459e6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab160a0ff435a7a1da8bb065ba03f1573"><td class="memItemLeft" align="right" valign="top"><a id="gab160a0ff435a7a1da8bb065ba03f1573"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::check_match</b> (uchar *rec_ptr)</td></tr>
<tr class="separator:gab160a0ff435a7a1da8bb065ba03f1573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08fb808afb3705abba0f0bfaf5798d05"><td class="memItemLeft" align="right" valign="top"><a id="ga08fb808afb3705abba0f0bfaf5798d05"></a>
virtual enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::join_null_complements</b> (bool skip_last)</td></tr>
<tr class="separator:ga08fb808afb3705abba0f0bfaf5798d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae42b1e09c108b419fb9eefac1312ef"><td class="memItemLeft" align="right" valign="top"><a id="ga5ae42b1e09c108b419fb9eefac1312ef"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::join_matching_records</b> (bool skip_last)</td></tr>
<tr class="separator:ga5ae42b1e09c108b419fb9eefac1312ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ba1e9701fe4bab26bd70d79e91cd30"><td class="memItemLeft" align="right" valign="top"><a id="ga89ba1e9701fe4bab26bd70d79e91cd30"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::init_join_matching_records</b> (<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq_funcs, uint ranges)</td></tr>
<tr class="separator:ga89ba1e9701fe4bab26bd70d79e91cd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812222f5f9eb4a9026c8ce89069ef8d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga812222f5f9eb4a9026c8ce89069ef8d7">JOIN_CACHE::read_all_flag_fields_by_pos</a> (uchar *rec_ptr)</td></tr>
<tr class="separator:ga812222f5f9eb4a9026c8ce89069ef8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d40beb0d805bd84dd9c1547450de48"><td class="memItemLeft" align="right" valign="top"><a id="ga31d40beb0d805bd84dd9c1547450de48"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::get_next_key</b> (uchar **key)</td></tr>
<tr class="separator:ga31d40beb0d805bd84dd9c1547450de48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ca6a85294c32bac8c69bea0c4e5fe1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaa7ca6a85294c32bac8c69bea0c4e5fe1">JOIN_CACHE_BKA_UNIQUE::init</a> ()</td></tr>
<tr class="separator:gaa7ca6a85294c32bac8c69bea0c4e5fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb1afc6322b69d01ea68b677b715ddc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7">JOIN_CACHE_BKA_UNIQUE::reset_cache</a> (bool for_writing)</td></tr>
<tr class="memdesc:gafb1afc6322b69d01ea68b677b715ddc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the join buffer for reading/writing: default implementation.  <a href="#gafb1afc6322b69d01ea68b677b715ddc7">More...</a><br /></td></tr>
<tr class="separator:gafb1afc6322b69d01ea68b677b715ddc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45dfdf58092c485f346a66afd4e124ad"><td class="memItemLeft" align="right" valign="top"><a id="ga45dfdf58092c485f346a66afd4e124ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::put_record_in_cache</b> ()</td></tr>
<tr class="separator:ga45dfdf58092c485f346a66afd4e124ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ffed7193009e4a49e1c66622217a0f"><td class="memItemLeft" align="right" valign="top"><a id="ga15ffed7193009e4a49e1c66622217a0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::get_record</b> ()</td></tr>
<tr class="separator:ga15ffed7193009e4a49e1c66622217a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc649f4ce5bb5be551fab670511e8b8"><td class="memItemLeft" align="right" valign="top"><a id="ga2fc649f4ce5bb5be551fab670511e8b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::skip_record_if_match</b> ()</td></tr>
<tr class="separator:ga2fc649f4ce5bb5be551fab670511e8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c98e95bbd633f5bd7df7c8bbbe4ed1"><td class="memItemLeft" align="right" valign="top"><a id="gac4c98e95bbd633f5bd7df7c8bbbe4ed1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::key_search</b> (uchar *key, uint key_len, uchar **key_ref_ptr)</td></tr>
<tr class="separator:gac4c98e95bbd633f5bd7df7c8bbbe4ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8212394416bc9e03f2b6ea4404e995fc"><td class="memItemLeft" align="right" valign="top"><a id="ga8212394416bc9e03f2b6ea4404e995fc"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::get_hash_idx</b> (uchar *key, uint key_len)</td></tr>
<tr class="separator:ga8212394416bc9e03f2b6ea4404e995fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb543f6524da72376a1d27a995f7559a"><td class="memItemLeft" align="right" valign="top"><a id="gabb543f6524da72376a1d27a995f7559a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::cleanup_hash_table</b> ()</td></tr>
<tr class="separator:gabb543f6524da72376a1d27a995f7559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afa1e2231c8090ecae73554fca37c41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga6afa1e2231c8090ecae73554fca37c41">JOIN_CACHE_BKA_UNIQUE::skip_index_tuple</a> (range_seq_t rseq, char *range_info)</td></tr>
<tr class="separator:ga6afa1e2231c8090ecae73554fca37c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c2a23d19df8e983c61ed2c25214c86d"><td class="memItemLeft" align="right" valign="top"><a id="ga1c2a23d19df8e983c61ed2c25214c86d"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::join_matching_records</b> (bool skip_last)</td></tr>
<tr class="separator:ga1c2a23d19df8e983c61ed2c25214c86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a69af2bfc11dc07fce9cdb261cdcd3"><td class="memItemLeft" align="right" valign="top"><a id="ga93a69af2bfc11dc07fce9cdb261cdcd3"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::check_all_match_flags_for_key</b> (uchar *key_chain_ptr)</td></tr>
<tr class="separator:ga93a69af2bfc11dc07fce9cdb261cdcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cacb8dfb5e5fad32b82fb0b8c572507"><td class="memItemLeft" align="right" valign="top"><a id="ga2cacb8dfb5e5fad32b82fb0b8c572507"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::get_next_key</b> (uchar **key)</td></tr>
<tr class="separator:ga2cacb8dfb5e5fad32b82fb0b8c572507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd031be055cee296d6629313a333b56f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gafd031be055cee296d6629313a333b56f">JOIN_CACHE_BKA_UNIQUE::check_match</a> (uchar *rec_ptr)</td></tr>
<tr class="separator:gafd031be055cee296d6629313a333b56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f722315c64ce97cff639d705107c660"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga7f722315c64ce97cff639d705107c660">JOIN::optimize</a> ()</td></tr>
<tr class="separator:ga7f722315c64ce97cff639d705107c660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa6edcfa6c4d934dd42d505d9de2fef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaeaa6edcfa6c4d934dd42d505d9de2fef">JOIN::update_equalities_for_sjm</a> ()</td></tr>
<tr class="separator:gaeaa6edcfa6c4d934dd42d505d9de2fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a9a63131b536315d16d122eed3102a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga61a9a63131b536315d16d122eed3102a">JOIN::set_prefix_tables</a> ()</td></tr>
<tr class="separator:ga61a9a63131b536315d16d122eed3102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d3829776ab95dee43086b5aa43b234"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga52d3829776ab95dee43086b5aa43b234">JOIN::set_semijoin_embedding</a> ()</td></tr>
<tr class="separator:ga52d3829776ab95dee43086b5aa43b234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9dfedea0a797bc7aa7f2625ee768b1"><td class="memItemLeft" align="right" valign="top"><a id="gafb9dfedea0a797bc7aa7f2625ee768b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN::flatten_subqueries</b> ()</td></tr>
<tr class="separator:gafb9dfedea0a797bc7aa7f2625ee768b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdbb72be9500a59e81e9e738607cb3a"><td class="memItemLeft" align="right" valign="top"><a id="gadcdbb72be9500a59e81e9e738607cb3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN::remove_subq_pushed_predicates</b> (<a class="el" href="class_item.html">Item</a> **where)</td></tr>
<tr class="separator:gadcdbb72be9500a59e81e9e738607cb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bf64a03ec666f565627fbb48ba4677"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga92bf64a03ec666f565627fbb48ba4677">JOIN::generate_derived_keys</a> ()</td></tr>
<tr class="memdesc:ga92bf64a03ec666f565627fbb48ba4677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add keys to derived tables'/views' result tables in a list.  <a href="#ga92bf64a03ec666f565627fbb48ba4677">More...</a><br /></td></tr>
<tr class="separator:ga92bf64a03ec666f565627fbb48ba4677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54392f4f40ec2c57b8263f22fa3d4296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga54392f4f40ec2c57b8263f22fa3d4296">JOIN::drop_unused_derived_keys</a> ()</td></tr>
<tr class="memdesc:ga54392f4f40ec2c57b8263f22fa3d4296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop unused keys for each materialized derived table/view.  <a href="#ga54392f4f40ec2c57b8263f22fa3d4296">More...</a><br /></td></tr>
<tr class="separator:ga54392f4f40ec2c57b8263f22fa3d4296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4408ac7e9a04a594110d2009cfcd54c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga4408ac7e9a04a594110d2009cfcd54c9">JOIN::cache_const_exprs</a> ()</td></tr>
<tr class="separator:ga4408ac7e9a04a594110d2009cfcd54c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b521ce8c8cc3192c6ba5f38af9929b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga1b521ce8c8cc3192c6ba5f38af9929b4">JOIN::replace_item_field</a> (const char *field_name, <a class="el" href="class_item.html">Item</a> *new_item)</td></tr>
<tr class="separator:ga1b521ce8c8cc3192c6ba5f38af9929b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ceaa82804d41e083dee70b3a2a9be55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga9ceaa82804d41e083dee70b3a2a9be55">JOIN::optimize_fts_query</a> ()</td></tr>
<tr class="separator:ga9ceaa82804d41e083dee70b3a2a9be55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab413c6ac95a4742dcf1405e3256fae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaab413c6ac95a4742dcf1405e3256fae6">JOIN::optimize_fts_limit_query</a> ()</td></tr>
<tr class="separator:gaab413c6ac95a4742dcf1405e3256fae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab466b49a22220854ef8f11a2c4a2ae8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gab466b49a22220854ef8f11a2c4a2ae8a">JOIN::decide_subquery_strategy</a> ()</td></tr>
<tr class="separator:gab466b49a22220854ef8f11a2c4a2ae8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7029269a3541af8dee4cfe59e16fd3de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga7029269a3541af8dee4cfe59e16fd3de">JOIN::compare_costs_of_subquery_strategies</a> (<a class="el" href="class_item__exists__subselect.html#aa110ca13dba0d9c620f5f72e6bad798e">Item_exists_subselect::enum_exec_method</a> *method)</td></tr>
<tr class="separator:ga7029269a3541af8dee4cfe59e16fd3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4f64b9b280796d9abe945b2eda94ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaef4f64b9b280796d9abe945b2eda94ac">JOIN::refine_best_rowcount</a> ()</td></tr>
<tr class="separator:gaef4f64b9b280796d9abe945b2eda94ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e09d71987062663db1836d651ec4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gad4e09d71987062663db1836d651ec4d4">JOIN::reset</a> ()</td></tr>
<tr class="separator:gad4e09d71987062663db1836d651ec4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6214b5001b6cf6a328981401c253f6bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga6214b5001b6cf6a328981401c253f6bb">JOIN::prepare_result</a> (<a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; **columns_list)</td></tr>
<tr class="separator:ga6214b5001b6cf6a328981401c253f6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6daf5ee65a55d8b5f6ef6c4c35f3a90a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga6daf5ee65a55d8b5f6ef6c4c35f3a90a">JOIN::explain</a> ()</td></tr>
<tr class="separator:ga6daf5ee65a55d8b5f6ef6c4c35f3a90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d76654da99be4012095c016ea5d4d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaf2d76654da99be4012095c016ea5d4d2">JOIN::destroy</a> ()</td></tr>
<tr class="separator:gaf2d76654da99be4012095c016ea5d4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2786cd0e21a0be3b8a368112de01024b"><td class="memItemLeft" align="right" valign="top"><a id="ga2786cd0e21a0be3b8a368112de01024b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN::cleanup_item_list</b> (<a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="structitems.html">items</a>) const</td></tr>
<tr class="separator:ga2786cd0e21a0be3b8a368112de01024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c1cf0874f4bda777557d012148e059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gae9c1cf0874f4bda777557d012148e059">JOIN::get_best_combination</a> ()</td></tr>
<tr class="separator:gae9c1cf0874f4bda777557d012148e059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf940ffededb5c2eb1444ac13ef7775b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaaf940ffededb5c2eb1444ac13ef7775b">JOIN::set_access_methods</a> ()</td></tr>
<tr class="separator:gaaf940ffededb5c2eb1444ac13ef7775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ec58d0faabade96e5378b0e5a1c2c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gab7ec58d0faabade96e5378b0e5a1c2c2">JOIN::set_semijoin_info</a> ()</td></tr>
<tr class="separator:gab7ec58d0faabade96e5378b0e5a1c2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b423a4f37a7b1957744a2c82842d0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga98b423a4f37a7b1957744a2c82842d0e">JOIN::setup_materialized_table</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, uint tableno, const <a class="el" href="structst__position.html">POSITION</a> *inner_pos, <a class="el" href="structst__position.html">POSITION</a> *sjm_pos)</td></tr>
<tr class="separator:ga98b423a4f37a7b1957744a2c82842d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae913870950feb0d927de9b53963f0a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gae913870950feb0d927de9b53963f0a6a">st_join_table::cleanup</a> ()</td></tr>
<tr class="separator:gae913870950feb0d927de9b53963f0a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1dc44a9fcd103cc014e05e30faec197"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gae1dc44a9fcd103cc014e05e30faec197">st_join_table::sjm_query_block_id</a> () const</td></tr>
<tr class="separator:gae1dc44a9fcd103cc014e05e30faec197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga504ef4abccd4c3f837f2cef119eb5666"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga504ef4abccd4c3f837f2cef119eb5666">st_join_table::and_with_jt_and_sel_condition</a> (<a class="el" href="class_item.html">Item</a> *tmp_cond, uint line)</td></tr>
<tr class="separator:ga504ef4abccd4c3f837f2cef119eb5666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59504ff5091d87102a2f2a5d4649ec46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga59504ff5091d87102a2f2a5d4649ec46">st_join_table::and_with_condition</a> (<a class="el" href="class_item.html">Item</a> *tmp_cond, uint line)</td></tr>
<tr class="separator:ga59504ff5091d87102a2f2a5d4649ec46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393037fbd019d460dbafdcdc1e8786d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga393037fbd019d460dbafdcdc1e8786d7">st_join_table::unified_condition</a> () const</td></tr>
<tr class="separator:ga393037fbd019d460dbafdcdc1e8786d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62d47da29f3853e87b1069ee5c1ff21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gaa62d47da29f3853e87b1069ee5c1ff21">JOIN::join_free</a> ()</td></tr>
<tr class="separator:gaa62d47da29f3853e87b1069ee5c1ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d407ea5f5966580f25da80dd4e9c35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga52d407ea5f5966580f25da80dd4e9c35">JOIN::cleanup</a> (bool full)</td></tr>
<tr class="separator:ga52d407ea5f5966580f25da80dd4e9c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140c4ff912190f1c0f6279897103a720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga140c4ff912190f1c0f6279897103a720">JOIN::alloc_func_list</a> ()</td></tr>
<tr class="separator:ga140c4ff912190f1c0f6279897103a720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae713fbd3faf5b5aefad41408fd11685a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#gae713fbd3faf5b5aefad41408fd11685a">JOIN::make_sum_func_list</a> (<a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="class_j_o_i_n.html#abc71e8a6e6c7fa4db00cde12ba20f654">all_fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;send_fields, bool before_group_by, bool recompute=FALSE)</td></tr>
<tr class="separator:gae713fbd3faf5b5aefad41408fd11685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076b7e6736c0bf0a9e9bf7542e4746c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga076b7e6736c0bf0a9e9bf7542e4746c8">JOIN::rollup_process_const_fields</a> ()</td></tr>
<tr class="separator:ga076b7e6736c0bf0a9e9bf7542e4746c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e92b14b52e210ce225ad4c0312f9bca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga7e92b14b52e210ce225ad4c0312f9bca">JOIN::rollup_make_fields</a> (<a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;<a class="el" href="class_j_o_i_n.html#abc71e8a6e6c7fa4db00cde12ba20f654">all_fields</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;fields, <a class="el" href="class_item__sum.html">Item_sum</a> ***func)</td></tr>
<tr class="separator:ga7e92b14b52e210ce225ad4c0312f9bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91edca802204d71161d32b208ae3d969"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga91edca802204d71161d32b208ae3d969">JOIN::clear</a> ()</td></tr>
<tr class="separator:ga91edca802204d71161d32b208ae3d969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga573c4df23fc730283f00f922bdf80cc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga573c4df23fc730283f00f922bdf80cc3">JOIN::change_result</a> (select_result *result)</td></tr>
<tr class="separator:ga573c4df23fc730283f00f922bdf80cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d12748a936ddf29bf434f926bff493b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga3d12748a936ddf29bf434f926bff493b">JOIN::make_tmp_tables_info</a> ()</td></tr>
<tr class="separator:ga3d12748a936ddf29bf434f926bff493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb6b434229049cde9f65d25f59709f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___optimizer.html#ga5cb6b434229049cde9f65d25f59709f2">JOIN::add_sorting_to_table</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="class_j_o_i_n_1_1_o_r_d_e_r__with__src.html">ORDER_with_src</a> *<a class="el" href="class_j_o_i_n.html#ac06839682aae707b0e1d4fafd53abaf5">order</a>)</td></tr>
<tr class="memdesc:ga5cb6b434229049cde9f65d25f59709f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="class_filesort.html">Filesort</a> object to the given table to sort if with filesort.  <a href="#ga5cb6b434229049cde9f65d25f59709f2">More...</a><br /></td></tr>
<tr class="separator:ga5cb6b434229049cde9f65d25f59709f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga174d79a5aef2a8abd1caec143b42837e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174d79a5aef2a8abd1caec143b42837e">&#9670;&nbsp;</a></span>actual_key_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint actual_key_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__key.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns key flags depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_info</td><td>pointer to KEY structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>key flags. </dd></dl>

</div>
</div>
<a id="gadbf1b1ecda6374b7b3a32b5454d09876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbf1b1ecda6374b7b3a32b5454d09876">&#9670;&nbsp;</a></span>actual_key_parts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint actual_key_parts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__key.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of key parts depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_info</td><td>pointer to KEY structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of key parts. </dd></dl>

</div>
</div>
<a id="ga849187ffe748146555424fe615634bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga849187ffe748146555424fe615634bf1">&#9670;&nbsp;</a></span>add_found_match_trig_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_item.html">Item</a>* add_found_match_trig_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>root_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build a predicate guarded by match variables for embedding outer joins. The function recursively adds guards for predicate cond assending from tab to the first inner table next embedding nested outer join and so on until it reaches root_tab (root_tab can be 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>the first inner table for most nested outer join </td></tr>
    <tr><td class="paramname">cond</td><td>the predicate to be guarded (must be set) </td></tr>
    <tr><td class="paramname">root_tab</td><td>the first inner table to stop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>pointer to the guarded predicate, if success</li>
<li>0, otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabc625b885fcfa2fa058cce5480ea989b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc625b885fcfa2fa058cce5480ea989b">&#9670;&nbsp;</a></span>add_group_and_distinct_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void add_group_and_distinct_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Discover the indexes that might be used for GROUP BY or DISTINCT queries.</p>
<p>If the query has a GROUP BY clause, find all indexes that contain all GROUP BY fields, and add those indexes to join_tab-&gt;const_keys and join_tab-&gt;keys.</p>
<p>If the query has a DISTINCT clause, find all indexes that contain all SELECT fields, and add those indexes to join_tab-&gt;const_keys and join_tab-&gt;keys. This allows later on such queries to be processed by a <a class="el" href="class_q_u_i_c_k___g_r_o_u_p___m_i_n___m_a_x___s_e_l_e_c_t.html">QUICK_GROUP_MIN_MAX_SELECT</a>.</p>
<p>Note that indexes that are not usable for resolving GROUP BY/DISTINCT may also be added in some corner cases. For example, an index covering 'a' and 'b' is not usable for the following query but is still added: "SELECT DISTINCT a+b FROM t1". This is not a big issue because a) although the optimizer will consider using the index, it will not chose it (so minor calculation cost added but not wrong result) and b) it applies only to corner cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td></td></tr>
    <tr><td class="paramname">join_tab</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ga125ad0b958d2c3716bbb8431fde578f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga125ad0b958d2c3716bbb8431fde578f7">&#9670;&nbsp;</a></span>add_key_equal_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void add_key_equal_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_key__field.html">Key_field</a> **&#160;</td>
          <td class="paramname"><em>key_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>and_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>field_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> **&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>usable_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__sargable__param.html">SARGABLE_PARAM</a> **&#160;</td>
          <td class="paramname"><em>sargables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add possible keys to array of possible keys originated from a simple predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_fields</td><td>Pointer to add key, if usable </td></tr>
    <tr><td class="paramname">and_level</td><td>And level, to be stored in <a class="el" href="struct_key__field.html" title="Used when finding key fields. ">Key_field</a> </td></tr>
    <tr><td class="paramname">cond</td><td>Condition predicate </td></tr>
    <tr><td class="paramname">field</td><td><a class="el" href="class_field.html">Field</a> used in comparision </td></tr>
    <tr><td class="paramname">eq_func</td><td>True if we used =, &lt;=&gt; or IS NULL </td></tr>
    <tr><td class="paramname">value</td><td>Value used for comparison with field Is NULL for BETWEEN and IN </td></tr>
    <tr><td class="paramname">usable_tables</td><td>Tables which can be used for key optimization </td></tr>
    <tr><td class="paramname">sargables</td><td>IN/OUT Array of found sargable candidates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If field items f1 and f2 belong to the same multiple equality and a key is added for f1, the the same key is added for f2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>key_fields is incremented if we stored a key in the array </dd></dl>

</div>
</div>
<a id="ga51521ef9ae68c5305be5d9ef2a643a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51521ef9ae68c5305be5d9ef2a643a5d">&#9670;&nbsp;</a></span>add_key_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void add_key_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_key__field.html">Key_field</a> **&#160;</td>
          <td class="paramname"><em>key_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>and_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__func.html">Item_func</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>usable_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__sargable__param.html">SARGABLE_PARAM</a> **&#160;</td>
          <td class="paramname"><em>sargables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a possible key to array of possible keys if it's usable as a key</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_fields</td><td>Pointer to add key, if usable </td></tr>
    <tr><td class="paramname">and_level</td><td>And level, to be stored in <a class="el" href="struct_key__field.html" title="Used when finding key fields. ">Key_field</a> </td></tr>
    <tr><td class="paramname">cond</td><td>Condition predicate </td></tr>
    <tr><td class="paramname">field</td><td><a class="el" href="class_field.html">Field</a> used in comparision </td></tr>
    <tr><td class="paramname">eq_func</td><td>True if we used =, &lt;=&gt; or IS NULL </td></tr>
    <tr><td class="paramname">value</td><td>Array of values used for comparison with field </td></tr>
    <tr><td class="paramname">num_values</td><td>Number of elements in the array of values </td></tr>
    <tr><td class="paramname">usable_tables</td><td>Tables which can be used for key optimization </td></tr>
    <tr><td class="paramname">sargables</td><td>IN/OUT Array of found sargable candidates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If we are doing a NOT NULL comparison on a NOT NULL field in a outer join table, we store this to be able to do not exists optimization later.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>key_fields is incremented if we stored a key in the array </dd></dl>

</div>
</div>
<a id="ga774dd8254e1c2ed55a9adf69e4657046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga774dd8254e1c2ed55a9adf69e4657046">&#9670;&nbsp;</a></span>add_not_null_conds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void add_not_null_conds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add to join_tab[i]-&gt;condition() "table.field IS NOT NULL" conditions we've inferred from ref/eq_ref access performed.</p>
<p>This function is a part of "Early NULL-values filtering for ref access" optimization.</p>
<p>Example of this optimization: For query SELECT * FROM t1,t2 WHERE t2.key=t1.field <br />
 and plan " any-access(t1), ref(t2.key=t1.field) " <br />
 add "t1.field IS NOT NULL" to t1's table condition. <br />
 Description of the optimization:</p>
<p>We look through equalities choosen to perform ref/eq_ref access, pick equalities that have form "tbl.part_of_key = othertbl.field" (where othertbl is a non-const table and othertbl.field may be NULL) and add them to conditions on correspoding tables (othertbl in this example).</p>
<p>Exception from that is the case when referred_tab-&gt;join != join. I.e. don't add NOT NULL constraints from any embedded subquery. Consider this query: </p><div class="fragment"><div class="line">SELECT A.f2 FROM t1 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t2 A ON A.f2 = f1</div><div class="line">WHERE A.f3=(SELECT MIN(f3) FROM  t2 C WHERE A.f4 = C.f4) OR A.f3 IS NULL;</div></div><!-- fragment --><p> Here condition A.f3 IS NOT NULL is going to be added to the WHERE condition of the embedding query. Another example: SELECT * FROM t10, t11 WHERE (t10.a &lt; 10 OR t10.a IS NULL) AND t11.b &lt;=&gt; t10.b AND (t11.a = (SELECT MAX(a) FROM t12 WHERE t12.b = t10.a )); Here condition t10.a IS NOT NULL is going to be added. In both cases addition of NOT NULL condition will erroneously reject some rows of the result set. referred_tab-&gt;join != join constraint would disallow such additions.</p>
<p>This optimization doesn't affect the choices that ref, range, or join optimizer make. This was intentional because this was added after 4.1 was GA.</p>
<p>Implementation overview</p><ol type="1">
<li><a class="el" href="group___query___optimizer.html#ga28477ddc155910db0971a61f1cf6bd66">update_ref_and_keys()</a> accumulates info about null-rejecting predicates in in <a class="el" href="struct_key__field.html#ad15eb695b878f6436d97bcc8f37fad20">Key_field::null_rejecting</a> 1.1 add_key_part saves these to <a class="el" href="class_key__use.html">Key_use</a>.</li>
<li>create_ref_for_key copies them to TABLE_REF.</li>
<li>add_not_null_conds adds "x IS NOT NULL" to join_tab-&gt;m_condition of appropiate JOIN_TAB members. </li>
</ol>

</div>
</div>
<a id="gac55d30d32086560224c62b7c237f79e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac55d30d32086560224c62b7c237f79e1">&#9670;&nbsp;</a></span>add_ref_to_table_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool add_ref_to_table_cond </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a condition for a const reference and add this to the currenct select for the table. </p>

</div>
</div>
<a id="ga5cb6b434229049cde9f65d25f59709f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cb6b434229049cde9f65d25f59709f2">&#9670;&nbsp;</a></span>add_sorting_to_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::add_sorting_to_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n_1_1_o_r_d_e_r__with__src.html">ORDER_with_src</a> *&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add <a class="el" href="class_filesort.html">Filesort</a> object to the given table to sort if with filesort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>the JOIN_TAB object to attach created <a class="el" href="class_filesort.html">Filesort</a> object to </td></tr>
    <tr><td class="paramname">order</td><td><a class="el" href="class_list.html">List</a> of expressions to sort the table by</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function moves tab-&gt;select, if any, to filesort-&gt;select</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on OOM </dd></dl>

</div>
</div>
<a id="ga5932344e1185abf63788970856f45766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5932344e1185abf63788970856f45766">&#9670;&nbsp;</a></span>alloc_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_CACHE::alloc_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate memory for a join buffer.</p>
<p>The function allocates a lump of memory for the join buffer. The size of the allocated memory is 'buff_size' bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>false if success, otherwise true. </dd></dl>

</div>
</div>
<a id="ga140c4ff912190f1c0f6279897103a720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga140c4ff912190f1c0f6279897103a720">&#9670;&nbsp;</a></span>alloc_func_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::alloc_func_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an array of pointers to sum_functions to speed up sum_func calculation.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3c0a5624f789fb0bf0c5fc5ec057de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3c0a5624f789fb0bf0c5fc5ec057de9">&#9670;&nbsp;</a></span>and_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool and_conditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> **&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extend e1 by AND'ing e2 to the condition e1 points to. The resulting condition is fixed. Requirement: the input Items must already have been fixed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e1</td><td>Pointer to condition that will be extended with e2 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">e2</td><td>Condition that will extend e1</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error, in which case e1 remains unchanged </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59504ff5091d87102a2f2a5d4649ec46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59504ff5091d87102a2f2a5d4649ec46">&#9670;&nbsp;</a></span>and_with_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_TAB::and_with_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>add_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extend join_tab-&gt;cond by AND'ing add_cond to it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">add_cond</td><td>The condition to AND with the existing cond for this JOIN_TAB </td></tr>
    <tr><td class="paramname">line</td><td>Code line this method was called from</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga504ef4abccd4c3f837f2cef119eb5666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga504ef4abccd4c3f837f2cef119eb5666">&#9670;&nbsp;</a></span>and_with_jt_and_sel_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_TAB::and_with_jt_and_sel_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>add_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extend join_tab-&gt;m_condition and join_tab-&gt;select-&gt;cond by AND'ing add_cond to them</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">add_cond</td><td>The condition to AND with the existing conditions </td></tr>
    <tr><td class="paramname">line</td><td>Code line this method was called from</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8661280e3da40b2c581ec758c50e1979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8661280e3da40b2c581ec758c50e1979">&#9670;&nbsp;</a></span>aux_buffer_incr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint JOIN_CACHE_BKA::aux_buffer_incr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the increment of the MRR buffer for a record write </p>

<p>Reimplemented from <a class="el" href="class_j_o_i_n___c_a_c_h_e.html">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="gaef7343f0416360c14c6134867b347c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef7343f0416360c14c6134867b347c83">&#9670;&nbsp;</a></span>aux_buffer_min_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint JOIN_CACHE_BKA::aux_buffer_min_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the minimume size for the MRR buffer</p>
<p>Calculate the minimume size for the MRR buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The minumum size that must be allocated for the MRR buffer </dd></dl>

<p>Reimplemented from <a class="el" href="class_j_o_i_n___c_a_c_h_e.html#a22f1df0156fa6d176df6d6e6d4b84916">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="gadaa0a23c55c6f007481261b1b22e78d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaa0a23c55c6f007481261b1b22e78d1">&#9670;&nbsp;</a></span>build_bitmap_for_nested_joins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint build_bitmap_for_nested_joins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>first_unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign each nested join structure a bit in nested_join_map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_list</td><td><a class="el" href="class_list.html">List</a> of tables </td></tr>
    <tr><td class="paramname">first_unused</td><td>Number of first unused bit in nested_join_map before the call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is called after <a class="el" href="group___query___optimizer.html#ga437d0af0465d8ebf56f66f8e2ecfd926">simplify_joins()</a>, when there are no redundant nested joins. We cannot have more nested joins in a query block than there are tables, so as long as the number of bits in nested_join_map is not less than the maximum number of tables in a query block, nested_join_map can never overflow.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>First unused bit in nested_join_map after the call. </dd></dl>

</div>
</div>
<a id="gaa6b7012eda6c33a9a9e734948853a334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6b7012eda6c33a9a9e734948853a334">&#9670;&nbsp;</a></span>build_equal_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_item.html">Item</a>* build_equal_items </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>inherited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> **&#160;</td>
          <td class="paramname"><em>cond_equal_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build multiple equalities for a condition and all on expressions that inherit these multiple equalities.</p>
<p>The function first applies the build_equal_items_for_cond function to build all multiple equalities for condition cond utilizing equalities referred through the parameter inherited. The extended set of equalities is returned in the structure referred by the cond_equal_ref parameter. After this the function calls itself recursively for all on expressions whose direct references can be found in join_list and who inherit directly the multiple equalities just having built.</p>
<dl class="section note"><dt>Note</dt><dd>The on expression used in an outer join operation inherits all equalities from the on expression of the embedding join, if there is any, or otherwise - from the where condition. This fact is not obvious, but presumably can be proved. Consider the following query: <div class="fragment"><div class="line">SELECT * FROM (t1,t2) LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> (t3,t4) ON t1.a=t3.a AND t2.a=t4.a</div><div class="line">  WHERE t1.a=t2.a;</div></div><!-- fragment --> If the on expression in the query inherits =(t1.a,t2.a), then we can build the multiple equality =(t1.a,t2.a,t3.a,t4.a) that infers the equality t3.a=t4.a. Although the on expression t1.a=t3.a AND t2.a=t4.a AND t3.a=t4.a is not equivalent to the one in the query the latter can be replaced by the former: the new query will return the same result set as the original one.</dd></dl>
<p>Interesting that multiple equality =(t1.a,t2.a,t3.a,t4.a) allows us to use t1.a=t3.a AND t3.a=t4.a under the on condition: </p><div class="fragment"><div class="line">SELECT * FROM (t1,t2) LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> (t3,t4) ON t1.a=t3.a AND t3.a=t4.a</div><div class="line">  WHERE t1.a=t2.a</div></div><!-- fragment --><p> This query equivalent to: </p><div class="fragment"><div class="line">SELECT * FROM (t1 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> (t3,t4) ON t1.a=t3.a AND t3.a=t4.a),t2</div><div class="line">  WHERE t1.a=t2.a</div></div><!-- fragment --><p> Similarly the original query can be rewritten to the query: </p><div class="fragment"><div class="line">SELECT * FROM (t1,t2) LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> (t3,t4) ON t2.a=t4.a AND t3.a=t4.a</div><div class="line">  WHERE t1.a=t2.a</div></div><!-- fragment --><p> that is equivalent to: </p><div class="fragment"><div class="line">SELECT * FROM (t2 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> (t3,t4)ON t2.a=t4.a AND t3.a=t4.a), t1</div><div class="line">  WHERE t1.a=t2.a</div></div><!-- fragment --><p> Thus, applying equalities from the where condition we basically can get more freedom in performing join operations. Althogh we don't use this property now, it probably makes sense to use it in the future. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>condition to build the multiple equalities for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inherited</td><td>path to all inherited multiple equality items </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">do_inherit</td><td>whether or not to inherit equalities from other parts of the condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list of join tables to which the condition refers to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_equal_ref</td><td>pointer to the structure to place built equalities in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the transformed condition containing multiple equalities </dd></dl>

</div>
</div>
<a id="ga7e32afb6ec083c342da20ea3843952cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e32afb6ec083c342da20ea3843952cc">&#9670;&nbsp;</a></span>build_equal_items_for_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_item.html">Item</a>* build_equal_items_for_cond </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>inherited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace all equality predicates in a condition by multiple equality items.</p>
<p>At each 'and' level the function detects items for equality predicates and replaced them by a set of multiple equality items of class <a class="el" href="class_item__equal.html">Item_equal</a>, taking into account inherited equalities from upper levels. If an equality predicate is used not in a conjunction it's just replaced by a multiple equality predicate. For each 'and' level the function set a pointer to the inherited multiple equalities in the cond_equal field of the associated object of the type <a class="el" href="class_item__cond__and.html">Item_cond_and</a>. The function also traverses the cond tree and and for each field reference sets a pointer to the multiple equality item containing the field, if there is any. If this multiple equality equates fields to a constant the function replaces the field reference by the constant in the cases when the field is not of a string type or when the field reference is just an argument of a comparison predicate. The function also determines the maximum number of members in equality lists of each <a class="el" href="class_item__cond__and.html">Item_cond_and</a> object assigning it to thd-&gt;lex-&gt;current_select-&gt;max_equal_elems.</p>
<dl class="section note"><dt>Note</dt><dd>Multiple equality predicate =(f1,..fn) is equivalent to the conjuction of f1=f2, .., fn-1=fn. It substitutes any inference from these equality predicates that is equivalent to the conjunction. Thus, =(a1,a2,a3) can substitute for ((a1=a3) AND (a2=a3) AND (a2=a1)) as it is equivalent to ((a1=a2) AND (a2=a3)). The function always makes a substitution of all equality predicates occured in a conjuction for a minimal set of multiple equality predicates. This set can be considered as a canonical representation of the sub-conjunction of the equality predicates. E.g. (t1.a=t2.b AND t2.b&gt;5 AND t1.a=t3.c) is replaced by (=(t1.a,t2.b,t3.c) AND t2.b&gt;5), not by (=(t1.a,t2.b) AND =(t1.a,t3.c) AND t2.b&gt;5); while (t1.a=t2.b AND t2.b&gt;5 AND t3.c=t4.d) is replaced by (=(t1.a,t2.b) AND =(t3.c=t4.d) AND t2.b&gt;5), but if additionally =(t4.d,t2.b) is inherited, it will be replaced by (=(t1.a,t2.b,t3.c,t4.d) AND t2.b&gt;5)</dd></dl>
<p>The function performs the substitution in a recursive descent by the condtion tree, passing to the next AND level a chain of multiple equality predicates which have been built at the upper levels. The <a class="el" href="class_item__equal.html">Item_equal</a> items built at the level are attached to other non-equality conjucts as a sublist. The pointer to the inherited multiple equalities is saved in the and condition object (<a class="el" href="class_item__cond__and.html">Item_cond_and</a>). This chain allows us for any field reference occurence easyly to find a multiple equality that must be held for this occurence. For each AND level we do the following:</p><ul>
<li>scan it for all equality predicate (=) items</li>
<li>join them into disjoint <a class="el" href="class_item__equal.html">Item_equal()</a> groups</li>
<li>process the included OR conditions recursively to do the same for lower AND levels.</li>
</ul>
<p>We need to do things in this order as lower AND levels need to know about all possible <a class="el" href="class_item__equal.html">Item_equal</a> objects in upper levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">cond</td><td>condition(expression) where to make replacement </td></tr>
    <tr><td class="paramname">inherited</td><td>path to all inherited multiple equality items </td></tr>
    <tr><td class="paramname">do_inherit</td><td>whether or not to inherit equalities from other parts of the condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the transformed condition </dd></dl>

</div>
</div>
<a id="ga4408ac7e9a04a594110d2009cfcd54c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4408ac7e9a04a594110d2009cfcd54c9">&#9670;&nbsp;</a></span>cache_const_exprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::cache_const_exprs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cache constant expressions in WHERE, HAVING, ON conditions.</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is run after conditions have been pushed down to individual tables, so transformation is applied to JOIN_TAB::condition and not to the WHERE condition. </dd></dl>

</div>
</div>
<a id="gaa978828bfe7be091fb76e1c5da80d644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa978828bfe7be091fb76e1c5da80d644">&#9670;&nbsp;</a></span>calc_group_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calc_group_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>calc how big buffer we need for comparing group entries. </p>

</div>
</div>
<a id="gab0ca922593fe6b15db19791f8133f407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0ca922593fe6b15db19791f8133f407">&#9670;&nbsp;</a></span>calc_used_field_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calc_used_field_length </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find how much space the prevous read not const tables takes in cache. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000118">Todo:</a></b></dt><dd>why don't we count the rowids that we might need to store when using DuplicateElimination? </dd></dl>

</div>
</div>
<a id="ga76ca5e962b784c066559515c5286e6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ca5e962b784c066559515c5286e6c5">&#9670;&nbsp;</a></span>calculate_materialization_costs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void calculate_materialization_costs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>sj_nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_semijoin__mat__optimize.html">Semijoin_mat_optimize</a> *&#160;</td>
          <td class="paramname"><em>sjm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For {semijoin,subquery} materialization: calculates various cost information, based on a plan in join-&gt;best_positions covering the to-be-materialized query block and only this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td><a class="el" href="class_j_o_i_n.html">JOIN</a> where plan can be found </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sj_nest</td><td>sj materialization nest (NULL if subquery materialization) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n_tables</td><td>number of to-be-materialized tables </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sjm</td><td>where computed costs will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>that this function modifies join-&gt;map2table, which has to be filled correctly later. </dd></dl>

</div>
</div>
<a id="ga573c4df23fc730283f00f922bdf80cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga573c4df23fc730283f00f922bdf80cc3">&#9670;&nbsp;</a></span>change_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::change_result </td>
          <td>(</td>
          <td class="paramtype">select_result *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>change select_result object of <a class="el" href="class_j_o_i_n.html">JOIN</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>new select_result object</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7cdf3c010b4cf2965bf44a492978ae9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cdf3c010b4cf2965bf44a492978ae9f">&#9670;&nbsp;</a></span>check_equality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool check_equality </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *&#160;</td>
          <td class="paramname"><em>eq_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Eliminate row equalities and form multiple equalities predicates.</p>
<p>This function checks whether the item is a simple equality i.e. the one that equates a field with another field or a constant (field=field_item or field=constant_item), or, a row equality. For a simple equality the function looks for a multiple equality in the lists referenced directly or indirectly by cond_equal inferring the given simple equality. If it doesn't find any, it builds/expands multiple equality that covers the predicate. Row equalities are eliminated substituted for conjunctive regular equalities which are treated in the same way as original equality predicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">item</td><td>predicate to process </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities that must hold together with the predicate </td></tr>
    <tr><td class="paramname">eq_list</td><td>results of conversions of row equalities that are not simple enough to form multiple equalities</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if re-writing rules have been applied </td></tr>
    <tr><td class="paramname">FALSE</td><td>otherwise, i.e. if the predicate is not an equality, or, if the equality is neither a simple one nor a row equality, or, if the procedure fails by a fatal error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the equality was created by IN-&gt;EXISTS, it may be removed later by subquery materialization. So we don't mix this possibly temporary equality with others; if we let it go into a multiple-equality (<a class="el" href="class_item__equal.html">Item_equal</a>), then we could not remove it later. There is however an exception: if the outer expression is a constant, it is safe to leave the equality even in materialization; all it can do is preventing NULL/FALSE distinction but if such distinction mattered the equality would be in a triggered condition so we would not come to this function. And injecting constants is good because it makes the materialized table smaller. </dd></dl>

</div>
</div>
<a id="gafd031be055cee296d6629313a333b56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd031be055cee296d6629313a333b56f">&#9670;&nbsp;</a></span>check_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_CACHE_BKA_UNIQUE::check_match </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>rec_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> matching to a partial join record from the join buffer, an implementation specialized for <a class="el" href="class_j_o_i_n___c_a_c_h_e___b_k_a___u_n_i_q_u_e.html">JOIN_CACHE_BKA_UNIQUE</a>. Only <a class="el" href="class_j_o_i_n___c_a_c_h_e___b_k_a___u_n_i_q_u_e.html">JOIN_CACHE_BKA_UNIQUE</a> needs that, because it's the only cache using distinct keys. <a class="el" href="class_j_o_i_n___c_a_c_h_e___b_k_a.html">JOIN_CACHE_BKA</a>, on the other hand, does one key lookup per cached record, so can take a per-record individualized decision for the pushed index condition as soon as it has the index tuple. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#ga6afa1e2231c8090ecae73554fca37c41">JOIN_CACHE_BKA_UNIQUE::skip_index_tuple</a> </dd>
<dd>
JOIN_CACHE::check_match </dd></dl>

<p>Reimplemented from <a class="el" href="class_j_o_i_n___c_a_c_h_e.html">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="ga86286130cb5f18c54b9387ccc74cd3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86286130cb5f18c54b9387ccc74cd3c5">&#9670;&nbsp;</a></span>check_row_equality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool check_row_equality </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>left_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__row.html">Item_row</a> *&#160;</td>
          <td class="paramname"><em>right_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; *&#160;</td>
          <td class="paramname"><em>eq_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert row equalities into a conjunction of regular equalities.</p>
<p>The function converts a row equality of the form (E1,...,En)=(E'1,...,E'n) into a list of equalities E1=E'1,...,En=E'n. For each of these equalities Ei=E'i the function checks whether it is a simple equality or a row equality. If it is a simple equality it is used to expand multiple equalities of cond_equal. If it is a row equality it converted to a sequence of equalities between row elements. If Ei=E'i is neither a simple equality nor a row equality the item for this predicate is added to eq_list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">left_row</td><td>left term of the row equality to be processed </td></tr>
    <tr><td class="paramname">right_row</td><td>right term of the row equality to be processed </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities that must hold together with the predicate </td></tr>
    <tr><td class="paramname">eq_list</td><td>results of conversions of row equalities that are not simple enough to form multiple equalities</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if conversion has succeeded (no fatal error) </td></tr>
    <tr><td class="paramname">FALSE</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f38c840626fc6f58b10876246a50cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f38c840626fc6f58b10876246a50cfa">&#9670;&nbsp;</a></span>check_simple_equality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool check_simple_equality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>left_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>right_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> whether an equality can be used to build multiple equalities.</p>
<p>This function first checks whether the equality (left_item=right_item) is a simple equality i.e. the one that equates a field with another field or a constant (field=field_item or field=const_item). If this is the case the function looks for a multiple equality in the lists referenced directly or indirectly by cond_equal inferring the given simple equality. If it doesn't find any, it builds a multiple equality that covers the predicate, i.e. the predicate can be inferred from this multiple equality. The built multiple equality could be obtained in such a way: create a binary multiple equality equivalent to the predicate, then merge it, if possible, with one of old multiple equalities. This guarantees that the set of multiple equalities covering equality predicates will be minimal.</p>
<p>EXAMPLE: For the where condition </p><div class="fragment"><div class="line">WHERE <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>=<a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a> AND <a class="code" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>=c AND</div><div class="line">      (b=2 OR f=e)</div></div><!-- fragment --><p> the check_equality will be called for the following equality predicates a=b, b=c, b=2 and f=e.</p><ul>
<li>For a=b it will be called with *cond_equal=(0,[]) and will transform cond_equal into (0,[<a class="el" href="class_item__equal.html">Item_equal(a,b)</a>]).</li>
<li>For b=c it will be called with *cond_equal=(0,[<a class="el" href="class_item__equal.html">Item_equal(a,b)</a>]) and will transform *cond_equal into CE=(0,[<a class="el" href="class_item__equal.html">Item_equal(a,b,c)</a>]).</li>
<li>For b=2 it will be called with *cond_equal=(ptr(CE),[]) and will transform *cond_equal into (ptr(CE),[<a class="el" href="class_item__equal.html">Item_equal(2,a,b,c)</a>]).</li>
<li>For f=e it will be called with *cond_equal=(ptr(CE), []) and will transform *cond_equal into (ptr(CE),[<a class="el" href="class_item__equal.html">Item_equal(f,e)</a>]).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Now only fields that have the same type definitions (verified by the <a class="el" href="class_field.html#a7c9a51f0cc4e8c580838eed3a4f8e846">Field::eq_def</a> method) are placed to the same multiple equalities. Because of this some equality predicates are not eliminated and can be used in the constant propagation procedure. We could weeken the equlity test as soon as at least one of the equal fields is to be equal to a constant. It would require a more complicated implementation: we would have to store, in general case, its own constant for each fields from the multiple equality. But at the same time it would allow us to get rid of constant propagation completely: it would be done by the call to build_equal_items_for_cond.</dd></dl>
<p>The implementation does not follow exactly the above rules to build a new multiple equality for the equality predicate. If it processes the equality of the form field1=field2, it looks for multiple equalities me1 containig field1 and me2 containing field2. If only one of them is found the fuction expands it with the lacking field. If multiple equalities for both fields are found they are merged. If both searches fail a new multiple equality containing just field1 and field2 is added to the existing multiple equalities. If the function processes the predicate of the form field1=const, it looks for a multiple equality containing field1. If found, the function checks the constant of the multiple equality. If the value is unknown, it is setup to const. Otherwise the value is compared with const and the evaluation of the equality predicate is performed. When expanding/merging equality predicates from the upper levels the function first copies them for the current level. It looks acceptable, as this happens rarely. The implementation without copying would be much more complicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_item</td><td>left term of the quality to be checked </td></tr>
    <tr><td class="paramname">right_item</td><td>right term of the equality to be checked </td></tr>
    <tr><td class="paramname">item</td><td>equality item if the equality originates from a condition predicate, 0 if the equality is the result of row elimination </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities that must hold together with the equality</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the predicate is a simple equality predicate to be used for building multiple equalities </td></tr>
    <tr><td class="paramname">FALSE</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga52d407ea5f5966580f25da80dd4e9c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52d407ea5f5966580f25da80dd4e9c35">&#9670;&nbsp;</a></span>cleanup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::cleanup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleanup this <a class="el" href="class_j_o_i_n.html">JOIN</a>, possibly for reuse</p>
<p>Free resources of given join.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fill</td><td>true if we should free all resources, call with full==1 should be last, before it this function can be called with full==0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With subquery this function definitely will be called several times, but even for simple query it can be called several times. </dd></dl>

</div>
</div>
<a id="gae913870950feb0d927de9b53963f0a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae913870950feb0d927de9b53963f0a6a">&#9670;&nbsp;</a></span>cleanup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_TAB::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up associated table after query execution, including resources</p>
<p>Cleanup table of join operation.</p>
<dl class="section note"><dt>Note</dt><dd>Notice that this is not a complete cleanup. In some situations, the object may be reused after a cleanup operation, hence we cannot set the table pointer to NULL in this function. </dd></dl>

</div>
</div>
<a id="ga91edca802204d71161d32b208ae3d969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91edca802204d71161d32b208ae3d969">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>clear results if there are not rows found for group (end_send_group/end_write_group) </p>

</div>
</div>
<a id="ga7e0bbbe120736860a73919679044834f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e0bbbe120736860a73919679044834f">&#9670;&nbsp;</a></span>clear_sj_tmp_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int clear_sj_tmp_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove all rows from all temp tables used by NL-semijoin runtime</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join to remove tables for</td></tr>
  </table>
  </dd>
</dl>
<p>All rows must be removed from all temporary tables before every join re-execution. </p>

</div>
</div>
<a id="ga7029269a3541af8dee4cfe59e16fd3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7029269a3541af8dee4cfe59e16fd3de">&#9670;&nbsp;</a></span>compare_costs_of_subquery_strategies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::compare_costs_of_subquery_strategies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item__exists__subselect.html#aa110ca13dba0d9c620f5f72e6bad798e">Item_exists_subselect::enum_exec_method</a> *&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tells what is the cheapest between IN-&gt;EXISTS and subquery materialization, in terms of cost, for the subquery's <a class="el" href="class_j_o_i_n.html">JOIN</a>. Input:</p><ul>
<li>join-&gt;{best_positions,best_read,best_rowcount} must contain the execution plan of EXISTS (where 'join' is the subquery's <a class="el" href="class_j_o_i_n.html">JOIN</a>)</li>
<li>join2-&gt;{best_positions,best_read,best_rowcount} must be correctly set (where 'join2' is the parent join, the grandparent join, etc). Output: join-&gt;{best_positions,best_read,best_rowcount} contain the cheapest execution plan (where 'join' is the subquery's <a class="el" href="class_j_o_i_n.html">JOIN</a>).</li>
</ul>
<p>This plan choice has to happen before calling functions which set up execution structures, like <a class="el" href="group___query___optimizer.html#gae9c1cf0874f4bda777557d012148e059">JOIN::get_best_combination()</a> or <a class="el" href="group___query___optimizer.html#gaaf940ffededb5c2eb1444ac13ef7775b">JOIN::set_access_methods()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">method</td><td>chosen method (EXISTS or materialization) will be put here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success </dd></dl>

</div>
</div>
<a id="ga952d22693874e3582c89615bdb73934c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga952d22693874e3582c89615bdb73934c">&#9670;&nbsp;</a></span>compare_fields_by_table_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int compare_fields_by_table_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>field1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>field2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>table_join_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare field items by table order in the execution plan.</p>
<p>field1 considered as better than field2 if the table containing field1 is accessed earlier than the table containing field2. The function finds out what of two fields is better according this criteria.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field1</td><td>first field item to compare </td></tr>
    <tr><td class="paramname">field2</td><td>second field item to compare </td></tr>
    <tr><td class="paramname">table_join_idx</td><td>index to tables determining table order</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if field1 is better than field2 </td></tr>
    <tr><td class="paramname">1</td><td>if field2 is better than field1 </td></tr>
    <tr><td class="paramname">0</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8478e8df214dcc332c84d24ebe3f0785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8478e8df214dcc332c84d24ebe3f0785">&#9670;&nbsp;</a></span>const_expression_in_where()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool const_expression_in_where </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>comp_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> *&#160;</td>
          <td class="paramname"><em>comp_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> **&#160;</td>
          <td class="paramname"><em>const_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if a field or an item is equal to a constant value in WHERE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>WHERE clause expression </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp_item</td><td><a class="el" href="class_item.html">Item</a> to find in WHERE expression (if comp_field != NULL) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp_field</td><td><a class="el" href="class_field.html">Field</a> to find in WHERE expression (if comp_item != NULL) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">const_item</td><td>intermediate arg, set to <a class="el" href="class_item.html">Item</a> pointer to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is a constant value in WHERE</dd></dl>
<dl class="section note"><dt>Note</dt><dd>comp_item and comp_field parameters are mutually exclusive. </dd></dl>

</div>
</div>
<a id="ga7207e4c2b811db6a803fde5e3ca73e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7207e4c2b811db6a803fde5e3ca73e80">&#9670;&nbsp;</a></span>convert_subquery_to_semijoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool convert_subquery_to_semijoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>parent_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__exists__subselect.html">Item_exists_subselect</a> *&#160;</td>
          <td class="paramname"><em>subq_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a subquery predicate into a <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> semi-join nest</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent_join</td><td>Parent join, which has subq_pred in its WHERE/ON clause. </td></tr>
    <tr><td class="paramname">subq_pred</td><td>Subquery predicate to be converted. This is either an IN, =ANY or EXISTS predicate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error</td></tr>
  </table>
  </dd>
</dl>
<p>The following transformations are performed:</p>
<ol type="1">
<li>IN/=ANY predicates on the form:</li>
</ol>
<p>SELECT ... FROM ot1 ... otN WHERE (oe1, ... oeM) IN (SELECT ie1, ..., ieM) FROM it1 ... itK [WHERE inner-cond]) [AND outer-cond] [GROUP BY ...] [HAVING ...] [ORDER BY ...]</p>
<p>are transformed into:</p>
<p>SELECT ... FROM (ot1 ... otN) SJ (it1 ... itK) ON (oe1, ... oeM) = (ie1, ..., ieM) [AND inner-cond] [WHERE outer-cond] [GROUP BY ...] [HAVING ...] [ORDER BY ...]</p>
<p>Notice that the inner-cond may contain correlated and non-correlated expressions. Further transformations will analyze and break up such expressions.</p>
<p>Prepared Statements: the transformation is permanent:</p><ul>
<li>Changes in <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> structures are naturally permanent</li>
<li><a class="el" href="class_item.html">Item</a> tree changes are performed on statement MEM_ROOT: = we activate statement MEM_ROOT = this function is called before the first fix_prepare_information call.</li>
</ul>
<p>This is intended because the criteria for subquery-to-sj conversion remain constant for the lifetime of the Prepared Statement. </p>

</div>
</div>
<a id="ga61bf73cb2d42b343f9e6306b5d5e56ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61bf73cb2d42b343f9e6306b5d5e56ec">&#9670;&nbsp;</a></span>count_field_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void count_field_types </td>
          <td>(</td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMP_TABLE_PARAM *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset_with_sum_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update join with count of the different type of fields. </p>

</div>
</div>
<a id="gaa22943cfab7f83bbaa4d8b65533ead60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa22943cfab7f83bbaa4d8b65533ead60">&#9670;&nbsp;</a></span>create_cond_for_const_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_item__cond__and.html">Item_cond_and</a>* create_cond_for_const_ref </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a condition for a const reference for a table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">join_tab</td><td>pointer to the table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created condition for the const reference. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">!NULL</td><td>if the condition was created successfully </td></tr>
    <tr><td class="paramname">NULL</td><td>if an error has occured </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab8ed4c89159febd52c19c9f64e68709b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8ed4c89159febd52c19c9f64e68709b">&#9670;&nbsp;</a></span>create_distinct_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structst__order.html">ORDER</a> * create_distinct_group </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>all_order_by_fields_used</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a group by that consist of all non const fields.</p>
<p>Try to use the fields in the order given by 'order' to allow one to optimize away 'order by'. </p>

</div>
</div>
<a id="ga7a5efe6ddb0de3a2b43f36c3330354e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a5efe6ddb0de3a2b43f36c3330354e7">&#9670;&nbsp;</a></span>create_keyuse_for_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mem__root__array.html">Key_use_array</a>* create_keyuse_for_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__field.html">Item_field</a> **&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt;&#160;</td>
          <td class="paramname"><em>outer_exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a keyuse array for a table with a primary key. To be used when creating a materialized temporary table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer, for memory allocation </td></tr>
    <tr><td class="paramname">table</td><td>Table object representing table </td></tr>
    <tr><td class="paramname">keyparts</td><td>Number of key parts in the primary key </td></tr>
    <tr><td class="paramname">outer_exprs</td><td><a class="el" href="class_list.html">List</a> of items used for key lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to created keyuse array, or NULL if error </dd></dl>

</div>
</div>
<a id="ga3b518fb7975676afc7395b412e803368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b518fb7975676afc7395b412e803368">&#9670;&nbsp;</a></span>create_ref_for_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool create_ref_for_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_key__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>org_keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>used_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup a ref access for looking up rows via an index (a key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join object being handled </td></tr>
    <tr><td class="paramname">j</td><td>The join_tab which will have the ref access populated </td></tr>
    <tr><td class="paramname">first_keyuse</td><td>First key part of (possibly multi-part) key </td></tr>
    <tr><td class="paramname">used_tables</td><td><a class="el" href="class_bitmap.html">Bitmap</a> of available tables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<p>This function will set up a ref access using the best key found during access path analysis and cost analysis.</p>
<dl class="section note"><dt>Note</dt><dd>We cannot setup fields used for ref access before we have sorted the items within multiple equalities according to the final order of the tables involved in the join operation. Currently, this occurs in </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#ga253393c0747cf378b9cefa109662bd17">substitute_for_best_equal_field()</a>. The exception is ref access for const <a class="el" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>, which are fixed before the greedy search planner is invoked. </dd></dl>

</div>
</div>
<a id="gab466b49a22220854ef8f11a2c4a2ae8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab466b49a22220854ef8f11a2c4a2ae8a">&#9670;&nbsp;</a></span>decide_subquery_strategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::decide_subquery_strategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decides between EXISTS and materialization; performs last steps to set up the chosen strategy. </p><dl class="section return"><dt>Returns</dt><dd>'false' if no error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If UNION this is called on each contained <a class="el" href="class_j_o_i_n.html">JOIN</a>. </dd></dl>

</div>
</div>
<a id="gaf2d76654da99be4012095c016ea5d4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2d76654da99be4012095c016ea5d4d2">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up and destroy join object.</p>
<dl class="section return"><dt>Returns</dt><dd>false if previous execution was successful, and true otherwise </dd></dl>

</div>
</div>
<a id="ga54392f4f40ec2c57b8263f22fa3d4296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54392f4f40ec2c57b8263f22fa3d4296">&#9670;&nbsp;</a></span>drop_unused_derived_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::drop_unused_derived_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop unused keys for each materialized derived table/view. </p>
<p>For each materialized derived table/view, call TABLE::use_index to save one index chosen by the optimizer and ignore others. If no key is chosen, then all keys will be ignored. </p>

</div>
</div>
<a id="gaae977f888923f3443e09345a10bbee9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae977f888923f3443e09345a10bbee9a">&#9670;&nbsp;</a></span>duplicate_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool duplicate_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>first_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>possible_dup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if an expression in ORDER BY or GROUP BY is a duplicate of a preceding expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_order</td><td>the first expression in the ORDER BY or GROUP BY clause </td></tr>
    <tr><td class="paramname">possible_dup</td><td>the expression that might be a duplicate of another expression preceding it the ORDER BY or GROUP BY clause</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if possible_dup is a duplicate, false otherwise </dd></dl>

</div>
</div>
<a id="ga6cabb45db6dff4142c28674dbe0c3ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cabb45db6dff4142c28674dbe0c3ce4">&#9670;&nbsp;</a></span>eliminate_item_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_item.html">Item</a>* eliminate_item_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>upper_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__equal.html">Item_equal</a> *&#160;</td>
          <td class="paramname"><em>item_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate minimal set of simple equalities equivalent to a multiple equality.</p>
<p>The function retrieves the fields of the multiple equality item item_equal and for each field f:</p><ul>
<li>if item_equal contains const it generates the equality f=const_item;</li>
<li>otherwise, if f is not the first field, generates the equality f=item_equal-&gt;get_first(). All generated equality are added to the cond conjunction.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition to add the generated equality to </td></tr>
    <tr><td class="paramname">upper_levels</td><td>structure to access multiple equality of upper levels </td></tr>
    <tr><td class="paramname">item_equal</td><td>multiple equality to generate simple equality from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Before generating an equality function checks that it has not been generated for multiple equalities of the upper levels. E.g. for the following where condition WHERE a=5 AND ((a=b AND b=c) OR c&gt;4) the upper level AND condition will contain =(5,a), while the lower level AND condition will contain =(5,a,b,c). When splitting =(5,a,b,c) into a separate equality predicates we should omit 5=a, as we have it already in the upper level. The following where condition gives us a more complicated case: WHERE t1.a=t2.b AND t3.c=t4.d AND (t2.b=t3.c OR t4.e&gt;5 ...) AND ... Given the tables are accessed in the order t1-&gt;t2-&gt;t3-&gt;t4 for the selected query execution plan the lower level multiple equality =(t1.a,t2.b,t3.c,t4.d) formally should be converted to t1.a=t2.b AND t1.a=t3.c AND t1.a=t4.d. But t1.a=t2.a will be generated for the upper level. Also t3.c=t4.d will be generated there. So only t1.a=t3.c should be left in the lower level. If cond is equal to 0, then not more then one equality is generated and a pointer to it is returned as the result of the function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The condition with generated simple equalities or a pointer to the simple generated equality, if success.</li>
<li>0, otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad6581c041c0e0f1f0f681536e0ca35dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6581c041c0e0f1f0f681536e0ca35dc">&#9670;&nbsp;</a></span>eq_ref_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool eq_ref_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>start_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map *&#160;</td>
          <td class="paramname"><em>cached_eq_ref_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map *&#160;</td>
          <td class="paramname"><em>eq_ref_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the following expressions from ORDER BY and GROUP BY: Constant expressions <br />
Expression that only uses tables that are of type EQ_REF and the reference is in the ORDER list or if all refereed tables are of the above type.</p>
<p>In the following, the X field can be removed: </p><div class="fragment"><div class="line">SELECT * FROM t1,t2 WHERE t1.a=t2.a <a class="code" href="structst__order.html">ORDER</a> BY t1.a,t2.X</div><div class="line">SELECT * FROM t1,t2,t3 WHERE t1.a=t2.a AND t2.b=t3.b <a class="code" href="structst__order.html">ORDER</a> BY t1.a,t3.X</div></div><!-- fragment --><p>These can't be optimized: </p><div class="fragment"><div class="line">SELECT * FROM t1,t2 WHERE t1.a=t2.a <a class="code" href="structst__order.html">ORDER</a> BY t2.X,t1.a</div><div class="line">SELECT * FROM t1,t2 WHERE t1.a=t2.a AND t1.b=t2.b <a class="code" href="structst__order.html">ORDER</a> BY t1.a,t2.c</div><div class="line">SELECT * FROM t1,t2 WHERE t1.a=t2.a <a class="code" href="structst__order.html">ORDER</a> BY t2.b,t1.a</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_j_o_i_n.html">JOIN</a></td><td>join object </td></tr>
    <tr><td class="paramname">start_order</td><td>clause being analyzed (ORDER BY, GROUP BY...) </td></tr>
    <tr><td class="paramname">tab</td><td>table </td></tr>
    <tr><td class="paramname">cached_eq_ref_tables</td><td>bitmap: bit Z is set if the table of map Z was already the subject of an <a class="el" href="group___query___optimizer.html#gad6581c041c0e0f1f0f681536e0ca35dc">eq_ref_table()</a> call for the same clause; then the return value of this previous call can be found at bit Z of 'eq_ref_tables' </td></tr>
    <tr><td class="paramname">eq_ref_tables</td><td>see above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1351457ee30a4e67786117e50413541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1351457ee30a4e67786117e50413541">&#9670;&nbsp;</a></span>error_if_full_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool error_if_full_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Give error if we some tables are done with a full join.</p>
<p>This is used by multi_table_update and multi_table_delete when running in safe mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>Error (full join used) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6daf5ee65a55d8b5f6ef6c4c35f3a90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6daf5ee65a55d8b5f6ef6c4c35f3a90a">&#9670;&nbsp;</a></span>explain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::explain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_explain.html">Explain</a> join. </p>

</div>
</div>
<a id="ga3f21fed3a20651b87cac72bbb304b33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f21fed3a20651b87cac72bbb304b33c">&#9670;&nbsp;</a></span>find_field_in_item_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool find_field_in_item_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function for list_contains_unique_index. Find a field reference in a dynamic list of Items. Finds a direct reference of the <a class="el" href="class_field.html">Field</a> in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>The field to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td><a class="el" href="class_list.html">List&lt;Item&gt;</a> *.The list to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>found </td></tr>
    <tr><td class="paramname">0</td><td>not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac97c3001abc54d7c0fd18d26601d4fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac97c3001abc54d7c0fd18d26601d4fdf">&#9670;&nbsp;</a></span>find_field_in_order_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool find_field_in_order_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function for list_contains_unique_index. Find a field reference in a list of ORDER structures. Finds a direct reference of the <a class="el" href="class_field.html">Field</a> in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The field to search for. </td></tr>
    <tr><td class="paramname">data</td><td>ORDER *.The list to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>found </td></tr>
    <tr><td class="paramname">0</td><td>not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab9652206431848c00d81533336a424c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9652206431848c00d81533336a424c6">&#9670;&nbsp;</a></span>find_item_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_item__equal.html">Item_equal</a>* find_item_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>inherited_fl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the multiple equality predicate containing a field.</p>
<p>The function retrieves the multiple equalities accessed through the con_equal structure from current level and up looking for an equality containing field. It stops retrieval as soon as the equality is found and set up inherited_fl to TRUE if it's found on upper levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cond_equal</td><td>multiple equalities to search in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">field</td><td>field to look for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inherited_fl</td><td>set up to TRUE if multiple equality is found on upper levels (not on current level of cond_equal)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li><a class="el" href="class_item__equal.html">Item_equal</a> for the found multiple equality predicate if a success;</li>
<li>NULL otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafd0c3fdb07be77d705feaf3f8f51164f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd0c3fdb07be77d705feaf3f8f51164f">&#9670;&nbsp;</a></span>find_shortest_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint find_shortest_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *&#160;</td>
          <td class="paramname"><em>usable_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find shortest key suitable for full table scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table to scan </td></tr>
    <tr><td class="paramname">usable_keys</td><td>Allowed keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As far as 1) clustered primary key entry data set is a set of all record fields (key fields and not key fields) and 2) secondary index entry data is a union of its key fields and primary key fields (at least InnoDB and its derivatives don't duplicate primary key fields there, even if the primary and the secondary keys have a common subset of key fields), then secondary index entry data is always a subset of primary key entry. Unfortunately, key_info[nr].key_length doesn't show the length of key/pointer pair but a sum of key field lengths only, thus we can't estimate index IO volume comparing only this key_length value of secondary keys and clustered PK. So, try secondary keys first, and choose PK only if there are no usable secondary covering keys or found best secondary key include all table fields (i.e. same as PK):</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>MAX_KEY no suitable key found key index otherwise </dd></dl>

</div>
</div>
<a id="ga59080a3acd829efcf18fc56d51df215c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59080a3acd829efcf18fc56d51df215c">&#9670;&nbsp;</a></span>free_underlaid_joins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_underlaid_joins </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free joins of subselect of this select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">select</td><td>pointer to st_select_lex which subselects joins we will free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92bf64a03ec666f565627fbb48ba4677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92bf64a03ec666f565627fbb48ba4677">&#9670;&nbsp;</a></span>generate_derived_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::generate_derived_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add keys to derived tables'/views' result tables in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select_lex</td><td>generate derived keys for select_lex's derived tables</td></tr>
  </table>
  </dd>
</dl>
<p>This function generates keys for all derived tables/views of the select_lex to which this join corresponds to with help of the <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a>:generate_keys function.</p>
<dl class="section return"><dt>Returns</dt><dd>FALSE all keys were successfully added. </dd>
<dd>
TRUE OOM error </dd></dl>

</div>
</div>
<a id="gae9c1cf0874f4bda777557d012148e059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9c1cf0874f4bda777557d012148e059">&#9670;&nbsp;</a></span>get_best_combination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::get_best_combination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up JOIN_TAB structs according to the picked join order in best_positions. This allocates execution structures so may be called only after we have the very final plan. It must be called after <a class="el" href="group___query___planner.html#gaba76f383cbe1dccc7c7a6facaf1fe6b8" title="Fix semi-join strategies for the picked join order. ">Optimize_table_order::fix_semijoin_strategies()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<ul>
<li>create join-&gt;join_tab array and copy from existing JOIN_TABs in join order</li>
<li>create helper structs for materialized semi-join handling</li>
<li>finalize semi-join strategy choices</li>
<li>Number of intermediate tables "tmp_tables" is calculated.</li>
<li>"tables" and "primary_tables" are recalculated.</li>
</ul>
<p>Notice that intermediate tables will not have a POSITION reference; and they will not have a <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> reference before the final stages of code generation. </p>

</div>
</div>
<a id="ga67d1175177356bf1c9b05e9104d28c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d1175177356bf1c9b05e9104d28c5b">&#9670;&nbsp;</a></span>get_best_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_item__field.html">Item_field</a>* get_best_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the best field substitution for a given field.</p>
<p>If the field is member of a multiple equality, look up that equality and return the most appropriate field. Usually this is the equivalenced field belonging to the outer-most table in the join order, but </p><dl class="section see"><dt>See also</dt><dd>Item_field::get_subst_item() for details. Otherwise, return the same field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_field</td><td>The field that we are seeking a substitution for. </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The substituted field. </dd></dl>

</div>
</div>
<a id="ga5e83c73f6271bc56ebedaa2e8d3ec5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e83c73f6271bc56ebedaa2e8d3ec5ad">&#9670;&nbsp;</a></span>get_index_for_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint get_index_for_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_q_l___s_e_l_e_c_t.html">SQL_SELECT</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key to apply single table UPDATE/DELETE by a given ORDER</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table to find a key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select</td><td>Pointer to access/update select-&gt;quick (if any) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">limit</td><td>LIMIT clause parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_sort</td><td>TRUE if filesort needed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reverse</td><td>TRUE if the key is reversed again given ORDER (undefined if key == MAX_KEY)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>MAX_KEY if no key found (need_sort == TRUE)</li>
<li>MAX_KEY if quick select result order is OK (need_sort == FALSE)</li>
<li>key number (either index scan or quick select) (need_sort == FALSE)</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Side effects:<ul>
<li>may deallocate or deallocate and replace select-&gt;quick;</li>
<li>may set table-&gt;quick_condition_rows and table-&gt;quick_rows[...] to table-&gt;file-&gt;stats.records. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabd357c5516871a35204aea908c95d350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd357c5516871a35204aea908c95d350">&#9670;&nbsp;</a></span>get_quick_record_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ha_rows get_quick_record_count </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_q_l___s_e_l_e_c_t.html">SQL_SELECT</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns estimated number of rows that could be fetched by given select. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">select</td><td>select to test </td></tr>
    <tr><td class="paramname">table</td><td>source table </td></tr>
    <tr><td class="paramname">keys</td><td>allowed keys </td></tr>
    <tr><td class="paramname">limit</td><td>select limit</td></tr>
  </table>
  </dd>
</dl>
<p>In case of valid range, a <a class="el" href="class_q_u_i_c_k___s_e_l_e_c_t___i.html">QUICK_SELECT_I</a> object will be constructed and saved in select-&gt;quick.</p>
<dl class="section return"><dt>Returns</dt><dd>HA_POS_ERROR for derived tables/views or if an error occur. Otherwise, estimated number of rows. </dd></dl>

</div>
</div>
<a id="gacf9cd2ffd854fd4ed7ee4205cfb1f36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9cd2ffd854fd4ed7ee4205cfb1f36c">&#9670;&nbsp;</a></span>get_semi_join_select_list_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint get_semi_join_select_list_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_field.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a field, return its index in semi-join's select list, or UINT_MAX</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td><a class="el" href="class_field.html">Field</a> that we are looking up table for</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">=UINT_MAX</td><td><a class="el" href="class_field.html">Field</a> is not from a semijoin-transformed subquery </td></tr>
    <tr><td class="paramname">&lt;UINT_MAX</td><td>Index in select list of subquery</td></tr>
  </table>
  </dd>
</dl>
<p>Given a field, find its table; then see if the table is within a semi-join nest and if the field was in select list of the subquery (if subquery was part of a quantified comparison predicate), or the field was a result of subquery decorrelation. If it was, then return the field's index in the select list. The value is used by LooseScan strategy. </p>

</div>
</div>
<a id="ga60338e02a4512db7d658add6f008fd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60338e02a4512db7d658add6f008fd2e">&#9670;&nbsp;</a></span>get_sort_by_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> * get_sort_by_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return table number if there is only one table in sort order and group and order is compatible, else return 0. </p>

</div>
</div>
<a id="gad9015b581d8214425649d273f3e12090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9015b581d8214425649d273f3e12090">&#9670;&nbsp;</a></span>handle_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool handle_select </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">select_result *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>setup_tables_done_option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This handles SELECT with and without UNION </p>

</div>
</div>
<a id="gab3dbb0f8b69dc30985e0d9a0ff94121f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3dbb0f8b69dc30985e0d9a0ff94121f">&#9670;&nbsp;</a></span>init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN_CACHE_BNL::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize operation's internal state. Called once per query execution. </p>

<p>Implements <a class="el" href="class_j_o_i_n___c_a_c_h_e.html#a1dcdce348bba725c675b327eb90aa924">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="ga327376f63198bf31a770fb89242d49aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga327376f63198bf31a770fb89242d49aa">&#9670;&nbsp;</a></span>init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN_CACHE_BKA::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize operation's internal state. Called once per query execution. </p>

<p>Implements <a class="el" href="class_j_o_i_n___c_a_c_h_e.html#a1dcdce348bba725c675b327eb90aa924">JOIN_CACHE</a>.</p>

<p>Reimplemented in <a class="el" href="group___query___optimizer.html#gaa7ca6a85294c32bac8c69bea0c4e5fe1">JOIN_CACHE_BKA_UNIQUE</a>.</p>

</div>
</div>
<a id="gaa7ca6a85294c32bac8c69bea0c4e5fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7ca6a85294c32bac8c69bea0c4e5fe1">&#9670;&nbsp;</a></span>init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN_CACHE_BKA_UNIQUE::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize operation's internal state. Called once per query execution. </p>

<p>Reimplemented from <a class="el" href="group___query___optimizer.html#ga327376f63198bf31a770fb89242d49aa">JOIN_CACHE_BKA</a>.</p>

</div>
</div>
<a id="gaee8383a2cc774094f3750e4f02514c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8383a2cc774094f3750e4f02514c02">&#9670;&nbsp;</a></span>internal_remove_eq_conds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_item.html">Item</a>* internal_remove_eq_conds </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item::cond_result *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Handles the reqursive job for <a class="el" href="group___query___optimizer.html#gaba67ab6a59be99d1ae4d29ff674feebc">remove_eq_conds()</a></p>
<p>Remove const and eq items. Return new item, or NULL if no condition cond_value is set to according: COND_OK query is possible (field = constant) COND_TRUE always true ( 1 = 1 ) COND_FALSE always false ( 1 = 2 )</p>
<p>SYNPOSIS <a class="el" href="group___query___optimizer.html#gaba67ab6a59be99d1ae4d29ff674feebc">remove_eq_conds()</a> thd THD environment cond the condition to handle. Note that cond is changed by this function cond_value the resulting value of the condition</p>
<p>RETURN <a class="el" href="class_item.html">Item</a> with the simplified condition </p>

</div>
</div>
<a id="gaa992e841315769954816105b951d3e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa992e841315769954816105b951d3e17">&#9670;&nbsp;</a></span>is_indexed_agg_distinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_indexed_agg_distinct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item__field.html">Item_field</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> for the presence of AGGFN(DISTINCT a) queries that may be subject to loose index scan.</p>
<p><a class="el" href="struct_check.html">Check</a> if the query is a subject to AGGFN(DISTINCT) using loose index scan (<a class="el" href="class_q_u_i_c_k___g_r_o_u_p___m_i_n___m_a_x___s_e_l_e_c_t.html">QUICK_GROUP_MIN_MAX_SELECT</a>). Optionally (if out_args is supplied) will push the arguments of AGGFN(DISTINCT) to the list</p>
<p><a class="el" href="struct_check.html">Check</a> for every COUNT(DISTINCT), AVG(DISTINCT) or SUM(DISTINCT). These can be resolved by Loose Index Scan as long as all the aggregate distinct functions refer to the same fields. Thus:</p>
<p>SELECT AGGFN(DISTINCT a, b), AGGFN(DISTINCT b, a)... =&gt; can use LIS SELECT AGGFN(DISTINCT a), AGGFN(DISTINCT a) ... =&gt; can use LIS SELECT AGGFN(DISTINCT a, b), AGGFN(DISTINCT a) ... =&gt; cannot use LIS SELECT AGGFN(DISTINCT a), AGGFN(DISTINCT b) ... =&gt; cannot use LIS etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>the join to check </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_args</td><td>Collect the arguments of the aggregate functions to a list. We don't worry about duplicates as these will be sorted out later in get_best_group_min_max.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>does the query qualify for indexed AGGFN(DISTINCT) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>it does </td></tr>
    <tr><td class="paramname">false</td><td>AGGFN(DISTINCT) must apply distinct in it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga155464f8c15576de13e9aba1e6ca875a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga155464f8c15576de13e9aba1e6ca875a">&#9670;&nbsp;</a></span>is_local_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool is_local_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if an expression is a non-outer field.</p>
<p>Checks if an expression is a field and belongs to the current select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td><a class="el" href="class_item.html">Item</a> expression to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>the expression is a local field </td></tr>
    <tr><td class="paramname">FALSE</td><td>it's something else </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c7525857d6d4c3c486dd5985d81675f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c7525857d6d4c3c486dd5985d81675f">&#9670;&nbsp;</a></span>is_ref_or_null_optimized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_ref_or_null_optimized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ref_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if REF_OR_NULL optimization will be used if the specified ref_key is used for REF-access to 'tab'</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>JT_REF_OR_NULL will be used </td></tr>
    <tr><td class="paramname">false</td><td>no JT_REF_OR_NULL access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a8d854a364ab749539a9363619acf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a8d854a364ab749539a9363619acf99">&#9670;&nbsp;</a></span>is_subkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_subkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>ref_key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>ref_key_part_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if a second key is the subkey of the first one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_part</td><td>First key parts </td></tr>
    <tr><td class="paramname">ref_key_part</td><td>Second key parts </td></tr>
    <tr><td class="paramname">ref_key_part_end</td><td>Last+1 part of the second key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Second key MUST be shorter than the first one.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>is a subkey </td></tr>
    <tr><td class="paramname">0</td><td>no sub key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a30c7eaa937772da0fdc2af376b8925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a30c7eaa937772da0fdc2af376b8925">&#9670;&nbsp;</a></span>join_buffer_alg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint join_buffer_alg </td>
          <td>(</td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns which join buffer algorithms are enabled for this session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>the <code>THD</code> for this session</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitmap with available join buffer algorithms </dd></dl>

</div>
</div>
<a id="gaa62d47da29f3853e87b1069ee5c1ff21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62d47da29f3853e87b1069ee5c1ff21">&#9670;&nbsp;</a></span>join_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::join_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release memory and, if possible, the open tables held by this execution plan (and nested plans). It's used to release some tables before the end of execution in order to increase concurrency and reduce memory consumption.</p>
<p>Partially cleanup <a class="el" href="class_j_o_i_n.html">JOIN</a> after it has executed: close index or rnd read (table cursors), free quick selects.</p>
<p>This function is called in the end of execution of a <a class="el" href="class_j_o_i_n.html">JOIN</a>, before the used tables are unlocked and closed.</p>
<p>For a join that is resolved using a temporary table, the first sweep is performed against actual tables and an intermediate result is inserted into the temprorary table. The last sweep is performed against the temporary table. Therefore, the base tables and associated buffers used to fill the temporary table are no longer needed, and this function is called to free them.</p>
<p>For a join that is performed without a temporary table, this function is called after all rows are sent, but before EOF packet is sent.</p>
<p>For a simple SELECT with no subqueries this function performs a full cleanup of the <a class="el" href="class_j_o_i_n.html">JOIN</a> and calls mysql_unlock_read_tables to free used base tables.</p>
<p>If a <a class="el" href="class_j_o_i_n.html">JOIN</a> is executed for a subquery or if it has a subquery, we can't do the full cleanup and need to do a partial cleanup only.</p><ul>
<li>If a <a class="el" href="class_j_o_i_n.html">JOIN</a> is not the top level join, we must not unlock the tables because the outer select may not have been evaluated yet, and we can't unlock only selected tables of a query.</li>
<li>Additionally, if this <a class="el" href="class_j_o_i_n.html">JOIN</a> corresponds to a correlated subquery, we should not free quick selects and join buffers because they will be needed for the next execution of the correlated subquery.</li>
<li>However, if this is a <a class="el" href="class_j_o_i_n.html">JOIN</a> for a [sub]select, which is not a correlated subquery itself, but has subqueries, we can free it fully and also free JOINs of all its subqueries. The exception is a subquery in SELECT list, e.g: <br />
 SELECT a, (select max(b) from t1) group by c <br />
 This subquery will not be evaluated at first sweep and its value will not be inserted into the temporary table. Instead, it's evaluated when selecting from the temporary table. Therefore, it can't be freed here even though it's not correlated.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000121">Todo:</a></b></dt><dd>Unlock tables even if the join isn't top level select in the tree </dd></dl>

</div>
</div>
<a id="ga93fa24dcc32ac483c17625d748cc09d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93fa24dcc32ac483c17625d748cc09d9">&#9670;&nbsp;</a></span>list_contains_unique_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool list_contains_unique_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(<a class="el" href="class_field.html">Field</a> *, void *)&#160;</td>
          <td class="paramname"><em>find_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if GROUP BY/DISTINCT can be optimized away because the set is already known to be distinct.</p>
<p>Used in removing the GROUP BY/DISTINCT of the following types of statements: </p><div class="fragment"><div class="line">SELECT [DISTINCT] &lt;unique_key_cols&gt;... FROM &lt;single_table_ref&gt;</div><div class="line">  [GROUP BY &lt;unique_key_cols&gt;,...]</div></div><!-- fragment --><p>If (a,b,c is distinct) then &lt;any combination of a,b,c&gt;,{whatever} is also distinct</p>
<p>This function checks if all the key parts of any of the unique keys of the table are referenced by a list : either the select list through find_field_in_item_list or GROUP BY list through find_field_in_order_list. If the above holds and the key parts cannot contain NULLs then we can safely remove the GROUP BY/DISTINCT, as no result set can be more distinct than an unique key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>The join table to operate on. </td></tr>
    <tr><td class="paramname">find_func</td><td>function to iterate over the list and search for a field</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>found </td></tr>
    <tr><td class="paramname">0</td><td>not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that <a class="el" href="group___query___optimizer.html#gae451c9059e4079180d6c88b5f903ec78">make_outerjoin_info()</a> has been called in order for the check for outer tables to work. </dd></dl>

</div>
</div>
<a id="gaedf2fb3248e5d013e6a74b29dd9e7429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf2fb3248e5d013e6a74b29dd9e7429">&#9670;&nbsp;</a></span>make_cond_for_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_item.html">Item</a>* make_cond_for_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>used_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclude_expensive_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a condition that can be checked after reading given table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to analyze </td></tr>
    <tr><td class="paramname">tables</td><td>Tables for which "current field values" are available </td></tr>
    <tr><td class="paramname">used_table</td><td>Table(s) that we are extracting the condition for (may also include PSEUDO_TABLE_BITS, and may be zero) </td></tr>
    <tr><td class="paramname">exclude_expensive_cond</td><td>Do not push expensive conditions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;&gt;NULL</td><td>Generated condition </td></tr>
    <tr><td class="paramname">=</td><td>NULL Already checked, OR error</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the condition that can be checked after reading the table(s) specified in <code>used_table</code>, given that current-field values for tables specified in <code>tables</code> bitmap are available. If <code>used_table</code> is 0, extract conditions for all tables in <code>tables</code>.</p>
<p>This function can be used to extract conditions relevant for a table in a join order. Together with its caller, it will ensure that all conditions are attached to the first table in the join order where all necessary fields are available, and it will also ensure that a given condition is attached to only one table. To accomplish this, first initialize <code>tables</code> to the empty set. Then, loop over all tables in the join order, set <code>used_table</code> to the bit representing the current table, accumulate <code>used_table</code> into the <code>tables</code> set, and call this function. To ensure correct handling of const expressions and outer references, add the const table map and OUTER_REF_TABLE_BIT to <code>used_table</code> for the first table. To ensure that random expressions are evaluated for the final table, add RAND_TABLE_BIT to <code>used_table</code> for the final table.</p>
<p>The function assumes that constant, inexpensive parts of the condition have already been checked. Constant, expensive parts will be attached to the first table in the join order, provided that the above call sequence is followed.</p>
<p>The call order will ensure that conditions covering tables in <code>tables</code> minus those in <code>used_table</code>, have already been checked.</p>
<p>The function takes into account that some parts of the condition are guaranteed to be true by employed 'ref' access methods (the code that does this is located at the end, search down for "EQ_FUNC").</p>
<dl class="section note"><dt>Note</dt><dd>make_cond_for_info_schema() uses an algorithm similar to <a class="el" href="group___query___optimizer.html#gaedf2fb3248e5d013e6a74b29dd9e7429">make_cond_for_table()</a>. </dd></dl>

</div>
</div>
<a id="ga77fc941f20e42c089b99ab1641646828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77fc941f20e42c089b99ab1641646828">&#9670;&nbsp;</a></span>make_join_readinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool make_join_readinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>no_jbuf_after</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plan refinement stage: do various setup things for the executor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join being processed </td></tr>
    <tr><td class="paramname">options</td><td>Join's options (checking for SELECT_DESCRIBE, SELECT_NO_JOIN_CACHE) </td></tr>
    <tr><td class="paramname">no_jbuf_after</td><td>Don't use join buffering after table with this number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error (Out of memory)</dd></dl>
<p>Plan refinement stage: do various set ups for the executioner</p><ul>
<li>setup join buffering use</li>
<li>push index conditions</li>
<li>increment relevant counters</li>
<li>etc </li>
</ul>

</div>
</div>
<a id="ga9b7e768b9cfa47758fbaf11d1b878898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b7e768b9cfa47758fbaf11d1b878898">&#9670;&nbsp;</a></span>make_join_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool make_join_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Separates the predicates in a join condition and pushes them to the join step where all involved tables are available in the join prefix. ON clauses from <a class="el" href="class_j_o_i_n.html">JOIN</a> expressions are also pushed to the most appropriate step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join object where predicates are pushed.</td></tr>
    <tr><td class="paramname">cond</td><td>Pointer to condition which may contain an arbitrary number of predicates, combined using AND, OR and XOR items. If NULL, equivalent to a predicate that returns TRUE for all row combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Found impossible WHERE clause, or out-of-memory </td></tr>
    <tr><td class="paramname">false</td><td>Other </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae283571a1e38e5f3260f36027afdc148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae283571a1e38e5f3260f36027afdc148">&#9670;&nbsp;</a></span>make_join_statistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool make_join_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mem__root__array.html">Key_use_array</a> *&#160;</td>
          <td class="paramname"><em>keyuse_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first_optimization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate best possible join order and initialize the join structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join object that is populated with statistics data </td></tr>
    <tr><td class="paramname">tables_arg</td><td><a class="el" href="class_list.html">List</a> of tables that is referenced by this query </td></tr>
    <tr><td class="paramname">conds</td><td>Where condition of query </td></tr>
    <tr><td class="paramname">keyuse_array[out]</td><td>Populated with key_use information </td></tr>
    <tr><td class="paramname">first_optimization</td><td>True if first optimization of this query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false if error</dd></dl>
<p>Here is an overview of the logic of this function:</p>
<ul>
<li>Initialize <a class="el" href="class_j_o_i_n.html">JOIN</a> data structures and setup basic dependencies between tables.</li>
<li>Update dependencies based on join information.</li>
<li>Make key descriptions (<a class="el" href="group___query___optimizer.html#ga28477ddc155910db0971a61f1cf6bd66">update_ref_and_keys()</a>).</li>
<li>Pull out semi-join tables based on table dependencies.</li>
<li>Extract tables with zero or one rows as const tables.</li>
<li>Read contents of const tables, substitute columns from these tables with actual data. Also keep track of empty tables vs. one-row tables.</li>
<li>After const table extraction based on row count, more tables may have become functionally dependent. Extract these as const tables.</li>
<li>Add new sargable predicates based on retrieved const values.</li>
<li>Calculate number of rows to be retrieved from each table.</li>
<li>Calculate cost of potential semi-join materializations.</li>
<li>Calculate best possible join order based on available statistics.</li>
<li>Fill in remaining information for the generated join order. </li>
</ul>

</div>
</div>
<a id="gae451c9059e4079180d6c88b5f903ec78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae451c9059e4079180d6c88b5f903ec78">&#9670;&nbsp;</a></span>make_outerjoin_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void make_outerjoin_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill in outer join related info for the execution plan structure.</p>
<p>For each outer join operation left after simplification of the original query the function set up the following pointers in the linear structure join-&gt;join_tab representing the selected execution plan. The first inner table t0 for the operation is set to refer to the last inner table tk through the field t0-&gt;last_inner. Any inner table ti for the operation are set to refer to the first inner table ti-&gt;first_inner. The first inner table t0 for the operation is set to refer to the first inner table of the embedding outer join operation, if there is any, through the field t0-&gt;first_upper. The on expression for the outer join operation is attached to the corresponding first inner table through the field t0-&gt;on_expr_ref. Here ti are structures of the JOIN_TAB type.</p>
<p>EXAMPLE. For the query: </p><div class="fragment"><div class="line">SELECT * FROM t1</div><div class="line">              LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a></div><div class="line">              (t2, t3 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t4 ON t3.a=t4.a)</div><div class="line">              ON (t1.a=t2.a AND t1.b=t3.b)</div><div class="line">  WHERE t1.c &gt; 5,</div></div><!-- fragment --><p>given the execution plan with the table order t1,t2,t3,t4 is selected, the following references will be set; t4-&gt;last_inner=[t4], t4-&gt;first_inner=[t4], t4-&gt;first_upper=[t2] t2-&gt;last_inner=[t4], t2-&gt;first_inner=t3-&gt;first_inner=[t2], on expression (t1.a=t2.a AND t1.b=t3.b) will be attached to t2-&gt;on_expr_ref, while t3.a=t4.a will be attached to *t4-&gt;on_expr_ref.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>reference to the info fully describing the query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the simplification procedure has been already applied to the join query (see simplify_joins). This function can be called only after the execution plan has been chosen. </dd></dl>

</div>
</div>
<a id="gae713fbd3faf5b5aefad41408fd11685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae713fbd3faf5b5aefad41408fd11685a">&#9670;&nbsp;</a></span>make_sum_func_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::make_sum_func_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>send_result_set_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>before_group_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>FALSE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize 'sum_funcs' array with all <a class="el" href="class_item__sum.html">Item_sum</a> objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_list</td><td>All items </td></tr>
    <tr><td class="paramname">send_result_set_metadata</td><td>Items in select list </td></tr>
    <tr><td class="paramname">before_group_by</td><td>Set to 1 if this is called before GROUP BY handling </td></tr>
    <tr><td class="paramname">recompute</td><td>Set to TRUE if sum_funcs must be recomputed</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d12748a936ddf29bf434f926bff493b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d12748a936ddf29bf434f926bff493b">&#9670;&nbsp;</a></span>make_tmp_tables_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::make_tmp_tables_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Init tmp tables usage info.</p>
<p>This function finalizes execution plan by taking following actions: .) tmp tables are created, but not instantiated (this is done during execution). JOIN_TABs dedicated to tmp tables are filled appropriately. see <a class="el" href="group___query___executor.html#gaea471c270f3abb3609ab633d41770189">JOIN::create_intermediate_table</a>. .) prepare fields lists (fields, all_fields, ref_pointer_array slices) for each required stage of execution. These fields lists are set for tmp tables' tabs and for the tab of last table in the join. .) fill info for sorting/grouping/dups removal is prepared and saved to appropriate tabs. Here is an example: SELECT * from t1,t2 WHERE ... GROUP BY t1.f1 ORDER BY t2.f2, t1.f2 and lets assume that the table order in the plan is t1,t2. In this case optimizer will sort for group only the first table as the second one isn't mentioned in GROUP BY. The result will be materialized in tmp table. As filesort can't sort join optimizer will sort tmp table also. The first sorting (for group) is called simple as is doesn't require tmp table. The <a class="el" href="class_filesort.html">Filesort</a> object for it is created here - in <a class="el" href="group___query___executor.html#gaea471c270f3abb3609ab633d41770189">JOIN::create_intermediate_table</a>. <a class="el" href="class_filesort.html">Filesort</a> for the second case is created here, in <a class="el" href="group___query___optimizer.html#ga3d12748a936ddf29bf434f926bff493b">JOIN::make_tmp_tables_info</a>. </p><dl class="section return"><dt>Returns</dt><dd>false - Ok true - Error </dd></dl>

</div>
</div>
<a id="ga1de27fe9f2c08ca72261a3eb995c5b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1de27fe9f2c08ca72261a3eb995c5b76">&#9670;&nbsp;</a></span>merge_key_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_key__field.html">Key_field</a>* merge_key_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_key__field.html">Key_field</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_key__field.html">Key_field</a> *&#160;</td>
          <td class="paramname"><em>new_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_key__field.html">Key_field</a> *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>and_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge new key definitions to old ones, remove those not used in both.</p>
<p>This is called for OR between different levels.</p>
<p>To be able to do 'ref_or_null' we merge a comparison of a column and 'column IS NULL' to one test. This is useful for sub select queries that are internally transformed to something like:.</p>
<div class="fragment"><div class="line">SELECT * FROM t1 WHERE t1.key=outer_ref_field or t1.key IS NULL </div></div><!-- fragment --><p><a class="el" href="struct_key__field.html#ad15eb695b878f6436d97bcc8f37fad20">Key_field::null_rejecting</a> is processed as follows: <br />
result has null_rejecting=true if it is set for both ORed references. for example:</p><ul>
<li>(t2.key = t1.field OR t2.key = t1.field) -&gt; null_rejecting=true</li>
<li>(t2.key = t1.field OR t2.key &lt;=&gt; t1.field) -&gt; null_rejecting=false</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000095">Todo:</a></b></dt><dd>The result of this is that we're missing some 'ref' accesses. OptimizerTeam: Fix this </dd></dl>

</div>
</div>
<a id="ga011b405ebbd3b60eda4eb936dea9c2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga011b405ebbd3b60eda4eb936dea9c2c2">&#9670;&nbsp;</a></span>might_do_join_buffering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool might_do_join_buffering </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>join_buffer_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>sj_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if the optimizer might choose to use join buffering for this join. If that is the case, and if duplicate weedout semijoin strategy is used, the duplicate generating range must be extended to the first non-const table.</p>
<p>This function is called from <a class="el" href="group___query___optimizer.html#gadd6d91b682441f4991964f9b3ef828c9">setup_semijoin_dups_elimination()</a> before the final decision is made on whether or not buffering is used. It is therefore only a rough test that covers all cases where join buffering might be used, but potentially also some cases where join buffering will not be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_buffer_alg</td><td><a class="el" href="class_bitmap.html">Bitmap</a> with possible join buffer algorithms </td></tr>
    <tr><td class="paramname">sj_tab</td><td>Table that might be joined by BNL/BKA</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if join buffering might be used, false otherwise </dd></dl>

</div>
</div>
<a id="ga80d77b10aa34ec6307edb04ccafd8483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80d77b10aa34ec6307edb04ccafd8483">&#9670;&nbsp;</a></span>mysql_execute_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mysql_execute_select </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_join</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Execute stage of mysql_select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">select_lex</td><td>the only SELECT_LEX of this query </td></tr>
    <tr><td class="paramname">free_join</td><td>if join should be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>success </td></tr>
    <tr><td class="paramname">true</td><td>an error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>tables must be opened and locked before calling mysql_execute_select. </dd></dl>

</div>
</div>
<a id="gac4a5dd8427d34c4218f75a814d513249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4a5dd8427d34c4218f75a814d513249">&#9670;&nbsp;</a></span>mysql_prepare_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mysql_prepare_select </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>wild_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>og_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>having</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>select_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">select_result *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX_UNIT *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>free_join</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare stage of mysql_select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handler the top-level select_lex for this query </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tables</td><td>list of all tables used in this query. The tables have been pre-opened. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">wild_num</td><td>number of wildcards used in the top level select of this query. For example statement SELECT *, t1.*, catalog.t2.* FROM t0, t1, t2; has 3 wildcards. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fields</td><td>list of items in SELECT list of the top-level select e.g. SELECT a, b, c FROM t1 will have <a class="el" href="class_item__field.html">Item_field</a> for a, b and c in this list. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">conds</td><td>top level item of an expression representing WHERE clause of the top level select </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">og_num</td><td>total number of ORDER BY and GROUP BY clauses arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>linked list of ORDER BY agruments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">group</td><td>linked list of GROUP BY arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">having</td><td>top level item of HAVING expression </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select_options</td><td>select options (BIG_RESULT, etc) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">result</td><td>an instance of result set handling class. This object is responsible for send result set rows to the client or inserting them into a table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">unit</td><td>top-level UNIT of this query UNIT is an artificial object created by the parser for every SELECT clause. e.g. SELECT * FROM t1 WHERE a1 IN (SELECT * FROM t2) has 2 unions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select_lex</td><td>the only SELECT_LEX of this query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">free_join</td><td>Will be set to false if select_lex-&gt;join does not need to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>success </td></tr>
    <tr><td class="paramname">true</td><td>an error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>tables must be opened before calling mysql_prepare_select. </dd></dl>

</div>
</div>
<a id="gac201f6bcc85fbd7e04997dda1c83e5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac201f6bcc85fbd7e04997dda1c83e5b1">&#9670;&nbsp;</a></span>mysql_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mysql_select </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>wild_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_q_l___i___list.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>having</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>select_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">select_result *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX_UNIT *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An entry point to single-unit select (a select without UNION).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>list of all tables used in this query. The tables have been pre-opened. </td></tr>
    <tr><td class="paramname">wild_num</td><td>number of wildcards used in the top level select of this query. For example statement SELECT *, t1.*, catalog.t2.* FROM t0, t1, t2; has 3 wildcards. </td></tr>
    <tr><td class="paramname">fields</td><td>list of items in SELECT list of the top-level select e.g. SELECT a, b, c FROM t1 will have <a class="el" href="class_item__field.html">Item_field</a> for a, b and c in this list. </td></tr>
    <tr><td class="paramname">conds</td><td>top level item of an expression representing WHERE clause of the top level select </td></tr>
    <tr><td class="paramname">order</td><td>linked list of ORDER BY agruments </td></tr>
    <tr><td class="paramname">group</td><td>linked list of GROUP BY arguments </td></tr>
    <tr><td class="paramname">having</td><td>top level item of HAVING expression </td></tr>
    <tr><td class="paramname">select_options</td><td>select options (BIG_RESULT, etc) </td></tr>
    <tr><td class="paramname">result</td><td>an instance of result set handling class. This object is responsible for send result set rows to the client or inserting them into a table. </td></tr>
    <tr><td class="paramname">unit</td><td>top-level UNIT of this query UNIT is an artificial object created by the parser for every SELECT clause. e.g. SELECT * FROM t1 WHERE a1 IN (SELECT * FROM t2) has 2 unions. </td></tr>
    <tr><td class="paramname">select_lex</td><td>the only SELECT_LEX of this query</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>success </td></tr>
    <tr><td class="paramname">true</td><td>an error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e5943531e04254b574e4e0f9aa77b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5943531e04254b574e4e0f9aa77b82">&#9670;&nbsp;</a></span>only_eq_ref_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool only_eq_ref_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map *&#160;</td>
          <td class="paramname"><em>cached_eq_ref_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map *&#160;</td>
          <td class="paramname"><em>eq_ref_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#gad6581c041c0e0f1f0f681536e0ca35dc">eq_ref_table()</a> </dd></dl>

</div>
</div>
<a id="ga7f722315c64ce97cff639d705107c660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f722315c64ce97cff639d705107c660">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN::optimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>global select optimisation.</p>
<dl class="section note"><dt>Note</dt><dd>error code saved in field 'error'</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000094">Todo:</a></b></dt><dd>Above we passed unique=false. But for this query: (oe1, oe2) IN (SELECT primary_key, non_key_maybe_null_field FROM tbl) we could use "unique=true" for the first index component and let <a class="el" href="class_item__is__not__null__test.html">Item_is_not_null_test(non_key_maybe_null_field)</a> handle the second. </dd></dl>
<p>Push joins to <a class="el" href="classhandler.html">handler(s)</a> whenever possible. The handlers will inspect the QEP through the <a class="el" href="namespace_a_q_p.html">AQP</a> (Abstract Query Plan), and extract from it whatewer it might implement of pushed execution. It is the responsibility if the handler to store any information it need for later execution of pushed queries.</p>
<p>Currently pushed joins are only implemented by NDB. It only make sense to try pushing if &gt; 1 non-const tables.</p>
<p>Set up access functions for the tables as required by the selected access type.</p>

</div>
</div>
<a id="ga5e8bc785b0cfb6f2269f566283e239f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e8bc785b0cfb6f2269f566283e239f7">&#9670;&nbsp;</a></span>optimize_cond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_item.html">Item</a>* optimize_cond </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> **&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>build_equalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item::cond_result *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimize conditions by</p>
<p>a) applying transitivity to build multiple equality predicates (MEP): if x=y and y=z the MEP x=y=z is built. b) apply constants where possible. If the value of x is known to be 42, x is replaced with a constant of value 42. By transitivity, this also applies to MEPs, so the MEP in a) will become 42=x=y=z. c) remove conditions that are impossible or always true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>pointer to the structure providing all context info for the query </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">conds</td><td>conditions to optimize </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list of join tables to which the condition refers to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_value</td><td>Not changed if conds was empty COND_TRUE if conds is always true COND_FALSE if conds is impossible COND_OK otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>optimized conditions </dd></dl>

</div>
</div>
<a id="gaab413c6ac95a4742dcf1405e3256fae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab413c6ac95a4742dcf1405e3256fae6">&#9670;&nbsp;</a></span>optimize_fts_limit_query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::optimize_fts_limit_query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimize FTS queries with ORDER BY/LIMIT, but no WHERE clause.</p>
<p>Optimize FTS queries with ORDER BY/LIMIT, but no WHERE clause.</p>
<p>If MATCH expression is not in WHERE clause, but in ORDER BY, JT_FT access will not apply. However, if we are ordering on rank and there is a limit, normally, only the top ranking rows are needed returned, and one would benefit from the optimizations associated with JT_FT acess (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#ga9ceaa82804d41e083dee70b3a2a9be55">optimize_fts_query</a>). To get JT_FT access we will add the MATCH expression <a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a> the WHERE clause.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This optimization will only be applied to single table queries with no existing WHERE clause. </dd>
<dd>
This transformation is not correct if number of matches is less than the number of rows requested by limit. If this turns out to be the case, the transformation will be reverted </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#ga9ceaa82804d41e083dee70b3a2a9be55">optimize_fts_query()</a> </dd></dl>

</div>
</div>
<a id="ga9ceaa82804d41e083dee70b3a2a9be55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ceaa82804d41e083dee70b3a2a9be55">&#9670;&nbsp;</a></span>optimize_fts_query()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::optimize_fts_query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimize FTS queries where JT_FT access has been selected.</p>
<p>The following optimization is may be applied:</p><ol type="1">
<li>Skip filesort if FTS result is ordered</li>
<li>Skip accessing table rows if FTS result contains necessary information Also verifize that LIMIT optimization was sound.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Optimizations are restricted to single table queries, and the table engine needs to support the extended FTS API. </dd></dl>

</div>
</div>
<a id="gab9c26ae2d2f1f34ea900c5c713a32854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c26ae2d2f1f34ea900c5c713a32854">&#9670;&nbsp;</a></span>optimize_keyuse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void optimize_keyuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mem__root__array.html">Key_use_array</a> *&#160;</td>
          <td class="paramname"><em>keyuse_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update some values in keyuse for faster choose_table_order() loop. </p>

</div>
</div>
<a id="ga2b0c1fe8bf704242bb61acaa40a81fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b0c1fe8bf704242bb61acaa40a81fb4">&#9670;&nbsp;</a></span>optimize_semijoin_nests_for_materialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool optimize_semijoin_nests_for_materialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimize semi-join nests that could be run with sj-materialization</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join to optimize semi-join nests for</td></tr>
  </table>
  </dd>
</dl>
<p>Optimize each of the semi-join nests that can be run with materialization. For each of the nests, we</p><ul>
<li>Generate the best join order for this "sub-join" and remember it;</li>
<li>Remember the sub-join execution cost (it's part of materialization cost);</li>
<li>Calculate other costs that will be incurred if we decide to use materialization strategy for this semi-join nest.</li>
</ul>
<p>All obtained information is saved and will be used by the main join optimization pass.</p>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>

</div>
</div>
<a id="ga6214b5001b6cf6a328981401c253f6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6214b5001b6cf6a328981401c253f6bb">&#9670;&nbsp;</a></span>prepare_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::prepare_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; **&#160;</td>
          <td class="paramname"><em>columns_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare join result.</p>
<p>Prepare join result prior to join execution or describing. Instantiate derived tables and get schema tables result if necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE An error during derived or schema tables instantiation. FALSE Ok </dd></dl>

</div>
</div>
<a id="gaec74b2258a6fa694f7c1e4cca9242b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec74b2258a6fa694f7c1e4cca9242b2f">&#9670;&nbsp;</a></span>pull_out_semijoin_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool pull_out_semijoin_tables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pull tables out of semi-join nests based on functional dependencies</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join where to do the semi-join table pullout</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if successful, true if error (Out of memory)</dd></dl>
<p>Pull tables out of semi-join nests based on functional dependencies, ie. if a table is accessed via eq_ref(outer_tables). The function may be called several times, the caller is responsible for setting up proper key information that this function acts upon.</p>
<p>PRECONDITIONS When this function is called, the join may have several semi-join nests but it is guaranteed that one semi-join nest does not contain another. For functionally dependent tables to be pulled out, key information must have been calculated (see <a class="el" href="group___query___optimizer.html#ga28477ddc155910db0971a61f1cf6bd66">update_ref_and_keys()</a>).</p>
<p>POSTCONDITIONS Tables that were pulled out are removed from the semi-join nest they belonged to and added to the parent join nest. For these tables, the used_tables and not_null_tables fields of the semi-join nest they belonged to will be adjusted. The semi-join nest is also marked as correlated, and sj_corr_tables and sj_depends_on are adjusted if necessary. Semi-join nests' sj_inner_tables is set equal to used_tables</p>
<p>NOTE Table pullout may make uncorrelated subquery correlated. Consider this example:</p>
<p>... WHERE oe IN (SELECT it1.primary_key WHERE p(it1, it2) ... )</p>
<p>here table it1 can be pulled out (we have it1.primary_key=oe which gives us functional dependency). Once it1 is pulled out, all references to it1 from p(it1, it2) become references to outside of the subquery and thus make the subquery (i.e. its semi-join nest) correlated. Making the subquery (i.e. its semi-join nest) correlated prevents us from using Materialization or LooseScan to execute it. </p>

</div>
</div>
<a id="ga33316853c1b52be9f18b13e4a37bb4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33316853c1b52be9f18b13e4a37bb4fb">&#9670;&nbsp;</a></span>push_index_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void push_index_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>other_tbls_ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_opt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>trace_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to extract and push the index condition down to table handler</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>A join tab that has tab-&gt;table-&gt;file and its condition in tab-&gt;m_condition </td></tr>
    <tr><td class="paramname">keyno</td><td>Index for which extract and push the condition </td></tr>
    <tr><td class="paramname">other_tbls_ok</td><td>TRUE &lt;=&gt; Fields of other non-const tables are allowed </td></tr>
    <tr><td class="paramname">trace_obj</td><td>trace object where information is to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82cbeb58f7f5ba4a462e691b7e075578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82cbeb58f7f5ba4a462e691b7e075578">&#9670;&nbsp;</a></span>pushdown_on_conditions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool pushdown_on_conditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>last_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local helper function for <a class="el" href="group___query___optimizer.html#ga9b7e768b9cfa47758fbaf11d1b878898">make_join_select()</a>.</p>
<p>Push down conditions from all on expressions. Each of these conditions are guarded by a variable that turns if off just before null complemented row for outer joins is formed. Thus, the condition from an 'on expression' are guaranteed not to be checked for the null complemented row. </p>

</div>
</div>
<a id="ga812222f5f9eb4a9026c8ce89069ef8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga812222f5f9eb4a9026c8ce89069ef8d7">&#9670;&nbsp;</a></span>read_all_flag_fields_by_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE::read_all_flag_fields_by_pos </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>rec_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads all flag fields of a positioned record from the join buffer. Including all flag fields (of this record) stored in the previous join buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec_ptr</td><td>position of the first field of the record in the join buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa19cecc5eccee0ff1285c62769daf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa19cecc5eccee0ff1285c62769daf39">&#9670;&nbsp;</a></span>read_some_flag_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE::read_some_flag_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read some flag fields of a record from the join buffer.</p>
<p>Reads all flag fields stored in this join buffer, for the current record (at 'pos'). If the buffer is incremental, flag fields of this record which are stored in previous join buffers are <em>not</em> read so remain unknown: caller must then make sure to call this function on previous buffers too.</p>
<p>The flag fields are read starting from the position 'pos'. The function increments the value of 'pos' by the length of the read data.</p>
<p>Flag fields are copied back to their source. </p>

</div>
</div>
<a id="ga20c8bd509fba4099611e8a7b01c115d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20c8bd509fba4099611e8a7b01c115d8">&#9670;&nbsp;</a></span>read_some_record_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN_CACHE::read_some_record_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read some flag and data fields of a record from the join buffer.</p>
<p>Reads all fields (flag and data fields) stored in this join buffer, for the current record (at 'pos'). If the buffer is incremental, fields of this record which are stored in previous join buffers are <em>not</em> read so remain unknown: caller must then make sure to call this function on previous buffers too.</p>
<p>The fields are read starting from the position 'pos' which is supposed to point to the beginning of the first record field. The function increments the value of 'pos' by the length of the read data.</p>
<p>Flag fields are copied back to their source; data fields are copied to the record's buffer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">(-1)</td><td>if there are no more records in the join buffer </td></tr>
    <tr><td class="paramname">&lt;&gt;(-1)</td><td>length of the data read from the join buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga00996fa73375b70c9e2a55a9e24620a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00996fa73375b70c9e2a55a9e24620a0">&#9670;&nbsp;</a></span>record_join_nest_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool record_join_nest_info </td>
          <td>(</td>
          <td class="paramtype">st_select_lex *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Record join nest info in the select block.</p>
<p>After simplification of inner join, outer join and semi-join structures:</p><ul>
<li>record the remaining semi-join structures in the enclosing query block.</li>
<li>record transformed join conditions in <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> objects.</li>
</ul>
<p>This function is called recursively for each join nest and/or table in the query block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select</td><td>The query block </td></tr>
    <tr><td class="paramname">tables</td><td><a class="el" href="class_list.html">List</a> of tables and join nests</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if successful, True if failure </dd></dl>

</div>
</div>
<a id="gaef4f64b9b280796d9abe945b2eda94ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef4f64b9b280796d9abe945b2eda94ac">&#9670;&nbsp;</a></span>refine_best_rowcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::refine_best_rowcount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine the best_rowcount estimation based on what happens after tables have been joined: LIMIT and type of result sink. </p>

</div>
</div>
<a id="ga76cb6108cc02fa4d53fb8cf473ddf291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76cb6108cc02fa4d53fb8cf473ddf291">&#9670;&nbsp;</a></span>remove_additional_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_item.html">Item</a> * remove_additional_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove additional condition inserted by IN/ALL/ANY transformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conds</td><td>condition for processing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new conditions</dd></dl>
<dl class="section note"><dt>Note</dt><dd>that this function has Bug#13915291. </dd></dl>

</div>
</div>
<a id="gade27e5590663fce22ead93ccc5a2162b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade27e5590663fce22ead93ccc5a2162b">&#9670;&nbsp;</a></span>remove_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structst__order.html">ORDER</a> * remove_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>first_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>change_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>simple_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>clause_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove all constants and check if ORDER only contains simple expressions.</p>
<p>simple_order is set to 1 if sort_order only uses fields from head table and the head table is not a LEFT <a class="el" href="class_j_o_i_n.html">JOIN</a> table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join handler </td></tr>
    <tr><td class="paramname">first_order</td><td><a class="el" href="class_list.html">List</a> of SORT or GROUP order </td></tr>
    <tr><td class="paramname">cond</td><td>WHERE statement </td></tr>
    <tr><td class="paramname">change_list</td><td>Set to 1 if we should remove things from list. If this is not set, then only simple_order is calculated. </td></tr>
    <tr><td class="paramname">simple_order</td><td>Set to 1 if we are only using simple expressions </td></tr>
    <tr><td class="paramname">clause_type</td><td>"ORDER BY" etc for printing in optimizer trace</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns new sort order </dd></dl>

</div>
</div>
<a id="gaba67ab6a59be99d1ae4d29ff674feebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba67ab6a59be99d1ae4d29ff674feebc">&#9670;&nbsp;</a></span>remove_eq_conds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_item.html">Item</a>* remove_eq_conds </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item::cond_result *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove const and eq items. Return new item, or NULL if no condition cond_value is set to according: COND_OK query is possible (field = constant) COND_TRUE always true ( 1 = 1 ) COND_FALSE always false ( 1 = 2 )</p>
<p>SYNPOSIS <a class="el" href="group___query___optimizer.html#gaba67ab6a59be99d1ae4d29ff674feebc">remove_eq_conds()</a> thd THD environment cond the condition to handle cond_value the resulting value of the condition</p>
<p>NOTES calls the inner_remove_eq_conds to check all the tree reqursively</p>
<p>RETURN <a class="el" href="class_item.html">Item</a> with the simplified condition </p>

</div>
</div>
<a id="ga1b521ce8c8cc3192c6ba5f38af9929b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b521ce8c8cc3192c6ba5f38af9929b4">&#9670;&nbsp;</a></span>replace_item_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::replace_item_field </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>new_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace all <a class="el" href="class_item__field.html">Item_field</a> objects with the given field name with the given item in all parts of the query.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000096">Todo:</a></b></dt><dd>So far this function only handles SELECT list and WHERE clause, For more general use, ON clause, ORDER BY list, GROUP BY list and HAVING clause also needs to be handled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>Name of the field to search for </td></tr>
    <tr><td class="paramname">new_item</td><td>Replacement item </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad58027047f122daabf2ab024b274897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad58027047f122daabf2ab024b274897">&#9670;&nbsp;</a></span>replace_subcondition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool replace_subcondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> **&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>old_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>new_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_fix_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract a condition that can be checked after reading given table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to analyze </td></tr>
    <tr><td class="paramname">tables</td><td>Tables for which "current field values" are available </td></tr>
    <tr><td class="paramname">used_table</td><td>Table that we're extracting the condition for (may also include PSEUDO_TABLE_BITS, and may be zero) </td></tr>
    <tr><td class="paramname">exclude_expensive_cond</td><td>Do not push expensive conditions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;&gt;NULL</td><td>Generated condition </td></tr>
    <tr><td class="paramname">=NULL</td><td>Already checked, OR error</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the condition that can be checked after reading the table specified in 'used_table', given that current-field values for tables specified in 'tables' bitmap are available. If 'used_table' is 0</p><ul>
<li>extract conditions for all tables in 'tables'.</li>
<li>extract conditions are unrelated to any tables in the same query block/level(i.e. conditions which have used_tables == 0).</li>
</ul>
<p>The function assumes that</p><ul>
<li>Constant parts of the condition has already been checked.</li>
<li>Condition that could be checked for tables in 'tables' has already been checked.</li>
</ul>
<p>The function takes into account that some parts of the condition are guaranteed to be true by employed 'ref' access methods (the code that does this is located at the end, search down for "EQ_FUNC").</p>
<dl class="section note"><dt>Note</dt><dd>make_cond_for_info_schema() uses an algorithm similar to <a class="el" href="group___query___optimizer.html#gaedf2fb3248e5d013e6a74b29dd9e7429">make_cond_for_table()</a>. Destructively replaces a sub-condition inside a condition tree. The parse tree is also altered.</dd>
<dd>
Because of current requirements for semijoin flattening, we do not need to recurse here, hence this function will only examine the top-level AND conditions. (see <a class="el" href="group___query___resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a>, comment starting with "Check if the 
subquery predicate can be executed via materialization".)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The top-level query.</td></tr>
    <tr><td class="paramname">tree</td><td>Must be the handle to the top level condition. This is needed when the top-level condition changes.</td></tr>
    <tr><td class="paramname">old_cond</td><td>The condition to be replaced.</td></tr>
    <tr><td class="paramname">new_cond</td><td>The condition to be substituted.</td></tr>
    <tr><td class="paramname">do_fix_fields</td><td>If true, Item::fix_fields(THD*, Item**) is called for the new condition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error status</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If there was an error. </td></tr>
    <tr><td class="paramname">false</td><td>If successful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4e09d71987062663db1836d651ec4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e09d71987062663db1836d651ec4d4">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the state of this join object so that it is ready for a new execution. </p>

</div>
</div>
<a id="gad54e309ac7f0fd377d7a422ea54f59f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54e309ac7f0fd377d7a422ea54f59f8">&#9670;&nbsp;</a></span>reset_cache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE::reset_cache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_writing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the join buffer for reading/writing: default implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">for_writing</td><td>if it's TRUE the function reset the buffer for writing</td></tr>
  </table>
  </dd>
</dl>
<p>This default implementation of the virtual function <a class="el" href="group___query___optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8" title="Reset the join buffer for reading/writing: default implementation. ">reset_cache()</a> resets the join buffer for reading or writing. If the buffer is reset for reading only the 'pos' value is reset to point to the very beginning of the join buffer. If the buffer is reset for writing additionally:</p><ul>
<li>the counter of the records in the buffer is set to 0,</li>
<li>the the value of 'last_rec_pos' gets pointing at the position just before the buffer,</li>
<li>'end_pos' is set to point to the beginning of the join buffer,</li>
<li>the size of the auxiliary buffer is reset to 0,</li>
<li>the flag 'last_rec_blob_data_is_in_rec_buff' is set to 0. </li>
</ul>

<p>Reimplemented in <a class="el" href="group___query___optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7">JOIN_CACHE_BKA_UNIQUE</a>.</p>

</div>
</div>
<a id="gafb1afc6322b69d01ea68b677b715ddc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb1afc6322b69d01ea68b677b715ddc7">&#9670;&nbsp;</a></span>reset_cache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE_BKA_UNIQUE::reset_cache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_writing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the join buffer for reading/writing: default implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">for_writing</td><td>if it's TRUE the function reset the buffer for writing</td></tr>
  </table>
  </dd>
</dl>
<p>This default implementation of the virtual function <a class="el" href="group___query___optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7" title="Reset the join buffer for reading/writing: default implementation. ">reset_cache()</a> resets the join buffer for reading or writing. If the buffer is reset for reading only the 'pos' value is reset to point to the very beginning of the join buffer. If the buffer is reset for writing additionally:</p><ul>
<li>the counter of the records in the buffer is set to 0,</li>
<li>the the value of 'last_rec_pos' gets pointing at the position just before the buffer,</li>
<li>'end_pos' is set to point to the beginning of the join buffer,</li>
<li>the size of the auxiliary buffer is reset to 0,</li>
<li>the flag 'last_rec_blob_data_is_in_rec_buff' is set to 0. </li>
</ul>

<p>Reimplemented from <a class="el" href="group___query___optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="ga54a15a3b027af8533c100d5c0fa218f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54a15a3b027af8533c100d5c0fa218f5">&#9670;&nbsp;</a></span>reset_nj_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_nj_counters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set NESTED_JOIN::counter=0 in all nested joins in passed list.</p>
<p>Recursively set NESTED_JOIN::counter=0 for all nested joins contained in the passed join_list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_list</td><td><a class="el" href="class_list.html">List</a> of nested joins to process. It may also contain base tables which will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e92b14b52e210ce225ad4c0312f9bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e92b14b52e210ce225ad4c0312f9bca">&#9670;&nbsp;</a></span>rollup_make_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::rollup_make_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_item.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sel_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__sum.html">Item_sum</a> ***&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill up rollup structures with pointers to fields to use.</p>
<p>Creates copies of item_sum items for each sum level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fields_arg</td><td><a class="el" href="class_list.html">List</a> of all fields (hidden and real ones) </td></tr>
    <tr><td class="paramname">sel_fields</td><td>Pointer to selected fields </td></tr>
    <tr><td class="paramname">func</td><td>Store here a pointer to all fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ok; In this case func is pointing to next not used element. </td></tr>
    <tr><td class="paramname">1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga076b7e6736c0bf0a9e9bf7542e4746c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga076b7e6736c0bf0a9e9bf7542e4746c8">&#9670;&nbsp;</a></span>rollup_process_const_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::rollup_process_const_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap all constant Items in GROUP BY list.</p>
<p>For ROLLUP queries each constant item referenced in GROUP BY list is wrapped up into an <a class="el" href="class_item__func.html">Item_func</a> object yielding the same value as the constant item. The objects of the wrapper class are never considered as constant items and besides they inherit all properties of the <a class="el" href="class_item__result__field.html">Item_result_field</a> class. This wrapping allows us to ensure writing constant items into temporary tables whenever the result of the ROLLUP operation has to be written into a temporary table, e.g. when ROLLUP is used together with DISTINCT in the SELECT list. Usually when creating temporary tables for a intermidiate result we do not include fields for constant expressions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ok </td></tr>
    <tr><td class="paramname">1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaaf7d0c085b6fa2c810619adfcc8cfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf7d0c085b6fa2c810619adfcc8cfd9">&#9670;&nbsp;</a></span>semijoin_types_allow_materialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void semijoin_types_allow_materialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>sj_nest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_check.html">Check</a> if semijoin's compared types allow materialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sj_nest</td><td>Semi-join nest containing information about correlated expressions. Set nested_join-&gt;sjm.scan_allowed to TRUE if MaterializeScan strategy allowed. Set nested_join-&gt;sjm.lookup_allowed to TRUE if MaterializeLookup strategy allowed</td></tr>
  </table>
  </dd>
</dl>
<p>This is a temporary fix for BUG#36752.</p>
<p>There are two subquery materialization strategies for semijoin:</p>
<ol type="1">
<li><p class="startli">Materialize and do index lookups in the materialized table. See BUG#36752 for description of restrictions we need to put on the compared expressions.</p>
<p class="startli">In addition, since indexes are not supported for BLOB columns, this strategy can not be used if any of the columns in the materialized table will be BLOB/GEOMETRY columns. (Note that also columns for non-BLOB values that may be greater in size than CONVERT_IF_BIGGER_TO_BLOB, will be represented as BLOB columns.)</p>
</li>
<li>Materialize and then do a full scan of the materialized table. The same criteria as for MaterializeLookup are applied, except that BLOB/GEOMETRY columns are allowed. </li>
</ol>

</div>
</div>
<a id="gaaf940ffededb5c2eb1444ac13ef7775b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf940ffededb5c2eb1444ac13ef7775b">&#9670;&nbsp;</a></span>set_access_methods()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::set_access_methods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set access methods for the tables of a query plan.</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<p>We need to fill in data for the case where</p><ul>
<li>There is no key selected (use JT_ALL)</li>
<li>Loose scan semi-join strategy is selected (use JT_ALL)</li>
<li>A ref key can be used (use JT_REF, JT_REF_OR_NULL, JT_EQ_REF or JT_FT)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>We cannot setup fields used for ref access before we have sorted the items within multiple equalities according to the final order of the tables involved in the join operation. Currently, this occurs in </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#ga253393c0747cf378b9cefa109662bd17">substitute_for_best_equal_field()</a>. </dd></dl>

</div>
</div>
<a id="gad5b3161d639edbd3a8ce6b8d5bbf0e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b3161d639edbd3a8ce6b8d5bbf0e03">&#9670;&nbsp;</a></span>set_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void set_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_key__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save const tables first as used tables. </p>

</div>
</div>
<a id="ga61a9a63131b536315d16d122eed3102a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61a9a63131b536315d16d122eed3102a">&#9670;&nbsp;</a></span>set_prefix_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::set_prefix_tables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign set of available (prefix) tables to all tables in query block. Also set added tables, ie the tables added in each JOIN_TAB compared to the previous JOIN_TAB. This function must be called for every query block after the table order has been determined. </p>

</div>
</div>
<a id="ga52d3829776ab95dee43086b5aa43b234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52d3829776ab95dee43086b5aa43b234">&#9670;&nbsp;</a></span>set_semijoin_embedding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::set_semijoin_embedding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set semi-join embedding join nest pointers.</p>
<p>Set pointer to embedding semi-join nest for all semi-joined tables. Note that this must be done for every table inside all semi-join nests, even for tables within outer join nests embedded in semi-join nests. A table can never be part of multiple semi-join nests, hence no ambiguities can ever occur. Note also that the pointer is not set for <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> objects that are outer join nests within semi-join nests. </p>

</div>
</div>
<a id="gab7ec58d0faabade96e5378b0e5a1c2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ec58d0faabade96e5378b0e5a1c2c2">&#9670;&nbsp;</a></span>set_semijoin_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::set_semijoin_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the first_sj_inner_tab and last_sj_inner_tab fields for all tables inside the semijoin nests of the query. </p>

</div>
</div>
<a id="ga1510993d68f776aedbd40bc732b94fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1510993d68f776aedbd40bc732b94fa6">&#9670;&nbsp;</a></span>setup_join_buffering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool setup_join_buffering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>no_jbuf_after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>icp_other_tables_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set up join buffering for a specified table, if possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>joined table to check join buffer usage for </td></tr>
    <tr><td class="paramname">join</td><td>join for which the check is performed </td></tr>
    <tr><td class="paramname">options</td><td>options of the join </td></tr>
    <tr><td class="paramname">no_jbuf_after</td><td>don't use join buffering after table with this number </td></tr>
    <tr><td class="paramname">icp_other_tables_ok[out]</td><td>TRUE if condition pushdown supports other tables presence</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error. Currently, allocation errors for join cache objects are ignored, and regular execution is chosen silently.</dd></dl>
<pre class="fragment">The function finds out whether the table 'tab' can be joined using a join
buffer. This check is performed after the best execution plan for 'join'
has been chosen. If the function decides that a join buffer can be employed
then it selects the most appropriate join cache object that contains this
join buffer.
If it has already been decided to not use join buffering for this table,
no action is taken.

Often it is already decided that join buffering will be used earlier in
the optimization process, and this will also ensure that the most correct
cost for the operation is calculated, and hence the probability of
choosing an optimal join plan is higher. However, some join buffering
decisions cannot currently be taken before this stage, hence we need this
function to decide the most accurate join buffering strategy.
</pre><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000119">Todo:</a></b></dt><dd>Long-term it is the goal that join buffering strategy is decided when the plan is selected.</dd></dl>
<pre class="fragment">The result of the check and the type of the the join buffer to be used
depend on:
  - the access method to access rows of the joined table
  - whether the join table is an inner table of an outer join or semi-join
  - the optimizer_switch settings for join buffering
  - the join 'options'.
In any case join buffer is not used if the number of the joined table is
greater than 'no_jbuf_after'. 

If block_nested_loop is turned on, and if all other criteria for using
join buffering is fulfilled (see below), then join buffer is used 
for any join operation (inner join, outer join, semi-join) with 'JT_ALL' 
access method.  In that case, a JOIN_CACHE_BNL object is always employed.

If an index is used to access rows of the joined table and batched_key_access
is on, then a JOIN_CACHE_BKA object is employed. (Unless debug flag,
test_bka unique, is set, then a JOIN_CACHE_BKA_UNIQUE object is employed
instead.) 

If the function decides that a join buffer can be used to join the table
'tab' then it sets @c tab-&gt;use_join_cache to reflect the chosen algorithm 
and assigns the selected join cache object to the field 'cache' of the 
previous join table.  After creating a join cache object, it will be 
initialized. Failure to do so, will cause the decision to use join
buffering to be reverted.
</pre><dl class="section note"><dt>Note</dt><dd>For a nested outer join/semi-join, currently, we either use join buffers for all inner tables or for none of them.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000120">Todo:</a></b></dt><dd><pre class="fragment">Support BKA inside SJ-Materialization nests. When doing this, we'll need
to only store sj-inner tables in the join buffer.
</pre> #if 0 JOIN_TAB *first_tab= join-&gt;join_tab+join-&gt;const_tables; uint n_tables= i-join-&gt;const_tables; / * We normally put all preceding tables into the join buffer, except for the constant tables. If we're inside a semi-join materialization nest, e.g.</dd></dl>
<pre class="fragment">         outer_tbl1  outer_tbl2  ( inner_tbl1, inner_tbl2 ) ...
                                                   ^-- we're here

      then we need to put into the join buffer only the tables from
      within the nest.
      /
    if (i &gt;= first_sjm_table &amp;&amp; i &lt; last_sjm_table)
    {
      n_tables= i - first_sjm_table; // will be &gt;0 if we got here
      first_tab= join-&gt;join_tab + first_sjm_table;
    }
</pre><p> #endif </p>

</div>
</div>
<a id="ga98b423a4f37a7b1957744a2c82842d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98b423a4f37a7b1957744a2c82842d0e">&#9670;&nbsp;</a></span>setup_materialized_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::setup_materialized_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tableno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__position.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>inner_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__position.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>sjm_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Setup the materialized table for a semi-join nest</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>join_tab for the materialized semi-join table </td></tr>
    <tr><td class="paramname">tableno</td><td>table number of materialized table </td></tr>
    <tr><td class="paramname">inner_pos</td><td>information about the first inner table of the subquery </td></tr>
    <tr><td class="paramname">sjm_pos</td><td>information about the materialized semi-join table, to be filled with data.</td></tr>
  </table>
  </dd>
</dl>
<p>Setup execution structures for one semi-join materialization nest:</p><ul>
<li>Create the materialization temporary table, including <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> object.</li>
<li>Create a list of <a class="el" href="class_item__field.html">Item_field</a> objects per column in the temporary table.</li>
<li>Create a keyuse array describing index lookups into the table (for MaterializeLookup)</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>False if OK, True if error </dd></dl>

</div>
</div>
<a id="gadd6d91b682441f4991964f9b3ef828c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd6d91b682441f4991964f9b3ef828c9">&#9670;&nbsp;</a></span>setup_semijoin_dups_elimination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool setup_semijoin_dups_elimination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>no_jbuf_after</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Setup the strategies to eliminate semi-join duplicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join to process </td></tr>
    <tr><td class="paramname">options</td><td>Join options (needed to see if join buffering will be used or not) </td></tr>
    <tr><td class="paramname">no_jbuf_after</td><td>Do not use join buffering after the table with this number</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>Out of memory error</td></tr>
  </table>
  </dd>
</dl>
<p>Setup the strategies to eliminate semi-join duplicates. At the moment there are 5 strategies:</p>
<ol type="1">
<li>DuplicateWeedout (use of temptable to remove duplicates based on rowids of row combinations)</li>
<li>FirstMatch (pick only the 1st matching row combination of inner tables)</li>
<li>LooseScan (scanning the sj-inner table in a way that groups duplicates together and picking the 1st one)</li>
<li>MaterializeLookup (Materialize inner tables, then setup a scan over outer correlated tables, lookup in materialized table)</li>
<li>MaterializeScan (Materialize inner tables, then setup a scan over materialized tables, perform lookup in outer tables)</li>
</ol>
<p>The join order has "duplicate-generating ranges", and every range is served by one strategy or a combination of FirstMatch with with some other strategy.</p>
<p>"Duplicate-generating range" is defined as a range within the join order that contains all of the inner tables of a semi-join. All ranges must be disjoint, if tables of several semi-joins are interleaved, then the ranges are joined together, which is equivalent to converting SELECT ... WHERE oe1 IN (SELECT ie1 ...) AND oe2 IN (SELECT ie2 ) to SELECT ... WHERE (oe1, oe2) IN (SELECT ie1, ie2 ... ...) Applicability conditions are as follows:</p>
<p>DuplicateWeedout strategy ~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>(ot|nt)* [ it ((it|ot|nt)* (it|ot))] (nt)* +&mdash;&mdash;+ +=========================+ +&mdash;+ (1) (2) (3)</p>
<p>(1) - Prefix of OuterTables (those that participate in IN-equality and/or are correlated with subquery) and outer Non-correlated tables. (2) - The handled range. The range starts with the first sj-inner table, and covers all sj-inner and outer tables Within the range, Inner, Outer, outer non-correlated tables may follow in any order. (3) - The suffix of outer non-correlated tables.</p>
<p>FirstMatch strategy ~~~~~~~~~~~~~~~~~~~</p>
<p>(ot|nt)* [ it ((it|nt)* it) ] (nt)* +&mdash;&mdash;+ +==================+ +&mdash;+ (1) (2) (3)</p>
<p>(1) - Prefix of outer correlated and non-correlated tables (2) - The handled range, which may contain only inner and non-correlated tables. (3) - The suffix of outer non-correlated tables.</p>
<p>LooseScan strategy ~~~~~~~~~~~~~~~~~~</p>
<p>(ot|ct|nt) [ loosescan_tbl (ot|nt|it)* it ] (ot|nt)* +--&mdash;&mdash;+ +===========+ +=============+ +&mdash;&mdash;+ (1) (2) (3) (4)</p>
<p>(1) - Prefix that may contain any outer tables. The prefix must contain all the non-trivially correlated outer tables. (non-trivially means that the correlation is not just through the IN-equality).</p>
<p>(2) - Inner table for which the LooseScan scan is performed. Notice that special requirements for existence of certain indexes apply to this table, </p><dl class="section see"><dt>See also</dt><dd>class <a class="el" href="class_loose__scan__opt.html">Loose_scan_opt</a>.</dd></dl>
<p>(3) - The remainder of the duplicate-generating range. It is served by application of FirstMatch strategy. Outer IN-correlated tables must be correlated to the LooseScan table but not to the inner tables in this range. (Currently, there can be no outer tables in this range because of implementation restrictions, </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___planner.html#ga89a7e995505577ffbc683024366808b0">Optimize_table_order::advance_sj_state()</a>).</dd></dl>
<p>(4) - The suffix of outer correlated and non-correlated tables.</p>
<p>MaterializeLookup strategy </p><div class="fragment"><div class="line"> (ot|nt)*  [ it (it)* ]  (nt)*</div><div class="line"> +------+  +==========+  +---+</div><div class="line">    (1)         (2)        (3)</div><div class="line"></div><div class="line">  (1) - Prefix <a class="code" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a> outer correlated and non-correlated <a class="code" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>.</div><div class="line"></div><div class="line">  (2) - The handled range, which may contain only inner <a class="code" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>.</div><div class="line">        The inner <a class="code" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a> are materialized in a temporary <a class="code" href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a> that is</div><div class="line">        later used as a lookup structure <span class="keywordflow">for</span> the outer correlated <a class="code" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>.</div><div class="line"></div><div class="line">  (3) - The suffix <a class="code" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a> outer non-correlated <a class="code" href="fts0fts_8cc.html#aa86c147940343159f5b38505b80bb233">tables</a>.</div><div class="line"></div><div class="line">MaterializeScan strategy</div></div><!-- fragment --><p>(ot|nt)* [ it (it)* ] (ot|nt)* +&mdash;&mdash;+ +==========+ +&ndash;&mdash;+ (1) (2) (3)</p>
<p>(1) - Prefix of outer correlated and non-correlated tables.</p>
<p>(2) - The handled range, which may contain only inner tables. The inner tables are materialized in a temporary table which is later used to setup a scan.</p>
<p>(3) - The suffix of outer correlated and non-correlated tables.</p>
<p>Note that MaterializeLookup and MaterializeScan has overlap in their patterns. It may be possible to consolidate the materialization strategies into one.</p>
<p>The choice between the strategies is made by the join optimizer (see advance_sj_state() and fix_semijoin_strategies()). This function sets up all fields/structures/etc needed for execution except for setup/initialization of semi-join materialization which is done in setup_materialized_table(). </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000117">Todo:</a></b></dt><dd>: merge <a class="el" href="group___query___optimizer.html#ga77fc941f20e42c089b99ab1641646828">make_join_readinfo()</a> and <a class="el" href="group___query___optimizer.html#gadd6d91b682441f4991964f9b3ef828c9">setup_semijoin_dups_elimination()</a> loops and change the following 'if' to</dd></dl>
<p>"if (join-&gt;join_tab[sj_tableno]-&gt;position-&gt;use_join_buffer &amp;&amp; 
     sj_tableno &lt;= no_jbuf_after)".</p>
<p>For now, use a rough criteria:</p>

</div>
</div>
<a id="gadbc980a72c17c8442fab87af085697d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc980a72c17c8442fab87af085697d4">&#9670;&nbsp;</a></span>simple_remove_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__order.html">ORDER</a>* simple_remove_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filter out ORDER items those are equal to constants in WHERE</p>
<p>This function is a limited version of <a class="el" href="group___query___optimizer.html#gade27e5590663fce22ead93ccc5a2162b">remove_const()</a> for use with non-JOIN statements (i.e. single-table UPDATE and DELETE).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramname">cond</td><td>WHERE expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to new filtered ORDER list or NULL if whole list eliminated</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function overwrites input order list. </dd></dl>

</div>
</div>
<a id="ga437d0af0465d8ebf56f66f8e2ecfd926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga437d0af0465d8ebf56f66f8e2ecfd926">&#9670;&nbsp;</a></span>simplify_joins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool simplify_joins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_sj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> **&#160;</td>
          <td class="paramname"><em>new_conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>changelog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simplify joins replacing outer joins by inner joins whenever it's possible.</p>
<p>The function, during a retrieval of join_list, eliminates those outer joins that can be converted into inner join, possibly nested. It also moves the join conditions for the converted outer joins and from inner joins to conds. The function also calculates some attributes for nested joins:</p><ul>
<li>used_tables</li>
<li>not_null_tables</li>
<li>dep_tables.</li>
<li>on_expr_dep_tables The first two attributes are used to test whether an outer join can be substituted for an inner join. The third attribute represents the relation 'to be dependent on' for tables. If table t2 is dependent on table t1, then in any evaluated execution plan table access to table t2 must precede access to table t2. This relation is used also to check whether the query contains invalid cross-references. The forth attribute is an auxiliary one and is used to calculate dep_tables. As the attribute dep_tables qualifies possibles orders of tables in the execution plan, the dependencies required by the straight join modifiers are reflected in this attribute as well. The function also removes all braces that can be removed from the join expression without changing its meaning.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>An outer join can be replaced by an inner join if the where condition or the join condition for an embedding nested join contains a conjunctive predicate rejecting null values for some attribute of the inner tables.</dd></dl>
<p>E.g. in the query: </p><div class="fragment"><div class="line">SELECT * FROM t1 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t2 ON t2.a=t1.a WHERE t2.b &lt; 5</div></div><!-- fragment --><p> the predicate t2.b &lt; 5 rejects nulls. The query is converted first to: </p><div class="fragment"><div class="line">SELECT * FROM t1 INNER <a class="code" href="class_j_o_i_n.html">JOIN</a> t2 ON t2.a=t1.a WHERE t2.b &lt; 5</div></div><!-- fragment --><p> then to the equivalent form: </p><div class="fragment"><div class="line">SELECT * FROM t1, t2 ON t2.a=t1.a WHERE t2.b &lt; 5 AND t2.a=t1.a</div></div><!-- fragment --><p>Similarly the following query: </p><div class="fragment"><div class="line">SELECT * <a class="code" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a> t1 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> (t2, t3) ON t2.a=t1.a t3.b=t1.b</div><div class="line">  WHERE t2.c &lt; 5  </div></div><!-- fragment --><p> is converted to: </p><div class="fragment"><div class="line">SELECT * FROM t1, (t2, t3) WHERE t2.c &lt; 5 AND t2.a=t1.a t3.b=t1.b </div></div><!-- fragment --><p>One conversion might trigger another: </p><div class="fragment"><div class="line">SELECT * FROM t1 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t2 ON t2.a=t1.a</div><div class="line">                 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t3 ON t3.b=t2.b</div><div class="line">  WHERE t3 IS NOT NULL =&gt;</div><div class="line">SELECT * FROM t1 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t2 ON t2.a=t1.a, t3</div><div class="line">  WHERE t3 IS NOT NULL AND t3.b=t2.b =&gt; </div><div class="line">SELECT * FROM t1, t2, t3</div><div class="line">  WHERE t3 IS NOT NULL AND t3.b=t2.b AND t2.a=t1.a</div></div><!-- fragment --><p>The function removes all unnecessary braces from the expression produced by the conversions. E.g. </p><div class="fragment"><div class="line">SELECT * FROM t1, (t2, t3) WHERE t2.c &lt; 5 AND t2.a=t1.a AND t3.b=t1.b</div></div><!-- fragment --><p> finally is converted to: </p><div class="fragment"><div class="line">SELECT * FROM t1, t2, t3 WHERE t2.c &lt; 5 AND t2.a=t1.a AND t3.b=t1.b</div></div><!-- fragment --><p>It also will remove braces from the following queries: </p><div class="fragment"><div class="line">SELECT * <a class="code" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a> (t1 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t2 ON t2.a=t1.a) LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t3 ON t3.b=t2.b</div><div class="line">SELECT * <a class="code" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a> (t1, (t2,t3)) WHERE t1.a=t2.a AND t2.b=t3.b.</div></div><!-- fragment --><p>The benefit of this simplification procedure is that it might return a query for which the optimizer can evaluate execution plan with more join orders. With a left join operation the optimizer does not consider any plan where one of the inner tables is before some of outer tables.</p>
<p>IMPLEMENTATION The function is implemented by a recursive procedure. On the recursive ascent all attributes are calculated, all outer joins that can be converted are replaced and then all unnecessary braces are removed. As join list contains join tables in the reverse order sequential elimination of outer joins does not require extra recursive calls.</p>
<p>SEMI-JOIN NOTES Remove all semi-joins that have are within another semi-join (i.e. have an "ancestor" semi-join nest)</p>
<p>EXAMPLES Here is an example of a join query with invalid cross references: </p><div class="fragment"><div class="line">SELECT * FROM t1 LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t2 ON t2.a=t3.a LEFT <a class="code" href="class_j_o_i_n.html">JOIN</a> t3 ON t3.b=t1.b </div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>reference to the query info </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list representation of the join to be converted </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">conds</td><td>condition that join condition for converted outer joins is added to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">top</td><td>true &lt;=&gt; conds is the where condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in_sj</td><td>TRUE &lt;=&gt; processing semi-join nest's children </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_conds</td><td>New condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">changelog</td><td>Don't specify this parameter, it is reserved for recursive calls inside this function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for error, false for success </dd></dl>

</div>
</div>
<a id="gae1dc44a9fcd103cc014e05e30faec197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1dc44a9fcd103cc014e05e30faec197">&#9670;&nbsp;</a></span>sjm_query_block_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint JOIN_TAB::sjm_query_block_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>query block id for an inner table of materialized semi-join, and 0 for all other tables. </dd></dl>

</div>
</div>
<a id="ga6afa1e2231c8090ecae73554fca37c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6afa1e2231c8090ecae73554fca37c41">&#9670;&nbsp;</a></span>skip_index_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_CACHE_BKA_UNIQUE::skip_index_tuple </td>
          <td>(</td>
          <td class="paramtype">range_seq_t&#160;</td>
          <td class="paramname"><em>rseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>range_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if the record combination matches the index condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rseq</td><td>Value returned by bka_range_seq_init() </td></tr>
    <tr><td class="paramname">range_info</td><td>MRR range association data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>JOIN_CACHE_BKA::skip_index_tuple(). This function is the variant for use with <a class="el" href="class_j_o_i_n___c_a_c_h_e___b_k_a___u_n_i_q_u_e.html">JOIN_CACHE_BKA_UNIQUE</a>. The difference <a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a> <a class="el" href="class_j_o_i_n___c_a_c_h_e___b_k_a.html">JOIN_CACHE_BKA</a> case is that there may be multiple previous <a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a> <a class="el" href="structrecord.html">record</a> combinations that share the same key, i.e. they map <a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a> the same MRR range. And for all <a class="el" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a> those records, we have just done one single key lookup in the current <a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="fts0que_8cc.html#a278a42b0432f35e1568f2697202fdc49">found</a> an <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a> <a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>. If in this function we discard this <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a> <a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, all those records will be eliminated <a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a> the result. Thus, in this function we can discard the <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a> <a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a> only if <em>all</em> those cached records and the <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a> <a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a> don't <a class="el" href="structmatch.html">match</a> the pushed <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a> condition. It'<a class="el" href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a> <a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a> "group-wide
decision". Thus we must here loop through all previous <a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a> records combinations that <a class="el" href="structmatch.html">match</a> the given MRR range key range_info, searching for <a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a> single one matching the <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a> condition. If we find none, we can safely discard the <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a> <a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a> here, which avoids retrieving the <a class="el" href="structrecord.html">record</a> <a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a> the current <a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>. If we instead find one, we cannot discard the <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a> <a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a> here; later in execution, in join_matching_records(), we can finally take one "case-by-case decision" per cached <a class="el" href="structrecord.html">record</a>, by checking again the <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a> condition (</dd>
<dd>
<a class="el" href="group___query___optimizer.html#gafd031be055cee296d6629313a333b56f">JOIN_CACHE_BKA_UNIQUE::check_match</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Possible optimization: Before we unpack the record from a previous table check if this table is used in the condition. If so then unpack the record otherwise skip the unpacking. This should be done by a special virtual method get_partial_record_by_pos().</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>The record combination satisfies the index condition </td></tr>
    <tr><td class="paramname">true</td><td>Otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga253393c0747cf378b9cefa109662bd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga253393c0747cf378b9cefa109662bd17">&#9670;&nbsp;</a></span>substitute_for_best_equal_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_item.html">Item</a>* substitute_for_best_equal_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>table_join_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Substitute every field reference in a condition by the best equal field and eliminate all multiple equality predicates.</p>
<p>The function retrieves the cond condition and for each encountered multiple equality predicate it sorts the field references in it according to the order of tables specified by the table_join_idx parameter. Then it eliminates the multiple equality predicate it replacing it by the conjunction of simple equality predicates equating every field from the multiple equality to the first field in it, or to the constant, if there is any. After this the function retrieves all other conjuncted predicates substitute every field reference by the field reference to the first equal field or equal constant if there are any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition to process </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities to take into consideration </td></tr>
    <tr><td class="paramname">table_join_idx</td><td>index to tables determining field preference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>At the first glance full sort of fields in multiple equality seems to be an overkill. Yet it's not the case due to possible new fields in multiple equality item of lower levels. We want the order in them to comply with the order of upper levels.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed condition, or NULL in case of error </dd></dl>

</div>
</div>
<a id="gaf45084f9f7f12e1368aa2f07811033f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf45084f9f7f12e1368aa2f07811033f2">&#9670;&nbsp;</a></span>test_if_cheaper_ordering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool test_if_cheaper_ordering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a>&#160;</td>
          <td class="paramname"><em>usable_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>select_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>new_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>new_key_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows *&#160;</td>
          <td class="paramname"><em>new_select_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>new_used_key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>saved_best_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a cheaper access key than a given <em>key</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>NULL or JOIN_TAB of the accessed table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table if tab == NULL or tab-&gt;table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">usable_keys</td><td><a class="el" href="class_key.html">Key</a> map to find a cheaper key in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref_key</td><td>0 &lt;= key &lt; MAX_KEY - key number (hint) to start the search -1 - no key number provided </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select_limit</td><td>LIMIT value, or HA_POS_ERROR if no limit </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_key</td><td><a class="el" href="class_key.html">Key</a> number if success, otherwise undefined </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_key_direction</td><td>Return -1 (reverse) or +1 if success, otherwise undefined </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_select_limit</td><td>Return adjusted LIMIT </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_used_key_parts</td><td>NULL by default, otherwise return number of new_key prefix columns if success or undefined if the function fails </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">saved_best_key_parts</td><td>NULL by default, otherwise preserve the value for further use in <a class="el" href="class_q_u_i_c_k___s_e_l_e_c_t___d_e_s_c.html">QUICK_SELECT_DESC</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function takes into account table-&gt;quick_condition_rows statistic (that is calculated by the make_join_statistics function). However, single table procedures such as mysql_update() and mysql_delete() never call make_join_statistics, so they have to update it manually (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#ga5e83c73f6271bc56ebedaa2e8d3ec5ad">get_index_for_order()</a>). </dd></dl>

</div>
</div>
<a id="ga96dc524565684a4e258c98f5b7fd1541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96dc524565684a4e258c98f5b7fd1541">&#9670;&nbsp;</a></span>test_if_order_by_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_if_order_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>used_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if one can use the key to resolve ORDER BY.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Sort order </td></tr>
    <tr><td class="paramname">table</td><td>Table to sort </td></tr>
    <tr><td class="paramname">idx</td><td>Index to check </td></tr>
    <tr><td class="paramname">used_key_parts</td><td>[out] NULL by default, otherwise return value for used key parts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>used_key_parts is set to correct key parts used if return value != 0 (On other cases, used_key_part may be changed) Note that the value may actually be greater than the number of index key parts. This can happen for storage engines that have the primary key parts as a suffix for every secondary key.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>key is ok. </td></tr>
    <tr><td class="paramname">0</td><td><a class="el" href="class_key.html">Key</a> can't be used </td></tr>
    <tr><td class="paramname">-1</td><td>Reverse key can be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82b8ed924bc1ecabf570961a7d6a7d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82b8ed924bc1ecabf570961a7d6a7d3b">&#9670;&nbsp;</a></span>test_if_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool test_if_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>root_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>left_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>right_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>1 if right_item is used removable reference key on left_item</dd></dl>
<dl class="section note"><dt>Note</dt><dd>see comments in make_cond_for_table_from_pred() about careful usage/modifications of <a class="el" href="group___query___optimizer.html#ga82b8ed924bc1ecabf570961a7d6a7d3b">test_if_ref()</a>. </dd></dl>

</div>
</div>
<a id="ga14a304484212b5489e8e995539493dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14a304484212b5489e8e995539493dd0">&#9670;&nbsp;</a></span>test_if_skip_sort_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool test_if_skip_sort_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>select_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>no_changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>clause_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if we can skip the ORDER BY by using an index.</p>
<p>SYNOPSIS <a class="el" href="group___query___optimizer.html#ga14a304484212b5489e8e995539493dd0">test_if_skip_sort_order()</a> tab order select_limit no_changes map</p>
<p>If we can use an index, the JOIN_TAB / tab-&gt;select struct is changed to use the index.</p>
<p>The index must cover all fields in &lt;order&gt;, or it will not be considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>NULL or JOIN_TAB of the accessed table </td></tr>
    <tr><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramname">select_limit</td><td>LIMIT value, or HA_POS_ERROR if no limit </td></tr>
    <tr><td class="paramname">no_changes</td><td>No changes will be made to the query plan. </td></tr>
    <tr><td class="paramname">map</td><td>key_map of applicable indexes. </td></tr>
    <tr><td class="paramname">clause_type</td><td>"ORDER BY" etc for printing in optimizer trace</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000122">Todo:</a></b></dt><dd><ul>
<li>sergeyp: Results of all index merge selects actually are ordered by clustered PK values.</li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>We have to use filesort to do the sorting </td></tr>
    <tr><td class="paramname">1</td><td>We can use an index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae43cd92bbdb313a0bec082f717a4f5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae43cd92bbdb313a0bec082f717a4f5ee">&#9670;&nbsp;</a></span>test_if_subkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint test_if_subkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ref_key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *&#160;</td>
          <td class="paramname"><em>usable_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if we can use one of the 'usable_keys' instead of 'ref' key for sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>Number of key, used for WHERE clause </td></tr>
    <tr><td class="paramname">usable_keys</td><td>Keys for testing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>MAX_KEY If we can't use other key</li>
<li>the number of found key Otherwise </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4d5a2e1822e2131fcfbe6501a8a97525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d5a2e1822e2131fcfbe6501a8a97525">&#9670;&nbsp;</a></span>test_if_subpart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool test_if_subpart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return 1 if second is a subpart of first argument.</p>
<p>If first parts has different direction, change it to second part (group is sorted like order) </p>

</div>
</div>
<a id="ga1a2f6510062aadbe683719e51560a3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a2f6510062aadbe683719e51560a3ff">&#9670;&nbsp;</a></span>trace_indices_added_group_distinct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trace_indices_added_group_distinct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_opt__trace__context.html">Opt_trace_context</a> *&#160;</td>
          <td class="paramname"><em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a>&#160;</td>
          <td class="paramname"><em>new_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cause</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print keys that were appended to join_tab-&gt;const_keys because they can be used for GROUP BY or DISTINCT to the optimizer trace.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>The optimizer trace context we're adding info to </td></tr>
    <tr><td class="paramname">join_tab</td><td>The table the indices cover </td></tr>
    <tr><td class="paramname">new_keys</td><td>The keys that are considered useful because they can be used for GROUP BY or DISTINCT </td></tr>
    <tr><td class="paramname">cause</td><td>Zero-terminated string with reason for adding indices to const_keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#gabc625b885fcfa2fa058cce5480ea989b">add_group_and_distinct_keys()</a> </dd></dl>

</div>
</div>
<a id="ga1c540754bd726695a5a7e36952136f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c540754bd726695a5a7e36952136f3d">&#9670;&nbsp;</a></span>trace_table_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trace_table_dependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_opt__trace__context.html">Opt_trace_context</a> *&#160;</td>
          <td class="paramname"><em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes to the optimizer trace information about dependencies between tables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>optimizer trace </td></tr>
    <tr><td class="paramname">join_tabs</td><td>all JOIN_TABs of the join </td></tr>
    <tr><td class="paramname">table_count</td><td>how many JOIN_TABs in the 'join_tabs' array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga410e1c85b186cd5520a7d21930ead6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410e1c85b186cd5520a7d21930ead6e5">&#9670;&nbsp;</a></span>types_allow_materialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool types_allow_materialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_check.html">Check</a> if two items are compatible wrt. materialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outer</td><td>Expression from outer query </td></tr>
    <tr><td class="paramname">inner</td><td>Expression from inner query</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>If subquery types allow materialization. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga393037fbd019d460dbafdcdc1e8786d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga393037fbd019d460dbafdcdc1e8786d7">&#9670;&nbsp;</a></span>unified_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_item.html">Item</a> * JOIN_TAB::unified_condition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if JOIN_TAB condition was moved to <a class="el" href="class_filesort.html">Filesort</a> condition. If yes then return condition belonging to <a class="el" href="class_filesort.html">Filesort</a>, otherwise return condition belonging to JOIN_TAB. </p>

</div>
</div>
<a id="ga81ebfe4ef44f9496582b436835f4680c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81ebfe4ef44f9496582b436835f4680c">&#9670;&nbsp;</a></span>update_depend_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_depend_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the dependency map for the tables. </p>

</div>
</div>
<a id="ga53565c3d7314221955132811e5ca9cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53565c3d7314221955132811e5ca9cb7">&#9670;&nbsp;</a></span>update_depend_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void update_depend_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the dependency map for the sort order. </p>

</div>
</div>
<a id="gaeaa6edcfa6c4d934dd42d505d9de2fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa6edcfa6c4d934dd42d505d9de2fef">&#9670;&nbsp;</a></span>update_equalities_for_sjm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::update_equalities_for_sjm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update equalities and keyuse references after semi-join materialization strategy is chosen.</p>
<p>For each multiple equality that contains a field that is selected from a subquery, and that subquery is executed using a semi-join materialization strategy, add the corresponding column in the materialized temporary table to the equality. For each injected semi-join equality that is not converted to multiple equality, replace the reference to the expression selected from the subquery with the corresponding column in the temporary table.</p>
<p>This is needed to properly reflect the equalities that involve injected semi-join equalities when materialization strategy is chosen. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___query___optimizer.html#ga6cabb45db6dff4142c28674dbe0c3ce4">eliminate_item_equal()</a> for how these equalities are used <a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a> generate correct equality predicates.</dd></dl>
<p>The MaterializeScan semi-join strategy requires some additional processing: All primary tables after the materialized temporary table must be inspected for keyuse objects that point to expressions from the subquery tables. These references must be replaced with references to corresponding columns in the materialized temporary table instead. Those primary tables using ref access will thus be made to depend on the materialized temporary table instead of the subquery tables.</p>
<p>Only the injected semi-join equalities need this treatment, other predicates will be handled correctly by the regular item substitution process.</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, true if error </dd></dl>

</div>
</div>
<a id="ga28477ddc155910db0971a61f1cf6bd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28477ddc155910db0971a61f1cf6bd66">&#9670;&nbsp;</a></span>update_ref_and_keys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool update_ref_and_keys </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mem__root__array.html">Key_use_array</a> *&#160;</td>
          <td class="paramname"><em>keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_item.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_o_n_d___e_q_u_a_l.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>normal_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__sargable__param.html">SARGABLE_PARAM</a> **&#160;</td>
          <td class="paramname"><em>sargables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update keyuse array with all possible keys we can use to fetch rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keyuse</td><td>Put here ordered array of <a class="el" href="class_key__use.html">Key_use</a> structures </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_tab</td><td>Array in tablenr_order </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tables</td><td>Number of tables in join </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>WHERE condition (note that the function analyzes join_tab[i]-&gt;join_cond() too) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">normal_tables</td><td>Tables not inner w.r.t some outer join (ones for which we can make ref access based the WHERE clause) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select_lex</td><td>current SELECT </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sargables</td><td>Array of found sargable candidates</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>Out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5798d039ab240f96c90d30e0819b9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5798d039ab240f96c90d30e0819b9b0">&#9670;&nbsp;</a></span>warn_index_not_applicable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void warn_index_not_applicable </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_field.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a>&#160;</td>
          <td class="paramname"><em>cant_use_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If EXPLAIN EXTENDED, add warning that an index cannot be used for ref access. </p>
<p>If EXPLAIN EXTENDED, add a warning for each index that cannot be used for ref access due to either type conversion or different collations on the field used for comparison</p>
<p>Example type conversion (char compared to int):</p>
<p>CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> t1 (url char(1) PRIMARY KEY); SELECT * FROM t1 WHERE url=1;</p>
<p>Example different collations (danish vs german2):</p>
<p>CREATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> t1 (url char(1) PRIMARY KEY) collate latin1_danish_ci; SELECT * FROM t1 WHERE url='1' collate latin1_german2_ci;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread for the connection that submitted the query </td></tr>
    <tr><td class="paramname">field</td><td><a class="el" href="class_field.html">Field</a> used in comparision </td></tr>
    <tr><td class="paramname">cant_use_indexes</td><td>Indexes that cannot be used for lookup </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

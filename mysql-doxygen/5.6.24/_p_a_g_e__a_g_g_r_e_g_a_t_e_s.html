<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Performance schema: the aggregates page.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Performance schema: the aggregates page. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Performance schema aggregates.</p>
<h1><a class="anchor" id="INTRO"></a>
Introduction</h1>
<p>Aggregates tables are tables that can be formally defined as SELECT ... from EVENTS_WAITS_HISTORY_INFINITE ... group by 'group clause'.</p>
<p>Each group clause defines a different kind of aggregate, and corresponds to a different table exposed by the performance schema.</p>
<p>Aggregates can be either:</p><ul>
<li>computed on the fly,</li>
<li>computed on demand, based on other available data.</li>
</ul>
<p>'EVENTS_WAITS_HISTORY_INFINITE' is a table that does not exist, the best approximation is EVENTS_WAITS_HISTORY_LONG. Aggregates computed on the fly in fact are based on EVENTS_WAITS_CURRENT, while aggregates computed on demand are based on other EVENTS_WAITS_SUMMARY_BY_xxx tables.</p>
<p>To better understand the implementation itself, a bit of math is required first, to understand the model behind the code: the code is deceptively simple, the real complexity resides in the flyweight of pointers between various performance schema buffers.</p>
<h1><a class="anchor" id="DIMENSION"></a>
Concept of dimension</h1>
<p>An event measured by the instrumentation has many attributes. An event is represented as a data point P(x1, x2, ..., xN), where each x_i coordinate represents a given attribute value.</p>
<p>Examples of attributes are:</p><ul>
<li>the time waited</li>
<li>the object waited on</li>
<li>the instrument waited on</li>
<li>the thread that waited</li>
<li>the operation performed</li>
<li>per object or per operation additional attributes, such as spins, number of bytes, etc.</li>
</ul>
<p>Computing an aggregate per thread is fundamentally different from computing an aggregate by instrument, so the "_BY_THREAD" and "_BY_EVENT_NAME" aggregates are different dimensions, operating on different x_i and x_j coordinates. These aggregates are "orthogonal".</p>
<h1><a class="anchor" id="PROJECTION"></a>
Concept of projection</h1>
<p>A given x_i attribute value can convey either just one basic information, such as a number of bytes, or can convey implied information, such as an object fully qualified name.</p>
<p>For example, from the value "test.t1", the name of the object schema "test" can be separated from the object name "t1", so that now aggregates by object schema can be implemented.</p>
<p>In math terms, that corresponds to defining a function: F_i (x): x &ndash;&gt; y Applying this function to our point P gives another point P':</p>
<p>F_i (P): P(x1, x2, ..., x{i-1}, x_i, x{i+1}, ..., x_N) &ndash;&gt; P' (x1, x2, ..., x{i-1}, f_i(x_i), x{i+1}, ..., x_N)</p>
<p>That function defines in fact an aggregate ! In SQL terms, this aggregate would look like the following table:</p>
<pre class="fragment">  CREATE VIEW EVENTS_WAITS_SUMMARY_BY_Func_i AS
  SELECT col_1, col_2, ..., col_{i-1},
         Func_i(col_i),
         COUNT(col_i),
         MIN(col_i), AVG(col_i), MAX(col_i), -- if col_i is a numeric value
         col_{i+1}, ..., col_N
         FROM EVENTS_WAITS_HISTORY_INFINITE
         group by col_1, col_2, ..., col_{i-1}, col{i+1}, ..., col_N.
</pre><p>Note that not all columns have to be included, in particular some columns that are dependent on the x_i column should be removed, so that in practice, MySQL's aggregation method tends to remove many attributes at each aggregation steps.</p>
<p>For example, when aggregating wait events by object instances,</p><ul>
<li>the wait_time and number_of_bytes can be summed, and sum(wait_time) now becomes an object instance attribute.</li>
<li>the source, timer_start, timer_end columns are not in the _BY_INSTANCE table, because these attributes are only meaningful for a wait.</li>
</ul>
<h1><a class="anchor" id="COMPOSITION"></a>
Concept of composition</h1>
<p>Now, the "test.t1" &ndash;&gt; "test" example was purely theory, just to explain the concept, and does not lead very far. Let's look at a more interesting example of data that can be derived from the row event.</p>
<p>An event creates a transient object, PFS_wait_locker, per operation. This object's life cycle is extremely short: it's created just before the start_wait() instrumentation call, and is destroyed in the end_wait() call.</p>
<p>The wait locker itself contains a pointer to the object instance waited on. That allows to implement a wait_locker &ndash;&gt; object instance projection, with m_target. The object instance life cycle depends on _init and _destroy calls from the code, such as <a class="el" href="group___thread__instrumentation.html#gaf4fc58e68eb34057e9954944a34824c1">mysql_mutex_init()</a> and <a class="el" href="group___thread__instrumentation.html#ga37298c942ab1882a74ed52b787605132">mysql_mutex_destroy()</a> for a mutex.</p>
<p>The object instance waited on contains a pointer to the object class, which is represented by the instrument name. That allows to implement an object instance &ndash;&gt; object class projection. The object class life cycle is permanent, as instruments are loaded in the server and never removed.</p>
<p>The object class is named in such a way (for example, "wait/sync/mutex/sql/LOCK_open", "wait/io/file/maria/data_file) that the component ("sql", "maria") that it belongs to can be inferred. That allows to implement an object class &ndash;&gt; server component projection.</p>
<p>Back to math again, we have, for example for mutexes:</p>
<p>F1 (l) : PFS_wait_locker l &ndash;&gt; <a class="el" href="struct_p_f_s__mutex.html">PFS_mutex</a> m = l-&gt;m_target.m_mutex</p>
<p>F1_to_2 (m) : <a class="el" href="struct_p_f_s__mutex.html">PFS_mutex</a> m &ndash;&gt; <a class="el" href="struct_p_f_s__mutex__class.html">PFS_mutex_class</a> i = m-&gt;m_class</p>
<p>F2_to_3 (i) : <a class="el" href="struct_p_f_s__mutex__class.html">PFS_mutex_class</a> i &ndash;&gt; const char *component = substring(i-&gt;m_name, ...)</p>
<p>Per components aggregates are not implemented, this is just an illustration.</p>
<p>F1 alone defines this aggregate:</p>
<p>EVENTS_WAITS_HISTORY_INFINITE &ndash;&gt; EVENTS_WAITS_SUMMARY_BY_INSTANCE (or MUTEX_INSTANCE)</p>
<p>F1_to_2 alone could define this aggregate:</p>
<p>EVENTS_WAITS_SUMMARY_BY_INSTANCE &ndash;&gt; EVENTS_WAITS_SUMMARY_BY_EVENT_NAME</p>
<p>Alternatively, using function composition, with F2 = F1_to_2 o F1, F2 defines:</p>
<p>EVENTS_WAITS_HISTORY_INFINITE &ndash;&gt; EVENTS_WAITS_SUMMARY_BY_EVENT_NAME</p>
<p>Likewise, F_2_to_3 defines:</p>
<p>EVENTS_WAITS_SUMMARY_BY_EVENT_NAME &ndash;&gt; EVENTS_WAITS_SUMMARY_BY_COMPONENT</p>
<p>and F3 = F_2_to_3 o F_1_to_2 o F1 defines:</p>
<p>EVENTS_WAITS_HISTORY_INFINITE &ndash;&gt; EVENTS_WAITS_SUMMARY_BY_COMPONENT</p>
<p>What has all this to do with the code ?</p>
<p>Functions (or aggregates) such as F_3 are not implemented as is. Instead, they are decomposed into F_2_to_3 o F_1_to_2 o F1, and each intermediate aggregate is stored into an internal buffer. This allows to support every F1, F2, F3 aggregates from shared internal buffers, where computation already performed to compute F2 is reused when computing F3.</p>
<h1><a class="anchor" id="OBJECT_GRAPH"></a>
Object graph</h1>
<p>In terms of object instances, or records, pointers between different buffers define an object instance graph.</p>
<p>For example, assuming the following scenario:</p><ul>
<li>A mutex class "M" is instrumented, the instrument name is "wait/sync/mutex/sql/M"</li>
<li>This mutex instrument has been instantiated twice, mutex instances are noted M-1 and M-2</li>
<li>Threads T-A and T-B are locking mutex instance M-1</li>
<li>Threads T-C and T-D are locking mutex instance M-2</li>
</ul>
<p>The performance schema will record the following data:</p><ul>
<li>EVENTS_WAITS_CURRENT has 4 rows, one for each mutex locker</li>
<li>EVENTS_WAITS_SUMMARY_BY_INSTANCE shows 2 rows, for M-1 and M-2</li>
<li>EVENTS_WAITS_SUMMARY_BY_EVENT_NAME shows 1 row, for M</li>
</ul>
<p>The graph of structures will look like:</p>
<pre class="fragment">  PFS_wait_locker (T-A, M-1) ----------
                                      |
                                      v
                                 PFS_mutex (M-1)
                                 - m_wait_stat    ------------
                                      ^                      |
                                      |                      |
  PFS_wait_locker (T-B, M-1) ----------                      |
                                                             v
                                                        PFS_mutex_class (M)
                                                        - m_wait_stat
  PFS_wait_locker (T-C, M-2) ----------                      ^
                                      |                      |
                                      v                      |
                                 PFS_mutex (M-2)             |
                                 - m_wait_stat    ------------
                                      ^
                                      |
  PFS_wait_locker (T-D, M-2) ----------

            ||                        ||                     ||
            ||                        ||                     ||
            vv                        vv                     vv

  EVENTS_WAITS_CURRENT ..._SUMMARY_BY_INSTANCE ..._SUMMARY_BY_EVENT_NAME
</pre><h1><a class="anchor" id="ON_THE_FLY"></a>
On the fly aggregates</h1>
<p>'On the fly' aggregates are computed during the code execution. This is necessary because the data the aggregate is based on is volatile, and can not be kept indefinitely.</p>
<p>With on the fly aggregates:</p><ul>
<li>the writer thread does all the computation</li>
<li>the reader thread accesses the result directly</li>
</ul>
<p>This model is to be avoided if possible, due to the overhead caused when instrumenting code.</p>
<h1><a class="anchor" id="HIGHER_LEVEL"></a>
Higher level aggregates</h1>
<p>'Higher level' aggregates are implemented on demand only. The code executing a SELECT from the aggregate table is collecting data from multiple internal buffers to produce the result.</p>
<p>With higher level aggregates:</p><ul>
<li>the reader thread does all the computation</li>
<li>the writer thread has no overhead.</li>
</ul>
<h1><a class="anchor" id="MIXED"></a>
Mixed level aggregates</h1>
<p>The 'Mixed' model is a compromise between 'On the fly' and 'Higher level' aggregates, for internal buffers that are not permanent.</p>
<p>While an object is present in a buffer, the higher level model is used. When an object is about to be destroyed, statistics are saved into a 'parent' buffer with a longer life cycle, to follow the on the fly model.</p>
<p>With mixed aggregates:</p><ul>
<li>the reader thread does a lot of complex computation,</li>
<li>the writer thread has minimal overhead, on destroy events.</li>
</ul>
<h1><a class="anchor" id="IMPL_WAIT"></a>
Implementation for waits aggregates</h1>
<p>For waits, the tables that contains aggregated wait data are:</p><ul>
<li>EVENTS_WAITS_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME</li>
<li>EVENTS_WAITS_SUMMARY_BY_HOST_BY_EVENT_NAME</li>
<li>EVENTS_WAITS_SUMMARY_BY_INSTANCE</li>
<li>EVENTS_WAITS_SUMMARY_BY_THREAD_BY_EVENT_NAME</li>
<li>EVENTS_WAITS_SUMMARY_BY_USER_BY_EVENT_NAME</li>
<li>EVENTS_WAITS_SUMMARY_GLOBAL_BY_EVENT_NAME</li>
<li>FILE_SUMMARY_BY_EVENT_NAME</li>
<li>FILE_SUMMARY_BY_INSTANCE</li>
<li>SOCKET_SUMMARY_BY_INSTANCE</li>
<li>SOCKET_SUMMARY_BY_EVENT_NAME</li>
<li>OBJECTS_SUMMARY_GLOBAL_BY_TYPE</li>
</ul>
<p>The instrumented code that generates waits events consist of:</p><ul>
<li>mutexes (mysql_mutex_t)</li>
<li>rwlocks (mysql_rwlock_t)</li>
<li>conditions (mysql_cond_t)</li>
<li>file io (MYSQL_FILE)</li>
<li>socket io (MYSQL_SOCKET)</li>
<li>table io</li>
<li>table lock</li>
<li>idle</li>
</ul>
<p>The flow of data between aggregates tables varies for each instrumentation.</p>
<h2><a class="anchor" id="IMPL_WAIT_MUTEX"></a>
Mutex waits</h2>
<pre class="fragment">  mutex_locker(T, M)
   |
   | [1]
   |
   |-&gt; pfs_mutex(M)                           =====&gt;&gt; [B], [C]
   |    |
   |    | [2]
   |    |
   |    |-&gt; pfs_mutex_class(M.class)          =====&gt;&gt; [C]
   |
   |-&gt; pfs_thread(T).event_name(M)            =====&gt;&gt; [A], [D], [E], [F]
        |
        | [3]
        |
     3a |-&gt; pfs_account(U, H).event_name(M)   =====&gt;&gt; [D], [E], [F]
        .    |
        .    | [4-RESET]
        .    |
     3b .....+-&gt; pfs_user(U).event_name(M)    =====&gt;&gt; [E]
        .    |
     3c .....+-&gt; pfs_host(H).event_name(M)    =====&gt;&gt; [F]
</pre><p>How to read this diagram:</p><ul>
<li>events that occur during the instrumented code execution are noted with numbers, as in [1]. Code executed by these events has an impact on overhead.</li>
<li>events that occur during TRUNCATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> operations are noted with numbers, followed by "-RESET", as in [4-RESET]. Code executed by these events has no impact on overhead, since they are executed by independent monitoring sessions.</li>
<li>events that occur when a reader extracts data from a performance schema table are noted with letters, as in [A]. The name of the table involved, and the method that builds a row are documented. Code executed by these events has no impact on the instrumentation overhead. Note that the table implementation may pull data from different buffers.</li>
<li>nominal code paths are in plain lines. A "nominal" code path corresponds to cases where the performance schema buffers are sized so that no records are lost.</li>
<li>degenerated code paths are in dotted lines. A "degenerated" code path corresponds to edge cases where parent buffers are full, which forces the code to aggregate to grand parents directly.</li>
</ul>
<p>Implemented as:</p><ul>
<li>[1] <code><a class="el" href="pfs_8cc.html#acda784c63a7659b6b976101411765376">start_mutex_wait_v1()</a></code>, <code><a class="el" href="pfs_8cc.html#abdca548d6993ee151774b12702ade008">end_mutex_wait_v1()</a></code> </li>
<li>[2] <code><a class="el" href="pfs_8cc.html#acafd687e9f830a571b5d885c0d238fbe">destroy_mutex_v1()</a></code> </li>
<li>[3] <code>aggregate_thread_waits()</code> </li>
<li>[4] <code>PFS_account::aggregate_waits()</code> </li>
<li>[A] EVENTS_WAITS_SUMMARY_BY_THREAD_BY_EVENT_NAME, <code>table_ews_by_thread_by_event_name::make_row()</code> </li>
<li>[B] EVENTS_WAITS_SUMMARY_BY_INSTANCE, <code><a class="el" href="classtable__events__waits__summary__by__instance.html#af7da0abe8ba7b98a179e8911196c8efc">table_events_waits_summary_by_instance::make_mutex_row()</a></code> </li>
<li>[C] EVENTS_WAITS_SUMMARY_GLOBAL_BY_EVENT_NAME, <code>table_ews_global_by_event_name::make_mutex_row()</code> </li>
<li>[D] EVENTS_WAITS_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME, <code>table_ews_by_account_by_event_name::make_row()</code> </li>
<li>[E] EVENTS_WAITS_SUMMARY_BY_USER_BY_EVENT_NAME, <code>table_ews_by_user_by_event_name::make_row()</code> </li>
<li>[F] EVENTS_WAITS_SUMMARY_BY_HOST_BY_EVENT_NAME, <code>table_ews_by_host_by_event_name::make_row()</code> </li>
</ul>
<p>Table EVENTS_WAITS_SUMMARY_BY_INSTANCE is a 'on the fly' aggregate, because the data is collected on the fly by (1) and stored into a buffer, pfs_mutex. The table implementation [B] simply reads the results directly from this buffer.</p>
<p>Table EVENTS_WAITS_SUMMARY_GLOBAL_BY_EVENT_NAME is a 'mixed' aggregate, because some data is collected on the fly (1), some data is preserved with (2) at a later time in the life cycle, and two different buffers pfs_mutex and pfs_mutex_class are used to store the statistics collected. The table implementation [C] is more complex, since it reads from two buffers pfs_mutex and pfs_mutex_class.</p>
<h2><a class="anchor" id="IMPL_WAIT_RWLOCK"></a>
Rwlock waits</h2>
<pre class="fragment">  rwlock_locker(T, R)
   |
   | [1]
   |
   |-&gt; pfs_rwlock(R)                          =====&gt;&gt; [B], [C]
   |    |
   |    | [2]
   |    |
   |    |-&gt; pfs_rwlock_class(R.class)         =====&gt;&gt; [C]
   |
   |-&gt; pfs_thread(T).event_name(R)            =====&gt;&gt; [A]
        |
       ...
</pre><p>Implemented as:</p><ul>
<li>[1] <code>start_rwlock_rdwait_v1()</code>, <code><a class="el" href="pfs_8cc.html#ad52e78faa896255c59629179216cb0eb">end_rwlock_rdwait_v1()</a></code>, ...</li>
<li>[2] <code><a class="el" href="pfs_8cc.html#a3797655602db115be788b08ab6328bc9">destroy_rwlock_v1()</a></code> </li>
<li>[A] EVENTS_WAITS_SUMMARY_BY_THREAD_BY_EVENT_NAME, <code>table_ews_by_thread_by_event_name::make_row()</code> </li>
<li>[B] EVENTS_WAITS_SUMMARY_BY_INSTANCE, <code><a class="el" href="classtable__events__waits__summary__by__instance.html#a7c9e846c53cc664548535f08a160759e">table_events_waits_summary_by_instance::make_rwlock_row()</a></code> </li>
<li>[C] EVENTS_WAITS_SUMMARY_GLOBAL_BY_EVENT_NAME, <code>table_ews_global_by_event_name::make_rwlock_row()</code> </li>
</ul>
<h2><a class="anchor" id="IMPL_WAIT_COND"></a>
Cond waits</h2>
<pre class="fragment">  cond_locker(T, C)
   |
   | [1]
   |
   |-&gt; pfs_cond(C)                            =====&gt;&gt; [B], [C]
   |    |
   |    | [2]
   |    |
   |    |-&gt; pfs_cond_class(C.class)           =====&gt;&gt; [C]
   |
   |-&gt; pfs_thread(T).event_name(C)            =====&gt;&gt; [A]
        |
       ...
</pre><p>Implemented as:</p><ul>
<li>[1] <code><a class="el" href="pfs_8cc.html#a3226da98cc9c85a383cc69cbfa053feb">start_cond_wait_v1()</a></code>, <code><a class="el" href="pfs_8cc.html#aedc7355c9f74eba4eeeb689208128da8">end_cond_wait_v1()</a></code> </li>
<li>[2] <code><a class="el" href="pfs_8cc.html#a5cc3539f9d62b287c53f94d790d2f06e">destroy_cond_v1()</a></code> </li>
<li>[A] EVENTS_WAITS_SUMMARY_BY_THREAD_BY_EVENT_NAME, <code>table_ews_by_thread_by_event_name::make_row()</code> </li>
<li>[B] EVENTS_WAITS_SUMMARY_BY_INSTANCE, <code><a class="el" href="classtable__events__waits__summary__by__instance.html#a1d8c078e8ab08cf810079f42a9a7ce53">table_events_waits_summary_by_instance::make_cond_row()</a></code> </li>
<li>[C] EVENTS_WAITS_SUMMARY_GLOBAL_BY_EVENT_NAME, <code>table_ews_global_by_event_name::make_cond_row()</code> </li>
</ul>
<h2><a class="anchor" id="IMPL_WAIT_FILE"></a>
File waits</h2>
<pre class="fragment">  file_locker(T, F)
   |
   | [1]
   |
   |-&gt; pfs_file(F)                            =====&gt;&gt; [B], [C], [D], [E]
   |    |
   |    | [2]
   |    |
   |    |-&gt; pfs_file_class(F.class)           =====&gt;&gt; [C], [D]
   |
   |-&gt; pfs_thread(T).event_name(F)            =====&gt;&gt; [A]
        |
       ...
</pre><p>Implemented as:</p><ul>
<li>[1] <code><a class="el" href="pfs_8cc.html#a0441265b6b960429988fed9cac036da1">get_thread_file_name_locker_v1()</a></code>, <code><a class="el" href="pfs_8cc.html#a1e858f371c9b74851268e201788c2efb">start_file_wait_v1()</a></code>, <code><a class="el" href="pfs_8cc.html#aa3088de8287afbd4ce603245b30875ea">end_file_wait_v1()</a></code>, ...</li>
<li>[2] <code>close_file_v1()</code> </li>
<li>[A] EVENTS_WAITS_SUMMARY_BY_THREAD_BY_EVENT_NAME, <code>table_ews_by_thread_by_event_name::make_row()</code> </li>
<li>[B] EVENTS_WAITS_SUMMARY_BY_INSTANCE, <code><a class="el" href="classtable__events__waits__summary__by__instance.html#a9d8ba8fd9560ec5b1ad6fd11073a2585">table_events_waits_summary_by_instance::make_file_row()</a></code> </li>
<li>[C] EVENTS_WAITS_SUMMARY_GLOBAL_BY_EVENT_NAME, <code>table_ews_global_by_event_name::make_file_row()</code> </li>
<li>[D] FILE_SUMMARY_BY_EVENT_NAME, <code><a class="el" href="classtable__file__summary__by__event__name.html#a4f7f22b8855edd0419ef06484893fdcd">table_file_summary_by_event_name::make_row()</a></code> </li>
<li>[E] FILE_SUMMARY_BY_INSTANCE, <code><a class="el" href="classtable__file__summary__by__instance.html#ad891768474e9b235a9cbac21f4551423">table_file_summary_by_instance::make_row()</a></code> </li>
</ul>
<h2><a class="anchor" id="IMPL_WAIT_SOCKET"></a>
Socket waits</h2>
<pre class="fragment">  socket_locker(T, S)
   |
   | [1]
   |
   |-&gt; pfs_socket(S)                            =====&gt;&gt; [A], [B], [C], [D], [E]
        |
        | [2]
        |
        |-&gt; pfs_socket_class(S.class)           =====&gt;&gt; [C], [D]
        |
        |-&gt; pfs_thread(T).event_name(S)         =====&gt;&gt; [A]
        |
        | [3]
        |
     3a |-&gt; pfs_account(U, H).event_name(S)     =====&gt;&gt; [F], [G], [H]
        .    |
        .    | [4-RESET]
        .    |
     3b .....+-&gt; pfs_user(U).event_name(S)      =====&gt;&gt; [G]
        .    |
     3c .....+-&gt; pfs_host(H).event_name(S)      =====&gt;&gt; [H]
</pre><p>Implemented as:</p><ul>
<li>[1] <code><a class="el" href="pfs_8cc.html#ac4bc84fe77cba6c4503f4dfade90ce98">start_socket_wait_v1()</a></code>, <code><a class="el" href="pfs_8cc.html#a6181a65e3672ac4001f833dca7b01e5f">end_socket_wait_v1()</a></code>.</li>
<li>[2] <code>close_socket_v1()</code> </li>
<li>[3] <code>aggregate_thread_waits()</code> </li>
<li>[4] <code>PFS_account::aggregate_waits()</code> </li>
<li>[5] <code>PFS_host::aggregate_waits()</code> </li>
<li>[A] EVENTS_WAITS_SUMMARY_BY_THREAD_BY_EVENT_NAME, <code>table_ews_by_thread_by_event_name::make_row()</code> </li>
<li>[B] EVENTS_WAITS_SUMMARY_BY_INSTANCE, <code><a class="el" href="classtable__events__waits__summary__by__instance.html#a8fff299d6f24703590e9aa8be18284aa">table_events_waits_summary_by_instance::make_socket_row()</a></code> </li>
<li>[C] EVENTS_WAITS_SUMMARY_GLOBAL_BY_EVENT_NAME, <code>table_ews_global_by_event_name::make_socket_row()</code> </li>
<li>[D] SOCKET_SUMMARY_BY_EVENT_NAME, <code>table_socket_summary_by_event_name::make_row()</code> </li>
<li>[E] SOCKET_SUMMARY_BY_INSTANCE, <code>table_socket_summary_by_instance::make_row()</code> </li>
<li>[F] EVENTS_WAITS_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME, <code>table_ews_by_account_by_event_name::make_row()</code> </li>
<li>[G] EVENTS_WAITS_SUMMARY_BY_USER_BY_EVENT_NAME, <code>table_ews_by_user_by_event_name::make_row()</code> </li>
<li>[H] EVENTS_WAITS_SUMMARY_BY_HOST_BY_EVENT_NAME, <code>table_ews_by_host_by_event_name::make_row()</code> </li>
</ul>
<h2><a class="anchor" id="IMPL_WAIT_TABLE"></a>
Table waits</h2>
<pre class="fragment">  table_locker(Thread Th, Table Tb, Event = io or lock)
   |
   | [1]
   |
1a |-&gt; pfs_table(Tb)                          =====&gt;&gt; [A], [B], [C]
   |    |
   |    | [2]
   |    |
   |    |-&gt; pfs_table_share(Tb.share)         =====&gt;&gt; [B], [C]
   |         |
   |         | [3]
   |         |
   |         |-&gt; global_table_io_stat         =====&gt;&gt; [C]
   |         |
   |         |-&gt; global_table_lock_stat       =====&gt;&gt; [C]
   |
1b |-&gt; pfs_thread(Th).event_name(E)           =====&gt;&gt; [D], [E], [F], [G]
   |    |
   |    | [ 4-RESET]
   |    |
   |    |-&gt; pfs_account(U, H).event_name(E)   =====&gt;&gt; [E], [F], [G]
   |    .    |
   |    .    | [5-RESET]
   |    .    |
   |    .....+-&gt; pfs_user(U).event_name(E)    =====&gt;&gt; [F]
   |    .    |
   |    .....+-&gt; pfs_host(H).event_name(E)    =====&gt;&gt; [G]
   |
1c |-&gt; pfs_thread(Th).waits_current(W)        =====&gt;&gt; [H]
   |
1d |-&gt; pfs_thread(Th).waits_history(W)        =====&gt;&gt; [I]
   |
1e |-&gt; waits_history_long(W)                  =====&gt;&gt; [J]
</pre><p>Implemented as:</p><ul>
<li>[1] <code><a class="el" href="pfs_8cc.html#aee8d22329bf2a9f0fc61034ae0c485bc">start_table_io_wait_v1()</a></code>, <code><a class="el" href="pfs_8cc.html#a9a58830e00c9d360b30a85525700283d">end_table_io_wait_v1()</a></code> </li>
<li>[2] <code><a class="el" href="pfs_8cc.html#a5c57e5cb62bfef9018e6427fa9647672">close_table_v1()</a></code> </li>
<li>[3] <code><a class="el" href="pfs_8cc.html#a0f25440682cf14328375f1371259393b">drop_table_share_v1()</a></code> </li>
<li>[4] <code>TRUNCATE</code> <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> EVENTS_WAITS_SUMMARY_BY_THREAD_BY_EVENT_NAME</li>
<li>[5] <code>TRUNCATE</code> <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> EVENTS_WAITS_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME</li>
<li>[A] EVENTS_WAITS_SUMMARY_BY_INSTANCE, <code>table_events_waits_summary_by_instance::make_table_row()</code> </li>
<li>[B] OBJECTS_SUMMARY_GLOBAL_BY_TYPE, <code>table_os_global_by_type::make_row()</code> </li>
<li>[C] EVENTS_WAITS_SUMMARY_GLOBAL_BY_EVENT_NAME, <code>table_ews_global_by_event_name::make_table_io_row()</code>, <code>table_ews_global_by_event_name::make_table_lock_row()</code> </li>
<li>[D] EVENTS_WAITS_SUMMARY_BY_THREAD_BY_EVENT_NAME, <code>table_ews_by_thread_by_event_name::make_row()</code> </li>
<li>[E] EVENTS_WAITS_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME, <code>table_ews_by_user_by_account_name::make_row()</code> </li>
<li>[F] EVENTS_WAITS_SUMMARY_BY_USER_BY_EVENT_NAME, <code>table_ews_by_user_by_event_name::make_row()</code> </li>
<li>[G] EVENTS_WAITS_SUMMARY_BY_HOST_BY_EVENT_NAME, <code>table_ews_by_host_by_event_name::make_row()</code> </li>
<li>[H] EVENTS_WAITS_CURRENT, <code><a class="el" href="classtable__events__waits__common.html#a7a0d7fc7d1514e5c4882177f214b685b">table_events_waits_common::make_row()</a></code> </li>
<li>[I] EVENTS_WAITS_HISTORY, <code><a class="el" href="classtable__events__waits__common.html#a7a0d7fc7d1514e5c4882177f214b685b">table_events_waits_common::make_row()</a></code> </li>
<li>[J] EVENTS_WAITS_HISTORY_LONG, <code><a class="el" href="classtable__events__waits__common.html#a7a0d7fc7d1514e5c4882177f214b685b">table_events_waits_common::make_row()</a></code> </li>
</ul>
<h1><a class="anchor" id="IMPL_STAGE"></a>
Implementation for stages aggregates</h1>
<p>For stages, the tables that contains aggregated data are:</p><ul>
<li>EVENTS_STAGES_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME</li>
<li>EVENTS_STAGES_SUMMARY_BY_HOST_BY_EVENT_NAME</li>
<li>EVENTS_STAGES_SUMMARY_BY_THREAD_BY_EVENT_NAME</li>
<li>EVENTS_STAGES_SUMMARY_BY_USER_BY_EVENT_NAME</li>
<li>EVENTS_STAGES_SUMMARY_GLOBAL_BY_EVENT_NAME</li>
</ul>
<pre class="fragment">  start_stage(T, S)
   |
   | [1]
   |
1a |-&gt; pfs_thread(T).event_name(S)            =====&gt;&gt; [A], [B], [C], [D], [E]
   |    |
   |    | [2]
   |    |
   | 2a |-&gt; pfs_account(U, H).event_name(S)   =====&gt;&gt; [B], [C], [D], [E]
   |    .    |
   |    .    | [3-RESET]
   |    .    |
   | 2b .....+-&gt; pfs_user(U).event_name(S)    =====&gt;&gt; [C]
   |    .    |
   | 2c .....+-&gt; pfs_host(H).event_name(S)    =====&gt;&gt; [D], [E]
   |    .    .    |
   |    .    .    | [4-RESET]
   | 2d .    .    |
1b |----+----+----+-&gt; pfs_stage_class(S)      =====&gt;&gt; [E]</pre><p>Implemented as:</p><ul>
<li>[1] <code>start_stage_v1()</code> </li>
<li>[2] <code><a class="el" href="pfs_8cc.html#a457186fb5f1b45af3887b6d0796284a6">delete_thread_v1()</a></code>, <code>aggregate_thread_stages()</code> </li>
<li>[3] <code>PFS_account::aggregate_stages()</code> </li>
<li>[4] <code>PFS_host::aggregate_stages()</code> </li>
<li>[A] EVENTS_STAGES_SUMMARY_BY_THREAD_BY_EVENT_NAME, <code>table_esgs_by_thread_by_event_name::make_row()</code> </li>
<li>[B] EVENTS_STAGES_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME, <code>table_esgs_by_account_by_event_name::make_row()</code> </li>
<li>[C] EVENTS_STAGES_SUMMARY_BY_USER_BY_EVENT_NAME, <code>table_esgs_by_user_by_event_name::make_row()</code> </li>
<li>[D] EVENTS_STAGES_SUMMARY_BY_HOST_BY_EVENT_NAME, <code>table_esgs_by_host_by_event_name::make_row()</code> </li>
<li>[E] EVENTS_STAGES_SUMMARY_GLOBAL_BY_EVENT_NAME, <code>table_esgs_global_by_event_name::make_row()</code> </li>
</ul>
<h1><a class="anchor" id="IMPL_STATEMENT"></a>
Implementation for statements consumers</h1>
<p>For statements, the tables that contains individual event data are:</p><ul>
<li>EVENTS_STATEMENTS_CURRENT</li>
<li>EVENTS_STATEMENTS_HISTORY</li>
<li>EVENTS_STATEMENTS_HISTORY_LONG</li>
</ul>
<p>For statements, the tables that contains aggregated data are:</p><ul>
<li>EVENTS_STATEMENTS_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME</li>
<li>EVENTS_STATEMENTS_SUMMARY_BY_HOST_BY_EVENT_NAME</li>
<li>EVENTS_STATEMENTS_SUMMARY_BY_THREAD_BY_EVENT_NAME</li>
<li>EVENTS_STATEMENTS_SUMMARY_BY_USER_BY_EVENT_NAME</li>
<li>EVENTS_STATEMENTS_SUMMARY_GLOBAL_BY_EVENT_NAME</li>
<li>EVENTS_STATEMENTS_SUMMARY_BY_DIGEST</li>
</ul>
<pre class="fragment">  statement_locker(T, S)
   |
   | [1]
   |
1a |-&gt; pfs_thread(T).event_name(S)            =====&gt;&gt; [A], [B], [C], [D], [E]
   |    |
   |    | [2]
   |    |
   | 2a |-&gt; pfs_account(U, H).event_name(S)   =====&gt;&gt; [B], [C], [D], [E]
   |    .    |
   |    .    | [3-RESET]
   |    .    |
   | 2b .....+-&gt; pfs_user(U).event_name(S)    =====&gt;&gt; [C]
   |    .    |
   | 2c .....+-&gt; pfs_host(H).event_name(S)    =====&gt;&gt; [D], [E]
   |    .    .    |
   |    .    .    | [4-RESET]
   | 2d .    .    |
1b |----+----+----+-&gt; pfs_statement_class(S)  =====&gt;&gt; [E]
   |
1c |-&gt; pfs_thread(T).statement_current(S)     =====&gt;&gt; [F]
   |
1d |-&gt; pfs_thread(T).statement_history(S)     =====&gt;&gt; [G]
   |
1e |-&gt; statement_history_long(S)              =====&gt;&gt; [H]
   |
1f |-&gt; statement_digest(S)                    =====&gt;&gt; [I]</pre><p>Implemented as:</p><ul>
<li>[1] <code>start_statement_v1()</code>, end_statement_v1() (1a, 1b) is an aggregation by EVENT_NAME, (1c, 1d, 1e) is an aggregation by TIME, (1f) is an aggregation by DIGEST all of these are orthogonal, and implemented in end_statement_v1().</li>
<li>[2] <code><a class="el" href="pfs_8cc.html#a457186fb5f1b45af3887b6d0796284a6">delete_thread_v1()</a></code>, <code>aggregate_thread_statements()</code> </li>
<li>[3] <code>PFS_account::aggregate_statements()</code> </li>
<li>[4] <code>PFS_host::aggregate_statements()</code> </li>
<li>[A] EVENTS_STATEMENTS_SUMMARY_BY_THREAD_BY_EVENT_NAME, <code>table_esms_by_thread_by_event_name::make_row()</code> </li>
<li>[B] EVENTS_STATEMENTS_SUMMARY_BY_ACCOUNT_BY_EVENT_NAME, <code>table_esms_by_account_by_event_name::make_row()</code> </li>
<li>[C] EVENTS_STATEMENTS_SUMMARY_BY_USER_BY_EVENT_NAME, <code>table_esms_by_user_by_event_name::make_row()</code> </li>
<li>[D] EVENTS_STATEMENTS_SUMMARY_BY_HOST_BY_EVENT_NAME, <code>table_esms_by_host_by_event_name::make_row()</code> </li>
<li>[E] EVENTS_STATEMENTS_SUMMARY_GLOBAL_BY_EVENT_NAME, <code>table_esms_global_by_event_name::make_row()</code> </li>
<li>[F] EVENTS_STATEMENTS_CURRENT, <code><a class="el" href="classtable__events__statements__current.html#af1d8fd7c92c7e2615c0ae9586377ad25">table_events_statements_current::rnd_next()</a></code>, <code>table_events_statements_common::make_row()</code> </li>
<li>[G] EVENTS_STATEMENTS_HISTORY, <code><a class="el" href="classtable__events__statements__history.html#aff1440979c4b92e08375447d2ae7c1bb">table_events_statements_history::rnd_next()</a></code>, <code>table_events_statements_common::make_row()</code> </li>
<li>[H] EVENTS_STATEMENTS_HISTORY_LONG, <code><a class="el" href="classtable__events__statements__history__long.html#adf5b1ab9134ba9974be33c9095793602">table_events_statements_history_long::rnd_next()</a></code>, <code>table_events_statements_common::make_row()</code> </li>
<li>[I] EVENTS_STATEMENTS_SUMMARY_BY_DIGEST <code>table_esms_by_digest::make_row()</code> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

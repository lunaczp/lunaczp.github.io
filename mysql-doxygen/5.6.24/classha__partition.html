<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: ha_partition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classha__partition-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ha_partition Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for ha_partition:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classha__partition.png" usemap="#ha_5Fpartition_map" alt=""/>
  <map id="ha_5Fpartition_map" name="ha_5Fpartition_map">
<area href="classhandler.html" alt="handler" shape="rect" coords="0,56,78,80"/>
<area href="class_sql__alloc.html" alt="Sql_alloc" shape="rect" coords="0,0,78,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6803596d872baa81045ee4a9c0694c0"><td class="memItemLeft" align="right" valign="top"><a id="af6803596d872baa81045ee4a9c0694c0"></a>
<a class="el" href="class_partition__share.html">Partition_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_part_share</b> ()</td></tr>
<tr class="separator:af6803596d872baa81045ee4a9c0694c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a53483496f68b8d44c120414db1f20"><td class="memItemLeft" align="right" valign="top"><a id="a59a53483496f68b8d44c120414db1f20"></a>
<a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:a59a53483496f68b8d44c120414db1f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcc90572e55257dc82499aa1168079a"><td class="memItemLeft" align="right" valign="top"><a id="aefcc90572e55257dc82499aa1168079a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_part_info</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info, bool early)</td></tr>
<tr class="separator:aefcc90572e55257dc82499aa1168079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8490262a2f4deafaa07d8d7eeb6110e9"><td class="memItemLeft" align="right" valign="top"><a id="a8490262a2f4deafaa07d8d7eeb6110e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ha_partition</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *table)</td></tr>
<tr class="separator:a8490262a2f4deafaa07d8d7eeb6110e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d21e7f4c644b40aae4d6089e637ab4"><td class="memItemLeft" align="right" valign="top"><a id="a56d21e7f4c644b40aae4d6089e637ab4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ha_partition</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="classpartition__info.html">partition_info</a> *part_info)</td></tr>
<tr class="separator:a56d21e7f4c644b40aae4d6089e637ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d768a1777093ccde7ecce3677cad2d"><td class="memItemLeft" align="right" valign="top"><a id="a40d768a1777093ccde7ecce3677cad2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ha_partition</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share, <a class="el" href="classpartition__info.html">partition_info</a> *part_info_arg, <a class="el" href="classha__partition.html">ha_partition</a> *clone_arg, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *clone_mem_root_arg)</td></tr>
<tr class="separator:a40d768a1777093ccde7ecce3677cad2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5f589be346d6a1cc22d02bb6fd55ae"><td class="memItemLeft" align="right" valign="top"><a id="afa5f589be346d6a1cc22d02bb6fd55ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initialize_partition</b> (<a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:afa5f589be346d6a1cc22d02bb6fd55ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdb3caedb579b35d9cda963b7a3c25f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aafdb3caedb579b35d9cda963b7a3c25f">delete_table</a> (const char *<a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a>)</td></tr>
<tr class="separator:aafdb3caedb579b35d9cda963b7a3c25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbc26903dfbc0128c0d5a7e68d3681b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a7dbc26903dfbc0128c0d5a7e68d3681b">rename_table</a> (const char *<a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a>, const char *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>)</td></tr>
<tr class="separator:a7dbc26903dfbc0128c0d5a7e68d3681b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a47fa739883b50c802d7b7731a2783"><td class="memItemLeft" align="right" valign="top"><a id="a75a47fa739883b50c802d7b7731a2783"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="ha__innodb_8cc.html#ae64f1475e9ca79d24be2a8091b9cbdd7">form</a>, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:a75a47fa739883b50c802d7b7731a2783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a209a58b239d6fab299adbb347d70e"><td class="memItemLeft" align="right" valign="top"><a id="ad1a209a58b239d6fab299adbb347d70e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create_handler_files</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:ad1a209a58b239d6fab299adbb347d70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56a3b571d71004409881cf4a54c1a16"><td class="memItemLeft" align="right" valign="top"><a id="ab56a3b571d71004409881cf4a54c1a16"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>update_create_info</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:ab56a3b571d71004409881cf4a54c1a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc862beba6055a3f2f64f20c60085de"><td class="memItemLeft" align="right" valign="top"><a id="a8dc862beba6055a3f2f64f20c60085de"></a>
virtual char *&#160;</td><td class="memItemRight" valign="bottom"><b>update_table_comment</b> (const char *comment)</td></tr>
<tr class="separator:a8dc862beba6055a3f2f64f20c60085de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0318a9d8d97e84ecd28f37cc29405b"><td class="memItemLeft" align="right" valign="top"><a id="a5e0318a9d8d97e84ecd28f37cc29405b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>change_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)</td></tr>
<tr class="separator:a5e0318a9d8d97e84ecd28f37cc29405b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b4ba0f54dde5d6259f7144e9f3df4d"><td class="memItemLeft" align="right" valign="top"><a id="ab8b4ba0f54dde5d6259f7144e9f3df4d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>drop_partitions</b> (const char *path)</td></tr>
<tr class="separator:ab8b4ba0f54dde5d6259f7144e9f3df4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152d4ec6a0bfd43f7d6fbff72bd174cf"><td class="memItemLeft" align="right" valign="top"><a id="a152d4ec6a0bfd43f7d6fbff72bd174cf"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rename_partitions</b> (const char *path)</td></tr>
<tr class="separator:a152d4ec6a0bfd43f7d6fbff72bd174cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ca395ca5c6066f00b30a9ccedfc43d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a36ca395ca5c6066f00b30a9ccedfc43d">get_no_parts</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, uint *num_parts)</td></tr>
<tr class="separator:a36ca395ca5c6066f00b30a9ccedfc43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d96fbe82c767c02bb81ef569b7bc3c"><td class="memItemLeft" align="right" valign="top"><a id="af9d96fbe82c767c02bb81ef569b7bc3c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>change_table_ptr</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table_arg, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:af9d96fbe82c767c02bb81ef569b7bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a9fc27dbc3652fec1fab4c7d9c077c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a66a9fc27dbc3652fec1fab4c7d9c077c">check_if_incompatible_data</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, uint table_changes)</td></tr>
<tr class="separator:a66a9fc27dbc3652fec1fab4c7d9c077c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70beac6714c1abca828bcbabbe6bf190"><td class="memItemLeft" align="right" valign="top"><a id="a70beac6714c1abca828bcbabbe6bf190"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>open</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, int <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, uint test_if_locked)</td></tr>
<tr class="separator:a70beac6714c1abca828bcbabbe6bf190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a208357e1474ef88323597c867399aa"><td class="memItemLeft" align="right" valign="top"><a id="a6a208357e1474ef88323597c867399aa"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>close</b> (void)</td></tr>
<tr class="separator:a6a208357e1474ef88323597c867399aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590ff604823725a59b5b7dd1fa83ac35"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">store_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> **<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>, enum thr_lock_type lock_type)</td></tr>
<tr class="separator:a590ff604823725a59b5b7dd1fa83ac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c3cd020a08eca662a3fe09df371d0b"><td class="memItemLeft" align="right" valign="top"><a id="a23c3cd020a08eca662a3fe09df371d0b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>external_lock</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, int lock_type)</td></tr>
<tr class="separator:a23c3cd020a08eca662a3fe09df371d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27278995a01cd7ceb1589226042cbe1"><td class="memItemLeft" align="right" valign="top"><a id="ac27278995a01cd7ceb1589226042cbe1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>start_stmt</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, thr_lock_type lock_type)</td></tr>
<tr class="separator:ac27278995a01cd7ceb1589226042cbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34acffe19d43c2dc2570e995cf22a3d8"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a34acffe19d43c2dc2570e995cf22a3d8">lock_count</a> (void) const</td></tr>
<tr class="separator:a34acffe19d43c2dc2570e995cf22a3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e4eb4cddc860809124d44d18335735"><td class="memItemLeft" align="right" valign="top"><a id="af5e4eb4cddc860809124d44d18335735"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_row</b> ()</td></tr>
<tr class="separator:af5e4eb4cddc860809124d44d18335735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a059c1ac08f3cd71b7087b876664e18"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a2a059c1ac08f3cd71b7087b876664e18">was_semi_consistent_read</a> ()</td></tr>
<tr class="separator:a2a059c1ac08f3cd71b7087b876664e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45235c1c364a4b1ac4a2b97134f7a4b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a45235c1c364a4b1ac4a2b97134f7a4b4">try_semi_consistent_read</a> (bool)</td></tr>
<tr class="separator:a45235c1c364a4b1ac4a2b97134f7a4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d60dde334dc67cdc7e7515c0d7d22a7"><td class="memItemLeft" align="right" valign="top"><a id="a2d60dde334dc67cdc7e7515c0d7d22a7"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>write_row</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a2d60dde334dc67cdc7e7515c0d7d22a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f735d915addfb3d9381a2959c31627"><td class="memItemLeft" align="right" valign="top"><a id="a77f735d915addfb3d9381a2959c31627"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr class="separator:a77f735d915addfb3d9381a2959c31627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afdb18e852abb6b174807e1386873e8"><td class="memItemLeft" align="right" valign="top"><a id="a0afdb18e852abb6b174807e1386873e8"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>delete_row</b> (const uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a0afdb18e852abb6b174807e1386873e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad162b32125ed0d7fb4b5b8167ce0269d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ad162b32125ed0d7fb4b5b8167ce0269d">delete_all_rows</a> (void)</td></tr>
<tr class="separator:ad162b32125ed0d7fb4b5b8167ce0269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42819e5cf989a23c0ade56feece2bcf4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a42819e5cf989a23c0ade56feece2bcf4">truncate</a> ()</td></tr>
<tr class="separator:a42819e5cf989a23c0ade56feece2bcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5fd3ae994fb440ffbb428b61a547fa"><td class="memItemLeft" align="right" valign="top"><a id="aee5fd3ae994fb440ffbb428b61a547fa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>start_bulk_insert</b> (ha_rows rows)</td></tr>
<tr class="separator:aee5fd3ae994fb440ffbb428b61a547fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6d95b4f15b8add5f5861369642a228"><td class="memItemLeft" align="right" valign="top"><a id="a8b6d95b4f15b8add5f5861369642a228"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>end_bulk_insert</b> ()</td></tr>
<tr class="separator:a8b6d95b4f15b8add5f5861369642a228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c01259c896144ad73923ee040e8b250"><td class="memItemLeft" align="right" valign="top"><a id="a6c01259c896144ad73923ee040e8b250"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>truncate_partition</b> (<a class="el" href="class_alter__info.html">Alter_info</a> *, bool *binlog_stmt)</td></tr>
<tr class="separator:a6c01259c896144ad73923ee040e8b250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e8ff8fce23b0ca305755e60d960cd9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a18e8ff8fce23b0ca305755e60d960cd9">is_fatal_error</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:a18e8ff8fce23b0ca305755e60d960cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1716a11f635614b7772b9b0711a1ff"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a0f1716a11f635614b7772b9b0711a1ff">rnd_init</a> (bool scan)</td></tr>
<tr class="separator:a0f1716a11f635614b7772b9b0711a1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d1115f4e995902c6026f08f1b0c995"><td class="memItemLeft" align="right" valign="top"><a id="a33d1115f4e995902c6026f08f1b0c995"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rnd_end</b> ()</td></tr>
<tr class="separator:a33d1115f4e995902c6026f08f1b0c995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad468c67dd2f37885994530f9e2ad2266"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ad468c67dd2f37885994530f9e2ad2266">rnd_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ad468c67dd2f37885994530f9e2ad2266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b052173ced1b88687dafba28a170335"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a7b052173ced1b88687dafba28a170335">rnd_pos</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uchar *pos)</td></tr>
<tr class="separator:a7b052173ced1b88687dafba28a170335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bbc7153fa41de3b53872cb8f4b4e6e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a58bbc7153fa41de3b53872cb8f4b4e6e">rnd_pos_by_record</a> (uchar *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="separator:a58bbc7153fa41de3b53872cb8f4b4e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af141cad25dc072898fa699e7b4cd2e33"><td class="memItemLeft" align="right" valign="top"><a id="af141cad25dc072898fa699e7b4cd2e33"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (const uchar *<a class="el" href="structrecord.html">record</a>)</td></tr>
<tr class="separator:af141cad25dc072898fa699e7b4cd2e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e153d8c7280e6d4440b09c61976e7f3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3">index_read_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="memdesc:a7e153d8c7280e6d4440b09c61976e7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="#a7e153d8c7280e6d4440b09c61976e7f3">More...</a><br /></td></tr>
<tr class="separator:a7e153d8c7280e6d4440b09c61976e7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47563fa6bac6a69ab66f79b18b40c7a3"><td class="memItemLeft" align="right" valign="top"><a id="a47563fa6bac6a69ab66f79b18b40c7a3"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_init</b> (uint idx, bool sorted)</td></tr>
<tr class="separator:a47563fa6bac6a69ab66f79b18b40c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388eb1eb01753bff5130d5b7aa265d6a"><td class="memItemLeft" align="right" valign="top"><a id="a388eb1eb01753bff5130d5b7aa265d6a"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_end</b> ()</td></tr>
<tr class="separator:a388eb1eb01753bff5130d5b7aa265d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee13430aea3946ffa6cf2c00104ba19c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aee13430aea3946ffa6cf2c00104ba19c">index_read_idx_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:aee13430aea3946ffa6cf2c00104ba19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a599d1fe239ff7d7dba0b3984fc8bea"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a6a599d1fe239ff7d7dba0b3984fc8bea">index_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a6a599d1fe239ff7d7dba0b3984fc8bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25706609cb26f778dd90cc2611b112fd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a25706609cb26f778dd90cc2611b112fd">index_prev</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a25706609cb26f778dd90cc2611b112fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc714b62d79e24a9c1d4f3db712322b1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#acc714b62d79e24a9c1d4f3db712322b1">index_first</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:acc714b62d79e24a9c1d4f3db712322b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4defdf04378b86f231928ed21e017b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4e4defdf04378b86f231928ed21e017b">index_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a4e4defdf04378b86f231928ed21e017b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2769f8f7dd54eebb15c6baa6c4651b2b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a2769f8f7dd54eebb15c6baa6c4651b2b">index_next_same</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a2769f8f7dd54eebb15c6baa6c4651b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28896451f43f7b821e441413936c93c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ae28896451f43f7b821e441413936c93c">index_read_last_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="memdesc:ae28896451f43f7b821e441413936c93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="#ae28896451f43f7b821e441413936c93c">More...</a><br /></td></tr>
<tr class="separator:ae28896451f43f7b821e441413936c93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0217cd2a331904f87fbfcbe4dde5800"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aa0217cd2a331904f87fbfcbe4dde5800">read_range_first</a> (const <a class="el" href="structst__key__range.html">key_range</a> *start_key, const <a class="el" href="structst__key__range.html">key_range</a> *end_key, bool eq_range, bool sorted)</td></tr>
<tr class="memdesc:aa0217cd2a331904f87fbfcbe4dde5800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges. Store ranges for future calls to read_range_next.  <a href="#aa0217cd2a331904f87fbfcbe4dde5800">More...</a><br /></td></tr>
<tr class="separator:aa0217cd2a331904f87fbfcbe4dde5800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77ce0688d4d2c0451dcb930e6ca42bc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ae77ce0688d4d2c0451dcb930e6ca42bc">read_range_next</a> ()</td></tr>
<tr class="memdesc:ae77ce0688d4d2c0451dcb930e6ca42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="#ae77ce0688d4d2c0451dcb930e6ca42bc">More...</a><br /></td></tr>
<tr class="separator:ae77ce0688d4d2c0451dcb930e6ca42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca42c32f4f86c02ecd6a6b50ea8069ef"><td class="memItemLeft" align="right" valign="top"><a id="aca42c32f4f86c02ecd6a6b50ea8069ef"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>info</b> (uint)</td></tr>
<tr class="separator:aca42c32f4f86c02ecd6a6b50ea8069ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfcb1d03a905441a9e19f346b138e46"><td class="memItemLeft" align="right" valign="top"><a id="a5bfcb1d03a905441a9e19f346b138e46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_dynamic_partition_info</b> (<a class="el" href="struct_p_a_r_t_i_t_i_o_n___s_t_a_t_s.html">PARTITION_STATS</a> *stat_info, uint part_id)</td></tr>
<tr class="separator:a5bfcb1d03a905441a9e19f346b138e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7739999a9b890dabd3d100b266b5021f"><td class="memItemLeft" align="right" valign="top"><a id="a7739999a9b890dabd3d100b266b5021f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra</b> (enum ha_extra_function operation)</td></tr>
<tr class="separator:a7739999a9b890dabd3d100b266b5021f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd6a052f1c518cc47275debb830ca5d"><td class="memItemLeft" align="right" valign="top"><a id="acbd6a052f1c518cc47275debb830ca5d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra_opt</b> (enum ha_extra_function operation, ulong cachesize)</td></tr>
<tr class="separator:acbd6a052f1c518cc47275debb830ca5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd96d4f1ecc4e63d6afbcc6d6d4c243"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a0dd96d4f1ecc4e63d6afbcc6d6d4c243">reset</a> (void)</td></tr>
<tr class="separator:a0dd96d4f1ecc4e63d6afbcc6d6d4c243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4673b0434ccbcd97542e1f7636d61db2"><td class="memItemLeft" align="right" valign="top">virtual my_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4673b0434ccbcd97542e1f7636d61db2">register_query_cache_table</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, char *table_key, uint key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)</td></tr>
<tr class="memdesc:a4673b0434ccbcd97542e1f7636d61db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a named table with a call back function to the query cache.  <a href="#a4673b0434ccbcd97542e1f7636d61db2">More...</a><br /></td></tr>
<tr class="separator:a4673b0434ccbcd97542e1f7636d61db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206e311288c7006bfc19ba1a63435c34"><td class="memItemLeft" align="right" valign="top"><a id="a206e311288c7006bfc19ba1a63435c34"></a>
virtual const <a class="el" href="class_bitmap_3_0164_01_4.html">key_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keys_to_use_for_scanning</b> ()</td></tr>
<tr class="separator:a206e311288c7006bfc19ba1a63435c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da2487666ad4209a0cd2002f6a6714b"><td class="memItemLeft" align="right" valign="top"><a id="a9da2487666ad4209a0cd2002f6a6714b"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>scan_time</b> ()</td></tr>
<tr class="separator:a9da2487666ad4209a0cd2002f6a6714b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cd9274cdcf243f53efc8c236bb8379"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ae2cd9274cdcf243f53efc8c236bb8379">read_time</a> (uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, uint ranges, ha_rows rows)</td></tr>
<tr class="separator:ae2cd9274cdcf243f53efc8c236bb8379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f108027df076f8ba593c60c08d3c98"><td class="memItemLeft" align="right" valign="top"><a id="a80f108027df076f8ba593c60c08d3c98"></a>
virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>records_in_range</b> (uint inx, <a class="el" href="structst__key__range.html">key_range</a> *min_key, <a class="el" href="structst__key__range.html">key_range</a> *max_key)</td></tr>
<tr class="separator:a80f108027df076f8ba593c60c08d3c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663485370abf958b89641924402db405"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a663485370abf958b89641924402db405">estimate_rows_upper_bound</a> ()</td></tr>
<tr class="separator:a663485370abf958b89641924402db405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4f4002504f73ed3ae195729b95603b"><td class="memItemLeft" align="right" valign="top">virtual uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a2b4f4002504f73ed3ae195729b95603b">table_cache_type</a> ()</td></tr>
<tr class="separator:a2b4f4002504f73ed3ae195729b95603b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada684ff4029d92f8b693952ccb780948"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ada684ff4029d92f8b693952ccb780948">records</a> ()</td></tr>
<tr class="separator:ada684ff4029d92f8b693952ccb780948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324b474174eed94b5b6af6be57391883"><td class="memItemLeft" align="right" valign="top"><a id="a324b474174eed94b5b6af6be57391883"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_key_hash_value</b> (<a class="el" href="class_field.html">Field</a> **field_array)</td></tr>
<tr class="separator:a324b474174eed94b5b6af6be57391883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355d772428660165c27f30457a3ce6ae"><td class="memItemLeft" align="right" valign="top"><a id="a355d772428660165c27f30457a3ce6ae"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> (uint inx)</td></tr>
<tr class="separator:a355d772428660165c27f30457a3ce6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccd1f4c54f976848686ae866e7f9c96"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4ccd1f4c54f976848686ae866e7f9c96">table_type</a> () const</td></tr>
<tr class="separator:a4ccd1f4c54f976848686ae866e7f9c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f337e2cd0e372d26af8222920a063d"><td class="memItemLeft" align="right" valign="top">virtual enum row_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ab4f337e2cd0e372d26af8222920a063d">get_row_type</a> () const</td></tr>
<tr class="separator:ab4f337e2cd0e372d26af8222920a063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbddb8246029958806a6078b3ea71b32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#afbddb8246029958806a6078b3ea71b32">print_error</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, myf errflag)</td></tr>
<tr class="separator:afbddb8246029958806a6078b3ea71b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb5ad51d61c07878d5626a315534497"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4fb5ad51d61c07878d5626a315534497">get_error_message</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>, <a class="el" href="class_string.html">String</a> *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a4fb5ad51d61c07878d5626a315534497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860884095b12882553cb2fe434e147bd"><td class="memItemLeft" align="right" valign="top"><a id="a860884095b12882553cb2fe434e147bd"></a>
virtual Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>table_flags</b> () const</td></tr>
<tr class="separator:a860884095b12882553cb2fe434e147bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d10a8495693f2b56eb73948c40ab176"><td class="memItemLeft" align="right" valign="top"><a id="a9d10a8495693f2b56eb73948c40ab176"></a>
virtual ulong&#160;</td><td class="memItemRight" valign="bottom"><b>index_flags</b> (uint inx, uint part, bool all_parts) const</td></tr>
<tr class="separator:a9d10a8495693f2b56eb73948c40ab176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6624f8a6246ce09553fece606d05df"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a1e6624f8a6246ce09553fece606d05df">alter_table_flags</a> (uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:a1e6624f8a6246ce09553fece606d05df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1b45cb204fe8102d7ac0b3214c8353"><td class="memItemLeft" align="right" valign="top">virtual const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aad1b45cb204fe8102d7ac0b3214c8353">bas_ext</a> () const</td></tr>
<tr class="separator:aad1b45cb204fe8102d7ac0b3214c8353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdad48af28ddaf4c911329f23fe535e"><td class="memItemLeft" align="right" valign="top"><a id="a2fdad48af28ddaf4c911329f23fe535e"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>min_of_the_max_uint</b> (uint(handler::*operator_func)(void) const) const</td></tr>
<tr class="separator:a2fdad48af28ddaf4c911329f23fe535e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadf4f7bb534d1c5413d3f866380f29e"><td class="memItemLeft" align="right" valign="top"><a id="afadf4f7bb534d1c5413d3f866380f29e"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_record_length</b> () const</td></tr>
<tr class="separator:afadf4f7bb534d1c5413d3f866380f29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711460239e4ced410071dbfd24e4ad2b"><td class="memItemLeft" align="right" valign="top"><a id="a711460239e4ced410071dbfd24e4ad2b"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_keys</b> () const</td></tr>
<tr class="separator:a711460239e4ced410071dbfd24e4ad2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a15e628823aefedcf8c54cbb1b386d"><td class="memItemLeft" align="right" valign="top"><a id="ab5a15e628823aefedcf8c54cbb1b386d"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_parts</b> () const</td></tr>
<tr class="separator:ab5a15e628823aefedcf8c54cbb1b386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2704628aced767e0c04faa85bb7cf76b"><td class="memItemLeft" align="right" valign="top"><a id="a2704628aced767e0c04faa85bb7cf76b"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_length</b> () const</td></tr>
<tr class="separator:a2704628aced767e0c04faa85bb7cf76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990e9b1b9afa91620ce81637a0c3c618"><td class="memItemLeft" align="right" valign="top"><a id="a990e9b1b9afa91620ce81637a0c3c618"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_part_length</b> () const</td></tr>
<tr class="separator:a990e9b1b9afa91620ce81637a0c3c618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba55d308846ceb0b95f24fac9a1fb7ad"><td class="memItemLeft" align="right" valign="top"><a id="aba55d308846ceb0b95f24fac9a1fb7ad"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>low_byte_first</b> () const</td></tr>
<tr class="separator:aba55d308846ceb0b95f24fac9a1fb7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7e2ab3f6583f38765c7d121b11209a"><td class="memItemLeft" align="right" valign="top"><a id="a4b7e2ab3f6583f38765c7d121b11209a"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>extra_rec_buf_length</b> () const</td></tr>
<tr class="separator:a4b7e2ab3f6583f38765c7d121b11209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae715aeed3505a286816164fbcd709a6a"><td class="memItemLeft" align="right" valign="top"><a id="ae715aeed3505a286816164fbcd709a6a"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>min_record_length</b> (uint options) const</td></tr>
<tr class="separator:ae715aeed3505a286816164fbcd709a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e725f6ebb1ff10140a3f6cddc7a35a"><td class="memItemLeft" align="right" valign="top"><a id="a14e725f6ebb1ff10140a3f6cddc7a35a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>primary_key_is_clustered</b> ()</td></tr>
<tr class="separator:a14e725f6ebb1ff10140a3f6cddc7a35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1014411cda7052e73ee1044b4b8a4be4"><td class="memItemLeft" align="right" valign="top"><a id="a1014411cda7052e73ee1044b4b8a4be4"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_ref</b> (const uchar *ref1, const uchar *ref2)</td></tr>
<tr class="separator:a1014411cda7052e73ee1044b4b8a4be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7668775be94bce9d7cf799c051096380"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a7668775be94bce9d7cf799c051096380">get_auto_increment</a> (ulonglong <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ulonglong increment, ulonglong nb_desired_values, ulonglong *first_value, ulonglong *nb_reserved_values)</td></tr>
<tr class="separator:a7668775be94bce9d7cf799c051096380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09641064fc782d4092e1e4033018da5e"><td class="memItemLeft" align="right" valign="top"><a id="a09641064fc782d4092e1e4033018da5e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>release_auto_increment</b> ()</td></tr>
<tr class="separator:a09641064fc782d4092e1e4033018da5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cefc229e5b84f939d5fee99729b778b"><td class="memItemLeft" align="right" valign="top"><a id="a9cefc229e5b84f939d5fee99729b778b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>init_table_handle_for_HANDLER</b> ()</td></tr>
<tr class="separator:a9cefc229e5b84f939d5fee99729b778b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b83aeaba7dadd1b28c22457ac67f43b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a8b83aeaba7dadd1b28c22457ac67f43b">can_switch_engines</a> ()</td></tr>
<tr class="separator:a8b83aeaba7dadd1b28c22457ac67f43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb5f75cddb82102a64ac36bfceaef57"><td class="memItemLeft" align="right" valign="top">virtual enum_alter_inplace_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aeeb5f75cddb82102a64ac36bfceaef57">check_if_supported_inplace_alter</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:aeeb5f75cddb82102a64ac36bfceaef57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60893ae5e2153faa3f35ffde0460d9d6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a60893ae5e2153faa3f35ffde0460d9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772afdad3f8e79ecf0c176dfee5c95d2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a772afdad3f8e79ecf0c176dfee5c95d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1797e0d681f755287d7858157a646e3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:aa1797e0d681f755287d7858157a646e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4350de763daa055bf18a26267664bda2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4350de763daa055bf18a26267664bda2">notify_table_changed</a> ()</td></tr>
<tr class="separator:a4350de763daa055bf18a26267664bda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d15223b48ade93d606dcfef85c9ac0f"><td class="memItemLeft" align="right" valign="top"><a id="a3d15223b48ade93d606dcfef85c9ac0f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a3d15223b48ade93d606dcfef85c9ac0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb6912ff086e35ce623ea01749af8b3"><td class="memItemLeft" align="right" valign="top"><a id="adbb6912ff086e35ce623ea01749af8b3"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>analyze</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:adbb6912ff086e35ce623ea01749af8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5788666b99cae30b065a5513b4107f6"><td class="memItemLeft" align="right" valign="top"><a id="af5788666b99cae30b065a5513b4107f6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>check</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:af5788666b99cae30b065a5513b4107f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7908bdcad420cac9f0d696e528ba8e1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ab7908bdcad420cac9f0d696e528ba8e1">repair</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ab7908bdcad420cac9f0d696e528ba8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa8df6e2a631ce726af759bd7a572c4"><td class="memItemLeft" align="right" valign="top"><a id="a7fa8df6e2a631ce726af759bd7a572c4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_and_repair</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:a7fa8df6e2a631ce726af759bd7a572c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997a54bf87c376852d2c629f733fcfe2"><td class="memItemLeft" align="right" valign="top"><a id="a997a54bf87c376852d2c629f733fcfe2"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>auto_repair</b> () const</td></tr>
<tr class="separator:a997a54bf87c376852d2c629f733fcfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c8e1f6e7d4f9d33b46e7eb7bfff947"><td class="memItemLeft" align="right" valign="top"><a id="ae9c8e1f6e7d4f9d33b46e7eb7bfff947"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_crashed</b> () const</td></tr>
<tr class="separator:ae9c8e1f6e7d4f9d33b46e7eb7bfff947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af912fe341244ec80ccdf21c9b87e4e02"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#af912fe341244ec80ccdf21c9b87e4e02">check_for_upgrade</a> (<a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:af912fe341244ec80ccdf21c9b87e4e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b881268a25ce958c68057778e37e5e4"><td class="memItemLeft" align="right" valign="top"><a id="a7b881268a25ce958c68057778e37e5e4"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>checksum</b> () const</td></tr>
<tr class="separator:a7b881268a25ce958c68057778e37e5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ce76e5900ed99b3594fa70c64ac8b1"><td class="memItemLeft" align="right" valign="top"><a id="ae1ce76e5900ed99b3594fa70c64ac8b1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>assign_to_keycache</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ae1ce76e5900ed99b3594fa70c64ac8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a0db0ca494639b9abcb49d873783ec"><td class="memItemLeft" align="right" valign="top"><a id="a98a0db0ca494639b9abcb49d873783ec"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>preload_keys</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a98a0db0ca494639b9abcb49d873783ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9ea02fe8323cf6b3a0e70fa92e07c6"><td class="memItemLeft" align="right" valign="top"><a id="a7a9ea02fe8323cf6b3a0e70fa92e07c6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>disable_indexes</b> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a7a9ea02fe8323cf6b3a0e70fa92e07c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c857a562d30c7e46f4ce72ce98ed2db"><td class="memItemLeft" align="right" valign="top"><a id="a4c857a562d30c7e46f4ce72ce98ed2db"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>enable_indexes</b> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a4c857a562d30c7e46f4ce72ce98ed2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250323102fde609b86058497893b5033"><td class="memItemLeft" align="right" valign="top"><a id="a250323102fde609b86058497893b5033"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>indexes_are_disabled</b> (void)</td></tr>
<tr class="separator:a250323102fde609b86058497893b5033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a72cfeaceefd05a2f700c138c194770fc inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a72cfeaceefd05a2f700c138c194770fc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unbind_psi</b> ()</td></tr>
<tr class="separator:a72cfeaceefd05a2f700c138c194770fc inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e335a403d8203854bc5b94111992b79 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1e335a403d8203854bc5b94111992b79"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rebind_psi</b> ()</td></tr>
<tr class="separator:a1e335a403d8203854bc5b94111992b79 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae8f7f7b4f67773b73906143238dc9f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9ae8f7f7b4f67773b73906143238dc9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b> (<a class="el" href="structhandlerton.html">handlerton</a> *ht_arg, <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share_arg)</td></tr>
<tr class="separator:a9ae8f7f7b4f67773b73906143238dc9f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad6edb66592b200a7c7ac0f947dc66 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init</a> ()</td></tr>
<tr class="separator:ab1ad6edb66592b200a7c7ac0f947dc66 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e02829386929734724b143391e0a11 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5e02829386929734724b143391e0a11">ha_open</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table, const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, int <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, int test_if_locked)</td></tr>
<tr class="memdesc:ab5e02829386929734724b143391e0a11 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open database-handler.  <a href="classhandler.html#ab5e02829386929734724b143391e0a11">More...</a><br /></td></tr>
<tr class="separator:ab5e02829386929734724b143391e0a11 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28824cdff2c1812e282463c908e84c2 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">ha_close</a> (void)</td></tr>
<tr class="separator:ae28824cdff2c1812e282463c908e84c2 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af23462b249041a0db03c1c7139d76b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init</a> (uint idx, bool sorted)</td></tr>
<tr class="separator:a0af23462b249041a0db03c1c7139d76b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6bd01057c6cdd86d2ea2ee4ea65ca3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a> ()</td></tr>
<tr class="separator:afa6bd01057c6cdd86d2ea2ee4ea65ca3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c99736cb400350e007578889b8375 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init</a> (bool scan)</td></tr>
<tr class="separator:afb5c99736cb400350e007578889b8375 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9bf34ac0a004d8c5c32267f20842f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a> ()</td></tr>
<tr class="separator:ad4d9bf34ac0a004d8c5c32267f20842f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3743f3a48e7be751dbb2691be4c992a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">ha_rnd_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ad3743f3a48e7be751dbb2691be4c992a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8615219b3e692e7d484d2ba6cfa86 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uchar *pos)</td></tr>
<tr class="separator:abcd8615219b3e692e7d484d2ba6cfa86 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729d9c9c011527b81287574294887bf3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">ha_index_read_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a729d9c9c011527b81287574294887bf3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9be09b8d0b1c03c96eb95f79dd7c9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3fa9be09b8d0b1c03c96eb95f79dd7c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_read_last_map</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a3fa9be09b8d0b1c03c96eb95f79dd7c9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831321e8d33958db4fd4968de932acf inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">ha_index_read_idx_map</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:ac831321e8d33958db4fd4968de932acf inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c99e96a8350ff577a94529be9387a30 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">ha_index_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a4c99e96a8350ff577a94529be9387a30 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb977dac0435158be227e45e04c8b798 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb977dac0435158be227e45e04c8b798">ha_index_prev</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:abb977dac0435158be227e45e04c8b798 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd574a3025588e9b0cd49e0d6908e3b8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">ha_index_first</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:abd574a3025588e9b0cd49e0d6908e3b8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7415f1744039a51ef15e923ef7da1b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">ha_index_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a2a7415f1744039a51ef15e923ef7da1b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f79360a45d50c6b558feb1c308c4157 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">ha_index_next_same</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a3f79360a45d50c6b558feb1c308c4157 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f8c07d2ede3fb1f46fc0afb4052d2c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a37f8c07d2ede3fb1f46fc0afb4052d2c">ha_index_read</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a37f8c07d2ede3fb1f46fc0afb4052d2c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1790fe12f8d773f27d5b4b1cb30bd7ab inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1790fe12f8d773f27d5b4b1cb30bd7ab">ha_index_read_last</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len)</td></tr>
<tr class="separator:a1790fe12f8d773f27d5b4b1cb30bd7ab inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">ha_reset</a> ()</td></tr>
<tr class="memdesc:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_check.html">Check</a> handler usage and reset state of file to after 'open'.  <a href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">More...</a><br /></td></tr>
<tr class="separator:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1ef9b6ab27156116f91bf50b1ac19f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6e1ef9b6ab27156116f91bf50b1ac19f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_or_rnd_end</b> ()</td></tr>
<tr class="separator:a6e1ef9b6ab27156116f91bf50b1ac19f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3015577f49008561db1d34ae750e70 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">Table_flags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b3015577f49008561db1d34ae750e70">ha_table_flags</a> () const</td></tr>
<tr class="separator:a6b3015577f49008561db1d34ae750e70 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99b5f8ae28bc5c374919396f8dcf08 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">ha_external_lock</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, int lock_type)</td></tr>
<tr class="separator:a9a99b5f8ae28bc5c374919396f8dcf08 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e651543ba0dbb2257a50dc1cdb5ea9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ad8e651543ba0dbb2257a50dc1cdb5ea9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_write_row</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ad8e651543ba0dbb2257a50dc1cdb5ea9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6bb19636dda0f1537fe780b6aca17a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1f6bb19636dda0f1537fe780b6aca17a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr class="separator:a1f6bb19636dda0f1537fe780b6aca17a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e3b24f5bb5b2a8fa0c45732db8cdd inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3f0e3b24f5bb5b2a8fa0c45732db8cdd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_delete_row</b> (const uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a3f0e3b24f5bb5b2a8fa0c45732db8cdd inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbcbef5b9b8ed0f76d700a29091ad3f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="abfbcbef5b9b8ed0f76d700a29091ad3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_release_auto_increment</b> ()</td></tr>
<tr class="separator:abfbcbef5b9b8ed0f76d700a29091ad3f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234580f9765751ce185182dd1edc3bdb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a234580f9765751ce185182dd1edc3bdb">check_collation_compatibility</a> ()</td></tr>
<tr class="separator:a234580f9765751ce185182dd1edc3bdb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a8030a4a3928d216599e1c03e9b28c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a79a8030a4a3928d216599e1c03e9b28c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_check_for_upgrade</b> (<a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a79a8030a4a3928d216599e1c03e9b28c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56545ec9967544c80d5612f8ac9b8e6e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">ha_check</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a56545ec9967544c80d5612f8ac9b8e6e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d70543d9566894b5a81d25eca2e8e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">ha_repair</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ad28d70543d9566894b5a81d25eca2e8e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f09a15d46c019a621b0a65bb1ec89d3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">ha_start_bulk_insert</a> (ha_rows rows)</td></tr>
<tr class="separator:a3f09a15d46c019a621b0a65bb1ec89d3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f3cbf4a769155c994ed39f76433106 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">ha_end_bulk_insert</a> ()</td></tr>
<tr class="separator:a30f3cbf4a769155c994ed39f76433106 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c8ce82a564b0cbf6340dc9b74a9c23 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">ha_bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:a49c8ce82a564b0cbf6340dc9b74a9c23 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef228137a11565f7d52a60ad802004 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">ha_delete_all_rows</a> ()</td></tr>
<tr class="separator:a1fef228137a11565f7d52a60ad802004 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25394328a49d42bb45b3b263009f02c7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a25394328a49d42bb45b3b263009f02c7">ha_truncate</a> ()</td></tr>
<tr class="separator:a25394328a49d42bb45b3b263009f02c7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68b71d64ca04789d1c6130320eaf22c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af68b71d64ca04789d1c6130320eaf22c">ha_reset_auto_increment</a> (ulonglong value)</td></tr>
<tr class="separator:af68b71d64ca04789d1c6130320eaf22c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a8a7650a41fd9a05a32521826ccd5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">ha_optimize</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a980a8a7650a41fd9a05a32521826ccd5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc9e4971b8e768c102398da0656a7f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">ha_analyze</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a66cc9e4971b8e768c102398da0656a7f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d5287bdf480f8cd20f758bb2d9bd1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">ha_check_and_repair</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>)</td></tr>
<tr class="separator:a169d5287bdf480f8cd20f758bb2d9bd1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb079b3dc59160ba828ef89b4463921 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">ha_disable_indexes</a> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:aeeb079b3dc59160ba828ef89b4463921 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9c53758728e07eb37cbb65ea3ab50 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">ha_enable_indexes</a> (uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:a36e9c53758728e07eb37cbb65ea3ab50 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f75cf982985d21907140a17521cd6c5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1f75cf982985d21907140a17521cd6c5">ha_discard_or_import_tablespace</a> (my_bool discard)</td></tr>
<tr class="separator:a1f75cf982985d21907140a17521cd6c5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee228a60527e81efd9a49ddfdd4850d inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ee228a60527e81efd9a49ddfdd4850d">ha_rename_table</a> (const char *<a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a>, const char *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>)</td></tr>
<tr class="separator:a6ee228a60527e81efd9a49ddfdd4850d inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28700a3bf1af24f9a31ebae51bf877db inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a28700a3bf1af24f9a31ebae51bf877db">ha_delete_table</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a28700a3bf1af24f9a31ebae51bf877db inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcc37ec84386f5d6cc86448781666cb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">ha_drop_table</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:a6bcc37ec84386f5d6cc86448781666cb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14af5825a427ba6baac74b13223637f8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a14af5825a427ba6baac74b13223637f8">ha_create</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *<a class="el" href="ha__innodb_8cc.html#ae64f1475e9ca79d24be2a8091b9cbdd7">form</a>, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a14af5825a427ba6baac74b13223637f8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722462d7e71059a8ed1f43d0fb28366b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a722462d7e71059a8ed1f43d0fb28366b">ha_create_handler_files</a> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a722462d7e71059a8ed1f43d0fb28366b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fb90782fea926f7a4450889d2d4a93 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5fb90782fea926f7a4450889d2d4a93">ha_change_partitions</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)</td></tr>
<tr class="separator:ab5fb90782fea926f7a4450889d2d4a93 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af575e947965117a3a200aec827b1a7c3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af575e947965117a3a200aec827b1a7c3">ha_drop_partitions</a> (const char *path)</td></tr>
<tr class="separator:af575e947965117a3a200aec827b1a7c3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624a8892433666df834a9b6ed6b8c2dd inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a624a8892433666df834a9b6ed6b8c2dd">ha_rename_partitions</a> (const char *path)</td></tr>
<tr class="separator:a624a8892433666df834a9b6ed6b8c2dd inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c090210fefb7e95d885688f5717028 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ad4c090210fefb7e95d885688f5717028"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_next_insert_id_after_explicit_value</b> (ulonglong nr)</td></tr>
<tr class="separator:ad4c090210fefb7e95d885688f5717028 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d2f9da11425e388640206b4d22241 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a8a7d2f9da11425e388640206b4d22241"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>update_auto_increment</b> ()</td></tr>
<tr class="separator:a8a7d2f9da11425e388640206b4d22241 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eede0999f8273864faa40c5e181793 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">get_dup_key</a> (int <a class="el" href="row0merge_8cc.html#a35322fe0b818842195cfd235eec09293">error</a>)</td></tr>
<tr class="separator:ad5eede0999f8273864faa40c5e181793 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20878b1fb8d31b91dbf53ac963d90f78 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a20878b1fb8d31b91dbf53ac963d90f78">get_foreign_dup_key</a> (char *child_table_name, uint child_table_name_len, char *child_key_name, uint child_key_name_len)</td></tr>
<tr class="separator:a20878b1fb8d31b91dbf53ac963d90f78 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ac6b2908a899c0ce230818bb7a993 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time</a> (uint keynr, double <a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a>)</td></tr>
<tr class="separator:a4a2ac6b2908a899c0ce230818bb7a993 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475f7fbe39f6ff0e9da2ac6c3d6c629e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a475f7fbe39f6ff0e9da2ac6c3d6c629e">get_memory_buffer_size</a> () const</td></tr>
<tr class="separator:a475f7fbe39f6ff0e9da2ac6c3d6c629e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee356d2340552eb121d423fc01597f8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">multi_range_read_info_const</a> (uint keyno, <a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint *bufsz, uint *<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_cost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:a5ee356d2340552eb121d423fc01597f8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5add40a6cd7088ffef25a3816294b624 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">multi_range_read_info</a> (uint keyno, uint n_ranges, uint keys, uint *bufsz, uint *<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="class_cost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:a5add40a6cd7088ffef25a3816294b624 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e8899f4bae262b6b91c7284f1d946e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init</a> (<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, <a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a33e8899f4bae262b6b91c7284f1d946e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3419071f3d4abf183dac95ef565adfff inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">multi_range_read_next</a> (char **range_info)</td></tr>
<tr class="separator:a3419071f3d4abf183dac95ef565adfff inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d4ecfa5cfe85d8179aa52488016d0 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae73d4ecfa5cfe85d8179aa52488016d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_transactions</b> ()</td></tr>
<tr class="separator:ae73d4ecfa5cfe85d8179aa52488016d0 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07">column_bitmaps_signal</a> ()</td></tr>
<tr class="memdesc:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL signal that it changed the column bitmap.  <a href="classhandler.html#a4de97045e5381007565fd2b0da235c07">More...</a><br /></td></tr>
<tr class="separator:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf0aed6539181d465676ebc661f2b5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aacdf0aed6539181d465676ebc661f2b5"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>get_index</b> (void) const</td></tr>
<tr class="separator:aacdf0aed6539181d465676ebc661f2b5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488245f51aa4676c872bb0564dbe71f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">start_bulk_update</a> ()</td></tr>
<tr class="separator:a7488245f51aa4676c872bb0564dbe71f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf7319a6498f655f8f07b1b34b12fc inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">start_bulk_delete</a> ()</td></tr>
<tr class="separator:acdaf7319a6498f655f8f07b1b34b12fc inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886bf2fbf16de7e200e3ebc0765fb6e4 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">exec_bulk_update</a> (uint *dup_key_found)</td></tr>
<tr class="separator:a886bf2fbf16de7e200e3ebc0765fb6e4 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6c46d66ca282a4cbd6118e4c99e03 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">end_bulk_update</a> ()</td></tr>
<tr class="separator:a2bf6c46d66ca282a4cbd6118e4c99e03 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f9f1ca2b5efc0b41e96c6b793d9bb1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">end_bulk_delete</a> ()</td></tr>
<tr class="separator:af5f9f1ca2b5efc0b41e96c6b793d9bb1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7dfb95a0da2e828ac018aa2b4abe3a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">set_end_range</a> (const <a class="el" href="structst__key__range.html">key_range</a> *range, enum_range_scan_direction <a class="el" href="btr0btr_8cc.html#a942da44c6711d230377078633665e89b">direction</a>)</td></tr>
<tr class="separator:a4b7dfb95a0da2e828ac018aa2b4abe3a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef38e7407e87ba5d1ccde59c3e94bb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">compare_key</a> (<a class="el" href="structst__key__range.html">key_range</a> *range)</td></tr>
<tr class="separator:af0ef38e7407e87ba5d1ccde59c3e94bb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767345668267e3c8881fab6e351e6c8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab767345668267e3c8881fab6e351e6c8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compare_key_icp</b> (const <a class="el" href="structst__key__range.html">key_range</a> *range) const</td></tr>
<tr class="separator:ab767345668267e3c8881fab6e351e6c8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab734678f90b9e7cc6b000047f7c89bb1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab734678f90b9e7cc6b000047f7c89bb1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init</b> ()</td></tr>
<tr class="separator:ab734678f90b9e7cc6b000047f7c89bb1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72693b6e25765a4290f531f578bcf2eb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a72693b6e25765a4290f531f578bcf2eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ft_end</b> ()</td></tr>
<tr class="separator:a72693b6e25765a4290f531f578bcf2eb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109448e09ee2c456b1471b74bb9eb8e6 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a109448e09ee2c456b1471b74bb9eb8e6"></a>
virtual <a class="el" href="structst__ft__info.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init_ext</b> (uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, uint inx, <a class="el" href="class_string.html">String</a> *key)</td></tr>
<tr class="separator:a109448e09ee2c456b1471b74bb9eb8e6 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c965ae56bcceee3cf63ce0320a5d31b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a0c965ae56bcceee3cf63ce0320a5d31b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_read</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a0c965ae56bcceee3cf63ce0320a5d31b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50b704d53d715d6b0fd3534c6107d8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aff50b704d53d715d6b0fd3534c6107d8">read_first_row</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint primary_key)</td></tr>
<tr class="separator:aff50b704d53d715d6b0fd3534c6107d8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730672727f9ad989e80f3732eb838a10 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a730672727f9ad989e80f3732eb838a10">restart_rnd_next</a> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uchar *pos)</td></tr>
<tr class="separator:a730672727f9ad989e80f3732eb838a10 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590afc40dd01fb9fc387ef1d97370f41 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a590afc40dd01fb9fc387ef1d97370f41"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rnd_same</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, uint inx)</td></tr>
<tr class="separator:a590afc40dd01fb9fc387ef1d97370f41 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2428788c2437e4e33c4b390cc697f7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">start_read_removal</a> (void)</td></tr>
<tr class="separator:a3e2428788c2437e4e33c4b390cc697f7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517d99c283e85e8d97460f07a781dabf inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">end_read_removal</a> (void)</td></tr>
<tr class="separator:a517d99c283e85e8d97460f07a781dabf inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f9bf8ee63f3b8312fdc31be3819ede inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab6f9bf8ee63f3b8312fdc31be3819ede"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_next_insert_id</b> (ulonglong <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>)</td></tr>
<tr class="separator:ab6f9bf8ee63f3b8312fdc31be3819ede inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b51670b2497f01f19f587a4a969386 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a15b51670b2497f01f19f587a4a969386"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>restore_auto_increment</b> (ulonglong <a class="el" href="handler_8cc.html#ae9f796d8fbc7dc812557a17547b8e69e">prev_insert_id</a>)</td></tr>
<tr class="separator:a15b51670b2497f01f19f587a4a969386 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc92ca74cd6aca9a6070a186ced4cb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1abc92ca74cd6aca9a6070a186ced4cb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_old_types</b> ()</td></tr>
<tr class="separator:a1abc92ca74cd6aca9a6070a186ced4cb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441afeebcb5b56e598fb7f860c9247d1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a441afeebcb5b56e598fb7f860c9247d1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>append_create_info</b> (<a class="el" href="class_string.html">String</a> *packet)</td></tr>
<tr class="separator:a441afeebcb5b56e598fb7f860c9247d1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda33331aacc500b1b974033cb64a869 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adda33331aacc500b1b974033cb64a869">is_fk_defined_on_table_or_index</a> (uint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:adda33331aacc500b1b974033cb64a869 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8712abc71df0d89559e2861c100a8e3e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a8712abc71df0d89559e2861c100a8e3e"></a>
virtual char *&#160;</td><td class="memItemRight" valign="bottom"><b>get_foreign_key_create_info</b> ()</td></tr>
<tr class="separator:a8712abc71df0d89559e2861c100a8e3e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81064e61d4c08261af409fb6ee34e3ca inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a81064e61d4c08261af409fb6ee34e3ca">get_foreign_key_list</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a81064e61d4c08261af409fb6ee34e3ca inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9187eea9999eba802ee4ae01f91dda3b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9187eea9999eba802ee4ae01f91dda3b">get_parent_foreign_key_list</a> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="class_list.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a9187eea9999eba802ee4ae01f91dda3b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b038c18aeb8114376725e6f8d39871 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a28b038c18aeb8114376725e6f8d39871"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>referenced_by_foreign_key</b> ()</td></tr>
<tr class="separator:a28b038c18aeb8114376725e6f8d39871 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4457d47baa6d136af65e041da4fe9e0 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aa4457d47baa6d136af65e041da4fe9e0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>free_foreign_key_create_info</b> (char *str)</td></tr>
<tr class="separator:aa4457d47baa6d136af65e041da4fe9e0 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a347e66418fe35a07f24900bcbdce82 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a8a347e66418fe35a07f24900bcbdce82"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>get_default_no_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a8a347e66418fe35a07f24900bcbdce82 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4512d49169a2766f5c5b4896a9691c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="abc4512d49169a2766f5c5b4896a9691c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_auto_partitions</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info)</td></tr>
<tr class="separator:abc4512d49169a2766f5c5b4896a9691c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9c5a03956913d75de1fca3af7833a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a7ee9c5a03956913d75de1fca3af7833a"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_record_length</b> () const</td></tr>
<tr class="separator:a7ee9c5a03956913d75de1fca3af7833a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493c1ac62569e6cc89cbfde66fea47f3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a493c1ac62569e6cc89cbfde66fea47f3"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_keys</b> () const</td></tr>
<tr class="separator:a493c1ac62569e6cc89cbfde66fea47f3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adabba96b635533f31d5e38e6d2a74c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1adabba96b635533f31d5e38e6d2a74c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_parts</b> () const</td></tr>
<tr class="separator:a1adabba96b635533f31d5e38e6d2a74c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b1d6fe7e717fe234c18915cb26e87 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9e1b1d6fe7e717fe234c18915cb26e87"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_length</b> () const</td></tr>
<tr class="separator:a9e1b1d6fe7e717fe234c18915cb26e87 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa0c2a89e52a27667973c1d5074dca7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a4fa0c2a89e52a27667973c1d5074dca7"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_part_length</b> () const</td></tr>
<tr class="separator:a4fa0c2a89e52a27667973c1d5074dca7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e765264bd31e0519e03e1bd53d8c6d2 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">cond_push</a> (const <a class="el" href="class_item.html">Item</a> *cond)</td></tr>
<tr class="separator:a5e765264bd31e0519e03e1bd53d8c6d2 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eb8d2966b848ec4beea5a25cba9dea inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">cond_pop</a> ()</td></tr>
<tr class="separator:ac3eb8d2966b848ec4beea5a25cba9dea inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb554282443af443fc8aae4533e1407 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">idx_cond_push</a> (uint keyno, <a class="el" href="class_item.html">Item</a> *idx_cond)</td></tr>
<tr class="separator:a0bb554282443af443fc8aae4533e1407 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc6ba204aa4d1bacc35d9d1d75ab15 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">cancel_pushed_idx_cond</a> ()</td></tr>
<tr class="separator:a41cc6ba204aa4d1bacc35d9d1d75ab15 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86930bf10b20ad19b3df07e07d28116e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a86930bf10b20ad19b3df07e07d28116e">number_of_pushed_joins</a> () const</td></tr>
<tr class="separator:a86930bf10b20ad19b3df07e07d28116e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f6946109f48559e92a9e7c1b86517 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a624f6946109f48559e92a9e7c1b86517">root_of_pushed_join</a> () const</td></tr>
<tr class="separator:a624f6946109f48559e92a9e7c1b86517 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef865015edc575d0a50d1a6f5b13e4a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaef865015edc575d0a50d1a6f5b13e4a">parent_of_pushed_join</a> () const</td></tr>
<tr class="separator:aaef865015edc575d0a50d1a6f5b13e4a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38213f889f5312cd3e452fc34d11a201 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a38213f889f5312cd3e452fc34d11a201"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_pushed</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a38213f889f5312cd3e452fc34d11a201 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f56e97f4fb1faebbc23145492bf541d inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a5f56e97f4fb1faebbc23145492bf541d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_next_pushed</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a5f56e97f4fb1faebbc23145492bf541d inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecf7f9bf265e6801b625768f0f2bbe inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad0ecf7f9bf265e6801b625768f0f2bbe">ha_prepare_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:ad0ecf7f9bf265e6801b625768f0f2bbe inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b182710a133be9561afc149cb6aa8f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a96b182710a133be9561afc149cb6aa8f">ha_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a96b182710a133be9561afc149cb6aa8f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec170a4aa71186f9dc17358b55587c7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ec170a4aa71186f9dc17358b55587c7">ha_commit_inplace_alter_table</a> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *altered_table, <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:a6ec170a4aa71186f9dc17358b55587c7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b81b74b0b7b87de4f99ebe20c49dc44 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5b81b74b0b7b87de4f99ebe20c49dc44">ha_notify_table_changed</a> ()</td></tr>
<tr class="separator:a5b81b74b0b7b87de4f99ebe20c49dc44 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key</a> ()</td></tr>
<tr class="memdesc:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f" title="use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY...">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key  <a href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">More...</a><br /></td></tr>
<tr class="separator:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd7e44bc71120ace1e467ccb02ad06 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:ac8dd7e44bc71120ace1e467ccb02ad06 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561768da16278d66deec08261111dbef inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a561768da16278d66deec08261111dbef"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>discard_or_import_tablespace</b> (my_bool discard)</td></tr>
<tr class="separator:a561768da16278d66deec08261111dbef inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d474cf912188a562e9f419872031e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ac61d474cf912188a562e9f419872031e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>drop_table</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ac61d474cf912188a562e9f419872031e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a271a4a135d110cf6f22ae8ce664664 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6a271a4a135d110cf6f22ae8ce664664"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_lock_type</b> () const</td></tr>
<tr class="separator:a6a271a4a135d110cf6f22ae8ce664664 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a3bf09603fd6b8dc8b9369e8c761d38d2"><td class="memItemLeft" align="right" valign="top"><a id="a3bf09603fd6b8dc8b9369e8c761d38d2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>partition_index_scan_type</b> { <br />
&#160;&#160;<b>partition_index_read</b> = 0, 
<b>partition_index_first</b> = 1, 
<b>partition_index_first_unordered</b> = 2, 
<b>partition_index_last</b> = 3, 
<br />
&#160;&#160;<b>partition_index_read_last</b> = 4, 
<b>partition_read_range</b> = 5, 
<b>partition_no_index_scan</b> = 6
<br />
 }</td></tr>
<tr class="separator:a3bf09603fd6b8dc8b9369e8c761d38d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0d287639a6218e5d7c1e8e63504fa8"><td class="memItemLeft" align="right" valign="top"><a id="aae0d287639a6218e5d7c1e8e63504fa8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>enum_handler_status</b> { <b>handler_not_initialized</b> = 0, 
<b>handler_initialized</b>, 
<b>handler_opened</b>, 
<b>handler_closed</b>
 }</td></tr>
<tr class="separator:aae0d287639a6218e5d7c1e8e63504fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:affa9c57d1e074482aa1f3a00c85fb662"><td class="memItemLeft" align="right" valign="top"><a id="affa9c57d1e074482aa1f3a00c85fb662"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_handler_variables</b> ()</td></tr>
<tr class="separator:affa9c57d1e074482aa1f3a00c85fb662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355d181ddc3a96e05448bec971c00572"><td class="memItemLeft" align="right" valign="top"><a id="a355d181ddc3a96e05448bec971c00572"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>copy_partitions</b> (ulonglong *const copied, ulonglong *const deleted)</td></tr>
<tr class="separator:a355d181ddc3a96e05448bec971c00572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc7feb8072c410011f8c92d740b8834"><td class="memItemLeft" align="right" valign="top"><a id="aefc7feb8072c410011f8c92d740b8834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanup_new_partition</b> (uint part_count)</td></tr>
<tr class="separator:aefc7feb8072c410011f8c92d740b8834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00961ba6ac0549203b2cbd56c979a6"><td class="memItemLeft" align="right" valign="top"><a id="a3d00961ba6ac0549203b2cbd56c979a6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>prepare_new_partition</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, <a class="el" href="classhandler.html">handler</a> *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, const char *part_name, <a class="el" href="classpartition__element.html">partition_element</a> *p_elem, uint disable_non_uniq_indexes)</td></tr>
<tr class="separator:a3d00961ba6ac0549203b2cbd56c979a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058a0d6c52a602a17bdcd0d2402c6294"><td class="memItemLeft" align="right" valign="top"><a id="a058a0d6c52a602a17bdcd0d2402c6294"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>del_ren_table</b> (const char *<a class="el" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a>, const char *<a class="el" href="ha__innodb_8cc.html#a255ec67df7b761df35e13aa7183c4bd2">to</a>)</td></tr>
<tr class="separator:a058a0d6c52a602a17bdcd0d2402c6294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03e617f46b77f558878cff86aa22426"><td class="memItemLeft" align="right" valign="top"><a id="ae03e617f46b77f558878cff86aa22426"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_handler_file</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:ae03e617f46b77f558878cff86aa22426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9f6afc22b188b42489c51c452c0b8e"><td class="memItemLeft" align="right" valign="top"><a id="a7c9f6afc22b188b42489c51c452c0b8e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setup_engine_array</b> (<a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:a7c9f6afc22b188b42489c51c452c0b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfe9b5f0d6925661dc0b15b5b0979ef"><td class="memItemLeft" align="right" valign="top"><a id="accfe9b5f0d6925661dc0b15b5b0979ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>read_par_file</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>)</td></tr>
<tr class="separator:accfe9b5f0d6925661dc0b15b5b0979ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec48dce61fcfb3a7f5c9308368c94cbd"><td class="memItemLeft" align="right" valign="top"><a id="aec48dce61fcfb3a7f5c9308368c94cbd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_from_handler_file</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root, bool is_clone)</td></tr>
<tr class="separator:aec48dce61fcfb3a7f5c9308368c94cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e966f8acdd0fee7e2582412e8e6c7a"><td class="memItemLeft" align="right" valign="top"><a id="a39e966f8acdd0fee7e2582412e8e6c7a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>new_handlers_from_part_info</b> (<a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:a39e966f8acdd0fee7e2582412e8e6c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ccbc22a7fdd9facd6dd8f7e6203916"><td class="memItemLeft" align="right" valign="top"><a id="ab0ccbc22a7fdd9facd6dd8f7e6203916"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_handlers</b> (<a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:ab0ccbc22a7fdd9facd6dd8f7e6203916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb418d9d43fef75aad13a3317b13e9b1"><td class="memItemLeft" align="right" valign="top"><a id="afb418d9d43fef75aad13a3317b13e9b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear_handler_file</b> ()</td></tr>
<tr class="separator:afb418d9d43fef75aad13a3317b13e9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fdb48bdc946797f0cf504e5a1061d1"><td class="memItemLeft" align="right" valign="top"><a id="af9fdb48bdc946797f0cf504e5a1061d1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>set_up_table_before_create</b> (<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *table_arg, const char *partition_name_with_path, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info, <a class="el" href="classpartition__element.html">partition_element</a> *p_elem)</td></tr>
<tr class="separator:af9fdb48bdc946797f0cf504e5a1061d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db3ed33d40d9b56e286f328382bf923"><td class="memItemLeft" align="right" valign="top"><a id="a1db3ed33d40d9b56e286f328382bf923"></a>
<a class="el" href="classpartition__element.html">partition_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_partition_element</b> (uint part_id)</td></tr>
<tr class="separator:a1db3ed33d40d9b56e286f328382bf923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ded5d491c9f3963ce68fcfc8b3d453"><td class="memItemLeft" align="right" valign="top"><a id="ad0ded5d491c9f3963ce68fcfc8b3d453"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insert_partition_name_in_hash</b> (const char *<a class="el" href="srv0start_8cc.html#a03c6040f5fe625af9dc4a701925fbe65">name</a>, uint part_id, bool is_subpart)</td></tr>
<tr class="separator:ad0ded5d491c9f3963ce68fcfc8b3d453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a335d7e57e9084c6d12c0cb46c31351"><td class="memItemLeft" align="right" valign="top"><a id="a5a335d7e57e9084c6d12c0cb46c31351"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>populate_partition_name_hash</b> ()</td></tr>
<tr class="separator:a5a335d7e57e9084c6d12c0cb46c31351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27f5c24d77ae8cc7fbbae89f6428518"><td class="memItemLeft" align="right" valign="top"><a id="ab27f5c24d77ae8cc7fbbae89f6428518"></a>
<a class="el" href="class_partition__share.html">Partition_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_share</b> ()</td></tr>
<tr class="separator:ab27f5c24d77ae8cc7fbbae89f6428518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33c3d4809db70c88baeac97e7e7a821"><td class="memItemLeft" align="right" valign="top"><a id="af33c3d4809db70c88baeac97e7e7a821"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_ha_share_ref</b> (<a class="el" href="class_handler__share.html">Handler_share</a> **<a class="el" href="classhandler.html#a97f83e0c7122ec3d276dcb0a0b940754">ha_share</a>)</td></tr>
<tr class="separator:af33c3d4809db70c88baeac97e7e7a821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74fabea064737a471ebf7edc630232a"><td class="memItemLeft" align="right" valign="top"><a id="ae74fabea064737a471ebf7edc630232a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fix_data_dir</b> (char *path)</td></tr>
<tr class="separator:ae74fabea064737a471ebf7edc630232a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62f005a1df94aa47a9f07be28c90a63"><td class="memItemLeft" align="right" valign="top"><a id="ab62f005a1df94aa47a9f07be28c90a63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>init_partition_bitmaps</b> ()</td></tr>
<tr class="separator:ab62f005a1df94aa47a9f07be28c90a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241176e0acffa0c663fdf17a69f66250"><td class="memItemLeft" align="right" valign="top"><a id="a241176e0acffa0c663fdf17a69f66250"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_partition_bitmaps</b> ()</td></tr>
<tr class="separator:a241176e0acffa0c663fdf17a69f66250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e5538d763a9b88af030f645b8b8b8a"><td class="memItemLeft" align="right" valign="top"><a id="a45e5538d763a9b88af030f645b8b8b8a"></a>
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>guess_bulk_insert_rows</b> ()</td></tr>
<tr class="separator:a45e5538d763a9b88af030f645b8b8b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984806eeaa7bef66f93cec980cda8d7f"><td class="memItemLeft" align="right" valign="top"><a id="a984806eeaa7bef66f93cec980cda8d7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>start_part_bulk_insert</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, uint part_id)</td></tr>
<tr class="separator:a984806eeaa7bef66f93cec980cda8d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55563647136e36880e5cbfab1a752a98"><td class="memItemLeft" align="right" valign="top"><a id="a55563647136e36880e5cbfab1a752a98"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>estimate_read_buffer_size</b> (long original_size)</td></tr>
<tr class="separator:a55563647136e36880e5cbfab1a752a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1542d658f42f8c4087c13b13be993c"><td class="memItemLeft" align="right" valign="top"><a id="a3c1542d658f42f8c4087c13b13be993c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>init_record_priority_queue</b> ()</td></tr>
<tr class="separator:a3c1542d658f42f8c4087c13b13be993c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ec82a3515319d359e3a613d3b96ace"><td class="memItemLeft" align="right" valign="top"><a id="aa5ec82a3515319d359e3a613d3b96ace"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy_record_priority_queue</b> ()</td></tr>
<tr class="separator:aa5ec82a3515319d359e3a613d3b96ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c3b5d886592f1b19b20eb9406c76bb"><td class="memItemLeft" align="right" valign="top"><a id="ae6c3b5d886592f1b19b20eb9406c76bb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>common_index_read</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, bool have_start_key)</td></tr>
<tr class="separator:ae6c3b5d886592f1b19b20eb9406c76bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84e7a225a45555821da1337cd267c07"><td class="memItemLeft" align="right" valign="top"><a id="ad84e7a225a45555821da1337cd267c07"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>common_first_last</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ad84e7a225a45555821da1337cd267c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c40c78ddc8b697313c193b83745cb2"><td class="memItemLeft" align="right" valign="top"><a id="a94c40c78ddc8b697313c193b83745cb2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>partition_scan_set_up</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, bool idx_read_flag)</td></tr>
<tr class="separator:a94c40c78ddc8b697313c193b83745cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c3dac3595d94e0c467cb01a4241c18"><td class="memItemLeft" align="right" valign="top"><a id="a20c3dac3595d94e0c467cb01a4241c18"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>handle_unordered_next</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, bool next_same)</td></tr>
<tr class="separator:a20c3dac3595d94e0c467cb01a4241c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbdb1eb979ccd4c0cb752d4deb0cbc7"><td class="memItemLeft" align="right" valign="top"><a id="a9bbdb1eb979ccd4c0cb752d4deb0cbc7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>handle_unordered_scan_next_partition</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a9bbdb1eb979ccd4c0cb752d4deb0cbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace55a0b6bf9552df7c4743af4e66bb55"><td class="memItemLeft" align="right" valign="top"><a id="ace55a0b6bf9552df7c4743af4e66bb55"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>handle_ordered_index_scan</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, bool reverse_order)</td></tr>
<tr class="separator:ace55a0b6bf9552df7c4743af4e66bb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be37e166f037d3ce4ab736ab232144e"><td class="memItemLeft" align="right" valign="top"><a id="a8be37e166f037d3ce4ab736ab232144e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>handle_ordered_index_scan_key_not_found</b> ()</td></tr>
<tr class="separator:a8be37e166f037d3ce4ab736ab232144e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5758c02099adf13504b1f50a4fe6930"><td class="memItemLeft" align="right" valign="top"><a id="aa5758c02099adf13504b1f50a4fe6930"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>handle_ordered_next</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, bool next_same)</td></tr>
<tr class="separator:aa5758c02099adf13504b1f50a4fe6930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de8722706c80486ae8017d5d5497bc1"><td class="memItemLeft" align="right" valign="top"><a id="a9de8722706c80486ae8017d5d5497bc1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>handle_ordered_prev</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:a9de8722706c80486ae8017d5d5497bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b9e443aadc483a6c2e6ef1be6ea3c1"><td class="memItemLeft" align="right" valign="top"><a id="ab4b9e443aadc483a6c2e6ef1be6ea3c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>return_top_record</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>)</td></tr>
<tr class="separator:ab4b9e443aadc483a6c2e6ef1be6ea3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080d59d0437a83e9bcda72004766dc4b"><td class="memItemLeft" align="right" valign="top"><a id="a080d59d0437a83e9bcda72004766dc4b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>loop_extra</b> (enum ha_extra_function operation)</td></tr>
<tr class="separator:a080d59d0437a83e9bcda72004766dc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525ecb345496333aecb680ba7e154933"><td class="memItemLeft" align="right" valign="top"><a id="a525ecb345496333aecb680ba7e154933"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>loop_extra_alter</b> (enum ha_extra_function operations)</td></tr>
<tr class="separator:a525ecb345496333aecb680ba7e154933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae04f217e76bac047d80454c835296b"><td class="memItemLeft" align="right" valign="top"><a id="a3ae04f217e76bac047d80454c835296b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>late_extra_cache</b> (uint partition_id)</td></tr>
<tr class="separator:a3ae04f217e76bac047d80454c835296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e206d9f867fee1f21ed805a08a0be7"><td class="memItemLeft" align="right" valign="top"><a id="a52e206d9f867fee1f21ed805a08a0be7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>late_extra_no_cache</b> (uint partition_id)</td></tr>
<tr class="separator:a52e206d9f867fee1f21ed805a08a0be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08063cba53262a4af4ad83460aee1890"><td class="memItemLeft" align="right" valign="top"><a id="a08063cba53262a4af4ad83460aee1890"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepare_extra_cache</b> (uint cachesize)</td></tr>
<tr class="separator:a08063cba53262a4af4ad83460aee1890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40c73853261133804819e35707b42ec"><td class="memItemLeft" align="right" valign="top"><a id="af40c73853261133804819e35707b42ec"></a>
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>min_rows_for_estimate</b> ()</td></tr>
<tr class="separator:af40c73853261133804819e35707b42ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffdc4ebd31d92761b407a32a42954b9"><td class="memItemLeft" align="right" valign="top"><a id="a5ffdc4ebd31d92761b407a32a42954b9"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>get_biggest_used_partition</b> (uint *part_index)</td></tr>
<tr class="separator:a5ffdc4ebd31d92761b407a32a42954b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c66eff39dc4dcc487709bd3b2c8aed6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a8c66eff39dc4dcc487709bd3b2c8aed6">reset_auto_increment</a> (ulonglong value)</td></tr>
<tr class="separator:a8c66eff39dc4dcc487709bd3b2c8aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a049884ab4b4549873274310756220"><td class="memItemLeft" align="right" valign="top"><a id="a93a049884ab4b4549873274310756220"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>lock_auto_increment</b> ()</td></tr>
<tr class="separator:a93a049884ab4b4549873274310756220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461784927ed1dc61c97a3d5d77a522fe"><td class="memItemLeft" align="right" valign="top"><a id="a461784927ed1dc61c97a3d5d77a522fe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_auto_increment</b> ()</td></tr>
<tr class="separator:a461784927ed1dc61c97a3d5d77a522fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fce96c952b4c1940470748c62f5d5c"><td class="memItemLeft" align="right" valign="top"><a id="ad4fce96c952b4c1940470748c62f5d5c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_auto_increment_if_higher</b> (<a class="el" href="class_field.html">Field</a> *field)</td></tr>
<tr class="separator:ad4fce96c952b4c1940470748c62f5d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5004b9c337b12df2349f44d00f706f"><td class="memItemLeft" align="right" valign="top"><a id="aae5004b9c337b12df2349f44d00f706f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>handle_opt_partitions</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt, uint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:aae5004b9c337b12df2349f44d00f706f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04f88b81859646077c4e535fbe6171c"><td class="memItemLeft" align="right" valign="top"><a id="ae04f88b81859646077c4e535fbe6171c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>handle_opt_part</b> (THD *<a class="el" href="row0quiesce_8cc.html#a75b6f5ba5a17ae9fb524f56a5eed51cb">thd</a>, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt, uint part_id, uint flag)</td></tr>
<tr class="separator:ae04f88b81859646077c4e535fbe6171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef1fc67a254d64a08df565ccf02bba8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#afef1fc67a254d64a08df565ccf02bba8">check_misplaced_rows</a> (uint read_part_id, bool <a class="el" href="classha__partition.html#ab7908bdcad420cac9f0d696e528ba8e1">repair</a>)</td></tr>
<tr class="separator:afef1fc67a254d64a08df565ccf02bba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ce683a94d918552d396b846f4496d9"><td class="memItemLeft" align="right" valign="top"><a id="aa0ce683a94d918552d396b846f4496d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append_row_to_str</b> (<a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="separator:aa0ce683a94d918552d396b846f4496d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a988e1c5a536b86e21963f383e2dfeda1"><td class="memItemLeft" align="right" valign="top"><a id="a988e1c5a536b86e21963f383e2dfeda1"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>compare_number_of_records</b> (<a class="el" href="classha__partition.html">ha_partition</a> *me, const uint32 *<a class="el" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>, const uint32 *<a class="el" href="row0merge_8cc.html#a40730b4776204efc5a07b947ce63f0b4">b</a>)</td></tr>
<tr class="separator:a988e1c5a536b86e21963f383e2dfeda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a02476d624ece22454807f521636afb7c"><td class="memItemLeft" align="right" valign="top"><a id="a02476d624ece22454807f521636afb7c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_mode</b></td></tr>
<tr class="separator:a02476d624ece22454807f521636afb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b5dedea7e9d3f325499598f00b5dd9"><td class="memItemLeft" align="right" valign="top"><a id="a41b5dedea7e9d3f325499598f00b5dd9"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_open_test_lock</b></td></tr>
<tr class="separator:a41b5dedea7e9d3f325499598f00b5dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e064c6fc4e895c69b1aea2cf315491"><td class="memItemLeft" align="right" valign="top"><a id="ac5e064c6fc4e895c69b1aea2cf315491"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>m_file_buffer</b></td></tr>
<tr class="separator:ac5e064c6fc4e895c69b1aea2cf315491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1df0145813614bc096a03f1669bd9e"><td class="memItemLeft" align="right" valign="top"><a id="a5c1df0145813614bc096a03f1669bd9e"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>m_name_buffer_ptr</b></td></tr>
<tr class="separator:a5c1df0145813614bc096a03f1669bd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722b62dfcdd4e3daffa3586f2527143e"><td class="memItemLeft" align="right" valign="top"><a id="a722b62dfcdd4e3daffa3586f2527143e"></a>
<a class="el" href="structst__plugin__int.html">plugin_ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_engine_array</b></td></tr>
<tr class="separator:a722b62dfcdd4e3daffa3586f2527143e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190511651454e40a3c277ebc018d90f6"><td class="memItemLeft" align="right" valign="top"><a id="a190511651454e40a3c277ebc018d90f6"></a>
<a class="el" href="classhandler.html">handler</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>m_file</b></td></tr>
<tr class="separator:a190511651454e40a3c277ebc018d90f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424f76ff8f27fb57a8fc35be0868e714"><td class="memItemLeft" align="right" valign="top"><a id="a424f76ff8f27fb57a8fc35be0868e714"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_file_tot_parts</b></td></tr>
<tr class="separator:a424f76ff8f27fb57a8fc35be0868e714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9f2055b24d32a849b1215cf10ba046"><td class="memItemLeft" align="right" valign="top"><a id="a9f9f2055b24d32a849b1215cf10ba046"></a>
<a class="el" href="classhandler.html">handler</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>m_new_file</b></td></tr>
<tr class="separator:a9f9f2055b24d32a849b1215cf10ba046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c9464295becda25badeb9ed9baf8f2"><td class="memItemLeft" align="right" valign="top"><a id="a99c9464295becda25badeb9ed9baf8f2"></a>
<a class="el" href="classhandler.html">handler</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>m_reorged_file</b></td></tr>
<tr class="separator:a99c9464295becda25badeb9ed9baf8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f70065eaae649bf90ce86a527b2cae"><td class="memItemLeft" align="right" valign="top"><a id="ae1f70065eaae649bf90ce86a527b2cae"></a>
<a class="el" href="classhandler.html">handler</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>m_added_file</b></td></tr>
<tr class="separator:ae1f70065eaae649bf90ce86a527b2cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6306f7a017cc05f0fe68bc517b6de35c"><td class="memItemLeft" align="right" valign="top"><a id="a6306f7a017cc05f0fe68bc517b6de35c"></a>
<a class="el" href="classpartition__info.html">partition_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_part_info</b></td></tr>
<tr class="separator:a6306f7a017cc05f0fe68bc517b6de35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e149b0fbfa2576c2d9376d2fd8da51"><td class="memItemLeft" align="right" valign="top"><a id="ae0e149b0fbfa2576c2d9376d2fd8da51"></a>
<a class="el" href="class_field.html">Field</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>m_part_field_array</b></td></tr>
<tr class="separator:ae0e149b0fbfa2576c2d9376d2fd8da51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49299ac0630b7856cefb70c574553b"><td class="memItemLeft" align="right" valign="top"><a id="aeb49299ac0630b7856cefb70c574553b"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>m_ordered_rec_buffer</b></td></tr>
<tr class="separator:aeb49299ac0630b7856cefb70c574553b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb15272a7ba9abfc64c091f480136e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__key.html">KEY</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aeb15272a7ba9abfc64c091f480136e28">m_curr_key_info</a> [3]</td></tr>
<tr class="separator:aeb15272a7ba9abfc64c091f480136e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc66549fe3cad4c52c77c0b4135d8f3"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#abdc66549fe3cad4c52c77c0b4135d8f3">m_rec_offset</a></td></tr>
<tr class="separator:abdc66549fe3cad4c52c77c0b4135d8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2c231039be653d05e7f98869d1c4a1"><td class="memItemLeft" align="right" valign="top"><a id="a1e2c231039be653d05e7f98869d1c4a1"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>m_rec0</b></td></tr>
<tr class="separator:a1e2c231039be653d05e7f98869d1c4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a55c3855435e0ddcb39a44cef85a01"><td class="memItemLeft" align="right" valign="top"><a id="a36a55c3855435e0ddcb39a44cef85a01"></a>
const uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>m_err_rec</b></td></tr>
<tr class="separator:a36a55c3855435e0ddcb39a44cef85a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b890be88e2c9d37cc6457a34bcb6162"><td class="memItemLeft" align="right" valign="top"><a id="a0b890be88e2c9d37cc6457a34bcb6162"></a>
<a class="el" href="structst__queue.html">QUEUE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_queue</b></td></tr>
<tr class="separator:a0b890be88e2c9d37cc6457a34bcb6162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076a26338ed465f570058304b7a50a7f"><td class="memItemLeft" align="right" valign="top"><a id="a076a26338ed465f570058304b7a50a7f"></a>
ulong&#160;</td><td class="memItemRight" valign="bottom"><b>m_low_byte_first</b></td></tr>
<tr class="separator:a076a26338ed465f570058304b7a50a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181fa33c5bd41c6ea86ee11a75b3c0e3"><td class="memItemLeft" align="right" valign="top"><a id="a181fa33c5bd41c6ea86ee11a75b3c0e3"></a>
enum_handler_status&#160;</td><td class="memItemRight" valign="bottom"><b>m_handler_status</b></td></tr>
<tr class="separator:a181fa33c5bd41c6ea86ee11a75b3c0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfaa3adc64180bb3dbf39759b12b1bbc"><td class="memItemLeft" align="right" valign="top"><a id="acfaa3adc64180bb3dbf39759b12b1bbc"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_reorged_parts</b></td></tr>
<tr class="separator:acfaa3adc64180bb3dbf39759b12b1bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae64d10648aeeb1b0f47ed368a5694cc"><td class="memItemLeft" align="right" valign="top"><a id="aae64d10648aeeb1b0f47ed368a5694cc"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_tot_parts</b></td></tr>
<tr class="separator:aae64d10648aeeb1b0f47ed368a5694cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa623cf03bbc65b5743432f79ed23b72b"><td class="memItemLeft" align="right" valign="top"><a id="aa623cf03bbc65b5743432f79ed23b72b"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_locks</b></td></tr>
<tr class="separator:aa623cf03bbc65b5743432f79ed23b72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5de62c3807e23408ef9157674d13e05"><td class="memItemLeft" align="right" valign="top"><a id="ab5de62c3807e23408ef9157674d13e05"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_last_part</b></td></tr>
<tr class="separator:ab5de62c3807e23408ef9157674d13e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac891fc87be619b546d2a2a27b004b776"><td class="memItemLeft" align="right" valign="top"><a id="ac891fc87be619b546d2a2a27b004b776"></a>
<a class="el" href="structpart__id__range.html">part_id_range</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_part_spec</b></td></tr>
<tr class="separator:ac891fc87be619b546d2a2a27b004b776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da65c6c37f25635279e264ff8fe95eb"><td class="memItemLeft" align="right" valign="top"><a id="a6da65c6c37f25635279e264ff8fe95eb"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_scan_value</b></td></tr>
<tr class="separator:a6da65c6c37f25635279e264ff8fe95eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffb271bdee1d8351682e47778b347c3"><td class="memItemLeft" align="right" valign="top"><a id="a7ffb271bdee1d8351682e47778b347c3"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_ref_length</b></td></tr>
<tr class="separator:a7ffb271bdee1d8351682e47778b347c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32600da1d1f0b0c3aba1a9ea362bd33c"><td class="memItemLeft" align="right" valign="top"><a id="a32600da1d1f0b0c3aba1a9ea362bd33c"></a>
<a class="el" href="structst__key__range.html">key_range</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_start_key</b></td></tr>
<tr class="separator:a32600da1d1f0b0c3aba1a9ea362bd33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723836f556669b478a685419c0ee117e"><td class="memItemLeft" align="right" valign="top"><a id="a723836f556669b478a685419c0ee117e"></a>
enum partition_index_scan_type&#160;</td><td class="memItemRight" valign="bottom"><b>m_index_scan_type</b></td></tr>
<tr class="separator:a723836f556669b478a685419c0ee117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512b8d23145c58c02f451ca6000604c0"><td class="memItemLeft" align="right" valign="top"><a id="a512b8d23145c58c02f451ca6000604c0"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_top_entry</b></td></tr>
<tr class="separator:a512b8d23145c58c02f451ca6000604c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf1a822e064bca49d2a1860cb69d304"><td class="memItemLeft" align="right" valign="top"><a id="afcf1a822e064bca49d2a1860cb69d304"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_rec_length</b></td></tr>
<tr class="separator:afcf1a822e064bca49d2a1860cb69d304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990bf9fcc98b161f991a884c0568a121"><td class="memItemLeft" align="right" valign="top"><a id="a990bf9fcc98b161f991a884c0568a121"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_ordered</b></td></tr>
<tr class="separator:a990bf9fcc98b161f991a884c0568a121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c4056071c60ec663409f124921994e"><td class="memItemLeft" align="right" valign="top"><a id="ac5c4056071c60ec663409f124921994e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_pkey_is_clustered</b></td></tr>
<tr class="separator:ac5c4056071c60ec663409f124921994e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc8b5f8f3e6c40c15e2b48dddb98410"><td class="memItemLeft" align="right" valign="top"><a id="a9fc8b5f8f3e6c40c15e2b48dddb98410"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_create_handler</b></td></tr>
<tr class="separator:a9fc8b5f8f3e6c40c15e2b48dddb98410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada59de6b29b90808ca7534c560a3686e"><td class="memItemLeft" align="right" valign="top"><a id="ada59de6b29b90808ca7534c560a3686e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_is_sub_partitioned</b></td></tr>
<tr class="separator:ada59de6b29b90808ca7534c560a3686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fa9d15198fb0202b3f491b07f43ef8"><td class="memItemLeft" align="right" valign="top"><a id="a44fa9d15198fb0202b3f491b07f43ef8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_ordered_scan_ongoing</b></td></tr>
<tr class="separator:a44fa9d15198fb0202b3f491b07f43ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1870711f5d75140dd81fe182e6969cf1"><td class="memItemLeft" align="right" valign="top"><a id="a1870711f5d75140dd81fe182e6969cf1"></a>
<a class="el" href="classha__partition.html">ha_partition</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_is_clone_of</b></td></tr>
<tr class="separator:a1870711f5d75140dd81fe182e6969cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f7a5dd9933ac8b361c97e008b7dfa8"><td class="memItemLeft" align="right" valign="top"><a id="ab7f7a5dd9933ac8b361c97e008b7dfa8"></a>
<a class="el" href="structst__mem__root.html">MEM_ROOT</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_clone_mem_root</b></td></tr>
<tr class="separator:ab7f7a5dd9933ac8b361c97e008b7dfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b4a8e393a89ef8a0ee5ea41d18a70a"><td class="memItemLeft" align="right" valign="top"><a id="a49b4a8e393a89ef8a0ee5ea41d18a70a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_myisam</b></td></tr>
<tr class="separator:a49b4a8e393a89ef8a0ee5ea41d18a70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3471f2f50f56c17f96b40f346504a"><td class="memItemLeft" align="right" valign="top"><a id="a77a3471f2f50f56c17f96b40f346504a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_innodb</b></td></tr>
<tr class="separator:a77a3471f2f50f56c17f96b40f346504a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba41e2f4dcbb1d40e77869506897213b"><td class="memItemLeft" align="right" valign="top"><a id="aba41e2f4dcbb1d40e77869506897213b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_extra_cache</b></td></tr>
<tr class="separator:aba41e2f4dcbb1d40e77869506897213b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f71ca43d98a351c928473a23b8fb88"><td class="memItemLeft" align="right" valign="top"><a id="a99f71ca43d98a351c928473a23b8fb88"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_extra_cache_size</b></td></tr>
<tr class="separator:a99f71ca43d98a351c928473a23b8fb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819a31c6c09ccc17f2f90bacb29ef67d"><td class="memItemLeft" align="right" valign="top"><a id="a819a31c6c09ccc17f2f90bacb29ef67d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_extra_prepare_for_update</b></td></tr>
<tr class="separator:a819a31c6c09ccc17f2f90bacb29ef67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f5fd76583db7abe6a267934009a801"><td class="memItemLeft" align="right" valign="top"><a id="a92f5fd76583db7abe6a267934009a801"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>m_extra_cache_part_id</b></td></tr>
<tr class="separator:a92f5fd76583db7abe6a267934009a801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1464be754ac1130034f899a5c09a0e24"><td class="memItemLeft" align="right" valign="top"><a id="a1464be754ac1130034f899a5c09a0e24"></a>
<a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lock</b></td></tr>
<tr class="separator:a1464be754ac1130034f899a5c09a0e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f4861c1ea2815527665ae9fefb6204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a76f4861c1ea2815527665ae9fefb6204">auto_increment_lock</a></td></tr>
<tr class="separator:a76f4861c1ea2815527665ae9fefb6204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d7e768a3436d4ac7658834a9dff742"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a31d7e768a3436d4ac7658834a9dff742">auto_increment_safe_stmt_log_lock</a></td></tr>
<tr class="separator:a31d7e768a3436d4ac7658834a9dff742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4ca93bc4947d77635b82e10d4f4529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__bitmap.html">MY_BITMAP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a7b4ca93bc4947d77635b82e10d4f4529">m_bulk_insert_started</a></td></tr>
<tr class="separator:a7b4ca93bc4947d77635b82e10d4f4529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971244460674996fea5926699875931e"><td class="memItemLeft" align="right" valign="top"><a id="a971244460674996fea5926699875931e"></a>
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>m_bulk_inserted_rows</b></td></tr>
<tr class="separator:a971244460674996fea5926699875931e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d70c88f78f888626c6f9159e1cd6d7"><td class="memItemLeft" align="right" valign="top">enum_monotonicity_info&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a61d70c88f78f888626c6f9159e1cd6d7">m_part_func_monotonicity_info</a></td></tr>
<tr class="separator:a61d70c88f78f888626c6f9159e1cd6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1ff8a85aa3d4ed312f3354ff6efff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__bitmap.html">MY_BITMAP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a3e1ff8a85aa3d4ed312f3354ff6efff3">m_locked_partitions</a></td></tr>
<tr class="separator:a3e1ff8a85aa3d4ed312f3354ff6efff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ecb52fe5cf4a9f81ee3e307ce60d5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_partition__share.html">Partition_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a53ecb52fe5cf4a9f81ee3e307ce60d5a">part_share</a></td></tr>
<tr class="separator:a53ecb52fe5cf4a9f81ee3e307ce60d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed24e9ccb75daae68c0e9fddd438a15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_list.html">List</a>&lt; <a class="el" href="class_parts__share__refs.html">Parts_share_refs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a2ed24e9ccb75daae68c0e9fddd438a15">m_new_partitions_share_refs</a></td></tr>
<tr class="separator:a2ed24e9ccb75daae68c0e9fddd438a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0f581ba24c80bfb46004c22c0fee5f"><td class="memItemLeft" align="right" valign="top">uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a0b0f581ba24c80bfb46004c22c0fee5f">m_part_ids_sorted_by_num_of_records</a></td></tr>
<tr class="separator:a0b0f581ba24c80bfb46004c22c0fee5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb2f621be7fb25af38a1ac8b20bc2c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__bitmap.html">MY_BITMAP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a9cb2f621be7fb25af38a1ac8b20bc2c7">m_partitions_to_reset</a></td></tr>
<tr class="separator:a9cb2f621be7fb25af38a1ac8b20bc2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1e4ae03ef02a70c4e86f0c09effad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__bitmap.html">MY_BITMAP</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4d1e4ae03ef02a70c4e86f0c09effad8">m_key_not_found_partitions</a></td></tr>
<tr class="separator:a4d1e4ae03ef02a70c4e86f0c09effad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15f0e12cb69507683a3de29c622f945"><td class="memItemLeft" align="right" valign="top"><a id="ab15f0e12cb69507683a3de29c622f945"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_key_not_found</b></td></tr>
<tr class="separator:ab15f0e12cb69507683a3de29c622f945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d339373a5cd94a7b418287f7bd7ce66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4d339373a5cd94a7b418287f7bd7ce66">m_sec_sort_by_rowid</a></td></tr>
<tr class="separator:a4d339373a5cd94a7b418287f7bd7ce66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a858d024b312eece031b521df30c6d17f"><td class="memItemLeft" align="right" valign="top"><a id="a858d024b312eece031b521df30c6d17f"></a>
static const uint&#160;</td><td class="memItemRight" valign="bottom"><b>NO_CURRENT_PART_ID</b></td></tr>
<tr class="separator:a858d024b312eece031b521df30c6d17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:ab5b14b11876fb5ac53a4cc7aceea6a2d inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab5b14b11876fb5ac53a4cc7aceea6a2d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>enum_range_scan_direction</b> { <b>RANGE_SCAN_ASC</b>, 
<b>RANGE_SCAN_DESC</b>
 }</td></tr>
<tr class="separator:ab5b14b11876fb5ac53a4cc7aceea6a2d inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17118f023ca8fc0db852fc578206c4fe inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a17118f023ca8fc0db852fc578206c4fe"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NONE</b> =0, 
<b>INDEX</b>, 
<b>RND</b>
 }</td></tr>
<tr class="separator:a17118f023ca8fc0db852fc578206c4fe inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67af5473a36655c922682399d4c5b6ec inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a67af5473a36655c922682399d4c5b6ec"></a>
typedef ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>Table_flags</b></td></tr>
<tr class="separator:a67af5473a36655c922682399d4c5b6ec inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_sql__alloc"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_sql__alloc')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_sql__alloc.html">Sql_alloc</a></td></tr>
<tr class="memitem:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a193100cab44074df6f4f1507b333dcda"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)  throw ()</td></tr>
<tr class="separator:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a14b17bd7ec22fc7a7e5b56702e5630a6"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)  throw ()</td></tr>
<tr class="separator:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a13f2eacbb6adcee5c9ac94629e2863b3"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)  throw ()</td></tr>
<tr class="separator:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a06adbd3404f702994fd10619c41267f0"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)  throw ()</td></tr>
<tr class="separator:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a1e428ed5b826482a49b1d8a1d246a579"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a7c08622003a34134a56eccaf2d95c0b9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="ab0c7ed4b5a1eb798f3af463eb84b1e3b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, <a class="el" href="structst__mem__root.html">MEM_ROOT</a> *mem_root)</td></tr>
<tr class="separator:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_class_sql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a6dd86b56cecc3919504cf5e1452f2511"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, size_t <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_class_sql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a395bae75af9e51a116097a788b2cf57f inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a395bae75af9e51a116097a788b2cf57f"></a>
<a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ht</b></td></tr>
<tr class="separator:a395bae75af9e51a116097a788b2cf57f inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c7037216007ba6140e6cff5162024d inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a53c7037216007ba6140e6cff5162024d"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>ref</b></td></tr>
<tr class="separator:a53c7037216007ba6140e6cff5162024d inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501dc41ecb010069e8bc9d035aae6aa inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a7501dc41ecb010069e8bc9d035aae6aa"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>dup_ref</b></td></tr>
<tr class="separator:a7501dc41ecb010069e8bc9d035aae6aa inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df561df4b2b6552a7b42189feb0400a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1df561df4b2b6552a7b42189feb0400a"></a>
<a class="el" href="classha__statistics.html">ha_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stats</b></td></tr>
<tr class="separator:a1df561df4b2b6552a7b42189feb0400a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec520eba79eb9f182c534e82c60ebc6 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9ec520eba79eb9f182c534e82c60ebc6"></a>
range_seq_t&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_iter</b></td></tr>
<tr class="separator:a9ec520eba79eb9f182c534e82c60ebc6 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51e423645829d3e540c109556931fa inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a2a51e423645829d3e540c109556931fa"></a>
<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_funcs</b></td></tr>
<tr class="separator:a2a51e423645829d3e540c109556931fa inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52372127bd238a7f622190316ba8124f inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a52372127bd238a7f622190316ba8124f"></a>
<a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>multi_range_buffer</b></td></tr>
<tr class="separator:a52372127bd238a7f622190316ba8124f inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a476dfe8526807dfc820c4b09f7a6d1 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1a476dfe8526807dfc820c4b09f7a6d1"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>ranges_in_seq</b></td></tr>
<tr class="separator:a1a476dfe8526807dfc820c4b09f7a6d1 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff4dfb21c4583b55afc4fe5aba50389 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="adff4dfb21c4583b55afc4fe5aba50389"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_is_output_sorted</b></td></tr>
<tr class="separator:adff4dfb21c4583b55afc4fe5aba50389 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2632d137c3a17fa583f08db5681e80a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="af2632d137c3a17fa583f08db5681e80a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_have_range</b></td></tr>
<tr class="separator:af2632d137c3a17fa583f08db5681e80a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2347edc229832e533d1fb73b236e32b inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="af2347edc229832e533d1fb73b236e32b"></a>
<a class="el" href="structst__key__multi__range.html">KEY_MULTI_RANGE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_cur_range</b></td></tr>
<tr class="separator:af2347edc229832e533d1fb73b236e32b inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d698fe9901f0f487c9618ddbb0f1be inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a28d698fe9901f0f487c9618ddbb0f1be"></a>
<a class="el" href="structst__key__range.html">key_range</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>end_range</b></td></tr>
<tr class="separator:a28d698fe9901f0f487c9618ddbb0f1be inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186b7c7a70634a8e9758ed51708359c inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3186b7c7a70634a8e9758ed51708359c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>errkey</b></td></tr>
<tr class="separator:a3186b7c7a70634a8e9758ed51708359c inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5efc62f32ef66b55667fd8370ef33 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a5ad5efc62f32ef66b55667fd8370ef33"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>key_used_on_scan</b></td></tr>
<tr class="separator:a5ad5efc62f32ef66b55667fd8370ef33 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f2838eebffef46663c19f85d2ad2cc inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a29f2838eebffef46663c19f85d2ad2cc"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>active_index</b></td></tr>
<tr class="separator:a29f2838eebffef46663c19f85d2ad2cc inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64def328ff0ca7e391b217c2d3a758ec inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a></td></tr>
<tr class="separator:a64def328ff0ca7e391b217c2d3a758ec inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943005f89e7a6d5cee246e1c5b46e9ab inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a943005f89e7a6d5cee246e1c5b46e9ab"></a>
<a class="el" href="structst__ft__info.html">FT_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_handler</b></td></tr>
<tr class="separator:a943005f89e7a6d5cee246e1c5b46e9ab inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745f5757f7d7d690fb30ea7df8f08d43 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a745f5757f7d7d690fb30ea7df8f08d43"></a>
enum handler:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>inited</b></td></tr>
<tr class="separator:a745f5757f7d7d690fb30ea7df8f08d43 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd47d68a7b406d8777396a657095d5e8 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="afd47d68a7b406d8777396a657095d5e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>implicit_emptied</b></td></tr>
<tr class="separator:afd47d68a7b406d8777396a657095d5e8 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2f8d7155cb44162bb4181cb09f2f3 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a0ed2f8d7155cb44162bb4181cb09f2f3"></a>
const <a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_cond</b></td></tr>
<tr class="separator:a0ed2f8d7155cb44162bb4181cb09f2f3 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3d956f73649657bad389acfad5f0b inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae9b3d956f73649657bad389acfad5f0b"></a>
<a class="el" href="class_item.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond</b></td></tr>
<tr class="separator:ae9b3d956f73649657bad389acfad5f0b inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc8d81143d1c9c10b976711fe44cf37 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a4dc8d81143d1c9c10b976711fe44cf37"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond_keyno</b></td></tr>
<tr class="separator:a4dc8d81143d1c9c10b976711fe44cf37 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ab295e407d8a5c50087fed0f4fcd18 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a></td></tr>
<tr class="separator:a62ab295e407d8a5c50087fed0f4fcd18 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd2cafd83ae60562649bf9688aebf1 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a></td></tr>
<tr class="separator:a05dd2cafd83ae60562649bf9688aebf1 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1540a47a05c03724f1102aaaa623131e inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_discrete__interval.html">Discrete_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">auto_inc_interval_for_cur_row</a></td></tr>
<tr class="separator:a1540a47a05c03724f1102aaaa623131e inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfcef0738a89138c8f41ded8da17c0a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a></td></tr>
<tr class="separator:acdfcef0738a89138c8f41ded8da17c0a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e7cba3fe3bf9731a91be82983cc35 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">PSI_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a></td></tr>
<tr class="separator:a881e7cba3fe3bf9731a91be82983cc35 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:aad25b44b50ac64192d6cfef591252ed7 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aad25b44b50ac64192d6cfef591252ed7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_statistic_increment</b> (ulonglong SSV::*<a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>) const</td></tr>
<tr class="separator:aad25b44b50ac64192d6cfef591252ed7 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57260c07a7ed5d6522a02d473e8ceb1d inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a57260c07a7ed5d6522a02d473e8ceb1d"></a>
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ha_data</b> (THD *) const</td></tr>
<tr class="separator:a57260c07a7ed5d6522a02d473e8ceb1d inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df65ee64bcedb5a4b34bf752b2fab08 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9df65ee64bcedb5a4b34bf752b2fab08"></a>
THD *&#160;</td><td class="memItemRight" valign="bottom"><b>ha_thd</b> (void) const</td></tr>
<tr class="separator:a9df65ee64bcedb5a4b34bf752b2fab08 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69803cd29d92bfecd97212354212c516 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">PSI_table_share *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a69803cd29d92bfecd97212354212c516">ha_table_share_psi</a> (const <a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *share) const</td></tr>
<tr class="separator:a69803cd29d92bfecd97212354212c516 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccf806316a9d88a7130d70e7637e8e5 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a4ccf806316a9d88a7130d70e7637e8e5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a4ccf806316a9d88a7130d70e7637e8e5 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90af353b21f935dc95212e1cfef50452 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a90af353b21f935dc95212e1cfef50452"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_last</b> (uchar *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, const uchar *key, uint key_len)</td></tr>
<tr class="separator:a90af353b21f935dc95212e1cfef50452 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf21a8ad4be872bbfe94f5cb40abca inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_handler__share.html">Handler_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">get_ha_share_ptr</a> ()</td></tr>
<tr class="separator:a13bf21a8ad4be872bbfe94f5cb40abca inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24470ac1d4ac336cedbe7c245d321c9 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">set_ha_share_ptr</a> (<a class="el" href="class_handler__share.html">Handler_share</a> *arg_ha_share)</td></tr>
<tr class="separator:ab24470ac1d4ac336cedbe7c245d321c9 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a39db9dc1cca31f4a3ec0e0e1d7300 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">lock_shared_ha_data</a> ()</td></tr>
<tr class="separator:aa3a39db9dc1cca31f4a3ec0e0e1d7300 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059bbed3de416b3bea51c69dc064e79 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">unlock_shared_ha_data</a> ()</td></tr>
<tr class="separator:a8059bbed3de416b3bea51c69dc064e79 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classhandler')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a3b094cfe680aa06a7d8b70194415aa3b inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3b094cfe680aa06a7d8b70194415aa3b"></a>
<a class="el" href="struct_t_a_b_l_e___s_h_a_r_e.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table_share</b></td></tr>
<tr class="separator:a3b094cfe680aa06a7d8b70194415aa3b inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0d051d1ef534891b27612cc4ff56f7 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="abb0d051d1ef534891b27612cc4ff56f7"></a>
<a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table</b></td></tr>
<tr class="separator:abb0d051d1ef534891b27612cc4ff56f7 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98743b18a24c8baef7e22a11df74d6c9 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a98743b18a24c8baef7e22a11df74d6c9"></a>
Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>cached_table_flags</b></td></tr>
<tr class="separator:a98743b18a24c8baef7e22a11df74d6c9 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44b6a4c101f982cd13a344dce5a870 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="adf44b6a4c101f982cd13a344dce5a870"></a>
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>estimation_rows_to_insert</b></td></tr>
<tr class="separator:adf44b6a4c101f982cd13a344dce5a870 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011df14ecc738037499572c304d8ee90 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a011df14ecc738037499572c304d8ee90"></a>
<a class="el" href="class_k_e_y___p_a_r_t___i_n_f_o.html">KEY_PART_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>range_key_part</b></td></tr>
<tr class="separator:a011df14ecc738037499572c304d8ee90 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272c3d9b40a9e7c5de20ed390d23a636 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a272c3d9b40a9e7c5de20ed390d23a636"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>eq_range</b></td></tr>
<tr class="separator:a272c3d9b40a9e7c5de20ed390d23a636 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a159ca294d8dafe32405e6ad546e6a4 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1a159ca294d8dafe32405e6ad546e6a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>in_range_check_pushed_down</b></td></tr>
<tr class="separator:a1a159ca294d8dafe32405e6ad546e6a4 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1e6624f8a6246ce09553fece606d05df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6624f8a6246ce09553fece606d05df">&#9670;&nbsp;</a></span>alter_table_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint ha_partition::alter_table_flags </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>wrapper function for handlerton alter_table_flags, since the ha_partition_hton cannot know all its capabilities </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="aad1b45cb204fe8102d7ac0b3214c8353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1b45cb204fe8102d7ac0b3214c8353">&#9670;&nbsp;</a></span>bas_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char** ha_partition::bas_ext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If frm_error() is called then we will use this to find out what file extentions exist for the storage engine. This is also used by the default rename_table and delete_table method in <a class="el" href="handler_8cc.html" title="Handler-calling-functions. ">handler.cc</a>.</p>
<p>For engines that have two file name extentions (separate meta/index file and data file), the order of elements is relevant. First element of engine file name extentions array should be meta/index file extention. Second element - data file extention. This order is assumed by prepare_for_repair() when REPAIR <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> ... USE_FRM is issued. </p>

<p>Implements <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">handler</a>.</p>

</div>
</div>
<a id="a8b83aeaba7dadd1b28c22457ac67f43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b83aeaba7dadd1b28c22457ac67f43b">&#9670;&nbsp;</a></span>can_switch_engines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ha_partition::can_switch_engines </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used in ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> to check if changing storage engine is allowed.</p>
<dl class="section note"><dt>Note</dt><dd>Called without holding thr_lock.c lock.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Changing storage engine is allowed. </td></tr>
    <tr><td class="paramname">false</td><td>Changing storage engine not allowed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">handler</a>.</p>

</div>
</div>
<a id="af912fe341244ec80ccdf21c9b87e4e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af912fe341244ec80ccdf21c9b87e4e02">&#9670;&nbsp;</a></span>check_for_upgrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::check_for_upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>admin commands - called from mysql_admin_table </p>

<p>Reimplemented from <a class="el" href="classhandler.html#af1642bdb1665421244f2b838861c4be3">handler</a>.</p>

</div>
</div>
<a id="a66a9fc27dbc3652fec1fab4c7d9c077c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a9fc27dbc3652fec1fab4c7d9c077c">&#9670;&nbsp;</a></span>check_if_incompatible_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ha_partition::check_if_incompatible_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Part of old, deprecated in-place ALTER API. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">handler</a>.</p>

</div>
</div>
<a id="aeeb5f75cddb82102a64ac36bfceaef57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb5f75cddb82102a64ac36bfceaef57">&#9670;&nbsp;</a></span>check_if_supported_inplace_alter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual enum_alter_inplace_result ha_partition::check_if_supported_inplace_alter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if a storage engine supports a particular alter table in-place</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ALTER_ERROR</td><td>Unexpected error. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NOT_SUPPORTED</td><td>Not supported, must use copy. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_EXCLUSIVE_LOCK</td><td>Supported, but requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE</td><td>Supported, but requires SNW lock during main phase. Prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK</td><td>Supported, but requires SNW lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE</td><td>Supported, concurrent reads/writes allowed. However, prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK</td><td>Supported, concurrent reads/writes allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation uses the old in-place ALTER API to determine if the storage engine supports in-place ALTER or not.</dd>
<dd>
Called without holding thr_lock.c lock. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">handler</a>.</p>

</div>
</div>
<a id="afef1fc67a254d64a08df565ccf02bba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef1fc67a254d64a08df565ccf02bba8">&#9670;&nbsp;</a></span>check_misplaced_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_partition::check_misplaced_rows </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>read_part_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if the rows are placed in the correct partition. If the given argument is true, then move the rows to the correct partition. </p>

</div>
</div>
<a id="aa1797e0d681f755287d7858157a646e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1797e0d681f755287d7858157a646e3">&#9670;&nbsp;</a></span>commit_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ha_partition::commit_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Commit or rollback the changes made during <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a> and <a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">inplace_alter_table()</a> inside the storage engine. Note that in case of rollback the allowed level of concurrency during this operation will be the same as for <a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">inplace_alter_table()</a> and thus might be higher than during <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a>. (For example, concurrent writes were blocked during prepare, but might not be during rollback).</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function with commit= true reports error, it will be called again with commit= false.</dd>
<dd>
In case of partitioning, this function might be called for rollback without <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a> having been called first. Also partitioned tables sets ha_alter_info-&gt;group_commit_ctx to a NULL terminated array of the partitions handlers and if all of them are committed as one, then group_commit_ctx should be set to NULL to indicate to the partitioning handler that all partitions handlers are committed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">commit</td><td>True =&gt; Commit, False =&gt; Rollback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">handler</a>.</p>

</div>
</div>
<a id="ad162b32125ed0d7fb4b5b8167ce0269d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad162b32125ed0d7fb4b5b8167ce0269d">&#9670;&nbsp;</a></span>delete_all_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::delete_all_rows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is called to delete all rows in a table If the handler don't support this, then this function will return HA_ERR_WRONG_COMMAND and MySQL will delete the rows one by one. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">handler</a>.</p>

</div>
</div>
<a id="aafdb3caedb579b35d9cda963b7a3c25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdb3caedb579b35d9cda963b7a3c25f">&#9670;&nbsp;</a></span>delete_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete a table in the engine. Called for base as well as temporary tables.</p>
<p>Delete all files with extension from <a class="el" href="classha__partition.html#aad1b45cb204fe8102d7ac0b3214c8353">bas_ext()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Base name of table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We assume that the handler may return more extensions than was actually used for the file.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If we successfully deleted at least one file from base_ext and didn't get any other errors than ENOENT </td></tr>
    <tr><td class="paramname">!0</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">handler</a>.</p>

</div>
</div>
<a id="a663485370abf958b89641924402db405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663485370abf958b89641924402db405">&#9670;&nbsp;</a></span>estimate_rows_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows ha_partition::estimate_rows_upper_bound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return upper bound of current number of records in the table (max. of how many records one will retrieve when doing a full table scan) If upper bound is not known, HA_POS_ERROR should be returned as a max possible upper bound. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">handler</a>.</p>

</div>
</div>
<a id="a7668775be94bce9d7cf799c051096380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7668775be94bce9d7cf799c051096380">&#9670;&nbsp;</a></span>get_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ha_partition::get_auto_increment </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>nb_desired_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>first_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>nb_reserved_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reserves an interval of auto_increment values from the handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>offset (modulus increment) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">increment</td><td>increment between calls </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nb_desired_values</td><td>how many values we want </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_value</td><td>the first value reserved by the handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_reserved_values</td><td>how many values the handler reserved</td></tr>
  </table>
  </dd>
</dl>
<p>offset and increment means that we want values to be of the form offset + N * increment, where N&gt;=0 is integer. If the function sets *first_value to ULONGLONG_MAX it means an error. If the function sets *nb_reserved_values to ULONGLONG_MAX it means it has reserved to "positive infinite". </p>

<p>Reimplemented from <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">handler</a>.</p>

</div>
</div>
<a id="a4fb5ad51d61c07878d5626a315534497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb5ad51d61c07878d5626a315534497">&#9670;&nbsp;</a></span>get_error_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ha_partition::get_error_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an error message specific to this handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code previously returned by handler </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to <a class="el" href="class_string.html">String</a> where to add error message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this is a temporary error </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">handler</a>.</p>

</div>
</div>
<a id="a36ca395ca5c6066f00b30a9ccedfc43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ca395ca5c6066f00b30a9ccedfc43d">&#9670;&nbsp;</a></span>get_no_parts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_partition::get_no_parts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>no_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get number of partitions for table in SE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>normalized path(same as open) to the table</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">no_parts</td><td>Number of partitions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>for success </td></tr>
    <tr><td class="paramname">true</td><td>for failure, for example table didn't exist in engine </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab3cad9d951b59dd0b705e6861dc489e7">handler</a>.</p>

</div>
</div>
<a id="ab4f337e2cd0e372d26af8222920a063d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f337e2cd0e372d26af8222920a063d">&#9670;&nbsp;</a></span>get_row_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual enum row_type ha_partition::get_row_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the row type from the storage engine. If this method returns ROW_TYPE_NOT_USED, the information in HA_CREATE_INFO should be used. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a163a360c0cd4575ae207553b8d5c918d">handler</a>.</p>

</div>
</div>
<a id="acc714b62d79e24a9c1d4f3db712322b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc714b62d79e24a9c1d4f3db712322b1">&#9670;&nbsp;</a></span>index_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::index_first </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af37bd518c53c966459632584c34855d0">handler</a>.</p>

</div>
</div>
<a id="a4e4defdf04378b86f231928ed21e017b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4defdf04378b86f231928ed21e017b">&#9670;&nbsp;</a></span>index_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::index_last </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">handler</a>.</p>

</div>
</div>
<a id="a6a599d1fe239ff7d7dba0b3984fc8bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a599d1fe239ff7d7dba0b3984fc8bea">&#9670;&nbsp;</a></span>index_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::index_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">handler</a>.</p>

</div>
</div>
<a id="a2769f8f7dd54eebb15c6baa6c4651b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2769f8f7dd54eebb15c6baa6c4651b2b">&#9670;&nbsp;</a></span>index_next_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::index_next_same </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">handler</a>.</p>

</div>
</div>
<a id="a25706609cb26f778dd90cc2611b112fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25706609cb26f778dd90cc2611b112fd">&#9670;&nbsp;</a></span>index_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::index_prev </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">handler</a>.</p>

</div>
</div>
<a id="aee13430aea3946ffa6cf2c00104ba19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee13430aea3946ffa6cf2c00104ba19c">&#9670;&nbsp;</a></span>index_read_idx_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::index_read_idx_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Positions an index cursor to the index specified in the hanlde. Fetches the row if available. If the key value is null, begin at first key of the index. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">handler</a>.</p>

</div>
</div>
<a id="ae28896451f43f7b821e441413936c93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28896451f43f7b821e441413936c93c">&#9670;&nbsp;</a></span>index_read_last_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::index_read_last_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following functions works like index_read, but it find the last row with the current key value or prefix. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">handler</a>.</p>

</div>
</div>
<a id="a7e153d8c7280e6d4440b09c61976e7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e153d8c7280e6d4440b09c61976e7f3">&#9670;&nbsp;</a></span>index_read_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::index_read_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if success (found a record, and function has set table-&gt;status to 0); non-zero if no record (function has set table-&gt;status to STATUS_NOT_FOUND). </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">handler</a>.</p>

</div>
</div>
<a id="a772afdad3f8e79ecf0c176dfee5c95d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772afdad3f8e79ecf0c176dfee5c95d2">&#9670;&nbsp;</a></span>inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ha_partition::inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and <a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a>. The level of concurrency allowed during this operation depends on the return value from <a class="el" href="classha__partition.html#aeeb5f75cddb82102a64ac36bfceaef57">check_if_supported_inplace_alter()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table()</a> will be called with commit= false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">handler</a>.</p>

</div>
</div>
<a id="a18e8ff8fce23b0ca305755e60d960cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e8ff8fce23b0ca305755e60d960cd9">&#9670;&nbsp;</a></span>is_fatal_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ha_partition::is_fatal_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used to analyse the error to see whether the error is ignorable or not, certain handlers can have more error that are ignorable than others. E.g. the partition handler can get inserts into a range where there is no partition and this is an ignorable error. HA_ERR_FOUND_DUP_UNIQUE is a special case in MyISAM that means the same thing as HA_ERR_FOUND_DUP_KEY but can in some cases lead to a slightly different error message. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a1bc56a8f3a2c01c127ad553fdf2a8c18">handler</a>.</p>

</div>
</div>
<a id="a34acffe19d43c2dc2570e995cf22a3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34acffe19d43c2dc2570e995cf22a3d8">&#9670;&nbsp;</a></span>lock_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint ha_partition::lock_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classha__partition.html#a34acffe19d43c2dc2570e995cf22a3d8">lock_count()</a> can return &gt; 1 if the table is MERGE or partitioned. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">handler</a>.</p>

</div>
</div>
<a id="a4350de763daa055bf18a26267664bda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4350de763daa055bf18a26267664bda2">&#9670;&nbsp;</a></span>notify_table_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ha_partition::notify_table_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notify the storage engine that the table structure (.FRM) has been updated.</p>
<dl class="section note"><dt>Note</dt><dd>No errors are allowed during <a class="el" href="classha__partition.html#a4350de763daa055bf18a26267664bda2">notify_table_changed()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">handler</a>.</p>

</div>
</div>
<a id="a60893ae5e2153faa3f35ffde0460d9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60893ae5e2153faa3f35ffde0460d9d6">&#9670;&nbsp;</a></span>prepare_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ha_partition::prepare_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_alter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows the storage engine to update internal structures with concurrent writes blocked. If <a class="el" href="classha__partition.html#aeeb5f75cddb82102a64ac36bfceaef57">check_if_supported_inplace_alter()</a> returns HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE or HA_ALTER_INPLACE_SHARED_AFTER_PREPARE, this function is called with exclusive lock otherwise the same level of locking as for <a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">inplace_alter_table()</a> will be used.</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table()</a> will be called with commit= false.</dd>
<dd>
For partitioning, failing to prepare one partition, means that <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table()</a> will be called to roll back changes for all partitions. This means that <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table()</a> might be called without <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a> having been called first for a given partition.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="struct_t_a_b_l_e.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">handler</a>.</p>

</div>
</div>
<a id="afbddb8246029958806a6078b3ea71b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbddb8246029958806a6078b3ea71b32">&#9670;&nbsp;</a></span>print_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ha_partition::print_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">myf&#160;</td>
          <td class="paramname"><em>errflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print error that we got from handler function.</p>
<dl class="section note"><dt>Note</dt><dd>In case of delete table it's only safe to use the following parts of the 'table' structure:<ul>
<li>table-&gt;s-&gt;path</li>
<li>table-&gt;alias </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">handler</a>.</p>

</div>
</div>
<a id="aa0217cd2a331904f87fbfcbe4dde5800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0217cd2a331904f87fbfcbe4dde5800">&#9670;&nbsp;</a></span>read_range_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::read_range_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structst__key__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__key__range.html">key_range</a> *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read first row between two ranges. Store ranges for future calls to read_range_next. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Start key. Is 0 if no min range </td></tr>
    <tr><td class="paramname">end_key</td><td>End key. Is 0 if no max range </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Set to 1 if start_key == end_key </td></tr>
    <tr><td class="paramname">sorted</td><td>Set to 1 if result should be sorted per key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">handler</a>.</p>

</div>
</div>
<a id="ae77ce0688d4d2c0451dcb930e6ca42bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77ce0688d4d2c0451dcb930e6ca42bc">&#9670;&nbsp;</a></span>read_range_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::read_range_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read next row between two endpoints. </p>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">handler</a>.</p>

</div>
</div>
<a id="ae2cd9274cdcf243f53efc8c236bb8379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cd9274cdcf243f53efc8c236bb8379">&#9670;&nbsp;</a></span>read_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ha_partition::read_time </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cost of reading a set of ranges from the table using an index to access it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index number. </td></tr>
    <tr><td class="paramname">ranges</td><td>The number of ranges to be read. </td></tr>
    <tr><td class="paramname">rows</td><td>Total number of rows to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be used to calculate the total cost of scanning a table using an index by calling it using read_time(index, 1, table_size). </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">handler</a>.</p>

</div>
</div>
<a id="ada684ff4029d92f8b693952ccb780948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada684ff4029d92f8b693952ccb780948">&#9670;&nbsp;</a></span>records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows ha_partition::records </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of rows in table. It will only be called if (table_flags() &amp; (HA_HAS_RECORDS | HA_STATS_RECORDS_IS_EXACT)) != 0 </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">handler</a>.</p>

</div>
</div>
<a id="a4673b0434ccbcd97542e1f7636d61db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4673b0434ccbcd97542e1f7636d61db2">&#9670;&nbsp;</a></span>register_query_cache_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual my_bool ha_partition::register_query_cache_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qc_engine_callback *&#160;</td>
          <td class="paramname"><em>engine_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>engine_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a named table with a call back function to the query cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_key</td><td>A pointer to the table name in the table cache </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_length</td><td>The length of the table name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_callback</td><td>The pointer to the storage engine call back function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_data</td><td>Storage engine specific data which could be anything</td></tr>
  </table>
  </dd>
</dl>
<p>This method offers the storage engine, the possibility to store a reference to a table name which is going to be used with query cache. The method is called each time a statement is written to the cache and can be used to verify if a specific statement is cachable. It also offers the possibility to register a generic (but static) call back function which is called each time a statement is matched against the query cache.</p>
<dl class="section note"><dt>Note</dt><dd>If engine_data supplied with this function is different from engine_data supplied with the callback function, and the callback returns FALSE, a table invalidation on the current table will occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Upon success the engine_callback will point to the storage engine call back function, if any, and engine_data will point to any storage engine data used in the specific implementation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Success </td></tr>
    <tr><td class="paramname">FALSE</td><td>The specified table or current statement should not be cached </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a2ec87bfd95b71d14fafbb3f88569094f">handler</a>.</p>

</div>
</div>
<a id="a7dbc26903dfbc0128c0d5a7e68d3681b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbc26903dfbc0128c0d5a7e68d3681b">&#9670;&nbsp;</a></span>rename_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default <a class="el" href="classha__partition.html#a7dbc26903dfbc0128c0d5a7e68d3681b">rename_table()</a> and <a class="el" href="classha__partition.html#aafdb3caedb579b35d9cda963b7a3c25f">delete_table()</a> rename/delete files with a given name and extensions from <a class="el" href="classha__partition.html#aad1b45cb204fe8102d7ac0b3214c8353">bas_ext()</a>.</p>
<p>These methods can be overridden, but their default implementation provide useful functionality. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">handler</a>.</p>

</div>
</div>
<a id="ab7908bdcad420cac9f0d696e528ba8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7908bdcad420cac9f0d696e528ba8e1">&#9670;&nbsp;</a></span>repair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::repair </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In this method check_opt can be modified to specify CHECK option to use to call <a class="el" href="row0ins_8cc.html#af89eccd3e535f029833696f4c35f730e">check()</a> upon the table. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a889322859f50e88a643067fb706c2bf2">handler</a>.</p>

</div>
</div>
<a id="a0dd96d4f1ecc4e63d6afbcc6d6d4c243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd96d4f1ecc4e63d6afbcc6d6d4c243">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset state of file to after 'open'. This function is called after every statement for all tables used by that statement. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a1161c615e45f4bd9c285a0e3c1e332af">handler</a>.</p>

</div>
</div>
<a id="a8c66eff39dc4dcc487709bd3b2c8aed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c66eff39dc4dcc487709bd3b2c8aed6">&#9670;&nbsp;</a></span>reset_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::reset_auto_increment </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the auto-increment counter to the given value, i.e. the next row inserted will get the given value. HA_ERR_WRONG_COMMAND is returned by storage engines that don't support this operation. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a27e343a6e97ad5264e1fe5a70659899f">handler</a>.</p>

</div>
</div>
<a id="a0f1716a11f635614b7772b9b0711a1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1716a11f635614b7772b9b0711a1ff">&#9670;&nbsp;</a></span>rnd_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::rnd_init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classha__partition.html#a0f1716a11f635614b7772b9b0711a1ff">rnd_init()</a> can be called two times without rnd_end() in between (it only makes sense if scan=1). then the second call should prepare for the new table scan (e.g if rnd_init allocates the cursor, second call should position it to the start of the table, no need to deallocate and allocate it again </p>

<p>Implements <a class="el" href="classhandler.html#a9ddfc5530e45a9340e2de99626085da6">handler</a>.</p>

</div>
</div>
<a id="ad468c67dd2f37885994530f9e2ad2266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad468c67dd2f37885994530f9e2ad2266">&#9670;&nbsp;</a></span>rnd_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::rnd_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">handler</a>.</p>

</div>
</div>
<a id="a7b052173ced1b88687dafba28a170335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b052173ced1b88687dafba28a170335">&#9670;&nbsp;</a></span>rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::rnd_pos </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">handler</a>.</p>

</div>
</div>
<a id="a58bbc7153fa41de3b53872cb8f4b4e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bbc7153fa41de3b53872cb8f4b4e6e">&#9670;&nbsp;</a></span>rnd_pos_by_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::rnd_pos_by_record </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function only works for handlers having HA_PRIMARY_KEY_REQUIRED_FOR_POSITION set. It will return the row with the PK given in the record argument. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">handler</a>.</p>

</div>
</div>
<a id="a590ff604823725a59b5b7dd1fa83ac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590ff604823725a59b5b7dd1fa83ac35">&#9670;&nbsp;</a></span>store_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a>** ha_partition::store_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__thr__lock__data.html">THR_LOCK_DATA</a> **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is not invoked for non-transactional temporary tables.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">store_lock()</a> can return more than one lock if the table is MERGE or partitioned.</dd>
<dd>
that one can NOT rely on table-&gt;in_use in <a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">store_lock()</a>. It may refer to a different thread if called from <a class="el" href="group___locking.html#ga321511c56502643e5aecbe6ed3e43b58">mysql_lock_abort_for_thread()</a>.</dd>
<dd>
If the table is MERGE, <a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">store_lock()</a> can return less locks than <a class="el" href="classha__partition.html#a34acffe19d43c2dc2570e995cf22a3d8">lock_count()</a> claimed. This can happen when the MERGE children are not attached when this is called from another thread. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">handler</a>.</p>

</div>
</div>
<a id="a2b4f4002504f73ed3ae195729b95603b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4f4002504f73ed3ae195729b95603b">&#9670;&nbsp;</a></span>table_cache_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint8 ha_partition::table_cache_type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type of table for caching query </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">handler</a>.</p>

</div>
</div>
<a id="a4ccd1f4c54f976848686ae866e7f9c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccd1f4c54f976848686ae866e7f9c96">&#9670;&nbsp;</a></span>table_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* ha_partition::table_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The following can be called without an open handler </p>

<p>Implements <a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">handler</a>.</p>

</div>
</div>
<a id="a42819e5cf989a23c0ade56feece2bcf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42819e5cf989a23c0ade56feece2bcf4">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ha_partition::truncate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quickly remove all rows from a table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is responsible for implementing MySQL's TRUNCATE <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> statement, which is a DDL operation. As such, a engine can bypass certain integrity checks and in some cases avoid fine-grained locking (e.g. row locks) which would normally be required for a DELETE statement.</dd>
<dd>
Typically, truncate is not used if it can result in integrity violation. For example, truncate is not used when a foreign key references the table, but it might be used if foreign key checks are disabled.</dd>
<dd>
Engine is responsible for resetting the auto-increment counter.</dd>
<dd>
The table is locked in exclusive mode. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">handler</a>.</p>

</div>
</div>
<a id="a45235c1c364a4b1ac4a2b97134f7a4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45235c1c364a4b1ac4a2b97134f7a4b4">&#9670;&nbsp;</a></span>try_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ha_partition::try_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell the engine whether it should avoid unnecessary lock waits. If yes, in an UPDATE or DELETE, if the row under the cursor was locked by another transaction, the engine may try an optimistic read of the last committed row value under the cursor. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">handler</a>.</p>

</div>
</div>
<a id="a2a059c1ac08f3cd71b7087b876664e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a059c1ac08f3cd71b7087b876664e18">&#9670;&nbsp;</a></span>was_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ha_partition::was_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In an UPDATE or DELETE, if the row under the cursor was locked by another transaction, and the engine used an optimistic read of the last committed row value under the cursor, then the engine returns 1 from this function. MySQL must NOT try to update this optimistic value. If the optimistic value does not match the WHERE condition, MySQL can decide to skip over this row. Currently only works for InnoDB. This can be used to avoid unnecessary lock waits.</p>
<p>If this method returns nonzero, it will also signal the storage engine that the next read will be a locking re-read of the row. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">handler</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a76f4861c1ea2815527665ae9fefb6204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f4861c1ea2815527665ae9fefb6204">&#9670;&nbsp;</a></span>auto_increment_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_partition::auto_increment_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>lock reading/updating auto_inc </p>

</div>
</div>
<a id="a31d7e768a3436d4ac7658834a9dff742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d7e768a3436d4ac7658834a9dff742">&#9670;&nbsp;</a></span>auto_increment_safe_stmt_log_lock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_partition::auto_increment_safe_stmt_log_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag to keep the auto_increment lock through out the statement. This to ensure it will work with statement based replication. </p>

</div>
</div>
<a id="a7b4ca93bc4947d77635b82e10d4f4529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4ca93bc4947d77635b82e10d4f4529">&#9670;&nbsp;</a></span>m_bulk_insert_started</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__bitmap.html">MY_BITMAP</a> ha_partition::m_bulk_insert_started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For optimizing ha_start_bulk_insert calls </p>

</div>
</div>
<a id="aeb15272a7ba9abfc64c091f480136e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb15272a7ba9abfc64c091f480136e28">&#9670;&nbsp;</a></span>m_curr_key_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__key.html">KEY</a>* ha_partition::m_curr_key_info[3]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Current index used for sorting. If clustered PK exists, then it will be used as secondary index to sort on if the first is equal in key_rec_cmp. So if clustered pk: m_curr_key_info[0]= current index and m_curr_key_info[1]= pk and [2]= NULL. Otherwise [0]= current index, [1]= NULL, and we will sort by rowid as secondary sort key if equal first key. </p>

</div>
</div>
<a id="a4d1e4ae03ef02a70c4e86f0c09effad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1e4ae03ef02a70c4e86f0c09effad8">&#9670;&nbsp;</a></span>m_key_not_found_partitions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__bitmap.html">MY_BITMAP</a> ha_partition::m_key_not_found_partitions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>partitions that returned HA_ERR_KEY_NOT_FOUND. </p>

</div>
</div>
<a id="a3e1ff8a85aa3d4ed312f3354ff6efff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1ff8a85aa3d4ed312f3354ff6efff3">&#9670;&nbsp;</a></span>m_locked_partitions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__bitmap.html">MY_BITMAP</a> ha_partition::m_locked_partitions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>keep track of locked partitions </p>

</div>
</div>
<a id="a2ed24e9ccb75daae68c0e9fddd438a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed24e9ccb75daae68c0e9fddd438a15">&#9670;&nbsp;</a></span>m_new_partitions_share_refs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_list.html">List</a>&lt;<a class="el" href="class_parts__share__refs.html">Parts_share_refs</a>&gt; ha_partition::m_new_partitions_share_refs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Temporary storage for new partitions Handler_shares during ALTER </p>

</div>
</div>
<a id="a61d70c88f78f888626c6f9159e1cd6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d70c88f78f888626c6f9159e1cd6d7">&#9670;&nbsp;</a></span>m_part_func_monotonicity_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_monotonicity_info ha_partition::m_part_func_monotonicity_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>used for prediction of start_bulk_insert rows </p>

</div>
</div>
<a id="a0b0f581ba24c80bfb46004c22c0fee5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0f581ba24c80bfb46004c22c0fee5f">&#9670;&nbsp;</a></span>m_part_ids_sorted_by_num_of_records</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32* ha_partition::m_part_ids_sorted_by_num_of_records</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorted array of partition ids in descending order of number of rows. </p>

</div>
</div>
<a id="a9cb2f621be7fb25af38a1ac8b20bc2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb2f621be7fb25af38a1ac8b20bc2c7">&#9670;&nbsp;</a></span>m_partitions_to_reset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__bitmap.html">MY_BITMAP</a> ha_partition::m_partitions_to_reset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>keep track of partitions to call ha_reset </p>

</div>
</div>
<a id="abdc66549fe3cad4c52c77c0b4135d8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc66549fe3cad4c52c77c0b4135d8f3">&#9670;&nbsp;</a></span>m_rec_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint ha_partition::m_rec_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offset in m_ordered_rec_buffer from part buffer to its record buffer. </p>

</div>
</div>
<a id="a4d339373a5cd94a7b418287f7bd7ce66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d339373a5cd94a7b418287f7bd7ce66">&#9670;&nbsp;</a></span>m_sec_sort_by_rowid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_partition::m_sec_sort_by_rowid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Need to sort by ref (rowid) too. </p>

</div>
</div>
<a id="a53ecb52fe5cf4a9f81ee3e307ce60d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ecb52fe5cf4a9f81ee3e307ce60d5a">&#9670;&nbsp;</a></span>part_share</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_partition__share.html">Partition_share</a>* ha_partition::part_share</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores shared auto_increment etc. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sql/<a class="el" href="ha__partition_8h_source.html">ha_partition.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

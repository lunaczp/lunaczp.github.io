<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/buf/buf0flu.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_19e7dc57837d445aa8a255d4d3e40a16.html">buf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0flu.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="buf0flu_8h_source.html">buf0flu.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;buf0checksum.h&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0lst_8h_source.html">ut0lst.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0rea_8h_source.html">buf0rea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0file_8h_source.html">os0file.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0sys_8h_source.html">trx0sys.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;mysql/plugin.h&quot;</code><br />
<code>#include &quot;<a class="el" href="service__thd__wait_8h_source.html">mysql/service_thd_wait.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5f1b8413bfc90f73a20259cb185c707c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a5f1b8413bfc90f73a20259cb185c707c">PAGE_CLEANER_LRU_BATCH_CHUNK_SIZE</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:a5f1b8413bfc90f73a20259cb185c707c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ce9aa39c4345fc00d614f78fb37e8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aa4ce9aa39c4345fc00d614f78fb37e8d">BUF_LRU_MIN_LEN</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:aa4ce9aa39c4345fc00d614f78fb37e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a761e7586969f3f27fd95463f47b08223"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a761e7586969f3f27fd95463f47b08223">incr_flush_list_size_in_bytes</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="separator:a761e7586969f3f27fd95463f47b08223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bdd8286389b526079a8449e0754048"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a03bdd8286389b526079a8449e0754048">buf_flush_set_hp</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:a03bdd8286389b526079a8449e0754048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeab8f3b149bac79f3101dfd166b05bc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aaeab8f3b149bac79f3101dfd166b05bc">buf_flush_is_hp</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:aaeab8f3b149bac79f3101dfd166b05bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad85d9f859e6045026bba54e4e014a8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aaad85d9f859e6045026bba54e4e014a8">buf_flush_update_hp</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:aaad85d9f859e6045026bba54e4e014a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c445e7d4386b79b9e58e6a902f6e1ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a1c445e7d4386b79b9e58e6a902f6e1ad">buf_flush_insert_in_flush_rbt</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:a1c445e7d4386b79b9e58e6a902f6e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af746dcfb3778cbdec70aef3e821bfb52"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#af746dcfb3778cbdec70aef3e821bfb52">buf_flush_delete_from_flush_rbt</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:af746dcfb3778cbdec70aef3e821bfb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3218423965865bfb20be90854fc67a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a0a3218423965865bfb20be90854fc67a">buf_flush_block_cmp</a> (const void *p1, const void *p2)</td></tr>
<tr class="separator:a0a3218423965865bfb20be90854fc67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49fa7dbba8849c77339ecf1a363ac3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aeb49fa7dbba8849c77339ecf1a363ac3">buf_flush_init_flush_rbt</a> (void)</td></tr>
<tr class="separator:aeb49fa7dbba8849c77339ecf1a363ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e647da62f866e246ae0c827700a1959"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a3e647da62f866e246ae0c827700a1959">buf_flush_free_flush_rbt</a> (void)</td></tr>
<tr class="separator:a3e647da62f866e246ae0c827700a1959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcc0b5c1f2a5b4cf2decf95faf1de1e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a1bcc0b5c1f2a5b4cf2decf95faf1de1e">buf_flush_insert_into_flush_list</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>)</td></tr>
<tr class="separator:a1bcc0b5c1f2a5b4cf2decf95faf1de1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e7df9409115663e4c79143ef51a68d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ae5e7df9409115663e4c79143ef51a68d">buf_flush_insert_sorted_into_flush_list</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>)</td></tr>
<tr class="separator:ae5e7df9409115663e4c79143ef51a68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ddaefb5098a15d7b40822fc0108dc0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a03ddaefb5098a15d7b40822fc0108dc0">buf_flush_ready_for_replace</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:a03ddaefb5098a15d7b40822fc0108dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6f303f516088aab8dbbe55d00b5c74"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a7f6f303f516088aab8dbbe55d00b5c74">buf_flush_ready_for_flush</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type)</td></tr>
<tr class="separator:a7f6f303f516088aab8dbbe55d00b5c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c10073f8f2608c74511614b3fb6c63d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a2c10073f8f2608c74511614b3fb6c63d">buf_flush_remove</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:a2c10073f8f2608c74511614b3fb6c63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab103ef786b28c99629d79d8f89e768e8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ab103ef786b28c99629d79d8f89e768e8">buf_flush_relocate_on_flush_list</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *dpage)</td></tr>
<tr class="separator:ab103ef786b28c99629d79d8f89e768e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4d812b4926a7d43eaf8dfc386e904d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aeb4d812b4926a7d43eaf8dfc386e904d">buf_flush_write_complete</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>)</td></tr>
<tr class="separator:aeb4d812b4926a7d43eaf8dfc386e904d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c09491b9228b827cab2f286adc944f6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a2c09491b9228b827cab2f286adc944f6">buf_flush_update_zip_checksum</a> (<a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>)</td></tr>
<tr class="separator:a2c09491b9228b827cab2f286adc944f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4460ad4f28ba2c245bda6cc4bfbfbe2c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a4460ad4f28ba2c245bda6cc4bfbfbe2c">buf_flush_init_for_writing</a> (byte *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, void *page_zip_, lsn_t newest_lsn)</td></tr>
<tr class="separator:a4460ad4f28ba2c245bda6cc4bfbfbe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1062d51b94e2b084c044e70f2ae88ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aa1062d51b94e2b084c044e70f2ae88ef">buf_flush_write_block_low</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type, bool <a class="el" href="ibuf0ibuf_8cc.html#a6265893dd43b2df4e241408f9e736f2e">sync</a>)</td></tr>
<tr class="separator:aa1062d51b94e2b084c044e70f2ae88ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5914fbbf06f6b008435e61ba0e3dadc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ab5914fbbf06f6b008435e61ba0e3dadc">buf_flush_page</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type, bool <a class="el" href="ibuf0ibuf_8cc.html#a6265893dd43b2df4e241408f9e736f2e">sync</a>)</td></tr>
<tr class="separator:ab5914fbbf06f6b008435e61ba0e3dadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0476cc43c55b63e49f3aefb19f5fb8fa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a0476cc43c55b63e49f3aefb19f5fb8fa">buf_flush_check_neighbor</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type)</td></tr>
<tr class="separator:a0476cc43c55b63e49f3aefb19f5fb8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587b0855b85f26812b5b5ef7f440266a"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a587b0855b85f26812b5b5ef7f440266a">buf_flush_try_neighbors</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type, ulint n_flushed, ulint n_to_flush)</td></tr>
<tr class="separator:a587b0855b85f26812b5b5ef7f440266a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4950ec60e820b2f86c2afc42b58009ed"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a4950ec60e820b2f86c2afc42b58009ed">buf_flush_page_and_try_neighbors</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *<a class="el" href="buf0lru_8cc.html#a9ffdaebdcefba1fd5f70092d43ca5d98">bpage</a>, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type, ulint n_to_flush, ulint *count)</td></tr>
<tr class="separator:a4950ec60e820b2f86c2afc42b58009ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00eb217491a10ca7a1811570177bf30"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ad00eb217491a10ca7a1811570177bf30">buf_free_from_unzip_LRU_list_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint max)</td></tr>
<tr class="separator:ad00eb217491a10ca7a1811570177bf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9aad352583b7bf98ccf0005d736e4ad"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ab9aad352583b7bf98ccf0005d736e4ad">buf_flush_LRU_list_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint max)</td></tr>
<tr class="separator:ab9aad352583b7bf98ccf0005d736e4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb81af9d46be9ca6afe966c01a63c375"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aeb81af9d46be9ca6afe966c01a63c375">buf_do_LRU_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint max)</td></tr>
<tr class="separator:aeb81af9d46be9ca6afe966c01a63c375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab380a24de97ba79d0e6db35c7e725b"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aeab380a24de97ba79d0e6db35c7e725b">buf_do_flush_list_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint min_n, lsn_t lsn_limit)</td></tr>
<tr class="separator:aeab380a24de97ba79d0e6db35c7e725b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5e7a3059daaf5c13a3892619494de3"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#acc5e7a3059daaf5c13a3892619494de3">buf_flush_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type, ulint min_n, lsn_t lsn_limit)</td></tr>
<tr class="separator:acc5e7a3059daaf5c13a3892619494de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b22126f84f74b44f1c3587a9aaae48c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a0b22126f84f74b44f1c3587a9aaae48c">buf_flush_common</a> (<a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type, ulint page_count)</td></tr>
<tr class="separator:a0b22126f84f74b44f1c3587a9aaae48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123e98bfe5f927a308226cb6d7fc1622"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a123e98bfe5f927a308226cb6d7fc1622">buf_flush_start</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type)</td></tr>
<tr class="separator:a123e98bfe5f927a308226cb6d7fc1622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f046fa30d716082b81862a574b8643"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a04f046fa30d716082b81862a574b8643">buf_flush_end</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type)</td></tr>
<tr class="separator:a04f046fa30d716082b81862a574b8643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae775b5ae847bc1c02cb581bf69ce1931"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#ae775b5ae847bc1c02cb581bf69ce1931">buf_flush_wait_batch_end</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>)</td></tr>
<tr class="separator:ae775b5ae847bc1c02cb581bf69ce1931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600bc9e904fce3f32a382b710ef3c07f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a600bc9e904fce3f32a382b710ef3c07f">buf_flush_LRU</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint min_n, ulint *n_processed)</td></tr>
<tr class="separator:a600bc9e904fce3f32a382b710ef3c07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9c99474dd78fbb55e8ed2e1dd5cea9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#abe9c99474dd78fbb55e8ed2e1dd5cea9">buf_flush_list</a> (ulint min_n, lsn_t lsn_limit, ulint *n_processed)</td></tr>
<tr class="separator:abe9c99474dd78fbb55e8ed2e1dd5cea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdcc4f760f8ebd33c02f0cd042490b4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a9cdcc4f760f8ebd33c02f0cd042490b4">buf_flush_single_page_from_LRU</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="separator:a9cdcc4f760f8ebd33c02f0cd042490b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c9b352f7400e101a335d34f36f6021"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a18c9b352f7400e101a335d34f36f6021">buf_flush_LRU_tail</a> (void)</td></tr>
<tr class="separator:a18c9b352f7400e101a335d34f36f6021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ba4c6df1e52b8f19586ee715ebda7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a516ba4c6df1e52b8f19586ee715ebda7">buf_flush_wait_LRU_batch_end</a> (void)</td></tr>
<tr class="separator:a516ba4c6df1e52b8f19586ee715ebda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691a6fafee1b7cb8e7fe2feb05656d92"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a691a6fafee1b7cb8e7fe2feb05656d92">page_cleaner_do_flush_batch</a> (ulint n_to_flush, lsn_t lsn_limit)</td></tr>
<tr class="separator:a691a6fafee1b7cb8e7fe2feb05656d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6752ffd3be594e1209410d6625fe90d6"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a6752ffd3be594e1209410d6625fe90d6">af_get_pct_for_dirty</a> ()</td></tr>
<tr class="separator:a6752ffd3be594e1209410d6625fe90d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06bf55c501ea5596474aa9d99f58cd4"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#aa06bf55c501ea5596474aa9d99f58cd4">af_get_pct_for_lsn</a> (lsn_t age)</td></tr>
<tr class="separator:aa06bf55c501ea5596474aa9d99f58cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dbaebafe42c35476b3274ae99105ee"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a02dbaebafe42c35476b3274ae99105ee">page_cleaner_flush_pages_if_needed</a> (void)</td></tr>
<tr class="separator:a02dbaebafe42c35476b3274ae99105ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168e06a8a44d2f706a16560b73beefa7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a168e06a8a44d2f706a16560b73beefa7">page_cleaner_sleep_if_needed</a> (ulint next_loop_time)</td></tr>
<tr class="separator:a168e06a8a44d2f706a16560b73beefa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2b9b37de9e8bb8b1c10945081e3e59"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a3e2b9b37de9e8bb8b1c10945081e3e59">buf_flush_page_cleaner_thread</a> (void *arg <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:a3e2b9b37de9e8bb8b1c10945081e3e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3202981d62523b59648d39f0226eecea"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a3202981d62523b59648d39f0226eecea">buf_lru_flush_page_count</a> = 0</td></tr>
<tr class="separator:a3202981d62523b59648d39f0226eecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b56e2842d48c564df5658af451790d3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8cc.html#a3b56e2842d48c564df5658af451790d3">buf_page_cleaner_is_active</a> = FALSE</td></tr>
<tr class="separator:a3b56e2842d48c564df5658af451790d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The database buffer buf_pool flush algorithm</p>
<p>Created 11/11/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa4ce9aa39c4345fc00d614f78fb37e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ce9aa39c4345fc00d614f78fb37e8d">&#9670;&nbsp;</a></span>BUF_LRU_MIN_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_MIN_LEN&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If LRU list of a buf_pool is less than this size then LRU eviction should not happen. This is because when we do LRU flushing we also put the blocks on free list. If LRU list is very small then we can end up in thrashing. </p>

</div>
</div>
<a id="a5f1b8413bfc90f73a20259cb185c707c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1b8413bfc90f73a20259cb185c707c">&#9670;&nbsp;</a></span>PAGE_CLEANER_LRU_BATCH_CHUNK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PAGE_CLEANER_LRU_BATCH_CHUNK_SIZE&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LRU flush batch is further divided into this chunk size to reduce the wait time for the threads waiting for a clean block </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6752ffd3be594e1209410d6625fe90d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6752ffd3be594e1209410d6625fe90d6">&#9670;&nbsp;</a></span>af_get_pct_for_dirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint af_get_pct_for_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates if flushing is required based on number of dirty pages in the buffer pool. </p><dl class="section return"><dt>Returns</dt><dd>percent of io_capacity to flush to manage dirty page ratio </dd></dl>

</div>
</div>
<a id="aa06bf55c501ea5596474aa9d99f58cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06bf55c501ea5596474aa9d99f58cd4">&#9670;&nbsp;</a></span>af_get_pct_for_lsn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint af_get_pct_for_lsn </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>age</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates if flushing is required based on redo generation rate. </p><dl class="section return"><dt>Returns</dt><dd>percent of io_capacity to flush to manage redo space </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">age</td><td>in: current age of LSN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeab380a24de97ba79d0e6db35c7e725b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab380a24de97ba79d0e6db35c7e725b">&#9670;&nbsp;</a></span>buf_do_flush_list_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_do_flush_list_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This utility flushes dirty blocks from the end of the flush_list. the calling thread is not allowed to own any latches on pages! </p><dl class="section return"><dt>Returns</dt><dd>number of blocks for which the write request was queued; ULINT_UNDEFINED if there was a flush of the same type already running </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">min_n</td><td>in: wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramname">lsn_limit</td><td>all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb81af9d46be9ca6afe966c01a63c375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb81af9d46be9ca6afe966c01a63c375">&#9670;&nbsp;</a></span>buf_do_LRU_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_do_LRU_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush and move pages from LRU or unzip_LRU list to the free list. Whether LRU or unzip_LRU is used depends on the state of the system. </p><dl class="section return"><dt>Returns</dt><dd>number of blocks for which either the write request was queued or in case of unzip_LRU the number of blocks actually moved to the free list </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">max</td><td>in: desired number of blocks in the free_list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc5e7a3059daaf5c13a3892619494de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5e7a3059daaf5c13a3892619494de3">&#9670;&nbsp;</a></span>buf_flush_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_flush_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This utility flushes dirty blocks from the end of the LRU list or flush_list. NOTE 1: in the case of an LRU flush the calling thread may own latches to pages: to avoid deadlocks, this function must be written so that it cannot end up waiting for these latches! NOTE 2: in the case of a flush list flush, the calling thread is not allowed to own any latches on pages! </p><dl class="section return"><dt>Returns</dt><dd>number of blocks for which the write request was queued </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: BUF_FLUSH_LRU or BUF_FLUSH_LIST; if BUF_FLUSH_LIST, then the caller must not own any latches on pages </td></tr>
    <tr><td class="paramname">min_n</td><td>in: wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramname">lsn_limit</td><td>in: in the case of BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a3218423965865bfb20be90854fc67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3218423965865bfb20be90854fc67a">&#9670;&nbsp;</a></span>buf_flush_block_cmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int buf_flush_block_cmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two modified blocks in the buffer pool. The key for comparison is: key = &lt;oldest_modification, space, offset&gt; This comparison is used to maintian ordering of blocks in the buf_pool-&gt;flush_rbt. Note that for the purpose of flush_rbt, we only need to order blocks on the oldest_modification. The other two fields are used to uniquely identify the blocks. </p><dl class="section return"><dt>Returns</dt><dd>&lt; 0 if b2 &lt; b1, 0 if b2 == b1, &gt; 0 if b2 &gt; b1 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>in: block1 </td></tr>
    <tr><td class="paramname">p2</td><td>in: block2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0476cc43c55b63e49f3aefb19f5fb8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0476cc43c55b63e49f3aefb19f5fb8fa">&#9670;&nbsp;</a></span>buf_flush_check_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool buf_flush_check_neighbor </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> the page is in buffer pool and can be flushed. </p><dl class="section return"><dt>Returns</dt><dd>true if the page can be flushed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page offset </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b22126f84f74b44f1c3587a9aaae48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b22126f84f74b44f1c3587a9aaae48c">&#9670;&nbsp;</a></span>buf_flush_common()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_common </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gather the aggregated stats for both flush list and LRU list flushing </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush_type</td><td>in: type of flush </td></tr>
    <tr><td class="paramname">page_count</td><td>in: number of pages flushed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af746dcfb3778cbdec70aef3e821bfb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af746dcfb3778cbdec70aef3e821bfb52">&#9670;&nbsp;</a></span>buf_flush_delete_from_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_delete_from_flush_rbt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete a bpage from the flush_rbt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: bpage to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04f046fa30d716082b81862a574b8643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f046fa30d716082b81862a574b8643">&#9670;&nbsp;</a></span>buf_flush_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End a buffer flush batch for LRU or flush list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e647da62f866e246ae0c827700a1959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e647da62f866e246ae0c827700a1959">&#9670;&nbsp;</a></span>buf_flush_free_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_free_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees up the red-black tree. </p>

</div>
</div>
<a id="aeb49fa7dbba8849c77339ecf1a363ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49fa7dbba8849c77339ecf1a363ac3">&#9670;&nbsp;</a></span>buf_flush_init_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_init_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the red-black tree to speed up insertions into the flush_list during recovery process. Should be called at the start of recovery process before any page has been read/written. </p>

</div>
</div>
<a id="a4460ad4f28ba2c245bda6cc4bfbfbe2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4460ad4f28ba2c245bda6cc4bfbfbe2c">&#9670;&nbsp;</a></span>buf_flush_init_for_writing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_init_for_writing </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>page_zip_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>newest_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a page for writing to the tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in/out: page </td></tr>
    <tr><td class="paramname">page_zip_</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">newest_lsn</td><td>in: newest modification lsn to the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c445e7d4386b79b9e58e6a902f6e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c445e7d4386b79b9e58e6a902f6e1ad">&#9670;&nbsp;</a></span>buf_flush_insert_in_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_flush_insert_in_flush_rbt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a block in the flush_rbt and returns a pointer to its predecessor or NULL if no predecessor. The ordering is maintained on the basis of the &lt;oldest_modification, space, offset&gt; key. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the predecessor or NULL if no predecessor. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: bpage to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bcc0b5c1f2a5b4cf2decf95faf1de1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcc0b5c1f2a5b4cf2decf95faf1de1e">&#9670;&nbsp;</a></span>buf_flush_insert_into_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_insert_into_flush_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a modified block into the flush list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">block</td><td>in/out: block which is modified </td></tr>
    <tr><td class="paramname">lsn</td><td>in: oldest modification </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5e7df9409115663e4c79143ef51a68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e7df9409115663e4c79143ef51a68d">&#9670;&nbsp;</a></span>buf_flush_insert_sorted_into_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_insert_sorted_into_flush_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a modified block into the flush list in the right sorted position. This function is used by recovery, because there the modifications do not necessarily come in the order of lsn's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">block</td><td>in/out: block which is modified </td></tr>
    <tr><td class="paramname">lsn</td><td>in: oldest modification </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeab8f3b149bac79f3101dfd166b05bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeab8f3b149bac79f3101dfd166b05bc">&#9670;&nbsp;</a></span>buf_flush_is_hp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE bool buf_flush_is_hp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given block is a hazard pointer </p><dl class="section return"><dt>Returns</dt><dd>true if bpage is hazard pointer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: buffer control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe9c99474dd78fbb55e8ed2e1dd5cea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9c99474dd78fbb55e8ed2e1dd5cea9">&#9670;&nbsp;</a></span>buf_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_flush_list </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_processed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This utility flushes dirty blocks from the end of the flush list of all buffer pool instances. NOTE: The calling thread is not allowed to own any latches on pages! </p><dl class="section return"><dt>Returns</dt><dd>true if a batch was queued successfully for each buffer pool instance. false if another batch of same type was already running in at least one of the buffer pool instance </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_n</td><td>in: wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramname">lsn_limit</td><td>in the case BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
    <tr><td class="paramname">n_processed</td><td>out: the number of pages which were processed is passed back to caller. Ignored if NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a600bc9e904fce3f32a382b710ef3c07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600bc9e904fce3f32a382b710ef3c07f">&#9670;&nbsp;</a></span>buf_flush_LRU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool buf_flush_LRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_processed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This utility flushes dirty blocks from the end of the LRU list and also puts replaceable clean pages from the end of the LRU list to the free list. NOTE: The calling thread is not allowed to own any latches on pages! </p><dl class="section return"><dt>Returns</dt><dd>true if a batch was queued successfully. false if another batch of same type was already running. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance </td></tr>
    <tr><td class="paramname">min_n</td><td>in: wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramname">n_processed</td><td>out: the number of pages which were processed is passed back to caller. Ignored if NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9aad352583b7bf98ccf0005d736e4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9aad352583b7bf98ccf0005d736e4ad">&#9670;&nbsp;</a></span>buf_flush_LRU_list_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_flush_LRU_list_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This utility flushes dirty blocks from the end of the LRU list. The calling thread is not allowed to own any latches on pages! It attempts to make 'max' blocks available in the free list. Note that it is a best effort attempt and it is not guaranteed that after a call to this function there will be 'max' blocks in the free list. </p><dl class="section return"><dt>Returns</dt><dd>number of blocks for which the write request was queued. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">max</td><td>in: desired number of blocks in the free_list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18c9b352f7400e101a335d34f36f6021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c9b352f7400e101a335d34f36f6021">&#9670;&nbsp;</a></span>buf_flush_LRU_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_flush_LRU_tail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears up tail of the LRU lists: Put replaceable pages at the tail of LRU to the free list Flush dirty pages at the tail of LRU to the disk The depth to which we scan each buffer pool is controlled by dynamic config parameter innodb_LRU_scan_depth. </p><dl class="section return"><dt>Returns</dt><dd>total pages flushed </dd></dl>

</div>
</div>
<a id="ab5914fbbf06f6b008435e61ba0e3dadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5914fbbf06f6b008435e61ba0e3dadc">&#9670;&nbsp;</a></span>buf_flush_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_flush_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a flushable page asynchronously from the buffer pool to a file. NOTE: in simulated aio we must call os_aio_simulated_wake_handler_threads after we have posted a batch of writes! NOTE: buf_pool-&gt;mutex and buf_page_get_mutex(bpage) must be held upon entering this function, and they will be released by this function if it returns true. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the page was flushed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: buffer control block </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: type of flush </td></tr>
    <tr><td class="paramname">sync</td><td>in: true if sync IO request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4950ec60e820b2f86c2afc42b58009ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4950ec60e820b2f86c2afc42b58009ed">&#9670;&nbsp;</a></span>buf_flush_page_and_try_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool buf_flush_page_and_try_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_to_flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if the block is modified and ready for flushing. If the the block is ready to flush then flush the page and try o flush its neighbors.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if buf_pool mutex was released during this function. This does not guarantee that some pages were written as well. Number of pages written are incremented to the count. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer control block, must be buf_page_in_file(bpage) </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
    <tr><td class="paramname">n_to_flush</td><td>in: number of pages to flush </td></tr>
    <tr><td class="paramname">count</td><td>in/out: number of pages flushed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e2b9b37de9e8bb8b1c10945081e3e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2b9b37de9e8bb8b1c10945081e3e59">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>() buf_flush_page_cleaner_thread </td>
          <td>(</td>
          <td class="paramtype">void *arg &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>page_cleaner thread tasked with flushing dirty pages from the buffer pools. As of now we'll have only one instance of this thread. </p><dl class="section return"><dt>Returns</dt><dd>a dummy parameter </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__attribute__</td><td>in: a dummy parameter required by os_thread_create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f6f303f516088aab8dbbe55d00b5c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6f303f516088aab8dbbe55d00b5c74">&#9670;&nbsp;</a></span>buf_flush_ready_for_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_flush_ready_for_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the block is modified and ready for flushing. </p><dl class="section return"><dt>Returns</dt><dd>true if can flush immediately </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer control block, must be buf_page_in_file(bpage) </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: type of flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03ddaefb5098a15d7b40822fc0108dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ddaefb5098a15d7b40822fc0108dc0">&#9670;&nbsp;</a></span>buf_flush_ready_for_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_flush_ready_for_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the file page block is immediately suitable for replacement, i.e., the transition FILE_PAGE =&gt; NOT_USED allowed. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if can replace immediately </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer control block, must be buf_page_in_file(bpage) and in the LRU list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab103ef786b28c99629d79d8f89e768e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab103ef786b28c99629d79d8f89e768e8">&#9670;&nbsp;</a></span>buf_flush_relocate_on_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_relocate_on_flush_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>dpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relocates a buffer control block on the flush_list. Note that it is assumed that the contents of bpage have already been copied to dpage. IMPORTANT: When this function is called bpage and dpage are not exact copies of each other. For example, they both will have different ::state. Also the ::list pointers in dpage may be stale. We need to use the current list node (bpage) to do the list manipulation because the list pointers could have changed between the time that we copied the contents of bpage to the dpage and the flush list manipulation below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block being moved </td></tr>
    <tr><td class="paramname">dpage</td><td>in/out: destination block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c10073f8f2608c74511614b3fb6c63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c10073f8f2608c74511614b3fb6c63d">&#9670;&nbsp;</a></span>buf_flush_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a block from the flush list of modified blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03bdd8286389b526079a8449e0754048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bdd8286389b526079a8449e0754048">&#9670;&nbsp;</a></span>buf_flush_set_hp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_flush_set_hp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets hazard pointer during flush_list iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: buffer control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cdcc4f760f8ebd33c02f0cd042490b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdcc4f760f8ebd33c02f0cd042490b4">&#9670;&nbsp;</a></span>buf_flush_single_page_from_LRU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_flush_single_page_from_LRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function picks up a single dirty page from the tail of the LRU list, flushes it, removes it from page_hash and LRU list and puts it on the free list. It is called from user threads when they are unable to find a replaceable page at the tail of the LRU list i.e.: when the background LRU flushing in the page_cleaner thread is not fast enough to keep pace with the workload. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a123e98bfe5f927a308226cb6d7fc1622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123e98bfe5f927a308226cb6d7fc1622">&#9670;&nbsp;</a></span>buf_flush_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool buf_flush_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a buffer flush batch for LRU or flush list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a587b0855b85f26812b5b5ef7f440266a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587b0855b85f26812b5b5ef7f440266a">&#9670;&nbsp;</a></span>buf_flush_try_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_flush_try_neighbors </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_flushed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_to_flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flushes to disk all flushable pages within the flush area. </p><dl class="section return"><dt>Returns</dt><dd>number of pages flushed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page offset </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
    <tr><td class="paramname">n_flushed</td><td>in: number of pages flushed so far in this batch </td></tr>
    <tr><td class="paramname">n_to_flush</td><td>in: maximum number of pages we are allowed to flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaad85d9f859e6045026bba54e4e014a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad85d9f859e6045026bba54e4e014a8">&#9670;&nbsp;</a></span>buf_flush_update_hp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_flush_update_hp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whenever we move a block in flush_list (either to remove it or to relocate it) we check the hazard pointer set by some other thread doing the flush list scan. If the hazard pointer is the same as the one we are about going to move then we set it to NULL to force a rescan in the thread doing the batch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: buffer control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c09491b9228b827cab2f286adc944f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c09491b9228b827cab2f286adc944f6">&#9670;&nbsp;</a></span>buf_flush_update_zip_checksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_update_zip_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the checksum of a page from compressed table and update the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in/out: Page to update </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: Compressed page size </td></tr>
    <tr><td class="paramname">lsn</td><td>in: Lsn to stamp on the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae775b5ae847bc1c02cb581bf69ce1931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae775b5ae847bc1c02cb581bf69ce1931">&#9670;&nbsp;</a></span>buf_flush_wait_batch_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_wait_batch_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until a flush batch of the given type ends </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">type</td><td>in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a516ba4c6df1e52b8f19586ee715ebda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516ba4c6df1e52b8f19586ee715ebda7">&#9670;&nbsp;</a></span>buf_flush_wait_LRU_batch_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_wait_LRU_batch_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for any possible LRU flushes that are in progress to end. </p>

</div>
</div>
<a id="aa1062d51b94e2b084c044e70f2ae88ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1062d51b94e2b084c044e70f2ae88ef">&#9670;&nbsp;</a></span>buf_flush_write_block_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void buf_flush_write_block_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does an asynchronous write of a buffer page. NOTE: in simulated aio and also when the doublewrite buffer is used, we must call buf_dblwr_flush_buffered_writes after we have posted a batch of writes! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer block to write </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: type of flush </td></tr>
    <tr><td class="paramname">sync</td><td>in: true if sync IO request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb4d812b4926a7d43eaf8dfc386e904d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4d812b4926a7d43eaf8dfc386e904d">&#9670;&nbsp;</a></span>buf_flush_write_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_write_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the flush system data structures when a write is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad00eb217491a10ca7a1811570177bf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00eb217491a10ca7a1811570177bf30">&#9670;&nbsp;</a></span>buf_free_from_unzip_LRU_list_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint buf_free_from_unzip_LRU_list_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This utility moves the uncompressed frames of pages to the free list. Note that this function does not actually flush any data to disk. It just detaches the uncompressed frames from the compressed pages at the tail of the unzip_LRU and puts those freed frames in the free list. Note that it is a best effort attempt and it is not guaranteed that after a call to this function there will be 'max' blocks in the free list. </p><dl class="section return"><dt>Returns</dt><dd>number of blocks moved to the free list. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">max</td><td>in: desired number of blocks in the free_list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a761e7586969f3f27fd95463f47b08223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761e7586969f3f27fd95463f47b08223">&#9670;&nbsp;</a></span>incr_flush_list_size_in_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void incr_flush_list_size_in_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Increases flush_list size in bytes with zip_size for compressed page, UNIV_PAGE_SIZE for uncompressed page in inline function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: control block </td></tr>
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a691a6fafee1b7cb8e7fe2feb05656d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691a6fafee1b7cb8e7fe2feb05656d92">&#9670;&nbsp;</a></span>page_cleaner_do_flush_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint page_cleaner_do_flush_batch </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_to_flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush a batch of dirty pages from the flush list </p><dl class="section return"><dt>Returns</dt><dd>number of pages flushed, 0 if no page is flushed or if another flush_list type batch is running </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_to_flush</td><td>in: number of pages that we should attempt to flush. </td></tr>
    <tr><td class="paramname">lsn_limit</td><td>in: LSN up to which flushing must happen </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02dbaebafe42c35476b3274ae99105ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dbaebafe42c35476b3274ae99105ee">&#9670;&nbsp;</a></span>page_cleaner_flush_pages_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint page_cleaner_flush_pages_if_needed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called approximately once every second by the page_cleaner thread. Based on various factors it decides if there is a need to do flushing. If flushing is needed it is performed and the number of pages flushed is returned. </p><dl class="section return"><dt>Returns</dt><dd>number of pages flushed </dd></dl>

</div>
</div>
<a id="a168e06a8a44d2f706a16560b73beefa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168e06a8a44d2f706a16560b73beefa7">&#9670;&nbsp;</a></span>page_cleaner_sleep_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void page_cleaner_sleep_if_needed </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>next_loop_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts the page_cleaner thread to sleep if it has finished work in less than a second </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_loop_time</td><td>in: time when next loop iteration should start </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3202981d62523b59648d39f0226eecea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3202981d62523b59648d39f0226eecea">&#9670;&nbsp;</a></span>buf_lru_flush_page_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_lru_flush_page_count = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of pages flushed through non flush_list flushes. </p>

</div>
</div>
<a id="a3b56e2842d48c564df5658af451790d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b56e2842d48c564df5658af451790d3">&#9670;&nbsp;</a></span>buf_page_cleaner_is_active</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool buf_page_cleaner_is_active = FALSE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicating if the page_cleaner is in active state. This flag is set to TRUE by the page_cleaner thread when it is spawned and is set back to FALSE at shutdown by the page_cleaner as well. Therefore no need to protect it by a mutex. It is only ever read by the thread doing the shutdown </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

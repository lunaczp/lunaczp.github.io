<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/sync0arr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sync0arr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0lst_8h_source.html">ut0lst.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0thread_8h_source.html">os0thread.h</a>&quot;</code><br />
<code>#include &quot;sync0arr.ic&quot;</code><br />
</div>
<p><a href="sync0arr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5acc8b6beae27cf5ee09409e2c1f9b4"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#ae5acc8b6beae27cf5ee09409e2c1f9b4">sync_array_get_and_reserve_cell</a> (void *object, ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, ulint *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:ae5acc8b6beae27cf5ee09409e2c1f9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7905f8df293f122783bfd1071067d50"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#ae7905f8df293f122783bfd1071067d50">sync_array_reserve_cell</a> (<a class="el" href="structsync__array__t.html">sync_array_t</a> *arr, void *object, ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, ulint *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:ae7905f8df293f122783bfd1071067d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdf80f2a3f4036670fe332c38711030"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a3fdf80f2a3f4036670fe332c38711030">sync_array_wait_event</a> (<a class="el" href="structsync__array__t.html">sync_array_t</a> *arr, ulint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a3fdf80f2a3f4036670fe332c38711030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74072ff39e7d9d49fcd56b5d7cfe716e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a74072ff39e7d9d49fcd56b5d7cfe716e">sync_array_free_cell</a> (<a class="el" href="structsync__array__t.html">sync_array_t</a> *arr, ulint <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a74072ff39e7d9d49fcd56b5d7cfe716e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136a5980f17a2bcc44f264115e572247"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a136a5980f17a2bcc44f264115e572247">sync_array_object_signalled</a> (void)</td></tr>
<tr class="separator:a136a5980f17a2bcc44f264115e572247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c59555400d611b0e377942612a10d0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a63c59555400d611b0e377942612a10d0">sync_arr_wake_threads_if_sema_free</a> (void)</td></tr>
<tr class="separator:a63c59555400d611b0e377942612a10d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a518e5aa5edfd308cfc760603de7e43"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a5a518e5aa5edfd308cfc760603de7e43">sync_array_print_long_waits</a> (<a class="el" href="os0thread_8h.html#a0e87ca653f4358a387e610ee5c542f74">os_thread_id_t</a> *waiter, const void **sema) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a5a518e5aa5edfd308cfc760603de7e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8c4d56bd2c8f4403a782c8ee5dfd71"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a5d8c4d56bd2c8f4403a782c8ee5dfd71">sync_array_validate</a> (<a class="el" href="structsync__array__t.html">sync_array_t</a> *arr)</td></tr>
<tr class="separator:a5d8c4d56bd2c8f4403a782c8ee5dfd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdb84e90e504ac199cc908a94f96962"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#aebdb84e90e504ac199cc908a94f96962">sync_array_print</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:aebdb84e90e504ac199cc908a94f96962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f1d0d6da6b67f04bb4c8b687c52911"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#ae2f1d0d6da6b67f04bb4c8b687c52911">sync_array_init</a> (ulint n_threads)</td></tr>
<tr class="separator:ae2f1d0d6da6b67f04bb4c8b687c52911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fb04100e042c963a6637695a8bb329"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#ad1fb04100e042c963a6637695a8bb329">sync_array_close</a> (void)</td></tr>
<tr class="separator:ad1fb04100e042c963a6637695a8bb329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818e0a7d2272a2bc4b529450359d9274"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a818e0a7d2272a2bc4b529450359d9274">sync_array_get</a> (void)</td></tr>
<tr class="separator:a818e0a7d2272a2bc4b529450359d9274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The wait array used in synchronization primitives</p>
<p>Created 9/5/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a63c59555400d611b0e377942612a10d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c59555400d611b0e377942612a10d0">&#9670;&nbsp;</a></span>sync_arr_wake_threads_if_sema_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_arr_wake_threads_if_sema_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the wakeup algorithm does not work perfectly at semaphore relases, this function will do the waking (see the comment in mutex_exit). This function should be called about every 1 second in the server.</p>
<p>If the wakeup algorithm does not work perfectly at semaphore relases, this function will do the waking (see the comment in mutex_exit). This function should be called about every 1 second in the server.</p>
<p>Note that there's a race condition between this thread and mutex_exit changing the lock_word and calling signal_object, so sometimes this finds threads to wake up even when nothing has gone wrong. </p>

</div>
</div>
<a id="ad1fb04100e042c963a6637695a8bb329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fb04100e042c963a6637695a8bb329">&#9670;&nbsp;</a></span>sync_array_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close sync array wait sub-system. </p>

</div>
</div>
<a id="a74072ff39e7d9d49fcd56b5d7cfe716e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74072ff39e7d9d49fcd56b5d7cfe716e">&#9670;&nbsp;</a></span>sync_array_free_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_free_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the cell. NOTE! sync_array_wait_event frees the cell automatically! in: index of the cell in array</p>
<p>Frees the cell. NOTE! sync_array_wait_event frees the cell automatically! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: wait array </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the cell in array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a818e0a7d2272a2bc4b529450359d9274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818e0a7d2272a2bc4b529450359d9274">&#9670;&nbsp;</a></span>sync_array_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structsync__array__t.html">sync_array_t</a>* sync_array_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an instance of the sync wait array. </p>

</div>
</div>
<a id="ae5acc8b6beae27cf5ee09409e2c1f9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5acc8b6beae27cf5ee09409e2c1f9b4">&#9670;&nbsp;</a></span>sync_array_get_and_reserve_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structsync__array__t.html">sync_array_t</a>* sync_array_get_and_reserve_cell </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an instance of the sync wait array and reserve a wait array cell in the instance for waiting for an object. The event of the cell is reset to nonsignalled state. If reserving cell of the instance fails, try to get another new instance until we can reserve an empty cell of it. </p><dl class="section return"><dt>Returns</dt><dd>the instance found, never NULL. out: index of the reserved cell </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>in: pointer to the object to wait for </td></tr>
    <tr><td class="paramname">type</td><td>in: lock request type </td></tr>
    <tr><td class="paramname">file</td><td>in: file where requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2f1d0d6da6b67f04bb4c8b687c52911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f1d0d6da6b67f04bb4c8b687c52911">&#9670;&nbsp;</a></span>sync_array_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the primary system wait array(s), they are protected by an OS mutex in: Number of slots to create</p>
<p>Create the primary system wait array(s), they are protected by an OS mutex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_threads</td><td>in: Number of slots to create in all arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a136a5980f17a2bcc44f264115e572247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136a5980f17a2bcc44f264115e572247">&#9670;&nbsp;</a></span>sync_array_object_signalled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_object_signalled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that one of the wait objects was signalled.</p>
<p>Increments the signalled count. </p>

</div>
</div>
<a id="aebdb84e90e504ac199cc908a94f96962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdb84e90e504ac199cc908a94f96962">&#9670;&nbsp;</a></span>sync_array_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of the wait array. in: file where to print</p>
<p>Print info about the sync array(s). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in/out: Print to this stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a518e5aa5edfd308cfc760603de7e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a518e5aa5edfd308cfc760603de7e43">&#9670;&nbsp;</a></span>sync_array_print_long_waits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool sync_array_print_long_waits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0thread_8h.html#a0e87ca653f4358a387e610ee5c542f74">os_thread_id_t</a> *&#160;</td>
          <td class="paramname"><em>waiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>sema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints warnings of long semaphore waits to stderr. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if fatal semaphore wait threshold was exceeded </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waiter</td><td>out: longest waiting thread </td></tr>
    <tr><td class="paramname">sema</td><td>out: longest-waited-for semaphore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7905f8df293f122783bfd1071067d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7905f8df293f122783bfd1071067d50">&#9670;&nbsp;</a></span>sync_array_reserve_cell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool sync_array_reserve_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves a wait array cell for waiting for an object. The event of the cell is reset to nonsignalled state. </p><dl class="section return"><dt>Returns</dt><dd>true if free cell is found, otherwise false out: index of the reserved cell</dd></dl>
<p>Reserves a wait array cell for waiting for an object. The event of the cell is reset to nonsignalled state. </p><dl class="section return"><dt>Returns</dt><dd>true if free cell is found, otherwise false </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: wait array </td></tr>
    <tr><td class="paramname">object</td><td>in: pointer to the object to wait for </td></tr>
    <tr><td class="paramname">type</td><td>in: lock request type </td></tr>
    <tr><td class="paramname">file</td><td>in: file where requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
    <tr><td class="paramname">index</td><td>out: index of the reserved cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d8c4d56bd2c8f4403a782c8ee5dfd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8c4d56bd2c8f4403a782c8ee5dfd71">&#9670;&nbsp;</a></span>sync_array_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validates the integrity of the wait array. Checks that the number of reserved cells equals the count variable. in: sync wait array</p>
<p>Validates the integrity of the wait array. Checks that the number of reserved cells equals the count variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: sync wait array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fdf80f2a3f4036670fe332c38711030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdf80f2a3f4036670fe332c38711030">&#9670;&nbsp;</a></span>sync_array_wait_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_wait_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsync__array__t.html">sync_array_t</a> *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called when a thread starts to wait on a wait array cell. In the debug version this function checks if the wait for a semaphore will result in a deadlock, in which case prints info and asserts. in: index of the reserved cell</p>
<p>This function should be called when a thread starts to wait on a wait array cell. In the debug version this function checks if the wait for a semaphore will result in a deadlock, in which case prints info and asserts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: wait array </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the reserved cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

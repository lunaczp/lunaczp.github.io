<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/btr/btr0btr.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_f48f5f24c3af6e5b48618127168756b9.html">btr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">btr0btr.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0fsp_8h_source.html">fsp0fsp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0pcur_8h_source.html">btr0pcur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9a7b333362dba21f0eb6daa9f099c65b"><td class="memItemLeft" align="right" valign="top"><a id="a9a7b333362dba21f0eb6daa9f099c65b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_page_get_father_node_ptr</b>(<a class="el" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a>,  <a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>,  cur,  <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)&#160;&#160;&#160;<a class="el" href="btr0btr_8cc.html#a5f9daab73d0306cbe1d8f2183e9aae58">btr_page_get_father_node_ptr_func</a>(<a class="el" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a>,<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>,cur,__FILE__,__LINE__,<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a9a7b333362dba21f0eb6daa9f099c65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2865000f79089bccbda40535ef15bc38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a2865000f79089bccbda40535ef15bc38">btr_level_list_remove</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>,  <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>,  <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>,  <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>,  <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)&#160;&#160;&#160;btr_level_list_remove_func(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>,<a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>,<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>,<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a2865000f79089bccbda40535ef15bc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a894aad4643bf9d728e194114a2c77239"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a894aad4643bf9d728e194114a2c77239">btr_can_merge_with_page</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> **merge_block, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a894aad4643bf9d728e194114a2c77239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f185f40a07920eea90f7714930df9ca"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a9f185f40a07920eea90f7714930df9ca">btr_corruption_report</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a9f185f40a07920eea90f7714930df9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d685895d1a72e610771de073d9eafb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a83d685895d1a72e610771de073d9eafb">btr_root_block_get</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a83d685895d1a72e610771de073d9eafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c494c567bdb707b7ebbf8cf9df05c7e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a6c494c567bdb707b7ebbf8cf9df05c7e">btr_root_get</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a6c494c567bdb707b7ebbf8cf9df05c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5364cac4d748f037336fa19a2254db54"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a5364cac4d748f037336fa19a2254db54">btr_height_get</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a5364cac4d748f037336fa19a2254db54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4cb219b48a0d3d5b04434d2812a8cf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#acc4cb219b48a0d3d5b04434d2812a8cf">btr_root_fseg_adjust_on_import</a> (fseg_header_t *seg_header, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:acc4cb219b48a0d3d5b04434d2812a8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282e89ac4c93e3b5d70c91b42a06107e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a282e89ac4c93e3b5d70c91b42a06107e">btr_root_adjust_on_import</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a282e89ac4c93e3b5d70c91b42a06107e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b90050c7ccf706da44bb338c1ba45ac"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a3b90050c7ccf706da44bb338c1ba45ac">btr_get_prev_user_rec</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a3b90050c7ccf706da44bb338c1ba45ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84e12c9c61d0b08711c54d0ec88d9f9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ad84e12c9c61d0b08711c54d0ec88d9f9">btr_get_next_user_rec</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ad84e12c9c61d0b08711c54d0ec88d9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac343a47dc3170cd3f0763d9e11c4aeef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ac343a47dc3170cd3f0763d9e11c4aeef">btr_page_create</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac343a47dc3170cd3f0763d9e11c4aeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95bf5ca68b072c40ed669b891d6fbdc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ac95bf5ca68b072c40ed669b891d6fbdc">btr_page_alloc_for_ibuf</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac95bf5ca68b072c40ed669b891d6fbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200d93775a70f0983bfdd215a32904e"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a5200d93775a70f0983bfdd215a32904e">__attribute__</a> ((nonnull, warn_unused_result)) <a class="el" href="structbuf__block__t.html">buf_block_t</a> *btr_page_alloc_low(<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a></td></tr>
<tr class="separator:a5200d93775a70f0983bfdd215a32904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269043aa1c9471d638f6cf8821f1c921"><td class="memItemLeft" align="right" valign="top"><a id="a269043aa1c9471d638f6cf8821f1c921"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>==0)</td></tr>
<tr class="separator:a269043aa1c9471d638f6cf8821f1c921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e7e7d47fa2e9d35e91d5afabd330eb"><td class="memItemLeft" align="right" valign="top"><a id="af9e7e7d47fa2e9d35e91d5afabd330eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (<a class="el" href="fsp0fsp_8h.html#a6a28341c3502464680f825a63b38ce8d">fseg_alloc_free_page_general</a>(seg_header, <a class="el" href="btr0btr_8cc.html#aae8fdbe2be22423ddb9e9c7a4c883235">hint_page_no</a>, <a class="el" href="btr0btr_8cc.html#a2f8482ebd865881c442d965edb9b295c">file_direction</a>, TRUE, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="fsp0fsp_8cc.html#affc0fcb1d10ea38c48239ca6a9772e0b">init_mtr</a>))</td></tr>
<tr class="separator:af9e7e7d47fa2e9d35e91d5afabd330eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0d443a56e3da6eaa2bdf000e9660d5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#acb0d443a56e3da6eaa2bdf000e9660d5">btr_page_alloc</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="btr0btr_8cc.html#aae8fdbe2be22423ddb9e9c7a4c883235">hint_page_no</a>, byte <a class="el" href="btr0btr_8cc.html#a2f8482ebd865881c442d965edb9b295c">file_direction</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="fsp0fsp_8cc.html#affc0fcb1d10ea38c48239ca6a9772e0b">init_mtr</a>)</td></tr>
<tr class="separator:acb0d443a56e3da6eaa2bdf000e9660d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62be4d9908b18272d859e71633eac5ce"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a62be4d9908b18272d859e71633eac5ce">btr_get_size</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint flag, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a62be4d9908b18272d859e71633eac5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77f1439ec7f9cb150e381f265b17cbc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aa77f1439ec7f9cb150e381f265b17cbc">btr_page_free_for_ibuf</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:aa77f1439ec7f9cb150e381f265b17cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63067890d65886795a2491f548b66169"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a63067890d65886795a2491f548b66169">btr_page_free_low</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a63067890d65886795a2491f548b66169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c2fdd9520ff2c1632592908aa6f2b8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a39c2fdd9520ff2c1632592908aa6f2b8">btr_page_free</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a39c2fdd9520ff2c1632592908aa6f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893f5b6a6db4df7afa8428df94442665"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a893f5b6a6db4df7afa8428df94442665">btr_node_ptr_set_child_page_no</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a893f5b6a6db4df7afa8428df94442665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2d39f03c3962f42af99952bd3ece11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a6b2d39f03c3962f42af99952bd3ece11">btr_node_ptr_get_child</a> (const rec_t *node_ptr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a6b2d39f03c3962f42af99952bd3ece11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9daab73d0306cbe1d8f2183e9aae58"><td class="memItemLeft" align="right" valign="top">static ulint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a5f9daab73d0306cbe1d8f2183e9aae58">btr_page_get_father_node_ptr_func</a> (ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a5f9daab73d0306cbe1d8f2183e9aae58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3932d4dbf34d80e117f38e776c5fce"><td class="memItemLeft" align="right" valign="top">static ulint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aff3932d4dbf34d80e117f38e776c5fce">btr_page_get_father_block</a> (ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:aff3932d4dbf34d80e117f38e776c5fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc7ce1bf5f89f0be26a4fb11d989bde"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#adcc7ce1bf5f89f0be26a4fb11d989bde">btr_page_get_father</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:adcc7ce1bf5f89f0be26a4fb11d989bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5ddd8401b16737bf162569732a2fa0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a4c5ddd8401b16737bf162569732a2fa0">btr_create</a> (ulint <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, index_id_t index_id, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a4c5ddd8401b16737bf162569732a2fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4c8428fac9c89af405a42eb209df6c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a4e4c8428fac9c89af405a42eb209df6c">btr_free_but_not_root</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint root_page_no)</td></tr>
<tr class="separator:a4e4c8428fac9c89af405a42eb209df6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f13ed1346f86b3160976ac8d2393da9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a3f13ed1346f86b3160976ac8d2393da9">btr_free_root</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint root_page_no, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a3f13ed1346f86b3160976ac8d2393da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd631122af1656cebce364f29bf470d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#afcd631122af1656cebce364f29bf470d">btr_page_reorganize_low</a> (bool recovery, ulint <a class="el" href="btr0btr_8cc.html#aa1d2140102d7a14490014d15e140df50">z_level</a>, <a class="el" href="structpage__cur__t.html">page_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:afcd631122af1656cebce364f29bf470d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c564511cdc50ac07ba5601d7cc0dea0"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a5c564511cdc50ac07ba5601d7cc0dea0">__attribute__</a> ((nonnull)) bool btr_page_reorganize_block(bool recovery</td></tr>
<tr class="separator:a5c564511cdc50ac07ba5601d7cc0dea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9060a3f0e3fbb84efdac339d58ee77"><td class="memItemLeft" align="right" valign="top"><a id="add9060a3f0e3fbb84efdac339d58ee77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>page_cur_set_before_first</b> (<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, &amp;cur)</td></tr>
<tr class="separator:add9060a3f0e3fbb84efdac339d58ee77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881767d50cebd9d0bd3fc5c15c6cab36"><td class="memItemLeft" align="right" valign="top"><a id="a881767d50cebd9d0bd3fc5c15c6cab36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (<a class="el" href="btr0btr_8h.html#a570df48e4c85314a92f9bb8b59f429f9">btr_page_reorganize_low</a>(recovery, <a class="el" href="btr0btr_8cc.html#aa1d2140102d7a14490014d15e140df50">z_level</a>, &amp;cur, <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>))</td></tr>
<tr class="separator:a881767d50cebd9d0bd3fc5c15c6cab36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7153cd6fec3c5a1fdfc6b85c1beefe5a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a7153cd6fec3c5a1fdfc6b85c1beefe5a">btr_page_reorganize</a> (<a class="el" href="structpage__cur__t.html">page_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a7153cd6fec3c5a1fdfc6b85c1beefe5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3408aa71c70e485d6f88362c72cfa71c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a3408aa71c70e485d6f88362c72cfa71c">btr_parse_page_reorganize</a> (byte *ptr, byte *end_ptr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, bool compressed, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a3408aa71c70e485d6f88362c72cfa71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356a2e070bba36d2e557fa7e1761a8ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a356a2e070bba36d2e557fa7e1761a8ab">btr_page_empty</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a356a2e070bba36d2e557fa7e1761a8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261c8181927751db813afa6b3905cff6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a261c8181927751db813afa6b3905cff6">btr_root_raise_and_insert</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, ulint <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a261c8181927751db813afa6b3905cff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49cde3a6c5898da0d7ac2675d3d7afa"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ad49cde3a6c5898da0d7ac2675d3d7afa">btr_page_get_split_rec_to_left</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, rec_t **<a class="el" href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a>)</td></tr>
<tr class="separator:ad49cde3a6c5898da0d7ac2675d3d7afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508c364c292de30a05105504f78f8f96"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a508c364c292de30a05105504f78f8f96">btr_page_get_split_rec_to_right</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, rec_t **<a class="el" href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a>)</td></tr>
<tr class="separator:a508c364c292de30a05105504f78f8f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5e732e0453c9d91d4f4b86559c5328"><td class="memItemLeft" align="right" valign="top">static rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a6b5e732e0453c9d91d4f4b86559c5328">btr_page_get_split_rec</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, ulint <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>)</td></tr>
<tr class="separator:a6b5e732e0453c9d91d4f4b86559c5328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47555ee5871726e53ad137654ed768c6"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a47555ee5871726e53ad137654ed768c6">__attribute__</a> ((nonnull(1, 3, 4, 6), warn_unused_result)) bool btr_page_insert_fits(<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a></td></tr>
<tr class="separator:a47555ee5871726e53ad137654ed768c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3d91ef6d765e2edaba9a3c396d719b"><td class="memItemLeft" align="right" valign="top"><a id="aae3d91ef6d765e2edaba9a3c396d719b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (!<a class="el" href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a>||!<a class="el" href="page0page_8h.html#a84498b8178988dbaccd7a9020ba1f590">page_is_comp</a>(<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)==!<a class="el" href="rem0rec_8h.html#af609184990480cb158dcf299e87462ee">rec_offs_comp</a>(*<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>))</td></tr>
<tr class="separator:aae3d91ef6d765e2edaba9a3c396d719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaa60f8fe6f87c2064114cd0c0c65b0"><td class="memItemLeft" align="right" valign="top"><a id="aaeaa60f8fe6f87c2064114cd0c0c65b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (!<a class="el" href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a>||rec_offs_validate(<a class="el" href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a>, <a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>-&gt;<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>))</td></tr>
<tr class="separator:aaeaa60f8fe6f87c2064114cd0c0c65b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac583aa4f2b8529af3fb83796609e6b6b"><td class="memItemLeft" align="right" valign="top"><a id="ac583aa4f2b8529af3fb83796609e6b6b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a>==NULL)</td></tr>
<tr class="separator:ac583aa4f2b8529af3fb83796609e6b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3225745be445553b144dd9913641d3c"><td class="memItemLeft" align="right" valign="top"><a id="aa3225745be445553b144dd9913641d3c"></a>
<a class="el" href="fsp0fsp_8cc.html#a0544c3fe466e421738dae463968b70ba">else</a>&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="rem0cmp_8cc.html#abb1f4cb7795cc69202a686c7df3e0899">cmp_dtuple_rec</a>(<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, <a class="el" href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a>, *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>) &gt;=0)</td></tr>
<tr class="separator:aa3225745be445553b144dd9913641d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872e44515aa0100af7fc16a03a031e00"><td class="memItemLeft" align="right" valign="top"><a id="a872e44515aa0100af7fc16a03a031e00"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (total_data+<a class="el" href="page0page_8h.html#a1fcd7af7e44c42c31538db96e3b24852">page_dir_calc_reserved_space</a>(total_n_recs)&lt;=free_space)</td></tr>
<tr class="separator:a872e44515aa0100af7fc16a03a031e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f114376b22291e89e08a4a7ba48f0a"><td class="memItemLeft" align="right" valign="top"><a id="a88f114376b22291e89e08a4a7ba48f0a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>while</b> (<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a> !=end_rec)</td></tr>
<tr class="separator:a88f114376b22291e89e08a4a7ba48f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf965a2fe6fb842e12c0d6398601aad"><td class="memItemLeft" align="right" valign="top"><a id="a2cf965a2fe6fb842e12c0d6398601aad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (false)</td></tr>
<tr class="separator:a2cf965a2fe6fb842e12c0d6398601aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cd9d9b058c865f26ac228105c6b13e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a99cd9d9b058c865f26ac228105c6b13e">btr_insert_on_non_leaf_level_func</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a99cd9d9b058c865f26ac228105c6b13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453d68eafde6bd45003e2ff138ec3d4d"><td class="memItemLeft" align="right" valign="top"><a id="a453d68eafde6bd45003e2ff138ec3d4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (mtr_memo_contains(<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, MTR_MEMO_PAGE_X_FIX))</td></tr>
<tr class="separator:a453d68eafde6bd45003e2ff138ec3d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd9e0a827757b4cbf593fc350460ea1"><td class="memItemLeft" align="right" valign="top"><a id="a3fd9e0a827757b4cbf593fc350460ea1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (mtr_memo_contains(<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>, MTR_MEMO_PAGE_X_FIX))</td></tr>
<tr class="separator:a3fd9e0a827757b4cbf593fc350460ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cde27109aa6f44e73c9c3afb46287c1"><td class="memItemLeft" align="right" valign="top"><a id="a5cde27109aa6f44e73c9c3afb46287c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="btr0btr_8cc.html#a942da44c6711d230377078633665e89b">direction</a>==FSP_DOWN)</td></tr>
<tr class="separator:a5cde27109aa6f44e73c9c3afb46287c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc55611b36fc4b921cd8d642e8b27ee8"><td class="memItemLeft" align="right" valign="top"><a id="abc55611b36fc4b921cd8d642e8b27ee8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>==btr_page_get_level(buf_block_get_frame(<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>), <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>))</td></tr>
<tr class="separator:abc55611b36fc4b921cd8d642e8b27ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0feccbd5eaa27edf4a5b4ab5a97a55"><td class="memItemLeft" align="right" valign="top"><a id="a3c0feccbd5eaa27edf4a5b4ab5a97a55"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>btr_insert_on_non_leaf_level</b> (<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>+1, node_ptr_upper, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a3c0feccbd5eaa27edf4a5b4ab5a97a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a31a8babbb6dc93262e47aff362638"><td class="memItemLeft" align="right" valign="top"><a id="a84a31a8babbb6dc93262e47aff362638"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mem_heap_free</b> (<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a84a31a8babbb6dc93262e47aff362638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd6fd0ffbc9d6a98be3930cc2039ef4"><td class="memItemLeft" align="right" valign="top"><a id="aacd6fd0ffbc9d6a98be3930cc2039ef4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (prev_page_no !=<a class="el" href="fil0fil_8h.html#aa3cefe750718b6961ad77a77b24de271">FIL_NULL</a>)</td></tr>
<tr class="separator:aacd6fd0ffbc9d6a98be3930cc2039ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b10788fccbb7459fd4d7893b054cb6"><td class="memItemLeft" align="right" valign="top"><a id="a85b10788fccbb7459fd4d7893b054cb6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (next_page_no !=<a class="el" href="fil0fil_8h.html#aa3cefe750718b6961ad77a77b24de271">FIL_NULL</a>)</td></tr>
<tr class="separator:a85b10788fccbb7459fd4d7893b054cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97cf48c43067d7fc522dbf039e9f281"><td class="memItemLeft" align="right" valign="top"><a id="ae97cf48c43067d7fc522dbf039e9f281"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>btr_page_set_prev</b> (lower_page, lower_page_zip, prev_page_no, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ae97cf48c43067d7fc522dbf039e9f281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac888da824f3d8dd11e2b19fb3a7fa334"><td class="memItemLeft" align="right" valign="top"><a id="ac888da824f3d8dd11e2b19fb3a7fa334"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>btr_page_set_next</b> (lower_page, lower_page_zip, upper_page_no, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac888da824f3d8dd11e2b19fb3a7fa334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52f5378ac0ed339ab0efffee6c31c06"><td class="memItemLeft" align="right" valign="top"><a id="ac52f5378ac0ed339ab0efffee6c31c06"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>btr_page_set_prev</b> (upper_page, upper_page_zip, lower_page_no, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac52f5378ac0ed339ab0efffee6c31c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0925e4c20490d8dd9147591634117c"><td class="memItemLeft" align="right" valign="top"><a id="a1c0925e4c20490d8dd9147591634117c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>btr_page_set_next</b> (upper_page, upper_page_zip, next_page_no, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a1c0925e4c20490d8dd9147591634117c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77846f6a3a119f9a7031014c9a4a3e79"><td class="memItemLeft" align="right" valign="top"><a id="a77846f6a3a119f9a7031014c9a4a3e79"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (<a class="el" href="rem0cmp_8cc.html#abb1f4cb7795cc69202a686c7df3e0899">cmp_dtuple_rec</a>(<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, first_rec, *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)&lt; 0)</td></tr>
<tr class="separator:a77846f6a3a119f9a7031014c9a4a3e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b94970d7282a8eafdf74348eec6b5b8"><td class="memItemLeft" align="right" valign="top">static rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a2b94970d7282a8eafdf74348eec6b5b8">btr_insert_into_right_sibling</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, ulint <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a2b94970d7282a8eafdf74348eec6b5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff38b00f99e80cb45a2253d4d5110c7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a5ff38b00f99e80cb45a2253d4d5110c7">btr_page_split_and_insert</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, ulint <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a5ff38b00f99e80cb45a2253d4d5110c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e54d2045697fe3e25d26e7bb73b220b"><td class="memItemLeft" align="right" valign="top"><a id="a1e54d2045697fe3e25d26e7bb73b220b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a> &amp;&amp;<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a1e54d2045697fe3e25d26e7bb73b220b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744210a66f19e4904fe8c96e77ca2db7"><td class="memItemLeft" align="right" valign="top"><a id="a744210a66f19e4904fe8c96e77ca2db7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (mtr_memo_contains_page(<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, MTR_MEMO_PAGE_X_FIX))</td></tr>
<tr class="separator:a744210a66f19e4904fe8c96e77ca2db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d87a4e211ef37da45c6ab323648d5a"><td class="memItemLeft" align="right" valign="top"><a id="a22d87a4e211ef37da45c6ab323648d5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>==<a class="el" href="page0page_8h.html#a4fc7ac2b94334e5c8aabf88a7717942a">page_get_space_id</a>(<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>))</td></tr>
<tr class="separator:a22d87a4e211ef37da45c6ab323648d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5050f7245a104bf110795d83da25efae"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a5050f7245a104bf110795d83da25efae">btr_set_min_rec_mark_log</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, byte <a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a5050f7245a104bf110795d83da25efae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831a556c36344bd516020b96604c447c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a831a556c36344bd516020b96604c447c">btr_parse_set_min_rec_mark</a> (byte *ptr, byte *end_ptr, ulint comp, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a831a556c36344bd516020b96604c447c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8369a4154e86f52ef9074c63797087"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a1f8369a4154e86f52ef9074c63797087">btr_set_min_rec_mark</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a1f8369a4154e86f52ef9074c63797087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ce48814c28472b2b35217a5ef0d334"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ad4ce48814c28472b2b35217a5ef0d334">btr_node_ptr_delete</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ad4ce48814c28472b2b35217a5ef0d334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24f869553390e4ae34621c1fc1f930b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ab24f869553390e4ae34621c1fc1f930b">btr_lift_page_up</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ab24f869553390e4ae34621c1fc1f930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a110568255fcb9271b5f675cff435f6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a1a110568255fcb9271b5f675cff435f6">btr_compress</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ibool adjust, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a1a110568255fcb9271b5f675cff435f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b0935bbe094292342ae9351919101e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aa0b0935bbe094292342ae9351919101e">btr_discard_only_page_on_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:aa0b0935bbe094292342ae9351919101e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ff7faeb9305d7f5a12feaccc8fe91c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ac1ff7faeb9305d7f5a12feaccc8fe91c">btr_discard_page</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac1ff7faeb9305d7f5a12feaccc8fe91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c70adcf6bbce7b319642aa3a3955519"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a3c70adcf6bbce7b319642aa3a3955519">btr_index_rec_validate_report</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a3c70adcf6bbce7b319642aa3a3955519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7a43ae80740e4976cc951543bc586b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a1e7a43ae80740e4976cc951543bc586b">btr_index_rec_validate</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ibool dump_on_error)</td></tr>
<tr class="separator:a1e7a43ae80740e4976cc951543bc586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce16f83edead92058fc37477d742c58"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a9ce16f83edead92058fc37477d742c58">btr_index_page_validate</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a9ce16f83edead92058fc37477d742c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcc2e5603db7d844425d09e00b91299"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#afbcc2e5603db7d844425d09e00b91299">btr_validate_report1</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:afbcc2e5603db7d844425d09e00b91299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201f40a474ab44ea3f6cc69885424dd2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a201f40a474ab44ea3f6cc69885424dd2">btr_validate_report2</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block1, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block2)</td></tr>
<tr class="separator:a201f40a474ab44ea3f6cc69885424dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83532ad9fe9612994b9f59d13ea06725"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a83532ad9fe9612994b9f59d13ea06725">btr_validate_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>)</td></tr>
<tr class="separator:a83532ad9fe9612994b9f59d13ea06725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2f5758b8fa81304438a8e86e1a75cc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a6b2f5758b8fa81304438a8e86e1a75cc">btr_validate_index</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a6b2f5758b8fa81304438a8e86e1a75cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aae8fdbe2be22423ddb9e9c7a4c883235"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aae8fdbe2be22423ddb9e9c7a4c883235">hint_page_no</a></td></tr>
<tr class="separator:aae8fdbe2be22423ddb9e9c7a4c883235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8482ebd865881c442d965edb9b295c"><td class="memItemLeft" align="right" valign="top">static ulint byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a2f8482ebd865881c442d965edb9b295c">file_direction</a></td></tr>
<tr class="separator:a2f8482ebd865881c442d965edb9b295c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e504d299fb7ca943fc98a74051f564"><td class="memItemLeft" align="right" valign="top">static ulint byte ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a> = btr_page_get_level(buf_block_get_frame(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>), <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a46e504d299fb7ca943fc98a74051f564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6778664613b89d4ea4dad4c5c218cd2"><td class="memItemLeft" align="right" valign="top">static ulint byte ulint <a class="el" href="structmtr__t.html">mtr_t</a> <a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#af6778664613b89d4ea4dad4c5c218cd2">init_mtr</a></td></tr>
<tr class="separator:af6778664613b89d4ea4dad4c5c218cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544c3fe466e421738dae463968b70ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>else</b></td></tr>
<tr class="separator:a0544c3fe466e421738dae463968b70ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d2140102d7a14490014d15e140df50"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aa1d2140102d7a14490014d15e140df50">z_level</a></td></tr>
<tr class="separator:aa1d2140102d7a14490014d15e140df50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02317286bfc7e3e5ac383506672e0773"><td class="memItemLeft" align="right" valign="top">static const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a></td></tr>
<tr class="separator:a02317286bfc7e3e5ac383506672e0773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68c273b782e74edd9ed68413223786e"><td class="memItemLeft" align="right" valign="top">static const rec_t ulint const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ae68c273b782e74edd9ed68413223786e">tuple</a></td></tr>
<tr class="separator:ae68c273b782e74edd9ed68413223786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0578735b43fba351dae8147e19e0ac"><td class="memItemLeft" align="right" valign="top">static const rec_t ulint const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a2a0578735b43fba351dae8147e19e0ac">n_ext</a></td></tr>
<tr class="separator:a2a0578735b43fba351dae8147e19e0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8525af1c2186bee6dc1f118c859dd2fd"><td class="memItemLeft" align="right" valign="top"><a id="a8525af1c2186bee6dc1f118c859dd2fd"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>insert_size</b> = <a class="el" href="rem0rec_8h.html#ac10f65922b5363713325364098f1b942">rec_get_converted_size</a>(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>-&gt;<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>)</td></tr>
<tr class="separator:a8525af1c2186bee6dc1f118c859dd2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404fdae1c3b41d5d05fe71b7aeb94698"><td class="memItemLeft" align="right" valign="top"><a id="a404fdae1c3b41d5d05fe71b7aeb94698"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>free_space</b> = <a class="el" href="page0page_8h.html#afc08bba6b54478a12428742f12b536aa">page_get_free_space_of_empty</a>(<a class="el" href="page0page_8h.html#a84498b8178988dbaccd7a9020ba1f590">page_is_comp</a>(<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>))</td></tr>
<tr class="separator:a404fdae1c3b41d5d05fe71b7aeb94698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301c8d10c37ca4cdd94ecbb62efdfcc9"><td class="memItemLeft" align="right" valign="top"><a id="a301c8d10c37ca4cdd94ecbb62efdfcc9"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>total_data</b> = <a class="el" href="page0page_8h.html#aa83f38500bff14e637eb3c559714c573">page_get_data_size</a>(<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>) + insert_size</td></tr>
<tr class="separator:a301c8d10c37ca4cdd94ecbb62efdfcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6baa599ccdbf3ef206b689ee40bbfd"><td class="memItemLeft" align="right" valign="top"><a id="a4c6baa599ccdbf3ef206b689ee40bbfd"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>total_n_recs</b> = <a class="el" href="page0page_8h.html#a23dbabd2124540c6fb89568b95d957de">page_get_n_recs</a>(<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>) + 1</td></tr>
<tr class="separator:a4c6baa599ccdbf3ef206b689ee40bbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457fcdb7b3a63195e5b4679f655dc20e"><td class="memItemLeft" align="right" valign="top">const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a457fcdb7b3a63195e5b4679f655dc20e">rec</a> = btr_cur_get_rec(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:a457fcdb7b3a63195e5b4679f655dc20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9abdd81d05614cdeba46029451ae67"><td class="memItemLeft" align="right" valign="top"><a id="a1b9abdd81d05614cdeba46029451ae67"></a>
const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><b>end_rec</b> = page_get_supremum_rec(<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:a1b9abdd81d05614cdeba46029451ae67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2d4c6e82783b01c3c235f281a8aada"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a8d2d4c6e82783b01c3c235f281a8aada">page</a> = <a class="el" href="btr0cur_8h.html#aed5024b078b665885c29921798da75dc">btr_cur_get_page</a>(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:a8d2d4c6e82783b01c3c235f281a8aada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027a5099548314f2e2405f7d6270725f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__index__t.html">dict_index_t</a> <a class="el" href="structbuf__block__t.html">buf_block_t</a> const rec_t <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a></td></tr>
<tr class="separator:a027a5099548314f2e2405f7d6270725f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942da44c6711d230377078633665e89b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__index__t.html">dict_index_t</a> <a class="el" href="structbuf__block__t.html">buf_block_t</a> const rec_t <a class="el" href="structbuf__block__t.html">buf_block_t</a> ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a942da44c6711d230377078633665e89b">direction</a></td></tr>
<tr class="separator:a942da44c6711d230377078633665e89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6aa70839825d251232072feeaeea05"><td class="memItemLeft" align="right" valign="top"><a id="a5e6aa70839825d251232072feeaeea05"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>prev_page_no</b> = <a class="el" href="btr0btr_8h.html#af5837e3dcb6927730b8a472d500fbd6a">btr_page_get_prev</a>(<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a5e6aa70839825d251232072feeaeea05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742efb69306323c7274f9e4e41a3940a"><td class="memItemLeft" align="right" valign="top"><a id="a742efb69306323c7274f9e4e41a3940a"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>next_page_no</b> = <a class="el" href="btr0btr_8h.html#a312aaebe36e749d13551f6133c36b6fb">btr_page_get_next</a>(<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a742efb69306323c7274f9e4e41a3940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7946907b08a6a311a334dd53b09b05"><td class="memItemLeft" align="right" valign="top"><a id="a5a7946907b08a6a311a334dd53b09b05"></a>
<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>lower_page</b></td></tr>
<tr class="separator:a5a7946907b08a6a311a334dd53b09b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134b55d74a06d775186a4a83b20c3d89"><td class="memItemLeft" align="right" valign="top"><a id="a134b55d74a06d775186a4a83b20c3d89"></a>
<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>upper_page</b> = buf_block_get_frame(<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>)</td></tr>
<tr class="separator:a134b55d74a06d775186a4a83b20c3d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3c54a8d108f8e94c4d5a39eda5643d"><td class="memItemLeft" align="right" valign="top"><a id="a4b3c54a8d108f8e94c4d5a39eda5643d"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>lower_page_no</b> = <a class="el" href="buf0buf_8h.html#acbfc27f4203f4baafb4cf010e4a62a63">buf_block_get_page_no</a>(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a4b3c54a8d108f8e94c4d5a39eda5643d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77467c855eef86980e09a9b0d2170de6"><td class="memItemLeft" align="right" valign="top"><a id="a77467c855eef86980e09a9b0d2170de6"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>upper_page_no</b> = <a class="el" href="buf0buf_8h.html#acbfc27f4203f4baafb4cf010e4a62a63">buf_block_get_page_no</a>(<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>)</td></tr>
<tr class="separator:a77467c855eef86980e09a9b0d2170de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e37924643f475360df41cd06a716ff"><td class="memItemLeft" align="right" valign="top"><a id="a66e37924643f475360df41cd06a716ff"></a>
<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>lower_page_zip</b> = <a class="el" href="buf0buf_8h.html#a78b0bcde049a4c30e62ec696daa55dff">buf_block_get_page_zip</a>(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a66e37924643f475360df41cd06a716ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ad85ba39081d6482538b4ee4643ac7"><td class="memItemLeft" align="right" valign="top"><a id="a00ad85ba39081d6482538b4ee4643ac7"></a>
<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>upper_page_zip</b> = <a class="el" href="buf0buf_8h.html#a78b0bcde049a4c30e62ec696daa55dff">buf_block_get_page_zip</a>(<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>)</td></tr>
<tr class="separator:a00ad85ba39081d6482538b4ee4643ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112d89cbc9059856cdf7ea929ab66251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr_upper</b></td></tr>
<tr class="separator:a112d89cbc9059856cdf7ea929ab66251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17fbac7d0f79c5f058c7a38a1d788a4"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ab17fbac7d0f79c5f058c7a38a1d788a4">n_uniq</a></td></tr>
<tr class="separator:ab17fbac7d0f79c5f058c7a38a1d788a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a05c21cd08b6ea6eb6dfb7c33dc1b29"><td class="memItemLeft" align="right" valign="top"><a id="a6a05c21cd08b6ea6eb6dfb7c33dc1b29"></a>
const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><b>first_rec</b> = page_cur_get_rec(&amp;<a class="el" href="row0upd_8cc.html#a26180b7ae7c02fc3d73b25a2b07affdf">pcur</a>)</td></tr>
<tr class="separator:a6a05c21cd08b6ea6eb6dfb7c33dc1b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Format of the IBUF_REC_FIELD_METADATA of an insert buffer record</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The fourth column in the MySQL 5.5 format contains an operation type, counter, and some flags. </p>
</div></td></tr>
<tr class="memitem:af8f41e3cf79c6d78cc1edf3489995cdf"><td class="memItemLeft" align="right" valign="top">static ulint byte ulint <a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#af8f41e3cf79c6d78cc1edf3489995cdf">mtr</a></td></tr>
<tr class="separator:af8f41e3cf79c6d78cc1edf3489995cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530f2e71a992f4e10087ab59f335e82c"><td class="memItemLeft" align="right" valign="top"><a id="a530f2e71a992f4e10087ab59f335e82c"></a>
<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>root</b> = <a class="el" href="btr0btr_8h.html#a3e2f7d56418e9887a9d3c5503bbb5be2">btr_root_get</a>(<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a530f2e71a992f4e10087ab59f335e82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a0ea71b9884198035c8b95d64f539a"><td class="memItemLeft" align="right" valign="top">static ulint <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a14a0ea71b9884198035c8b95d64f539a">block</a> = btr_cur_get_block(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:a14a0ea71b9884198035c8b95d64f539a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddeaa41a4dab23a7eaa06ee52e4522b"><td class="memItemLeft" align="right" valign="top">static ulint <a class="el" href="structbuf__block__t.html">buf_block_t</a> <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a></td></tr>
<tr class="separator:a4ddeaa41a4dab23a7eaa06ee52e4522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c392c2521fd8612203aedafc943e6b"><td class="memItemLeft" align="right" valign="top">static const rec_t ulint **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a78c392c2521fd8612203aedafc943e6b">offsets</a></td></tr>
<tr class="separator:a78c392c2521fd8612203aedafc943e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45d2d8916ab5959a689743fca2a83df"><td class="memItemLeft" align="right" valign="top">static const rec_t ulint const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#aa45d2d8916ab5959a689743fca2a83df">heap</a></td></tr>
<tr class="separator:aa45d2d8916ab5959a689743fca2a83df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab272a29ed146ac233db12e8b72443195"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#ab272a29ed146ac233db12e8b72443195">zip_size</a> = <a class="el" href="buf0buf_8h.html#a249077a1191ad178a7bd5c2547b0de5c">buf_block_get_zip_size</a>(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:ab272a29ed146ac233db12e8b72443195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd72ce2b4bdc1d7c9b787ceb546ac13f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#acd72ce2b4bdc1d7c9b787ceb546ac13f">space</a> = <a class="el" href="buf0buf_8h.html#a6e258e2b8c2420361849469635f9d7f2">buf_block_get_space</a>(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:acd72ce2b4bdc1d7c9b787ceb546ac13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c16256ae2c489cf64ca4bf580895a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__cur__t.html">page_cur_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8cc.html#a12c16256ae2c489cf64ca4bf580895a7">pcur</a></td></tr>
<tr class="separator:a12c16256ae2c489cf64ca4bf580895a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The B-tree</p>
<p>Created 6/2/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2865000f79089bccbda40535ef15bc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2865000f79089bccbda40535ef15bc38">&#9670;&nbsp;</a></span>btr_level_list_remove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_level_list_remove</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;btr_level_list_remove_func(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>,<a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>,<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>,<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a page from the level list of pages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space where removed </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes, or 0 for uncompressed </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page to remove </td></tr>
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5200d93775a70f0983bfdd215a32904e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5200d93775a70f0983bfdd215a32904e">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull, warn_unused_result)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new file page to be used in an index tree. NOTE: we assume that the caller has made the reservation for free extents! </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr) </td></tr>
    <tr><td class="paramname">block</td><td>(not allocated or initialized) otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if a tuple is smaller than any record on the page. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if smaller </dd></dl>

</div>
</div>
<a id="a5c564511cdc50ac07ba5601d7cc0dea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c564511cdc50ac07ba5601d7cc0dea0">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reorganizes an index page.</p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking <a class="el" href="ibuf0ibuf_8cc.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits()</a> before <a class="el" href="mtr0mtr_8h.html#a25a00697e0e499f9ff7848618c744112">mtr_commit()</a>. On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed</td></tr>
  </table>
  </dd>
</dl>
<p>Attaches the halves of an index page on the appropriate level in an index tree.</p>
<p>Removes a page from the level list of pages. </p>

</div>
</div>
<a id="a47555ee5871726e53ad137654ed768c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47555ee5871726e53ad137654ed768c6">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull(1, 3, 4, 6), warn_unused_result)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns TRUE if the insert fits on the appropriate half-page with the chosen split_rec. </p><dl class="section return"><dt>Returns</dt><dd>true if fits </dd></dl>

</div>
</div>
<a id="a894aad4643bf9d728e194114a2c77239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894aad4643bf9d728e194114a2c77239">&#9670;&nbsp;</a></span>btr_can_merge_with_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_can_merge_with_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> **&#160;</td>
          <td class="paramname"><em>merge_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the page in the cursor can be merged with given page. If necessary, re-organize the merge_page. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if possible to merge. in: mini-transaction</dd></dl>
<p>Checks if the page in the cursor can be merged with given page. If necessary, re-organize the merge_page. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if possible to merge. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on the page to merge </td></tr>
    <tr><td class="paramname">page_no</td><td>in: a sibling page </td></tr>
    <tr><td class="paramname">merge_block</td><td>out: the merge block </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a110568255fcb9271b5f675cff435f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a110568255fcb9271b5f675cff435f6">&#9670;&nbsp;</a></span>btr_compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>adjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to merge the page first to the left immediate brother if such a brother exists, and the node pointers to the current page and to the brother reside on the same page. If the left brother does not satisfy these conditions, looks at the right brother. If the page is the only one on that level lifts the records of the page to the father page, thus reducing the tree height. It is assumed that mtr holds an x-latch on the tree and on the page. If cursor is on the leaf level, mtr must also hold x-latches to the brothers, if they exist. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the page to merge or lift; the page must not be empty: when deleting records, use <a class="el" href="btr0btr_8cc.html#ac1ff7faeb9305d7f5a12feaccc8fe91c">btr_discard_page()</a> if the page would become empty </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE if should adjust the cursor position even if compression occurs </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f185f40a07920eea90f7714930df9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f185f40a07920eea90f7714930df9ca">&#9670;&nbsp;</a></span>btr_corruption_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_corruption_report </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Report that an index page is corrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: corrupted block </td></tr>
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c5ddd8401b16737bf162569732a2fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5ddd8401b16737bf162569732a2fa0">&#9670;&nbsp;</a></span>btr_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_id_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the root node for a new index tree. </p><dl class="section return"><dt>Returns</dt><dd>page number of the created root, FIL_NULL if did not succeed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: type of the index </td></tr>
    <tr><td class="paramname">space</td><td>in: space where created </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">index_id</td><td>in: index id </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0b0935bbe094292342ae9351919101e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b0935bbe094292342ae9351919101e">&#9670;&nbsp;</a></span>btr_discard_only_page_on_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_discard_only_page_on_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Discards a page that is the only page on its level. This will empty the whole B-tree, leaving just an empty root page. This function should never be reached, because <a class="el" href="btr0btr_8cc.html#a1a110568255fcb9271b5f675cff435f6">btr_compress()</a>, which is invoked in delete operations, calls <a class="el" href="btr0btr_8cc.html#ab24f869553390e4ae34621c1fc1f930b">btr_lift_page_up()</a> to flatten the B-tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: page which is the only on its level </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1ff7faeb9305d7f5a12feaccc8fe91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ff7faeb9305d7f5a12feaccc8fe91c">&#9670;&nbsp;</a></span>btr_discard_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_discard_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Discards a page from a B-tree. This is used to remove the last record from a B-tree page: the whole page must be removed at the same time. This cannot be used for the root page, which is allowed to be empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on the page to discard: not on the root page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e4c8428fac9c89af405a42eb209df6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4c8428fac9c89af405a42eb209df6c">&#9670;&nbsp;</a></span>btr_free_but_not_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_free_but_not_root </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>root_page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a B-tree except the root page, which MUST be freed after this by calling btr_free_root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space where created </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">root_page_no</td><td>in: root page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f13ed1346f86b3160976ac8d2393da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f13ed1346f86b3160976ac8d2393da9">&#9670;&nbsp;</a></span>btr_free_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_free_root </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>root_page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the B-tree root page. Other tree MUST already have been freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space where created </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">root_page_no</td><td>in: root page number </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad84e12c9c61d0b08711c54d0ec88d9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84e12c9c61d0b08711c54d0ec88d9f9">&#9670;&nbsp;</a></span>btr_get_next_user_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN rec_t* btr_get_next_user_rec </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets pointer to the next user record in the tree. It is assumed that the caller has appropriate latches on the page and its neighbor. </p><dl class="section return"><dt>Returns</dt><dd>next user record, NULL if there is none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record on leaf level </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr holding a latch on the page, and if needed, also to the next page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b90050c7ccf706da44bb338c1ba45ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b90050c7ccf706da44bb338c1ba45ac">&#9670;&nbsp;</a></span>btr_get_prev_user_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN rec_t* btr_get_prev_user_rec </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets pointer to the previous user record in the tree. It is assumed that the caller has appropriate latches on the page and its neighbor. </p><dl class="section return"><dt>Returns</dt><dd>previous user record, NULL if there is none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record on leaf level </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr holding a latch on the page, and if needed, also to the previous page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62be4d9908b18272d859e71633eac5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62be4d9908b18272d859e71633eac5ce">&#9670;&nbsp;</a></span>btr_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of pages in a B-tree. </p><dl class="section return"><dt>Returns</dt><dd>number of pages, or ULINT_UNDEFINED if the index is unavailable </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">flag</td><td>in: BTR_N_LEAF_PAGES or BTR_TOTAL_SIZE </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction where index is s-latched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5364cac4d748f037336fa19a2254db54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5364cac4d748f037336fa19a2254db54">&#9670;&nbsp;</a></span>btr_height_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_height_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the height of the B-tree (the level of the root, when the leaf level is assumed to be 0). The caller must hold an S or X latch on the index. </p><dl class="section return"><dt>Returns</dt><dd>tree height (level of the root) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ce16f83edead92058fc37477d742c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce16f83edead92058fc37477d742c58">&#9670;&nbsp;</a></span>btr_index_page_validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool btr_index_page_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks the size and number of fields in records based on the definition of the index. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e7a43ae80740e4976cc951543bc586b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7a43ae80740e4976cc951543bc586b">&#9670;&nbsp;</a></span>btr_index_rec_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_index_rec_validate </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>dump_on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the size and number of fields in a record based on the definition of the index. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">dump_on_error</td><td>in: TRUE if the function should print hex dump of record and page on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c70adcf6bbce7b319642aa3a3955519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c70adcf6bbce7b319642aa3a3955519">&#9670;&nbsp;</a></span>btr_index_rec_validate_report()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_index_rec_validate_report </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Display identification information for a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
    <tr><td class="paramname">rec</td><td>in: index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b94970d7282a8eafdf74348eec6b5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b94970d7282a8eafdf74348eec6b5b8">&#9670;&nbsp;</a></span>btr_insert_into_right_sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static rec_t* btr_insert_into_right_sibling </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert the tuple into the right sibling page, if the cursor is at the end of a page. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>undo logging and locking flags </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>cursor at which to insert; when the function succeeds, the cursor is positioned before the insert point. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offsets</td><td>offsets on inserted record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">heap</td><td>memory heap for allocating offsets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>tuple to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_ext</td><td>number of externally stored columns </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inserted record (first record on the right sibling page); the cursor will be positioned on the page infimum </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if the operation was not performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99cd9d9b058c865f26ac228105c6b13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cd9d9b058c865f26ac228105c6b13e">&#9670;&nbsp;</a></span>btr_insert_on_non_leaf_level_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_insert_on_non_leaf_level_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a data tuple to a tree on a non-leaf level. It is assumed that mtr holds an x-latch on the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: level, must be &gt; 0 </td></tr>
    <tr><td class="paramname">tuple</td><td>in: the record to be inserted </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24f869553390e4ae34621c1fc1f930b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24f869553390e4ae34621c1fc1f930b">&#9670;&nbsp;</a></span>btr_lift_page_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_lift_page_up </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If page is the only on its level, this function moves its records to the father page, thus reducing the tree height. </p><dl class="section return"><dt>Returns</dt><dd>father block </dd></dl>
<p>&lt; last used index in blocks[] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: page which is the only on its level; must not be empty: use btr_discard_only_page_on_level if the last record from the page should be removed </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4ce48814c28472b2b35217a5ef0d334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ce48814c28472b2b35217a5ef0d334">&#9670;&nbsp;</a></span>btr_node_ptr_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_node_ptr_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes on the upper level the node pointer to a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: page whose node pointer is deleted </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b2d39f03c3962f42af99952bd3ece11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2d39f03c3962f42af99952bd3ece11">&#9670;&nbsp;</a></span>btr_node_ptr_get_child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_node_ptr_get_child </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the child page of a node pointer and x-latches it. </p><dl class="section return"><dt>Returns</dt><dd>child page, x-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_ptr</td><td>in: node pointer </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a893f5b6a6db4df7afa8428df94442665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893f5b6a6db4df7afa8428df94442665">&#9670;&nbsp;</a></span>btr_node_ptr_set_child_page_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_node_ptr_set_child_page_no </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the child node file address in a node pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: node pointer record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">page_no</td><td>in: child node address </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb0d443a56e3da6eaa2bdf000e9660d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0d443a56e3da6eaa2bdf000e9660d5">&#9670;&nbsp;</a></span>btr_page_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_page_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hint_page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>file_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>init_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new file page to be used in an index tree. NOTE: we assume that the caller has made the reservation for free extents! </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr) </td></tr>
    <tr><td class="paramname">block</td><td>(not allocated or initialized) otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">hint_page_no</td><td>in: hint of a good page </td></tr>
    <tr><td class="paramname">file_direction</td><td>in: direction where a possible page split is made </td></tr>
    <tr><td class="paramname">level</td><td>in: level where the page is placed in the tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction for the allocation </td></tr>
    <tr><td class="paramname">init_mtr</td><td>in/out: mini-transaction for x-latching and initializing the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac95bf5ca68b072c40ed669b891d6fbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95bf5ca68b072c40ed669b891d6fbdc">&#9670;&nbsp;</a></span>btr_page_alloc_for_ibuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_page_alloc_for_ibuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new file page to be used in an ibuf tree. Takes the page from the free list of the tree, which must contain pages! </p><dl class="section return"><dt>Returns</dt><dd>new allocated block, x-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac343a47dc3170cd3f0763d9e11c4aeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac343a47dc3170cd3f0763d9e11c4aeef">&#9670;&nbsp;</a></span>btr_page_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_page_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new index page (not the root, and also not used in page reorganization). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="btr0btr_8cc.html#a356a2e070bba36d2e557fa7e1761a8ab">btr_page_empty()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: page to be created </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: the B-tree level of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a356a2e070bba36d2e557fa7e1761a8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356a2e070bba36d2e557fa7e1761a8ab">&#9670;&nbsp;</a></span>btr_page_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_page_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Empties an index page. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="btr0btr_8cc.html#ac343a47dc3170cd3f0763d9e11c4aeef">btr_page_create()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: page to be emptied </td></tr>
    <tr><td class="paramname">page_zip</td><td>out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the page </td></tr>
    <tr><td class="paramname">level</td><td>in: the B-tree level of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39c2fdd9520ff2c1632592908aa6f2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c2fdd9520ff2c1632592908aa6f2b8">&#9670;&nbsp;</a></span>btr_page_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_page_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a file page used in an index tree. NOTE: cannot free field external storage pages because the page must contain info on its level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa77f1439ec7f9cb150e381f265b17cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77f1439ec7f9cb150e381f265b17cbc">&#9670;&nbsp;</a></span>btr_page_free_for_ibuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_page_free_for_ibuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a page used in an ibuf tree. Puts the page to the free list of the ibuf tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63067890d65886795a2491f548b66169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63067890d65886795a2491f548b66169">&#9670;&nbsp;</a></span>btr_page_free_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_page_free_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a file page used in an index tree. Can be used also to (BLOB) external storage pages, because the page level 0 can be given as an argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">level</td><td>in: page level </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcc7ce1bf5f89f0be26a4fb11d989bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc7ce1bf5f89f0be26a4fb11d989bde">&#9670;&nbsp;</a></span>btr_page_get_father()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_page_get_father </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Seeks to the upper level node pointer to a page. It is assumed that mtr holds an x-latch on the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: b-tree index </td></tr>
    <tr><td class="paramname">block</td><td>in: child page in the index </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
    <tr><td class="paramname">cursor</td><td>out: cursor on node pointer record, its page x-latched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff3932d4dbf34d80e117f38e776c5fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3932d4dbf34d80e117f38e776c5fce">&#9670;&nbsp;</a></span>btr_page_get_father_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint* btr_page_get_father_block </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the upper level node pointer to a page. It is assumed that mtr holds an x-latch on the tree. </p><dl class="section return"><dt>Returns</dt><dd>rec_get_offsets() of the node pointer record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>in: work area for the return value </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap to use </td></tr>
    <tr><td class="paramname">index</td><td>in: b-tree index </td></tr>
    <tr><td class="paramname">block</td><td>in: child page in the index </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
    <tr><td class="paramname">cursor</td><td>out: cursor on node pointer record, its page x-latched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f9daab73d0306cbe1d8f2183e9aae58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9daab73d0306cbe1d8f2183e9aae58">&#9670;&nbsp;</a></span>btr_page_get_father_node_ptr_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint* btr_page_get_father_node_ptr_func </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the upper level node pointer to a page. It is assumed that mtr holds an x-latch on the tree. </p><dl class="section return"><dt>Returns</dt><dd>rec_get_offsets() of the node pointer record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>in: work area for the return value </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap to use </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor pointing to user record, out: cursor on node pointer record, its page x-latched </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b5e732e0453c9d91d4f4b86559c5328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5e732e0453c9d91d4f4b86559c5328">&#9670;&nbsp;</a></span>btr_page_get_split_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static rec_t* btr_page_get_split_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates a split record such that the tuple will certainly fit on its half-page when the split is performed. We assume in this function only that the cursor page has at least one user record. </p><dl class="section return"><dt>Returns</dt><dd>split record, or NULL if tuple will be the first record on the lower or upper half-page (determined by btr_page_tuple_smaller()) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which insert should be made </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad49cde3a6c5898da0d7ac2675d3d7afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49cde3a6c5898da0d7ac2675d3d7afa">&#9670;&nbsp;</a></span>btr_page_get_split_rec_to_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_page_get_split_rec_to_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>split_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decides if the page should be split at the convergence point of inserts converging to the left. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if split recommended </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert </td></tr>
    <tr><td class="paramname">split_rec</td><td>out: if split recommended, the first record on upper half page, or NULL if tuple to be inserted should be first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a508c364c292de30a05105504f78f8f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508c364c292de30a05105504f78f8f96">&#9670;&nbsp;</a></span>btr_page_get_split_rec_to_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_page_get_split_rec_to_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>split_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decides if the page should be split at the convergence point of inserts converging to the right. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if split recommended </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert </td></tr>
    <tr><td class="paramname">split_rec</td><td>out: if split recommended, the first record on upper half page, or NULL if tuple to be inserted should be first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7153cd6fec3c5a1fdfc6b85c1beefe5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7153cd6fec3c5a1fdfc6b85c1beefe5a">&#9670;&nbsp;</a></span>btr_page_reorganize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool btr_page_reorganize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reorganizes an index page.</p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking <a class="el" href="ibuf0ibuf_8cc.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits()</a> before <a class="el" href="mtr0mtr_8h.html#a25a00697e0e499f9ff7848618c744112">mtr_commit()</a>. On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index tree of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcd631122af1656cebce364f29bf470d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd631122af1656cebce364f29bf470d">&#9670;&nbsp;</a></span>btr_page_reorganize_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool btr_page_reorganize_low </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>z_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reorganizes an index page.</p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking <a class="el" href="ibuf0ibuf_8cc.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits()</a> before <a class="el" href="mtr0mtr_8h.html#a25a00697e0e499f9ff7848618c744112">mtr_commit()</a>. On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recovery</td><td>in: true if called in recovery: locks should not be updated, i.e., there cannot exist locks on the page, and a hash index should not be dropped: it cannot exist </td></tr>
    <tr><td class="paramname">z_level</td><td>in: compression level to be used if dealing with compressed page </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index tree of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ff38b00f99e80cb45a2253d4d5110c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff38b00f99e80cb45a2253d4d5110c7">&#9670;&nbsp;</a></span>btr_page_split_and_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN rec_t* btr_page_split_and_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits an index page to halves and inserts the tuple. It is assumed that mtr holds an x-latch to the index tree. NOTE: the tree x-latch is released within this function! NOTE that the operation of this function must always succeed, we cannot reverse it: therefore enough free disk space (2 pages) must be guaranteed to be available before this function is called.</p>
<dl class="section return"><dt>Returns</dt><dd>inserted record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert; when the function returns, the cursor is positioned on the predecessor of the inserted record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on inserted record </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3408aa71c70e485d6f88362c72cfa71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3408aa71c70e485d6f88362c72cfa71c">&#9670;&nbsp;</a></span>btr_parse_page_reorganize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_parse_page_reorganize </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a redo log record of reorganizing a page. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
    <tr><td class="paramname">compressed</td><td>in: true if compressed page </td></tr>
    <tr><td class="paramname">block</td><td>in: page to be reorganized, or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a831a556c36344bd516020b96604c447c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831a556c36344bd516020b96604c447c">&#9670;&nbsp;</a></span>btr_parse_set_min_rec_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_parse_set_min_rec_mark </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the redo log record for setting an index record as the predefined minimum record. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">comp</td><td>in: nonzero=compact page format </td></tr>
    <tr><td class="paramname">page</td><td>in: page or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a282e89ac4c93e3b5d70c91b42a06107e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282e89ac4c93e3b5d70c91b42a06107e">&#9670;&nbsp;</a></span>btr_root_adjust_on_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_root_adjust_on_import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks and adjusts the root node of a tree during IMPORT TABLESPACE. </p><dl class="section return"><dt>Returns</dt><dd>error code, or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83d685895d1a72e610771de073d9eafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d685895d1a72e610771de073d9eafb">&#9670;&nbsp;</a></span>btr_root_block_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_root_block_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the root node of a tree and x- or s-latches it. </p><dl class="section return"><dt>Returns</dt><dd>root page, x- or s-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mode</td><td>in: either RW_S_LATCH or RW_X_LATCH </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc4cb219b48a0d3d5b04434d2812a8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4cb219b48a0d3d5b04434d2812a8cf">&#9670;&nbsp;</a></span>btr_root_fseg_adjust_on_import()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool btr_root_fseg_adjust_on_import </td>
          <td>(</td>
          <td class="paramtype">fseg_header_t *&#160;</td>
          <td class="paramname"><em>seg_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks a file segment header within a B-tree root page and updates the segment header space id. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if valid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_header</td><td>in/out: segment header </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">space</td><td>in: tablespace identifier </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c494c567bdb707b7ebbf8cf9df05c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c494c567bdb707b7ebbf8cf9df05c7e">&#9670;&nbsp;</a></span>btr_root_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>* btr_root_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the root node of a tree and x-latches it. </p><dl class="section return"><dt>Returns</dt><dd>root page, x-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a261c8181927751db813afa6b3905cff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261c8181927751db813afa6b3905cff6">&#9670;&nbsp;</a></span>btr_root_raise_and_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN rec_t* btr_root_raise_and_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes tree one level higher by splitting the root, and inserts the tuple. It is assumed that mtr contains an x-latch on the tree. NOTE that the operation of this function must always succeed, we cannot reverse it: therefore enough free disk space must be guaranteed to be available before this function is called. </p><dl class="section return"><dt>Returns</dt><dd>inserted record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert: must be on the root page; when the function returns, the cursor is positioned on the predecessor of the inserted record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on inserted record </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f8369a4154e86f52ef9074c63797087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8369a4154e86f52ef9074c63797087">&#9670;&nbsp;</a></span>btr_set_min_rec_mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_set_min_rec_mark </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a record as the predefined minimum record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5050f7245a104bf110795d83da25efae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5050f7245a104bf110795d83da25efae">&#9670;&nbsp;</a></span>btr_set_min_rec_mark_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_set_min_rec_mark_log </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the redo log record for setting an index record as the predefined minimum record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">type</td><td>in: MLOG_COMP_REC_MIN_MARK or MLOG_REC_MIN_MARK </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b2f5758b8fa81304438a8e86e1a75cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2f5758b8fa81304438a8e86e1a75cc">&#9670;&nbsp;</a></span>btr_validate_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool btr_validate_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the consistency of an index tree. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83532ad9fe9612994b9f59d13ea06725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83532ad9fe9612994b9f59d13ea06725">&#9670;&nbsp;</a></span>btr_validate_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool btr_validate_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validates index tree level. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction or NULL </td></tr>
    <tr><td class="paramname">level</td><td>in: level number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbcc2e5603db7d844425d09e00b91299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcc2e5603db7d844425d09e00b91299">&#9670;&nbsp;</a></span>btr_validate_report1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_validate_report1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Report an error on one page of an index tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: B-tree level </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a201f40a474ab44ea3f6cc69885424dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201f40a474ab44ea3f6cc69885424dd2">&#9670;&nbsp;</a></span>btr_validate_report2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_validate_report2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Report an error on two pages of an index tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: B-tree level </td></tr>
    <tr><td class="paramname">block1</td><td>in: first index page </td></tr>
    <tr><td class="paramname">block2</td><td>in: second index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a14a0ea71b9884198035c8b95d64f539a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a0ea71b9884198035c8b95d64f539a">&#9670;&nbsp;</a></span>block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__index__t.html">dict_index_t</a> const <a class="el" href="structdict__table__t.html">dict_table_t</a> int <a class="el" href="row0merge_8h.html#aa487e4f70fe66c51d51691daccb65323">row_merge_block_t</a> * block = btr_cur_get_block(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in/out: B-tree page</p>
<p>in/out: page to be split</p>
<p>&lt; in: buffered entry to insert in/out: index page where the buffered entry should be placed</p>
<p>in/out: 3 buffers</p>
<p>&lt; in/out: file buffer </p>

</div>
</div>
<a id="a942da44c6711d230377078633665e89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942da44c6711d230377078633665e89b">&#9670;&nbsp;</a></span>direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a> <a class="el" href="structbuf__block__t.html">buf_block_t</a> const rec_t <a class="el" href="structbuf__block__t.html">buf_block_t</a> ulint direction</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: FSP_UP or FSP_DOWN </p>

</div>
</div>
<a id="a0544c3fe466e421738dae463968b70ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0544c3fe466e421738dae463968b70ba">&#9670;&nbsp;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">                seg_header = root + PAGE_HEADER + PAGE_BTR_SEG_TOP</div></div><!-- fragment -->
</div>
</div>
<a id="a2f8482ebd865881c442d965edb9b295c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8482ebd865881c442d965edb9b295c">&#9670;&nbsp;</a></span>file_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint byte file_direction</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: direction where a possible page split is made </p>

</div>
</div>
<a id="aa45d2d8916ab5959a689743fca2a83df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45d2d8916ab5959a689743fca2a83df">&#9670;&nbsp;</a></span>heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> * heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <a class="code" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>*         <a class="code" href="btr0btr_8cc.html#a8d2d4c6e82783b01c3c235f281a8aada">page</a></div><div class="ttc" id="page0types_8h_html_ac84908ddc97c37107986280aa8f37897"><div class="ttname"><a href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a></div><div class="ttdeci">byte page_t</div><div class="ttdef"><b>Definition:</b> page0types.h:40</div></div>
<div class="ttc" id="btr0btr_8cc_html_a8d2d4c6e82783b01c3c235f281a8aada"><div class="ttname"><a href="btr0btr_8cc.html#a8d2d4c6e82783b01c3c235f281a8aada">page</a></div><div class="ttdeci">page</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:2521</div></div>
</div><!-- fragment --><p>&lt; in: temporary memory heap</p>
<p>&lt; in/out: heap for offsets</p>
<p>in/out: memory heap</p>
<p>in: memory heap to use as temporary storage</p>
<p>in/out: memory heap for allocating data tuples</p>
<p>&lt; in/out: memory heap</p>
<p>Memory heap </p>

</div>
</div>
<a id="aae8fdbe2be22423ddb9e9c7a4c883235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8fdbe2be22423ddb9e9c7a4c883235">&#9670;&nbsp;</a></span>hint_page_no</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint hint_page_no</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: index in: hint of a good page </p>

</div>
</div>
<a id="a4ddeaa41a4dab23a7eaa06ee52e4522b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddeaa41a4dab23a7eaa06ee52e4522b">&#9670;&nbsp;</a></span>index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a> index</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <a class="code" href="structfts__string__t.html">fts_string_t</a>    <a class="code" href="fts0opt_8cc.html#abd9684a1e813f071a0a0316aac5b4fd7">word</a></div><div class="ttc" id="structfts__string__t_html"><div class="ttname"><a href="structfts__string__t.html">fts_string_t</a></div><div class="ttdef"><b>Definition:</b> fts0fts.h:231</div></div>
<div class="ttc" id="fts0opt_8cc_html_abd9684a1e813f071a0a0316aac5b4fd7"><div class="ttname"><a href="fts0opt_8cc.html#abd9684a1e813f071a0a0316aac5b4fd7">word</a></div><div class="ttdeci">static const fts_string_t * word</div><div class="ttdef"><b>Definition:</b> fts0opt.cc:804</div></div>
</div><!-- fragment --><p>in: the index tree of the page</p>
<p>&lt; in: undo logging and locking flags in: the index tree</p>
<p>&lt; in: optimize instance</p>
<p>&lt; in: table with one FTS index</p>
<p>&lt; in: optimize instance in: table with one FTS index</p>
<p>in: record descriptor</p>
<p>&lt; in: origin of record in: record descriptor</p>
<p>Index being read in</p>
<p>&lt; in: table in: index</p>
<p>&lt; in: undo logging and locking flags in: non-clustered unique index</p>
<p>&lt; out: mini-transaction in/out: secondary index</p>
<p>&lt; in: merge record in: index of mrec</p>
<p>&lt; in: transaction (for checking if the operation was interrupted) in/out: index</p>
<p>&lt; in: heap where allocated in: secondary index</p>
<p>in: indexes to be created</p>
<p>&lt; in: transaction identifier in: index</p>
<p>&lt; in: index Index creation node</p>
<p>&lt; in: row purge node in: index</p>
<p>in: index of rec</p>
<p>in: index</p>
<p>&lt; in/out: transaction</p>
<p>&lt; in: secondary index</p>
<p>&lt; in/out: row update node in: clustered index of the record</p>
<p>&lt; in: row update node in: clustered index </p>

</div>
</div>
<a id="af6778664613b89d4ea4dad4c5c218cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6778664613b89d4ea4dad4c5c218cd2">&#9670;&nbsp;</a></span>init_mtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint byte ulint <a class="el" href="structmtr__t.html">mtr_t</a> <a class="el" href="structmtr__t.html">mtr_t</a>* init_mtr</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        fseg_header_t*  seg_header</div></div><!-- fragment --><p>&lt; in/out: mtr or another mini-transaction in which the page should be initialized. If init_mtr!=mtr, but the page is already X-latched in mtr, do not initialize the page. </p>

</div>
</div>
<a id="a46e504d299fb7ca943fc98a74051f564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e504d299fb7ca943fc98a74051f564">&#9670;&nbsp;</a></span>level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint level = btr_page_get_level(buf_block_get_frame(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>), <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: level where the page is placed in the tree </p>

</div>
</div>
<a id="af8f41e3cf79c6d78cc1edf3489995cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f41e3cf79c6d78cc1edf3489995cdf">&#9670;&nbsp;</a></span>mtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtrx__rseg__t.html">trx_rseg_t</a> ulint <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> const <a class="el" href="structxid__t.html">XID</a> <a class="el" href="structtrx__undo__t.html">trx_undo_t</a> <a class="el" href="structmtr__t.html">mtr_t</a> * mtr</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <a class="code" href="structpage__cur__t.html">page_cur_t</a>      cur</div><div class="ttc" id="structpage__cur__t_html"><div class="ttname"><a href="structpage__cur__t.html">page_cur_t</a></div><div class="ttdef"><b>Definition:</b> page0cur.h:378</div></div>
</div><!-- fragment --><p>in/out: mini-transaction for the allocation</p>
<p>&lt; in/out: mini-transaction</p>
<p>&lt; in: mtr</p>
<p>in/out: mini-transaction</p>
<p>&lt; in: mini transaction</p>
<p>in/out: mtr</p>
<p>&lt; in: mtr; must be committed before latching any further pages</p>
<p>&lt; in: mtr holding the latch of pcur page</p>
<p>&lt; in: mtr used to get access to the non-clustered record; the same mtr is used to access the clustered index</p>
<p>&lt; in/out: mtr; gets committed here</p>
<p>&lt; in: mtr; gets committed here </p>

</div>
</div>
<a id="a2a0578735b43fba351dae8147e19e0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0578735b43fba351dae8147e19e0ac">&#9670;&nbsp;</a></span>n_ext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t ulint const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint n_ext</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: number of externally stored columns </p>

</div>
</div>
<a id="ab17fbac7d0f79c5f058c7a38a1d788a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17fbac7d0f79c5f058c7a38a1d788a4">&#9670;&nbsp;</a></span>n_uniq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint ulint n_uniq</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: number of unique fields in the index page records </p>

</div>
</div>
<a id="a027a5099548314f2e2405f7d6270725f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027a5099548314f2e2405f7d6270725f">&#9670;&nbsp;</a></span>new_block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a> <a class="el" href="structbuf__block__t.html">buf_block_t</a> const rec_t <a class="el" href="structbuf__block__t.html">buf_block_t</a>* new_block</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in/out: the new half page </p>

</div>
</div>
<a id="a112d89cbc9059856cdf7ea929ab66251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112d89cbc9059856cdf7ea929ab66251">&#9670;&nbsp;</a></span>node_ptr_upper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">node_ptr_upper</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="dict0dict_8cc.html#a894161e0d082b8e7376470ecab814016">dict_index_build_node_ptr</a>(<a class="code" href="btr0btr_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="code" href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a>,</div><div class="line">                                                   upper_page_no, <a class="code" href="btr0btr_8cc.html#aa45d2d8916ab5959a689743fca2a83df">heap</a>, <a class="code" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>)</div><div class="ttc" id="btr0btr_8cc_html_a02317286bfc7e3e5ac383506672e0773"><div class="ttname"><a href="btr0btr_8cc.html#a02317286bfc7e3e5ac383506672e0773">split_rec</a></div><div class="ttdeci">static const rec_t * split_rec</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:2506</div></div>
<div class="ttc" id="dict0dict_8cc_html_a894161e0d082b8e7376470ecab814016"><div class="ttname"><a href="dict0dict_8cc.html#a894161e0d082b8e7376470ecab814016">dict_index_build_node_ptr</a></div><div class="ttdeci">UNIV_INTERN dtuple_t * dict_index_build_node_ptr(const dict_index_t *index, const rec_t *rec, ulint page_no, mem_heap_t *heap, ulint level)</div><div class="ttdef"><b>Definition:</b> dict0dict.cc:5075</div></div>
<div class="ttc" id="btr0btr_8cc_html_a4ddeaa41a4dab23a7eaa06ee52e4522b"><div class="ttname"><a href="btr0btr_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a></div><div class="ttdeci">static ulint buf_block_t dict_index_t * index</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:1984</div></div>
<div class="ttc" id="btr0btr_8cc_html_aa45d2d8916ab5959a689743fca2a83df"><div class="ttname"><a href="btr0btr_8cc.html#aa45d2d8916ab5959a689743fca2a83df">heap</a></div><div class="ttdeci">static const rec_t ulint const dtuple_t ulint mem_heap_t ** heap</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:2512</div></div>
<div class="ttc" id="btr0btr_8cc_html_a46e504d299fb7ca943fc98a74051f564"><div class="ttname"><a href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a></div><div class="ttdeci">static ulint byte ulint level</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:1110</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a78c392c2521fd8612203aedafc943e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c392c2521fd8612203aedafc943e6b">&#9670;&nbsp;</a></span>offsets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint * offsets</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= rec_get_offsets(</div><div class="line">                first_rec, <a class="code" href="btr0cur_8cc.html#ae6be834938be56633c510e0de2248709">cursor</a>-&gt;<a class="code" href="structbtr__cur__t.html#a1d268419dab170f2cb96f2548ad99833">index</a>, *<a class="code" href="btr0btr_8cc.html#a78c392c2521fd8612203aedafc943e6b">offsets</a>,</div><div class="line">                <a class="code" href="btr0btr_8cc.html#ab17fbac7d0f79c5f058c7a38a1d788a4">n_uniq</a>, <a class="code" href="btr0btr_8cc.html#aa45d2d8916ab5959a689743fca2a83df">heap</a>)</div><div class="ttc" id="btr0cur_8cc_html_ae6be834938be56633c510e0de2248709"><div class="ttname"><a href="btr0cur_8cc.html#ae6be834938be56633c510e0de2248709">cursor</a></div><div class="ttdeci">UNIV_INLINE btr_cur_t * cursor</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1140</div></div>
<div class="ttc" id="btr0btr_8cc_html_a78c392c2521fd8612203aedafc943e6b"><div class="ttname"><a href="btr0btr_8cc.html#a78c392c2521fd8612203aedafc943e6b">offsets</a></div><div class="ttdeci">static const rec_t ulint ** offsets</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:2506</div></div>
<div class="ttc" id="structbtr__cur__t_html_a1d268419dab170f2cb96f2548ad99833"><div class="ttname"><a href="structbtr__cur__t.html#a1d268419dab170f2cb96f2548ad99833">btr_cur_t::index</a></div><div class="ttdeci">dict_index_t * index</div><div class="ttdef"><b>Definition:</b> btr0cur.h:807</div></div>
<div class="ttc" id="btr0btr_8cc_html_aa45d2d8916ab5959a689743fca2a83df"><div class="ttname"><a href="btr0btr_8cc.html#aa45d2d8916ab5959a689743fca2a83df">heap</a></div><div class="ttdeci">static const rec_t ulint const dtuple_t ulint mem_heap_t ** heap</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:2512</div></div>
<div class="ttc" id="btr0btr_8cc_html_ab17fbac7d0f79c5f058c7a38a1d788a4"><div class="ttname"><a href="btr0btr_8cc.html#ab17fbac7d0f79c5f058c7a38a1d788a4">n_uniq</a></div><div class="ttdeci">static const dtuple_t ulint ulint n_uniq</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:2782</div></div>
</div><!-- fragment --><p>in: rec_get_offsets( split_rec, cursor-&gt;index); out: garbage</p>
<p>in/out: temporary storage</p>
<p>in: rec_get_offsets() on cursor</p>
<p>out: offsets on *rec</p>
<p>out: offsets on cursor-&gt;page_cur.rec</p>
<p>&lt; in/out: rec_get_offsets(rec)</p>
<p>in/out: rec_get_offsets(rec)</p>
<p>in: offsets of mrec</p>
<p>&lt; in/out: B-tree cursor, will be trashed in: offsets on pcur</p>
<p>&lt; in/out: work area for parsing mrec</p>
<p>&lt; in/out: work area for <a class="el" href="rem0rec_8h.html#a0f8ee525550c9c340abd2c159ef560a6">rec_init_offsets_temp()</a></p>
<p>in/out: offsets returned by rec_get_offsets(rec, clust_index)</p>
<p>in: array returned by rec_get_offsets()</p>
<p>&lt; in: array returned by rec_get_offsets(rec)</p>
<p>in: offsets returned by rec_get_offsets(rec, sec_index); out: offsets returned by rec_get_offsets(out_rec, clust_index)</p>
<p>in: rec_get_offsets() on node-&gt;pcur</p>
<p>in/out: rec_get_offsets() for the record under the cursor </p>

</div>
</div>
<a id="a8d2d4c6e82783b01c3c235f281a8aada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2d4c6e82783b01c3c235f281a8aada">&#9670;&nbsp;</a></span>page</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static ulint page = <a class="el" href="btr0cur_8h.html#aed5024b078b665885c29921798da75dc">btr_cur_get_page</a>(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in/out: page to remove</p>
<p>&lt; in: segment inode in: page offset </p>

</div>
</div>
<a id="a12c16256ae2c489cf64ca4bf580895a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c16256ae2c489cf64ca4bf580895a7">&#9670;&nbsp;</a></span>pcur</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> * pcur</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in/out: persistent cursor whose position is to be restored</p>
<p>in: pcur positioned on the record to delete, having latch mode BTR_MODIFY_LEAF </p>

</div>
</div>
<a id="a457fcdb7b3a63195e5b4679f655dc20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457fcdb7b3a63195e5b4679f655dc20e">&#9670;&nbsp;</a></span>rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rec_t * rec = btr_cur_get_rec(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: clustered index record</p>
<p>in: record in a clustered index</p>
<p>in: record in a non-clustered index</p>
<p>in: InnoDB record; must be protected by a page latch</p>
<p>in: Innobase record in the index which was described in prebuilt's template, or in the clustered index; must be protected by a page latch</p>
<p>in: record in a non-clustered index; if this is a locking read, then rec is not allowed to be delete-marked, and that would not make sense either </p>

</div>
</div>
<a id="acd72ce2b4bdc1d7c9b787ceb546ac13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd72ce2b4bdc1d7c9b787ceb546ac13f">&#9670;&nbsp;</a></span>space</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint space = <a class="el" href="buf0buf_8h.html#a6e258e2b8c2420361849469635f9d7f2">buf_block_get_space</a>(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; out: actual increase in pages, where we measure the tablespace size from what the header field says; it may be the actual file size rounded down to megabyte in: space</p>
<p>in: space id where to insert </p>

</div>
</div>
<a id="a02317286bfc7e3e5ac383506672e0773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02317286bfc7e3e5ac383506672e0773">&#9670;&nbsp;</a></span>split_rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__index__t.html">dict_index_t</a> <a class="el" href="structbuf__block__t.html">buf_block_t</a> const rec_t * split_rec</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: cursor at which insert should be made in: suggestion for first record on upper half-page, or NULL if tuple to be inserted should be first</p>
<p>in: first record on upper half page </p>

</div>
</div>
<a id="ae68c273b782e74edd9ed68413223786e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68c273b782e74edd9ed68413223786e">&#9670;&nbsp;</a></span>tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a> * tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: tuple to insert</p>
<p>&lt; in: b-tree cursor in: tuple to consider </p>

</div>
</div>
<a id="aa1d2140102d7a14490014d15e140df50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d2140102d7a14490014d15e140df50">&#9670;&nbsp;</a></span>z_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint z_level</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: true if called in recovery: locks should not be updated, i.e., there cannot exist locks on the page, and a hash index should not be dropped: it cannot exist in: compression level to be used if dealing with compressed page </p>

</div>
</div>
<a id="ab272a29ed146ac233db12e8b72443195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab272a29ed146ac233db12e8b72443195">&#9670;&nbsp;</a></span>zip_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint zip_size = <a class="el" href="buf0buf_8h.html#a249077a1191ad178a7bd5c2547b0de5c">buf_block_get_zip_size</a>(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: space where removed in: compressed page size in bytes or 0 for uncompressed pages</p>
<p>&lt; in: space id in: compressed page size in bytes or 0 for uncompressed pages </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

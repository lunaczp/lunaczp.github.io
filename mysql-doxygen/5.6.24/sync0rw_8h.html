<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/sync0rw.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sync0rw.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0lst_8h_source.html">ut0lst.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0counter_8h_source.html">ut0counter.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="os0sync_8h_source.html">os0sync.h</a>&quot;</code><br />
<code>#include &quot;sync0rw.ic&quot;</code><br />
</div>
<p><a href="sync0rw_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__stats__t.html">rw_lock_stats_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html">rw_lock_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a307d47401046e3092b4db2252e2d5e20"><td class="memItemLeft" align="right" valign="top"><a id="a307d47401046e3092b4db2252e2d5e20"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RW_S_LATCH</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a307d47401046e3092b4db2252e2d5e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4153a08cf54353103c0dd6b969f5a09"><td class="memItemLeft" align="right" valign="top"><a id="ac4153a08cf54353103c0dd6b969f5a09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RW_X_LATCH</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac4153a08cf54353103c0dd6b969f5a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b729f2ee198ffed52628341cb3a9a0f"><td class="memItemLeft" align="right" valign="top"><a id="a6b729f2ee198ffed52628341cb3a9a0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RW_NO_LATCH</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a6b729f2ee198ffed52628341cb3a9a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b2662477d6b776c1e7ace4c29949ba"><td class="memItemLeft" align="right" valign="top"><a id="ac0b2662477d6b776c1e7ace4c29949ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_LOCK_DECR</b>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="separator:ac0b2662477d6b776c1e7ace4c29949ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c004f4cee18ed2d0f57d12a4395386"><td class="memItemLeft" align="right" valign="top"><a id="aa8c004f4cee18ed2d0f57d12a4395386"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_create</b>(K,  L,  <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#a9290b45247a6c4a1887a01252d1fab3f">pfs_rw_lock_create_func</a>((K), (L), __FILE__, __LINE__)</td></tr>
<tr class="separator:aa8c004f4cee18ed2d0f57d12a4395386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ab160551c85fc478837cda173ef4d0"><td class="memItemLeft" align="right" valign="top"><a id="a75ab160551c85fc478837cda173ef4d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_lock</b>(M)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#ad66d4c47a27dcbc374e4b49d07ddf061">pfs_rw_lock_s_lock_func</a>((M), 0, __FILE__, __LINE__)</td></tr>
<tr class="separator:a75ab160551c85fc478837cda173ef4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4f7fd32176ef5360016d0352780e47"><td class="memItemLeft" align="right" valign="top"><a id="a3c4f7fd32176ef5360016d0352780e47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_lock_inline</b>(M,  P,  F,  L)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#ad66d4c47a27dcbc374e4b49d07ddf061">pfs_rw_lock_s_lock_func</a>((M), (P), (F), (L))</td></tr>
<tr class="separator:a3c4f7fd32176ef5360016d0352780e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315e7c36f136ff80f9d25f7e4487f9b5"><td class="memItemLeft" align="right" valign="top"><a id="a315e7c36f136ff80f9d25f7e4487f9b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_lock_gen</b>(M,  P)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#ad66d4c47a27dcbc374e4b49d07ddf061">pfs_rw_lock_s_lock_func</a>((M), (P), __FILE__, __LINE__)</td></tr>
<tr class="separator:a315e7c36f136ff80f9d25f7e4487f9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf37bcc3e9b519fa56b6b6ac57d9114"><td class="memItemLeft" align="right" valign="top"><a id="accf37bcc3e9b519fa56b6b6ac57d9114"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_lock_gen_nowait</b>(M,  P)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#ad771cd3867aacc202f7a00a98891176e">pfs_rw_lock_s_lock_low</a>((M), (P), __FILE__, __LINE__)</td></tr>
<tr class="separator:accf37bcc3e9b519fa56b6b6ac57d9114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7973a87a4b5f0e81c38b4ddc5752078"><td class="memItemLeft" align="right" valign="top"><a id="ab7973a87a4b5f0e81c38b4ddc5752078"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_lock_nowait</b>(M,  F,  L)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#ad771cd3867aacc202f7a00a98891176e">pfs_rw_lock_s_lock_low</a>((M), 0, (F), (L))</td></tr>
<tr class="separator:ab7973a87a4b5f0e81c38b4ddc5752078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4a82c5c95e70ada76ea54fcd1ec3e9"><td class="memItemLeft" align="right" valign="top"><a id="a8b4a82c5c95e70ada76ea54fcd1ec3e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_unlock_gen</b>(L,  P)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#a0dccb615868b7971ca9f175c187044bb">pfs_rw_lock_s_unlock_func</a>(L)</td></tr>
<tr class="separator:a8b4a82c5c95e70ada76ea54fcd1ec3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3004dd4636535a3aab2cecfdb7dae54"><td class="memItemLeft" align="right" valign="top"><a id="ad3004dd4636535a3aab2cecfdb7dae54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock</b>(M)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#afe0577be3be289ac48316cae08a68a72">pfs_rw_lock_x_lock_func</a>((M), 0, __FILE__, __LINE__)</td></tr>
<tr class="separator:ad3004dd4636535a3aab2cecfdb7dae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c18777721b02a69abdd8f09f9a878a6"><td class="memItemLeft" align="right" valign="top"><a id="a3c18777721b02a69abdd8f09f9a878a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock_inline</b>(M,  P,  F,  L)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#afe0577be3be289ac48316cae08a68a72">pfs_rw_lock_x_lock_func</a>((M), (P), (F), (L))</td></tr>
<tr class="separator:a3c18777721b02a69abdd8f09f9a878a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa710bf51467ba64046aff9e50fc93453"><td class="memItemLeft" align="right" valign="top"><a id="aa710bf51467ba64046aff9e50fc93453"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock_gen</b>(M,  P)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#afe0577be3be289ac48316cae08a68a72">pfs_rw_lock_x_lock_func</a>((M), (P), __FILE__, __LINE__)</td></tr>
<tr class="separator:aa710bf51467ba64046aff9e50fc93453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db8af761e911c0508e00fad89cd5798"><td class="memItemLeft" align="right" valign="top"><a id="a1db8af761e911c0508e00fad89cd5798"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock_nowait</b>(M)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#a5c505f90944273ff022f56a3b9f856cd">pfs_rw_lock_x_lock_func_nowait</a>((M), __FILE__, __LINE__)</td></tr>
<tr class="separator:a1db8af761e911c0508e00fad89cd5798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f1a39a45b6f1cd4ece8260f43f19a5"><td class="memItemLeft" align="right" valign="top"><a id="a27f1a39a45b6f1cd4ece8260f43f19a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock_func_nowait_inline</b>(M,  F,  L)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#a5c505f90944273ff022f56a3b9f856cd">pfs_rw_lock_x_lock_func_nowait</a>((M), (F), (L))</td></tr>
<tr class="separator:a27f1a39a45b6f1cd4ece8260f43f19a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017ca55049f283ad3767df5a86d6143a"><td class="memItemLeft" align="right" valign="top"><a id="a017ca55049f283ad3767df5a86d6143a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_unlock_gen</b>(L,  P)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#a06f33224cbf4703c36e78699a215beb5">pfs_rw_lock_x_unlock_func</a>(L)</td></tr>
<tr class="separator:a017ca55049f283ad3767df5a86d6143a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08b06eb9f788c2f45e848d46556e1e9"><td class="memItemLeft" align="right" valign="top"><a id="ad08b06eb9f788c2f45e848d46556e1e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_free</b>(M)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#a839a766cddf1e9c276862d80081021f1">pfs_rw_lock_free_func</a>(M)</td></tr>
<tr class="separator:ad08b06eb9f788c2f45e848d46556e1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41172c45229ea4cbe60f4669b3b68994"><td class="memItemLeft" align="right" valign="top"><a id="a41172c45229ea4cbe60f4669b3b68994"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_unlock</b>(L)&#160;&#160;&#160;rw_lock_s_unlock_gen(L, 0)</td></tr>
<tr class="separator:a41172c45229ea4cbe60f4669b3b68994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10266de83fba11c12e595ca4ab1f17c"><td class="memItemLeft" align="right" valign="top"><a id="ae10266de83fba11c12e595ca4ab1f17c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_unlock</b>(L)&#160;&#160;&#160;rw_lock_x_unlock_gen(L, 0)</td></tr>
<tr class="separator:ae10266de83fba11c12e595ca4ab1f17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65c7d89e802eb83828ba5bef5217afb9"><td class="memItemLeft" align="right" valign="top"><a id="a65c7d89e802eb83828ba5bef5217afb9"></a>
typedef&#160;</td><td class="memItemRight" valign="bottom"><b>UT_LIST_BASE_NODE_T</b> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a>) rw_lock_list_t</td></tr>
<tr class="separator:a65c7d89e802eb83828ba5bef5217afb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7ca59c85c0d221ad9e4a2779988d3f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a8e7ca59c85c0d221ad9e4a2779988d3f">rw_lock_create_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, const char *cfile_name, ulint cline)</td></tr>
<tr class="separator:a8e7ca59c85c0d221ad9e4a2779988d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66e0a54048b7143a68813277bc70f5b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#af66e0a54048b7143a68813277bc70f5b">rw_lock_free_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:af66e0a54048b7143a68813277bc70f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1559e2f5077182255d2a0672d8d337"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a8e1559e2f5077182255d2a0672d8d337">rw_lock_s_lock_low</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)), const char *file_name, ulint line)</td></tr>
<tr class="separator:a8e1559e2f5077182255d2a0672d8d337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfb8bac26c0ede1f1cbb1c94d415370"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a1dfb8bac26c0ede1f1cbb1c94d415370">rw_lock_s_lock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, const char *file_name, ulint line)</td></tr>
<tr class="separator:a1dfb8bac26c0ede1f1cbb1c94d415370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec3c37952ede1fb7178c8ee66c35b14"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a9ec3c37952ede1fb7178c8ee66c35b14">rw_lock_x_lock_func_nowait</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, const char *file_name, ulint line)</td></tr>
<tr class="separator:a9ec3c37952ede1fb7178c8ee66c35b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4ddd6b7f654b585865be38a855c9c8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a7c4ddd6b7f654b585865be38a855c9c8">rw_lock_s_unlock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:a7c4ddd6b7f654b585865be38a855c9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af847cc23edeba216e1d5381f1facdf3f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#af847cc23edeba216e1d5381f1facdf3f">rw_lock_x_lock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, const char *file_name, ulint line)</td></tr>
<tr class="separator:af847cc23edeba216e1d5381f1facdf3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b696c942c9167dd8e868cc26375a403"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a1b696c942c9167dd8e868cc26375a403">rw_lock_x_unlock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:a1b696c942c9167dd8e868cc26375a403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ab05eba9ad152bc256180ef5430465"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ad4ab05eba9ad152bc256180ef5430465">rw_lock_x_lock_move_ownership</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:ad4ab05eba9ad152bc256180ef5430465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5b9c0969702ede99cdabbbc40fce33"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#add5b9c0969702ede99cdabbbc40fce33">rw_lock_get_x_lock_count</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:add5b9c0969702ede99cdabbbc40fce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc192baf074e7cba3590651df4b4194"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#accc192baf074e7cba3590651df4b4194">rw_lock_get_waiters</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:accc192baf074e7cba3590651df4b4194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5acf23523e06ae0ce287173349c2ff"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#acd5acf23523e06ae0ce287173349c2ff">rw_lock_get_writer</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:acd5acf23523e06ae0ce287173349c2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24ac5c3f41388704830966b07d50936"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ae24ac5c3f41388704830966b07d50936">rw_lock_get_reader_count</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:ae24ac5c3f41388704830966b07d50936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbd8f9cce63535b6d1196e067deecff"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a7cbd8f9cce63535b6d1196e067deecff">rw_lock_lock_word_decr</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint amount)</td></tr>
<tr class="separator:a7cbd8f9cce63535b6d1196e067deecff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2190009fb2d146f6b082fda6a339452"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE lint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ae2190009fb2d146f6b082fda6a339452">rw_lock_lock_word_incr</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint amount)</td></tr>
<tr class="separator:ae2190009fb2d146f6b082fda6a339452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d25e4a616558afa15d4c302d42c1f3c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a1d25e4a616558afa15d4c302d42c1f3c">rw_lock_set_writer_id_and_recursion_flag</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ibool recursive)</td></tr>
<tr class="separator:a1d25e4a616558afa15d4c302d42c1f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10a4e60b4bb7754862abd9e5c2aed0c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#af10a4e60b4bb7754862abd9e5c2aed0c">rw_lock_is_locked</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint lock_type)</td></tr>
<tr class="separator:af10a4e60b4bb7754862abd9e5c2aed0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9290b45247a6c4a1887a01252d1fab3f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a9290b45247a6c4a1887a01252d1fab3f">pfs_rw_lock_create_func</a> (<a class="el" href="group___instrumentation__interface.html#ga7baeb029125a5397a970fef39b12cae2">PSI_rwlock_key</a> key, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, const char *cfile_name, ulint cline)</td></tr>
<tr class="separator:a9290b45247a6c4a1887a01252d1fab3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0577be3be289ac48316cae08a68a72"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#afe0577be3be289ac48316cae08a68a72">pfs_rw_lock_x_lock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, const char *file_name, ulint line)</td></tr>
<tr class="separator:afe0577be3be289ac48316cae08a68a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c505f90944273ff022f56a3b9f856cd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a5c505f90944273ff022f56a3b9f856cd">pfs_rw_lock_x_lock_func_nowait</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, const char *file_name, ulint line)</td></tr>
<tr class="separator:a5c505f90944273ff022f56a3b9f856cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66d4c47a27dcbc374e4b49d07ddf061"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ad66d4c47a27dcbc374e4b49d07ddf061">pfs_rw_lock_s_lock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, const char *file_name, ulint line)</td></tr>
<tr class="separator:ad66d4c47a27dcbc374e4b49d07ddf061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad771cd3867aacc202f7a00a98891176e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ad771cd3867aacc202f7a00a98891176e">pfs_rw_lock_s_lock_low</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, const char *file_name, ulint line)</td></tr>
<tr class="separator:ad771cd3867aacc202f7a00a98891176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dccb615868b7971ca9f175c187044bb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a0dccb615868b7971ca9f175c187044bb">pfs_rw_lock_s_unlock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:a0dccb615868b7971ca9f175c187044bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f33224cbf4703c36e78699a215beb5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a06f33224cbf4703c36e78699a215beb5">pfs_rw_lock_x_unlock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:a06f33224cbf4703c36e78699a215beb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839a766cddf1e9c276862d80081021f1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a839a766cddf1e9c276862d80081021f1">pfs_rw_lock_free_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="separator:a839a766cddf1e9c276862d80081021f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a865b35e6bcb6041e1d21fe594be4b51a"><td class="memItemLeft" align="right" valign="top"><a id="a865b35e6bcb6041e1d21fe594be4b51a"></a>
rw_lock_list_t&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_list</b></td></tr>
<tr class="separator:a865b35e6bcb6041e1d21fe594be4b51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f2c7ca7d81c3ccd69421a9ce8a5a65"><td class="memItemLeft" align="right" valign="top"><a id="ab2f2c7ca7d81c3ccd69421a9ce8a5a65"></a>
<a class="el" href="structib__mutex__t.html">ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_list_mutex</b></td></tr>
<tr class="separator:ab2f2c7ca7d81c3ccd69421a9ce8a5a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170e3023b96429fc1d32d3f18e616128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__lock__stats__t.html">rw_lock_stats_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a170e3023b96429fc1d32d3f18e616128">rw_lock_stats</a></td></tr>
<tr class="separator:a170e3023b96429fc1d32d3f18e616128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fc304a651e288e38654cfb6b27f92b"><td class="memItemLeft" align="right" valign="top"><a id="ab3fc304a651e288e38654cfb6b27f92b"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>btr_search_latch_key</b></td></tr>
<tr class="separator:ab3fc304a651e288e38654cfb6b27f92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb51b844b24b1bd76d11a850cfdc719"><td class="memItemLeft" align="right" valign="top"><a id="abcb51b844b24b1bd76d11a850cfdc719"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_lock_key</b></td></tr>
<tr class="separator:abcb51b844b24b1bd76d11a850cfdc719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade753e7e1f5774a5bf99995fb11c8b9a"><td class="memItemLeft" align="right" valign="top"><a id="ade753e7e1f5774a5bf99995fb11c8b9a"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>dict_operation_lock_key</b></td></tr>
<tr class="separator:ade753e7e1f5774a5bf99995fb11c8b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824e66344b15f7dc1d4f9e96a6d2d307"><td class="memItemLeft" align="right" valign="top"><a id="a824e66344b15f7dc1d4f9e96a6d2d307"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>checkpoint_lock_key</b></td></tr>
<tr class="separator:a824e66344b15f7dc1d4f9e96a6d2d307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43262d88bf8b08af3ba9dbedf493b35b"><td class="memItemLeft" align="right" valign="top"><a id="a43262d88bf8b08af3ba9dbedf493b35b"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>fil_space_latch_key</b></td></tr>
<tr class="separator:a43262d88bf8b08af3ba9dbedf493b35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394c46743360a33ce0bef8b7aa0f8f60"><td class="memItemLeft" align="right" valign="top"><a id="a394c46743360a33ce0bef8b7aa0f8f60"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>fts_cache_rw_lock_key</b></td></tr>
<tr class="separator:a394c46743360a33ce0bef8b7aa0f8f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f206cc699ca19b3cab2986221730aae"><td class="memItemLeft" align="right" valign="top"><a id="a5f206cc699ca19b3cab2986221730aae"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>fts_cache_init_rw_lock_key</b></td></tr>
<tr class="separator:a5f206cc699ca19b3cab2986221730aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d0801923ee073ce77dd56a8c395a53"><td class="memItemLeft" align="right" valign="top"><a id="a64d0801923ee073ce77dd56a8c395a53"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>trx_i_s_cache_lock_key</b></td></tr>
<tr class="separator:a64d0801923ee073ce77dd56a8c395a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e942c8962b63517a064edcd95a4ade"><td class="memItemLeft" align="right" valign="top"><a id="a32e942c8962b63517a064edcd95a4ade"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>trx_purge_latch_key</b></td></tr>
<tr class="separator:a32e942c8962b63517a064edcd95a4ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b2e81f8f7de47c30f050451e226e3e"><td class="memItemLeft" align="right" valign="top"><a id="ad4b2e81f8f7de47c30f050451e226e3e"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>index_tree_rw_lock_key</b></td></tr>
<tr class="separator:ad4b2e81f8f7de47c30f050451e226e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf54c2ae15a14d29e584ff869136f6ef"><td class="memItemLeft" align="right" valign="top"><a id="adf54c2ae15a14d29e584ff869136f6ef"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>index_online_log_key</b></td></tr>
<tr class="separator:adf54c2ae15a14d29e584ff869136f6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358cadbdf8259d3ab3521702aa85d78"><td class="memItemLeft" align="right" valign="top"><a id="a2358cadbdf8259d3ab3521702aa85d78"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>dict_table_stats_key</b></td></tr>
<tr class="separator:a2358cadbdf8259d3ab3521702aa85d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a07eddfb32f12ea2f6b0927bd9a7d2"><td class="memItemLeft" align="right" valign="top"><a id="a46a07eddfb32f12ea2f6b0927bd9a7d2"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>trx_sys_rw_lock_key</b></td></tr>
<tr class="separator:a46a07eddfb32f12ea2f6b0927bd9a7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc0ed69788cff013e0e14ac4d215880"><td class="memItemLeft" align="right" valign="top"><a id="a0bc0ed69788cff013e0e14ac4d215880"></a>
mysql_pfs_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table_rw_lock_key</b></td></tr>
<tr class="separator:a0bc0ed69788cff013e0e14ac4d215880"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The read-write lock (for threads, not for database transactions)</p>
<p>Created 9/11/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9290b45247a6c4a1887a01252d1fab3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9290b45247a6c4a1887a01252d1fab3f">&#9670;&nbsp;</a></span>pfs_rw_lock_create_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void pfs_rw_lock_create_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___instrumentation__interface.html#ga7baeb029125a5397a970fef39b12cae2">PSI_rwlock_key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cfile_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performance schema instrumented wrap function for <a class="el" href="sync0rw_8h.html#a8e7ca59c85c0d221ad9e4a2779988d3f">rw_lock_create_func()</a> NOTE! Please use the corresponding macro rw_lock_create(), not directly this function! in: file line where created </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>in: key registered with performance schema </td></tr>
    <tr><td class="paramname">lock</td><td>in: rw lock </td></tr>
    <tr><td class="paramname">cfile_name</td><td>in: file name where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a839a766cddf1e9c276862d80081021f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839a766cddf1e9c276862d80081021f1">&#9670;&nbsp;</a></span>pfs_rw_lock_free_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void pfs_rw_lock_free_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performance schema instrumented wrap function for <a class="el" href="sync0rw_8h.html#af66e0a54048b7143a68813277bc70f5b">rw_lock_free_func()</a> NOTE! Please use the corresponding macro rw_lock_free(), not directly this function! in: rw-lock </p>

</div>
</div>
<a id="ad66d4c47a27dcbc374e4b49d07ddf061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66d4c47a27dcbc374e4b49d07ddf061">&#9670;&nbsp;</a></span>pfs_rw_lock_s_lock_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void pfs_rw_lock_s_lock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performance schema instrumented wrap function for <a class="el" href="sync0rw_8h.html#a1dfb8bac26c0ede1f1cbb1c94d415370">rw_lock_s_lock_func()</a> NOTE! Please use the corresponding macro rw_lock_s_lock(), not directly this function! in: line where requested </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad771cd3867aacc202f7a00a98891176e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad771cd3867aacc202f7a00a98891176e">&#9670;&nbsp;</a></span>pfs_rw_lock_s_lock_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool pfs_rw_lock_s_lock_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performance schema instrumented wrap function for <a class="el" href="sync0rw_8h.html#a1dfb8bac26c0ede1f1cbb1c94d415370">rw_lock_s_lock_func()</a> NOTE! Please use the corresponding macro rw_lock_s_lock(), not directly this function! </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success in: line where requested </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dccb615868b7971ca9f175c187044bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dccb615868b7971ca9f175c187044bb">&#9670;&nbsp;</a></span>pfs_rw_lock_s_unlock_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void pfs_rw_lock_s_unlock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performance schema instrumented wrap function for <a class="el" href="sync0rw_8h.html#a7c4ddd6b7f654b585865be38a855c9c8">rw_lock_s_unlock_func()</a> NOTE! Please use the corresponding macro rw_lock_s_unlock(), not directly this function! in/out: rw-lock </p>

</div>
</div>
<a id="afe0577be3be289ac48316cae08a68a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0577be3be289ac48316cae08a68a72">&#9670;&nbsp;</a></span>pfs_rw_lock_x_lock_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void pfs_rw_lock_x_lock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performance schema instrumented wrap function for <a class="el" href="sync0rw_8h.html#af847cc23edeba216e1d5381f1facdf3f">rw_lock_x_lock_func()</a> NOTE! Please use the corresponding macro rw_lock_x_lock(), not directly this function! in: line where requested </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c505f90944273ff022f56a3b9f856cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c505f90944273ff022f56a3b9f856cd">&#9670;&nbsp;</a></span>pfs_rw_lock_x_lock_func_nowait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool pfs_rw_lock_x_lock_func_nowait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performance schema instrumented wrap function for <a class="el" href="sync0rw_8h.html#a9ec3c37952ede1fb7178c8ee66c35b14">rw_lock_x_lock_func_nowait()</a> NOTE! Please use the corresponding macro, not directly this function! </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success in: line where requested </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06f33224cbf4703c36e78699a215beb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f33224cbf4703c36e78699a215beb5">&#9670;&nbsp;</a></span>pfs_rw_lock_x_unlock_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void pfs_rw_lock_x_unlock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performance schema instrumented wrap function for <a class="el" href="sync0rw_8h.html#a7c4ddd6b7f654b585865be38a855c9c8">rw_lock_s_unlock_func()</a> NOTE! Please use the corresponding macro rw_lock_x_unlock(), not directly this function! in/out: rw-lock </p>

</div>
</div>
<a id="a8e7ca59c85c0d221ad9e4a2779988d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7ca59c85c0d221ad9e4a2779988d3f">&#9670;&nbsp;</a></span>rw_lock_create_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_create_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cfile_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates, or rather, initializes an rw-lock object in a specified memory location (which must be appropriately aligned). The rw-lock is initialized to the non-locked state. Explicit freeing of the rw-lock with rw_lock_free is necessary only if the memory block containing it is freed. in: file line where created</p>
<p>Creates, or rather, initializes an rw-lock object in a specified memory location (which must be appropriately aligned). The rw-lock is initialized to the non-locked state. Explicit freeing of the rw-lock with rw_lock_free is necessary only if the memory block containing it is freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to memory </td></tr>
    <tr><td class="paramname">cfile_name</td><td>in: file name where created </td></tr>
    <tr><td class="paramname">cline</td><td>in: file line where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af66e0a54048b7143a68813277bc70f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66e0a54048b7143a68813277bc70f5b">&#9670;&nbsp;</a></span>rw_lock_free_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_free_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calling this function is obligatory only if the memory buffer containing the rw-lock is freed. Removes an rw-lock object from the global list. The rw-lock is checked to be in the non-locked state. in: rw-lock</p>
<p>Calling this function is obligatory only if the memory buffer containing the rw-lock is freed. Removes an rw-lock object from the global list. The rw-lock is checked to be in the non-locked state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae24ac5c3f41388704830966b07d50936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24ac5c3f41388704830966b07d50936">&#9670;&nbsp;</a></span>rw_lock_get_reader_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_reader_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of readers. </p><dl class="section return"><dt>Returns</dt><dd>number of readers in: rw-lock </dd></dl>

</div>
</div>
<a id="accc192baf074e7cba3590651df4b4194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc192baf074e7cba3590651df4b4194">&#9670;&nbsp;</a></span>rw_lock_get_waiters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_waiters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if there are threads waiting for the rw-lock. </p><dl class="section return"><dt>Returns</dt><dd>1 if waiters, 0 otherwise in: rw-lock </dd></dl>

</div>
</div>
<a id="acd5acf23523e06ae0ce287173349c2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5acf23523e06ae0ce287173349c2ff">&#9670;&nbsp;</a></span>rw_lock_get_writer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_writer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the write-status of the lock - this function made more sense with the old rw_lock implementation. </p><dl class="section return"><dt>Returns</dt><dd>RW_LOCK_NOT_LOCKED, RW_LOCK_EX, RW_LOCK_WAIT_EX in: rw-lock </dd></dl>

</div>
</div>
<a id="add5b9c0969702ede99cdabbbc40fce33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5b9c0969702ede99cdabbbc40fce33">&#9670;&nbsp;</a></span>rw_lock_get_x_lock_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_x_lock_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of writer_count for the lock. Does not reserve the lock mutex, so the caller must be sure it is not changed during the call. </p><dl class="section return"><dt>Returns</dt><dd>value of writer_count in: rw-lock </dd></dl>

</div>
</div>
<a id="af10a4e60b4bb7754862abd9e5c2aed0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10a4e60b4bb7754862abd9e5c2aed0c">&#9670;&nbsp;</a></span>rw_lock_is_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool rw_lock_is_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if somebody has locked the rw-lock in the specified mode. in: lock type: RW_LOCK_SHARED, RW_LOCK_EX</p>
<p>Checks if somebody has locked the rw-lock in the specified mode. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if locked </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
    <tr><td class="paramname">lock_type</td><td>in: lock type: RW_LOCK_SHARED, RW_LOCK_EX </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cbd8f9cce63535b6d1196e067deecff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbd8f9cce63535b6d1196e067deecff">&#9670;&nbsp;</a></span>rw_lock_lock_word_decr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool rw_lock_lock_word_decr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrements lock_word the specified amount if it is greater than 0. This is used by both s_lock and x_lock operations. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if decr occurs in: amount to decrement </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2190009fb2d146f6b082fda6a339452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2190009fb2d146f6b082fda6a339452">&#9670;&nbsp;</a></span>rw_lock_lock_word_incr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE lint rw_lock_lock_word_incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments lock_word the specified amount and returns new value. </p><dl class="section return"><dt>Returns</dt><dd>lock-&gt;lock_word after increment in: amount to increment </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dfb8bac26c0ede1f1cbb1c94d415370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfb8bac26c0ede1f1cbb1c94d415370">&#9670;&nbsp;</a></span>rw_lock_s_lock_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_s_lock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro, not directly this function, except if you supply the file name and line number. Lock an rw-lock in shared mode for the current thread. If the rw-lock is locked in exclusive mode, or there is an exclusive lock request waiting, the function spins a preset time (controlled by SYNC_SPIN_ROUNDS), waiting for the lock, before suspending the thread. in: line where requested </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e1559e2f5077182255d2a0672d8d337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1559e2f5077182255d2a0672d8d337">&#9670;&nbsp;</a></span>rw_lock_s_lock_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool rw_lock_s_lock_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint pass &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Low-level function which tries to lock an rw-lock in s-mode. Performs no spinning. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success in: line where requested </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c4ddd6b7f654b585865be38a855c9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4ddd6b7f654b585865be38a855c9c8">&#9670;&nbsp;</a></span>rw_lock_s_unlock_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_s_unlock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a shared mode lock. in/out: rw-lock </p>

</div>
</div>
<a id="a1d25e4a616558afa15d4c302d42c1f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d25e4a616558afa15d4c302d42c1f3c">&#9670;&nbsp;</a></span>rw_lock_set_writer_id_and_recursion_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_set_writer_id_and_recursion_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the lock-&gt;writer_thread and lock-&gt;recursive fields. For platforms where we are using atomic builtins instead of lock-&gt;mutex it sets the lock-&gt;writer_thread field using atomics to ensure memory ordering. Note that it is assumed that the caller of this function effectively owns the lock i.e.: nobody else is allowed to modify lock-&gt;writer_thread at this point in time. The protocol is that lock-&gt;writer_thread MUST be updated BEFORE the lock-&gt;recursive flag is set. in: TRUE if recursion allowed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: lock to work on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af847cc23edeba216e1d5381f1facdf3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af847cc23edeba216e1d5381f1facdf3f">&#9670;&nbsp;</a></span>rw_lock_x_lock_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_x_lock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro, not directly this function! Lock an rw-lock in exclusive mode for the current thread. If the rw-lock is locked in shared or exclusive mode, or there is an exclusive lock request waiting, the function spins a preset time (controlled by SYNC_SPIN_ROUNDS), waiting for the lock, before suspending the thread. If the same thread has an x-lock on the rw-lock, locking succeed, with the following exception: if pass != 0, only a single x-lock may be taken on the lock. NOTE: If the same thread has an s-lock, locking does not succeed! in: line where requested</p>
<p>NOTE! Use the corresponding macro, not directly this function! Lock an rw-lock in exclusive mode for the current thread. If the rw-lock is locked in shared or exclusive mode, or there is an exclusive lock request waiting, the function spins a preset time (controlled by SYNC_SPIN_ROUNDS), waiting for the lock before suspending the thread. If the same thread has an x-lock on the rw-lock, locking succeed, with the following exception: if pass != 0, only a single x-lock may be taken on the lock. NOTE: If the same thread has an s-lock, locking does not succeed! </p>
<p>&lt; spin round count</p>
<p>&lt; index of the reserved wait cell </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ec3c37952ede1fb7178c8ee66c35b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec3c37952ede1fb7178c8ee66c35b14">&#9670;&nbsp;</a></span>rw_lock_x_lock_func_nowait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool rw_lock_x_lock_func_nowait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro, not directly this function! Lock an rw-lock in exclusive mode for the current thread if the lock can be obtained immediately. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success in: line where requested </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4ab05eba9ad152bc256180ef5430465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ab05eba9ad152bc256180ef5430465">&#9670;&nbsp;</a></span>rw_lock_x_lock_move_ownership()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_x_lock_move_ownership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used in the insert buffer to move the ownership of an x-latch on a buffer frame to the current thread. The x-latch was set by the buffer read operation and it protected the buffer frame while the read was done. The ownership is moved because we want that the current thread is able to acquire a second x-latch which is stored in an mtr. This, in turn, is needed to pass the debug checks of index page operations. in: lock which was x-locked in the buffer read</p>
<p>This function is used in the insert buffer to move the ownership of an x-latch on a buffer frame to the current thread. The x-latch was set by the buffer read operation and it protected the buffer frame while the read was done. The ownership is moved because we want that the current thread is able to acquire a second x-latch which is stored in an mtr. This, in turn, is needed to pass the debug checks of index page operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock which was x-locked in the buffer read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b696c942c9167dd8e868cc26375a403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b696c942c9167dd8e868cc26375a403">&#9670;&nbsp;</a></span>rw_lock_x_unlock_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_x_unlock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases an exclusive mode lock. in/out: rw-lock </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a170e3023b96429fc1d32d3f18e616128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170e3023b96429fc1d32d3f18e616128">&#9670;&nbsp;</a></span>rw_lock_stats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__lock__stats__t.html">rw_lock_stats_t</a> rw_lock_stats</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counters for RW locks. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

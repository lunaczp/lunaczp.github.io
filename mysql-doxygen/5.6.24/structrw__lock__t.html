<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: rw_lock_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structrw__lock__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rw_lock_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sync0rw_8h_source.html">sync0rw.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad9707b2e08e20d7b496f7ddd5fdd1d6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#ad9707b2e08e20d7b496f7ddd5fdd1d6a">UT_LIST_NODE_T</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a>) list</td></tr>
<tr class="separator:ad9707b2e08e20d7b496f7ddd5fdd1d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a27674049fdc48cf15e5f2cf6ed7297b8"><td class="memItemLeft" align="right" valign="top">volatile lint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a27674049fdc48cf15e5f2cf6ed7297b8">lock_word</a></td></tr>
<tr class="separator:a27674049fdc48cf15e5f2cf6ed7297b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13331c41c505a694820ef9a5103cf331"><td class="memItemLeft" align="right" valign="top">volatile ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a13331c41c505a694820ef9a5103cf331">waiters</a></td></tr>
<tr class="separator:a13331c41c505a694820ef9a5103cf331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad070dd43b1e0f521cddd6a34ee136b9a"><td class="memItemLeft" align="right" valign="top">volatile ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#ad070dd43b1e0f521cddd6a34ee136b9a">recursive</a></td></tr>
<tr class="separator:ad070dd43b1e0f521cddd6a34ee136b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a9b8daf73c1c35f4d30632848df08b"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="os0thread_8h.html#a0e87ca653f4358a387e610ee5c542f74">os_thread_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a09a9b8daf73c1c35f4d30632848df08b">writer_thread</a></td></tr>
<tr class="separator:a09a9b8daf73c1c35f4d30632848df08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa382fc2d173f94864e88057aaa15e09b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#aa382fc2d173f94864e88057aaa15e09b">event</a></td></tr>
<tr class="separator:aa382fc2d173f94864e88057aaa15e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782d7ac356b97fee7edec4681dd22391"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a782d7ac356b97fee7edec4681dd22391">wait_ex_event</a></td></tr>
<tr class="separator:a782d7ac356b97fee7edec4681dd22391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136a4534c654942c2d24bd1960fbddcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structib__mutex__t.html">ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a136a4534c654942c2d24bd1960fbddcb">mutex</a></td></tr>
<tr class="separator:a136a4534c654942c2d24bd1960fbddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ced05bdef63646e45941e3a622fa5eb"><td class="memItemLeft" align="right" valign="top">struct PSI_rwlock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a9ced05bdef63646e45941e3a622fa5eb">pfs_psi</a></td></tr>
<tr class="separator:a9ced05bdef63646e45941e3a622fa5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ef9818a990b7cff8d65dfac388a4f4"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a37ef9818a990b7cff8d65dfac388a4f4">count_os_wait</a></td></tr>
<tr class="separator:a37ef9818a990b7cff8d65dfac388a4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e6a454de925915243d64a3d2ce0730"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a63e6a454de925915243d64a3d2ce0730">cfile_name</a></td></tr>
<tr class="separator:a63e6a454de925915243d64a3d2ce0730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a498a7f33893e3c31d8147b1a9bd5f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a73a498a7f33893e3c31d8147b1a9bd5f">last_s_file_name</a></td></tr>
<tr class="separator:a73a498a7f33893e3c31d8147b1a9bd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa001b622f460caca77cd274f84a5c00"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#aaa001b622f460caca77cd274f84a5c00">last_x_file_name</a></td></tr>
<tr class="separator:aaa001b622f460caca77cd274f84a5c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab641f9504e78011dc263e73c2435e166"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#ab641f9504e78011dc263e73c2435e166">writer_is_wait_ex</a></td></tr>
<tr class="separator:ab641f9504e78011dc263e73c2435e166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe5bdcaddb99c722fe45aea9a1cae40"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#abbe5bdcaddb99c722fe45aea9a1cae40">cline</a>:14</td></tr>
<tr class="separator:abbe5bdcaddb99c722fe45aea9a1cae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c8fb39c75f22fe02cf117fcbc5e1eb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#af1c8fb39c75f22fe02cf117fcbc5e1eb">last_s_line</a>:14</td></tr>
<tr class="separator:af1c8fb39c75f22fe02cf117fcbc5e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07965f511a71db9887f00ad223c593f4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html#a07965f511a71db9887f00ad223c593f4">last_x_line</a>:14</td></tr>
<tr class="separator:a07965f511a71db9887f00ad223c593f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The structure used in the spin lock implementation of a read-write lock. Several threads may have a shared lock simultaneously in this lock, but only one writer may have an exclusive lock, in which case no shared locks are allowed. To prevent starving of a writer blocked by readers, a writer may queue for x-lock by decrementing lock_word: no new readers will be let in while the thread waits for readers to exit. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9707b2e08e20d7b496f7ddd5fdd1d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9707b2e08e20d7b496f7ddd5fdd1d6a">&#9670;&nbsp;</a></span>UT_LIST_NODE_T()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rw_lock_t::UT_LIST_NODE_T </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All allocated rw locks are put into a list </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a63e6a454de925915243d64a3d2ce0730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e6a454de925915243d64a3d2ce0730">&#9670;&nbsp;</a></span>cfile_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rw_lock_t::cfile_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>File name where lock created </p>

</div>
</div>
<a id="abbe5bdcaddb99c722fe45aea9a1cae40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe5bdcaddb99c722fe45aea9a1cae40">&#9670;&nbsp;</a></span>cline</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rw_lock_t::cline</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Line where created </p>

</div>
</div>
<a id="a37ef9818a990b7cff8d65dfac388a4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ef9818a990b7cff8d65dfac388a4f4">&#9670;&nbsp;</a></span>count_os_wait</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint rw_lock_t::count_os_wait</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count of os_waits. May not be accurate </p>

</div>
</div>
<a id="aa382fc2d173f94864e88057aaa15e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa382fc2d173f94864e88057aaa15e09b">&#9670;&nbsp;</a></span>event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> rw_lock_t::event</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used by <a class="el" href="sync0arr_8cc.html">sync0arr.cc</a> for thread queueing </p>

</div>
</div>
<a id="a73a498a7f33893e3c31d8147b1a9bd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a498a7f33893e3c31d8147b1a9bd5f">&#9670;&nbsp;</a></span>last_s_file_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rw_lock_t::last_s_file_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>File name where last s-locked </p>

</div>
</div>
<a id="af1c8fb39c75f22fe02cf117fcbc5e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c8fb39c75f22fe02cf117fcbc5e1eb">&#9670;&nbsp;</a></span>last_s_line</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rw_lock_t::last_s_line</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Line number where last time s-locked </p>

</div>
</div>
<a id="aaa001b622f460caca77cd274f84a5c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa001b622f460caca77cd274f84a5c00">&#9670;&nbsp;</a></span>last_x_file_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rw_lock_t::last_x_file_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>File name where last x-locked </p>

</div>
</div>
<a id="a07965f511a71db9887f00ad223c593f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07965f511a71db9887f00ad223c593f4">&#9670;&nbsp;</a></span>last_x_line</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rw_lock_t::last_x_line</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Line number where last time x-locked </p>

</div>
</div>
<a id="a27674049fdc48cf15e5f2cf6ed7297b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27674049fdc48cf15e5f2cf6ed7297b8">&#9670;&nbsp;</a></span>lock_word</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile lint rw_lock_t::lock_word</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Holds the state of the lock. </p>

</div>
</div>
<a id="a136a4534c654942c2d24bd1960fbddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136a4534c654942c2d24bd1960fbddcb">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structib__mutex__t.html">ib_mutex_t</a> rw_lock_t::mutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The mutex protecting <a class="el" href="structrw__lock__t.html">rw_lock_t</a> </p>

</div>
</div>
<a id="a9ced05bdef63646e45941e3a622fa5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ced05bdef63646e45941e3a622fa5eb">&#9670;&nbsp;</a></span>pfs_psi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct PSI_rwlock* rw_lock_t::pfs_psi</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The instrumentation hook </p>

</div>
</div>
<a id="ad070dd43b1e0f521cddd6a34ee136b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad070dd43b1e0f521cddd6a34ee136b9a">&#9670;&nbsp;</a></span>recursive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile ibool rw_lock_t::recursive</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default value FALSE which means the lock is non-recursive. The value is typically set to TRUE making normal rw_locks recursive. In case of asynchronous IO, when a non-zero value of 'pass' is passed then we keep the lock non-recursive. This flag also tells us about the state of writer_thread field. If this flag is set then writer_thread MUST contain the thread id of the current x-holder or wait-x thread. This flag must be reset in x_unlock functions before incrementing the lock_word </p>

</div>
</div>
<a id="a782d7ac356b97fee7edec4681dd22391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782d7ac356b97fee7edec4681dd22391">&#9670;&nbsp;</a></span>wait_ex_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> rw_lock_t::wait_ex_event</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event for next-writer to wait on. A thread must decrement lock_word before waiting. </p>

</div>
</div>
<a id="a13331c41c505a694820ef9a5103cf331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13331c41c505a694820ef9a5103cf331">&#9670;&nbsp;</a></span>waiters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile ulint rw_lock_t::waiters</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>1: there are waiters </p>

</div>
</div>
<a id="ab641f9504e78011dc263e73c2435e166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab641f9504e78011dc263e73c2435e166">&#9670;&nbsp;</a></span>writer_is_wait_ex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool rw_lock_t::writer_is_wait_ex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is TRUE if the writer field is RW_LOCK_WAIT_EX; this field is located far from the memory update hotspot fields which are at the start of this struct, thus we can peek this field without causing much memory bus traffic </p>

</div>
</div>
<a id="a09a9b8daf73c1c35f4d30632848df08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a9b8daf73c1c35f4d30632848df08b">&#9670;&nbsp;</a></span>writer_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="os0thread_8h.html#a0e87ca653f4358a387e610ee5c542f74">os_thread_id_t</a> rw_lock_t::writer_thread</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread id of writer thread. Is only guaranteed to have sane and non-stale value iff recursive flag is set. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>storage/innobase/include/<a class="el" href="sync0rw_8h_source.html">sync0rw.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

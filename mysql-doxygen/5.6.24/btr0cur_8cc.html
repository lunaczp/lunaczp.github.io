<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/btr/btr0cur.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_f48f5f24c3af6e5b48618127168756b9.html">btr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">btr0cur.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0log_8h_source.html">mtr0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0rec_8h_source.html">rem0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0log_8h_source.html">row0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0purge_8h_source.html">row0purge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0rec_8h_source.html">trx0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0roll_8h_source.html">trx0roll.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0row_8h_source.html">row0row.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;zlib.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4676319e3e8cde7d9790089fe965df40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a4676319e3e8cde7d9790089fe965df40">BTR_CUR_PAGE_REORGANIZE_LIMIT</a>&#160;&#160;&#160;(UNIV_PAGE_SIZE / 32)</td></tr>
<tr class="separator:a4676319e3e8cde7d9790089fe965df40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e31d2f2c964ed620e7379a4196fbd"><td class="memItemLeft" align="right" valign="top"><a id="a9e4e31d2f2c964ed620e7379a4196fbd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>N_PAGES_READ_LIMIT</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a9e4e31d2f2c964ed620e7379a4196fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8d18327a6158583ba43c082f1e96a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a6a8d18327a6158583ba43c082f1e96a2">btr_rec_get_field_ref</a>(<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>,  <a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>,  <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)&#160;&#160;&#160;((<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>) + <a class="el" href="btr0cur_8cc.html#adf9151a0d4ebaee472d93bfd55f835f2">btr_rec_get_field_ref_offs</a>(<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>))</td></tr>
<tr class="separator:a6a8d18327a6158583ba43c082f1e96a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad2fa20fa4bf99570a15c9dcc0bbd0eb9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ad2fa20fa4bf99570a15c9dcc0bbd0eb9">BTR_BLOB_HDR_PART_LEN</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ad2fa20fa4bf99570a15c9dcc0bbd0eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81829f0bccb1547a55fd6461c1b8473e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a81829f0bccb1547a55fd6461c1b8473e">BTR_BLOB_HDR_NEXT_PAGE_NO</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a81829f0bccb1547a55fd6461c1b8473e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5f81ea5d3109de24a617dcecfe90b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aea5f81ea5d3109de24a617dcecfe90b4">BTR_BLOB_HDR_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:aea5f81ea5d3109de24a617dcecfe90b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76518092843bb988e2222a5712cc0a9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a76518092843bb988e2222a5712cc0a9f">BTR_TABLE_STATS_FROM_SAMPLE</a>(value,  <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>,  sample,  ext_size,  not_empty)</td></tr>
<tr class="separator:a76518092843bb988e2222a5712cc0a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac8e1e7dcb5ea919124b9d6e8e868bbc8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8">btr_op_t</a> { <br />
&#160;&#160;<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8a84f603208288c0b21ebee05430ca4229">BTR_NO_OP</a> = 0, 
<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8af727af06be5922ef5e53314387951e52">BTR_INSERT_OP</a>, 
<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8a791b52e53c17e5174c4a38d4b93d5fdb">BTR_INSERT_IGNORE_UNIQUE_OP</a>, 
<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8a4d7f260f169e344aa04a3df1a3100c63">BTR_DELETE_OP</a>, 
<br />
&#160;&#160;<a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8ac67a876f7a3a5ebc554eb5170a6604e4">BTR_DELMARK_OP</a>
<br />
 }</td></tr>
<tr class="separator:ac8e1e7dcb5ea919124b9d6e8e868bbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1097d8a403bf691a8345e5e581aeae84"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a1097d8a403bf691a8345e5e581aeae84">btr_cur_unmark_extern_fields</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a1097d8a403bf691a8345e5e581aeae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d25b1d3defc3c7b44c623f71c32dfce"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a8d25b1d3defc3c7b44c623f71c32dfce">btr_cur_add_path_info</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint height, ulint root_height)</td></tr>
<tr class="separator:a8d25b1d3defc3c7b44c623f71c32dfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e8222dc60b8dec80cac33498a15a2a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a28e8222dc60b8dec80cac33498a15a2a">btr_rec_free_updated_extern_fields</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a> rb_ctx, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a28e8222dc60b8dec80cac33498a15a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599b288d0f486987f54d85ce1c533d0e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a599b288d0f486987f54d85ce1c533d0e">btr_rec_free_externally_stored_fields</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a> rb_ctx, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a599b288d0f486987f54d85ce1c533d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649dfaf6f1de1688d814e6e95ac1caf5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a649dfaf6f1de1688d814e6e95ac1caf5">btr_rec_set_deleted_flag</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint flag)</td></tr>
<tr class="separator:a649dfaf6f1de1688d814e6e95ac1caf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d02a22ead9dd703eecfda611ac1e8f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a75d02a22ead9dd703eecfda611ac1e8f">btr_cur_latch_leaves</a> (<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a75d02a22ead9dd703eecfda611ac1e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a13fbc0aaa77d0f1164914785757c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, ulint <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint has_search_latch, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a82a13fbc0aaa77d0f1164914785757c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629bd7d543ce4b486a11ac6054d033a2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a629bd7d543ce4b486a11ac6054d033a2">btr_cur_open_at_index_side_func</a> (bool from_left, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint <a class="el" href="btr0btr_8cc.html#a46e504d299fb7ca943fc98a74051f564">level</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a629bd7d543ce4b486a11ac6054d033a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b17c00c932d341c9b0cbe9e0b23642"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ac6b17c00c932d341c9b0cbe9e0b23642">btr_cur_open_at_rnd_pos_func</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, const char *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac6b17c00c932d341c9b0cbe9e0b23642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ce4257c4707454c73e179f9006f5fe"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a84ce4257c4707454c73e179f9006f5fe">__attribute__</a> ((nonnull, warn_unused_result)) rec_t *btr_cur_insert_if_possible(<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a></td></tr>
<tr class="separator:a84ce4257c4707454c73e179f9006f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b866974e4ec2f6f04d3bd948e1cadc1"><td class="memItemLeft" align="right" valign="top"><a id="a8b866974e4ec2f6f04d3bd948e1cadc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="data0data_8h.html#ad6046cd1f70b59d3525615146b59baa6">dtuple_check_typed</a>(<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>))</td></tr>
<tr class="separator:a8b866974e4ec2f6f04d3bd948e1cadc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fc2be6fe3b0be3da2f6a20d9edf908"><td class="memItemLeft" align="right" valign="top"><a id="a47fc2be6fe3b0be3da2f6a20d9edf908"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (mtr_memo_contains(<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, btr_cur_get_block(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>), MTR_MEMO_PAGE_X_FIX))</td></tr>
<tr class="separator:a47fc2be6fe3b0be3da2f6a20d9edf908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dbdebba02efe731816a3579c8407d6"><td class="memItemLeft" align="right" valign="top"><a id="ab2dbdebba02efe731816a3579c8407d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (!<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a> &amp;&amp;!page_cur_get_page_zip(page_cursor) &amp;&amp;<a class="el" href="btr0btr_8h.html#af34a132467928688ce50eb2c17f71cfc">btr_page_reorganize</a>(page_cursor, <a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>-&gt;<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>))</td></tr>
<tr class="separator:ab2dbdebba02efe731816a3579c8407d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0d0960d02a466c5dafccb6558a855b"><td class="memItemLeft" align="right" valign="top"><a id="ace0d0960d02a466c5dafccb6558a855b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (!<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>||rec_offs_validate(<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>-&gt;<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>))</td></tr>
<tr class="separator:ace0d0960d02a466c5dafccb6558a855b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefec18ed108f702850dd425fe3385595"><td class="memItemLeft" align="right" valign="top"><a id="aefec18ed108f702850dd425fe3385595"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:aefec18ed108f702850dd425fe3385595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17c7aca3c9b98ea596c57c77e42ec55"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ad17c7aca3c9b98ea596c57c77e42ec55">__attribute__</a> ((warn_unused_result, nonnull(2, 3, 5, 6))) <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_ins_lock_and_undo(ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a></td></tr>
<tr class="separator:ad17c7aca3c9b98ea596c57c77e42ec55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0a82ab0f493135bcba2ca666d9850e"><td class="memItemLeft" align="right" valign="top"><a id="aac0a82ab0f493135bcba2ca666d9850e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (!<a class="el" href="dict0dict_8h.html#a4673894c367f28fa05badc046e6936a1">dict_index_is_online_ddl</a>(<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)||<a class="el" href="dict0dict_8h.html#af8741b8516077d237960a59240f7d950">dict_index_is_clust</a>(<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)||(<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a> &amp;<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5aa2e940baf537747a3cda3db0a2cbb865">BTR_CREATE_FLAG</a>))</td></tr>
<tr class="separator:aac0a82ab0f493135bcba2ca666d9850e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a58d02b1d2bad2652b6e7de43fb9bb"><td class="memItemLeft" align="right" valign="top"><a id="a28a58d02b1d2bad2652b6e7de43fb9bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (!(<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a> &amp;<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5a159501d7bc944849faa8082ce7b55466">BTR_KEEP_SYS_FLAG</a>))</td></tr>
<tr class="separator:a28a58d02b1d2bad2652b6e7de43fb9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcc2ada2a58da05de9b82cb8aeac9a7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aedcc2ada2a58da05de9b82cb8aeac9a7">btr_cur_optimistic_insert</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, rec_t **<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **<a class="el" href="row0ins_8cc.html#af030ac6538d68182f7760506abdafc69">big_rec</a>, ulint <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:aedcc2ada2a58da05de9b82cb8aeac9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fdcfe6aa08e8d6f9ce4af72d05ddb0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a34fdcfe6aa08e8d6f9ce4af72d05ddb0">btr_cur_pessimistic_insert</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="struct__entry.html">entry</a>, rec_t **<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **<a class="el" href="row0ins_8cc.html#af030ac6538d68182f7760506abdafc69">big_rec</a>, ulint <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a34fdcfe6aa08e8d6f9ce4af72d05ddb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f30c7cc54155670a51d7a9d57e7d3a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a71f30c7cc54155670a51d7a9d57e7d3a">__attribute__</a> ((warn_unused_result, nonnull(2, 3, 6, 7))) <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_upd_lock_and_undo(ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a></td></tr>
<tr class="separator:a71f30c7cc54155670a51d7a9d57e7d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c838ad82743da0eeb159f807f9aca08"><td class="memItemLeft" align="right" valign="top"><a id="a6c838ad82743da0eeb159f807f9aca08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>||(<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a> &amp;<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5a046932973ff414437088666363342436">BTR_NO_LOCKING_FLAG</a>))</td></tr>
<tr class="separator:a6c838ad82743da0eeb159f807f9aca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b062ae162ff1ce6055d7bad39fd187"><td class="memItemLeft" align="right" valign="top"><a id="ad0b062ae162ff1ce6055d7bad39fd187"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (rec_offs_validate(<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>))</td></tr>
<tr class="separator:ad0b062ae162ff1ce6055d7bad39fd187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108ea1e7a90ad3dd76aba193d9fad04d"><td class="memItemLeft" align="right" valign="top"><a id="a108ea1e7a90ad3dd76aba193d9fad04d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (!<a class="el" href="dict0dict_8h.html#af8741b8516077d237960a59240f7d950">dict_index_is_clust</a>(<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>))</td></tr>
<tr class="separator:a108ea1e7a90ad3dd76aba193d9fad04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7acef1182eda3c17bfbe137d600d389"><td class="memItemLeft" align="right" valign="top"><a id="ae7acef1182eda3c17bfbe137d600d389"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (!(<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a> &amp;<a class="el" href="btr0cur_8h.html#aa7df87806f64f3b241c8cde9eb57cad5a046932973ff414437088666363342436">BTR_NO_LOCKING_FLAG</a>))</td></tr>
<tr class="separator:ae7acef1182eda3c17bfbe137d600d389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c26bbbb99376f13e539d82f060e753f"><td class="memItemLeft" align="right" valign="top"><a id="a7c26bbbb99376f13e539d82f060e753f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (<a class="el" href="trx0rec_8cc.html#ad4c535b4d1fd59a4e56cf4f43b442314">trx_undo_report_row_operation</a>(<a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, TRX_UNDO_MODIFY_OP, <a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, NULL, <a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="btr0cur_8cc.html#ab7e363c98b33d8339e7170309cd05207">cmpl_info</a>, <a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a>))</td></tr>
<tr class="separator:a7c26bbbb99376f13e539d82f060e753f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee589ffc2bbe2baeef4aa270d839eaa0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aee589ffc2bbe2baeef4aa270d839eaa0">btr_cur_update_in_place_log</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> <a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:aee589ffc2bbe2baeef4aa270d839eaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06c6cbe14c2af25f2240b5e54aa1d5a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ad06c6cbe14c2af25f2240b5e54aa1d5a">btr_cur_parse_update_in_place</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:ad06c6cbe14c2af25f2240b5e54aa1d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73fe14abad54b535be2ef8914cc9af"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a0e73fe14abad54b535be2ef8914cc9af">btr_cur_update_alloc_zip_func</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structpage__cur__t.html">page_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, ulint length, bool create, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a0e73fe14abad54b535be2ef8914cc9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c229db0c9e7a45d3e5deba525eee172"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a9c229db0c9e7a45d3e5deba525eee172">btr_cur_update_in_place</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, ulint <a class="el" href="btr0cur_8cc.html#ab7e363c98b33d8339e7170309cd05207">cmpl_info</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a9c229db0c9e7a45d3e5deba525eee172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28009a77b6c56d6fe8fe6cfe9b1a1672"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a28009a77b6c56d6fe8fe6cfe9b1a1672">btr_cur_optimistic_update</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, ulint <a class="el" href="btr0cur_8cc.html#ab7e363c98b33d8339e7170309cd05207">cmpl_info</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a28009a77b6c56d6fe8fe6cfe9b1a1672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a8df6cc43f61d2a90dceb886983ef9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#af8a8df6cc43f61d2a90dceb886983ef9">btr_cur_pess_upd_restore_supremum</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:af8a8df6cc43f61d2a90dceb886983ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b65c349282e853286b7a51e0197a202"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a5b65c349282e853286b7a51e0197a202">btr_check_blob_limit</a> (const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *big_rec_vec)</td></tr>
<tr class="separator:a5b65c349282e853286b7a51e0197a202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b74099a04e706fcd43989aa373e9bd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a64b74099a04e706fcd43989aa373e9bd">btr_cur_pessimistic_update</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint **<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **<a class="el" href="row0upd_8cc.html#af327d0841463e479f70421eaf979de1b">offsets_heap</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *entry_heap, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **<a class="el" href="row0ins_8cc.html#af030ac6538d68182f7760506abdafc69">big_rec</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, ulint <a class="el" href="btr0cur_8cc.html#ab7e363c98b33d8339e7170309cd05207">cmpl_info</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a64b74099a04e706fcd43989aa373e9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770e0a5b2cd615f9d598bb931b0474be"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a770e0a5b2cd615f9d598bb931b0474be">btr_cur_del_mark_set_clust_rec_log</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> <a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a770e0a5b2cd615f9d598bb931b0474be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67626b88e4c9b6e4bd41bc71d432e095"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a67626b88e4c9b6e4bd41bc71d432e095">btr_cur_parse_del_mark_set_clust_rec</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:a67626b88e4c9b6e4bd41bc71d432e095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab141b416d488f70486cfc04e65887a7b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ab141b416d488f70486cfc04e65887a7b">btr_cur_del_mark_set_clust_rec</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ab141b416d488f70486cfc04e65887a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b5e425b158cb805c7a59d8d52ffc10"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a78b5e425b158cb805c7a59d8d52ffc10">btr_cur_del_mark_set_sec_rec_log</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, ibool val, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a78b5e425b158cb805c7a59d8d52ffc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8d168c724c8ac87371442df85fc233"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a3d8d168c724c8ac87371442df85fc233">btr_cur_parse_del_mark_set_sec_rec</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="separator:a3d8d168c724c8ac87371442df85fc233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c48710d5682281f4fd0f7fcffeac6d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ab1c48710d5682281f4fd0f7fcffeac6d">btr_cur_del_mark_set_sec_rec</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ibool val, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ab1c48710d5682281f4fd0f7fcffeac6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c43a7dff2e949e99467e0323bcc24f9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a0c43a7dff2e949e99467e0323bcc24f9">btr_cur_set_deleted_flag_for_ibuf</a> (rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ibool val, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a0c43a7dff2e949e99467e0323bcc24f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b81af0e0706d0294ef4f78a24e129cd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a5b81af0e0706d0294ef4f78a24e129cd">btr_cur_compress_if_useful</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ibool adjust, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a5b81af0e0706d0294ef4f78a24e129cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e09b340d9572904cd88353ed791715"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ae4e09b340d9572904cd88353ed791715">btr_cur_optimistic_delete_func</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ae4e09b340d9572904cd88353ed791715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb318f5dd90a5b76b03dfa7b52349048"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#afb318f5dd90a5b76b03dfa7b52349048">btr_cur_pessimistic_delete</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *<a class="el" href="row0import_8cc.html#a52482fdd3721e7db69dc740aefee8ad4">err</a>, ibool has_reserved_extents, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>, ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a> rb_ctx, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:afb318f5dd90a5b76b03dfa7b52349048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6e9e587cdf5dad1145ea99915b6280"><td class="memItemLeft" align="right" valign="top">static ib_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a6d6e9e587cdf5dad1145ea99915b6280">btr_estimate_n_rows_in_range_on_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbtr__path__t.html">btr_path_t</a> *slot1, <a class="el" href="structbtr__path__t.html">btr_path_t</a> *slot2, ib_int64_t n_rows_on_prev_level, ibool *is_n_rows_exact)</td></tr>
<tr class="separator:a6d6e9e587cdf5dad1145ea99915b6280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56a487d045ea12d204c0cbe34ff4c95"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ib_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ac56a487d045ea12d204c0cbe34ff4c95">btr_estimate_n_rows_in_range</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple1, ulint mode1, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple2, ulint mode2)</td></tr>
<tr class="separator:ac56a487d045ea12d204c0cbe34ff4c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3504db9f888c4d4994bf1b8a894b8b90"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a3504db9f888c4d4994bf1b8a894b8b90">btr_record_not_null_field_in_rec</a> (ulint n_unique, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ib_uint64_t *n_not_null)</td></tr>
<tr class="separator:a3504db9f888c4d4994bf1b8a894b8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50de491c34525f93cbe27307044ea89"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ab50de491c34525f93cbe27307044ea89">btr_estimate_number_of_different_key_vals</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)</td></tr>
<tr class="separator:ab50de491c34525f93cbe27307044ea89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9151a0d4ebaee472d93bfd55f835f2"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#adf9151a0d4ebaee472d93bfd55f835f2">btr_rec_get_field_ref_offs</a> (const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>)</td></tr>
<tr class="separator:adf9151a0d4ebaee472d93bfd55f835f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58003b4ea2270cb2170f97974b5f36fa"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a58003b4ea2270cb2170f97974b5f36fa">btr_rec_get_externally_stored_len</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>)</td></tr>
<tr class="separator:a58003b4ea2270cb2170f97974b5f36fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb798c62adc181798999bc16a85a21fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#abb798c62adc181798999bc16a85a21fe">btr_cur_set_ownership_of_extern_field</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>, ibool val, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:abb798c62adc181798999bc16a85a21fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5caa33f4651b2e26649e1659003497"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a0f5caa33f4651b2e26649e1659003497">btr_cur_disown_inherited_fields</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a0f5caa33f4651b2e26649e1659003497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8370879960597a006379bb68d82b52"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#afe8370879960597a006379bb68d82b52">btr_push_update_extern_fields</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="row0merge_8cc.html#aa15f6f5c88768ee85a3ed8a4905d7745">tuple</a>, const <a class="el" href="structupd__t.html">upd_t</a> *<a class="el" href="row0upd_8cc.html#a5319e5051382c064bfbcd88873c387d3">update</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:afe8370879960597a006379bb68d82b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d80569014cbe63fe700117569637d4"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ae8d80569014cbe63fe700117569637d4">btr_blob_get_part_len</a> (const byte *blob_header)</td></tr>
<tr class="separator:ae8d80569014cbe63fe700117569637d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee97b5a93315df85a25c58103157fe94"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aee97b5a93315df85a25c58103157fe94">btr_blob_get_next_page_no</a> (const byte *blob_header)</td></tr>
<tr class="separator:aee97b5a93315df85a25c58103157fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dded3d38f75234ce09545eb49296ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ab8dded3d38f75234ce09545eb49296ec">btr_blob_free</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ibool all, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ab8dded3d38f75234ce09545eb49296ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf9b005e1233e0700fc247dd383d475"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#abdf9b005e1233e0700fc247dd383d475">btr_store_big_rec_extern_fields</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *rec_block, rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *big_rec_vec, <a class="el" href="structmtr__t.html">mtr_t</a> *btr_mtr, enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a> <a class="el" href="ibuf0ibuf_8cc.html#a02d89caeb1f64de105ee1c3988799855">op</a>)</td></tr>
<tr class="separator:abdf9b005e1233e0700fc247dd383d475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c2ced4a02d7e7240c8a703f06c69c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a13c2ced4a02d7e7240c8a703f06c69c7">btr_check_blob_fil_page_type</a> (ulint space_id, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ibool read)</td></tr>
<tr class="separator:a13c2ced4a02d7e7240c8a703f06c69c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2d07c971548819ccb53196d89f83a6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a9a2d07c971548819ccb53196d89f83a6">btr_free_externally_stored_field</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, byte *field_ref, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>, enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a> rb_ctx, <a class="el" href="structmtr__t.html">mtr_t</a> *local_mtr <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:a9a2d07c971548819ccb53196d89f83a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8302445adebd0988fac5577c4b66a6"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a1c8302445adebd0988fac5577c4b66a6">btr_copy_blob_prefix</a> (byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, ulint space_id, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a1c8302445adebd0988fac5577c4b66a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7e668ecf8471882cba76f726b76b56"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a4f7e668ecf8471882cba76f726b76b56">btr_copy_zblob_prefix</a> (byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint space_id, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a4f7e668ecf8471882cba76f726b76b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfa1155d520e5dbba0d0b1c43e4238c"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a5cfa1155d520e5dbba0d0b1c43e4238c">btr_copy_externally_stored_field_prefix_low</a> (byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint space_id, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a5cfa1155d520e5dbba0d0b1c43e4238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24703540cfa917a52abe379751f5004"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ab24703540cfa917a52abe379751f5004">btr_copy_externally_stored_field_prefix</a> (byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, const byte *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ulint local_len)</td></tr>
<tr class="separator:ab24703540cfa917a52abe379751f5004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c5f0fcaabcc7487018ae03937c2412"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ac3c5f0fcaabcc7487018ae03937c2412">btr_copy_externally_stored_field</a> (ulint *<a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, const byte *<a class="el" href="row0sel_8cc.html#ad5785aee834440a0628434c5e5ab94d2">data</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint local_len, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:ac3c5f0fcaabcc7487018ae03937c2412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c383bd105f982d216a7a430935f5706"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a2c383bd105f982d216a7a430935f5706">btr_rec_copy_externally_stored_field</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint no, ulint *<a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *<a class="el" href="trx0rec_8cc.html#a18459ed20cf7df7b5953ca0f9f3fea33">heap</a>)</td></tr>
<tr class="separator:a2c383bd105f982d216a7a430935f5706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">- of the index to look for</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Find the index field entry in in the cfg indexes fields.</p>
<dl class="section return"><dt>Returns</dt><dd>instance if found else 0. </dd></dl>
</div></td></tr>
<tr class="memitem:aeeaae43d1804c4ea83c21d53c757c9b7"><td class="memItemLeft" align="right" valign="top"><a id="aeeaae43d1804c4ea83c21d53c757c9b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="row0import_8cc.html#a52482fdd3721e7db69dc740aefee8ad4">err</a> !=DB_SUCCESS||!<a class="el" href="dict0dict_8h.html#af8741b8516077d237960a59240f7d950">dict_index_is_clust</a>(<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>)||<a class="el" href="dict0dict_8h.html#a64bad64f48df276dc5141ad07d851304">dict_index_is_ibuf</a>(<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>))</td></tr>
<tr class="separator:aeeaae43d1804c4ea83c21d53c757c9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac56458861b2e62f1e3520e6df16f73"><td class="memItemLeft" align="right" valign="top"><a id="a3ac56458861b2e62f1e3520e6df16f73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (DB_SUCCESS)</td></tr>
<tr class="separator:a3ac56458861b2e62f1e3520e6df16f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a28f1a6f7902bd8a0cb58c2d0cac08c84"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a28f1a6f7902bd8a0cb58c2d0cac08c84">btr_cur_n_non_sea</a> = 0</td></tr>
<tr class="separator:a28f1a6f7902bd8a0cb58c2d0cac08c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86620ab2987088f030f547ea4efcb9c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a86620ab2987088f030f547ea4efcb9c0">btr_cur_n_sea</a> = 0</td></tr>
<tr class="separator:a86620ab2987088f030f547ea4efcb9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7643cc79559dd1b9461b11f88b554cd7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a7643cc79559dd1b9461b11f88b554cd7">btr_cur_n_non_sea_old</a> = 0</td></tr>
<tr class="separator:a7643cc79559dd1b9461b11f88b554cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999c419864f12f8c08bdb760a2932f76"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a999c419864f12f8c08bdb760a2932f76">btr_cur_n_sea_old</a> = 0</td></tr>
<tr class="separator:a999c419864f12f8c08bdb760a2932f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf93462cc7a2ace0e2399e07e85210fd"><td class="memItemLeft" align="right" valign="top">const byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#acf93462cc7a2ace0e2399e07e85210fd">field_ref_zero</a> [<a class="el" href="btr0types_8h.html#a0ce016535d5de52a1e27362330676df0">BTR_EXTERN_FIELD_REF_SIZE</a>]</td></tr>
<tr class="separator:acf93462cc7a2ace0e2399e07e85210fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dc77108c9afbd5a202202d6e239fca"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a77dc77108c9afbd5a202202d6e239fca">tuple</a></td></tr>
<tr class="separator:a77dc77108c9afbd5a202202d6e239fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb186d52353116440b6e52fe66ed7ea2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aeb186d52353116440b6e52fe66ed7ea2">offsets</a></td></tr>
<tr class="separator:aeb186d52353116440b6e52fe66ed7ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae46c2b2b2983e27a2c07a934885b46"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#adae46c2b2b2983e27a2c07a934885b46">heap</a></td></tr>
<tr class="separator:adae46c2b2b2983e27a2c07a934885b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14e90cca5a13bd23c0993003c060e03"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a></td></tr>
<tr class="separator:ab14e90cca5a13bd23c0993003c060e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd47c263be1b31cfc0b2ca0d0ba2f32"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> ulint <a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a4cd47c263be1b31cfc0b2ca0d0ba2f32">mtr</a></td></tr>
<tr class="separator:a4cd47c263be1b31cfc0b2ca0d0ba2f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8cb9c29630901b8b5da4cdd7401d36"><td class="memItemLeft" align="right" valign="top">rec_t *&#160;</td><td class="memItemRight" valign="bottom"><b>rec</b></td></tr>
<tr class="separator:a7c8cb9c29630901b8b5da4cdd7401d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf639a794d9e227ada7eaf79e4cb537"><td class="memItemLeft" align="right" valign="top"><a id="accf639a794d9e227ada7eaf79e4cb537"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>page_cursor</b> = btr_cur_get_page_cur(<a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>)</td></tr>
<tr class="separator:accf639a794d9e227ada7eaf79e4cb537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6be834938be56633c510e0de2248709"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ae6be834938be56633c510e0de2248709">cursor</a></td></tr>
<tr class="separator:ae6be834938be56633c510e0de2248709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522293ca1fb49d5a00042fade0fbb892"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a522293ca1fb49d5a00042fade0fbb892">entry</a></td></tr>
<tr class="separator:a522293ca1fb49d5a00042fade0fbb892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e213f7a1ae08e6d7a9c1c9218639a8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> <a class="el" href="structdtuple__t.html">dtuple_t</a> <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a09e213f7a1ae08e6d7a9c1c9218639a8">thr</a></td></tr>
<tr class="separator:a09e213f7a1ae08e6d7a9c1c9218639a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6abb32bf6a300010a2c88fe98cc831"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> <a class="el" href="structdtuple__t.html">dtuple_t</a> <a class="el" href="structque__thr__t.html">que_thr_t</a> <a class="el" href="structmtr__t.html">mtr_t</a> ibool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aee6abb32bf6a300010a2c88fe98cc831">inherit</a></td></tr>
<tr class="separator:aee6abb32bf6a300010a2c88fe98cc831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c4f16d584f1fabcea984746cf904a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ad1c4f16d584f1fabcea984746cf904a1">roll_ptr</a></td></tr>
<tr class="separator:ad1c4f16d584f1fabcea984746cf904a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6784e1c334dfceb8f017667c0b0f6a3e"><td class="memItemLeft" align="right" valign="top"><a id="a6784e1c334dfceb8f017667c0b0f6a3e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>index</b> = <a class="el" href="row0ins_8cc.html#ae8a68d572be3998302db348b39cb3c2b">cursor</a>-&gt;index</td></tr>
<tr class="separator:a6784e1c334dfceb8f017667c0b0f6a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322291216e779ab29b06492cf9e41dce"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> const ulint const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#a322291216e779ab29b06492cf9e41dce">update</a></td></tr>
<tr class="separator:a322291216e779ab29b06492cf9e41dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e363c98b33d8339e7170309cd05207"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> const ulint const <a class="el" href="structupd__t.html">upd_t</a> ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#ab7e363c98b33d8339e7170309cd05207">cmpl_info</a> = cmpl_info</td></tr>
<tr class="separator:ab7e363c98b33d8339e7170309cd05207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Format of the IBUF_REC_FIELD_METADATA of an insert buffer record</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The fourth column in the MySQL 5.5 format contains an operation type, counter, and some flags. </p>
</div></td></tr>
<tr class="memitem:aa2089f0f61b443ddde99d203fc1603fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8cc.html#aa2089f0f61b443ddde99d203fc1603fc">err</a></td></tr>
<tr class="separator:aa2089f0f61b443ddde99d203fc1603fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The index tree cursor</p>
<p>All changes that row operations make to a B-tree or the records there must go through this module! Undo log records are written here of every modify or insert of a clustered index record. </p><pre class="fragment">                    NOTE!!!
</pre><p> To make sure we do not run out of disk space during a pessimistic insert or update, we have to reserve 2 x the height of the index tree many pages in the tablespace before we start the operation, because if leaf splitting has been started, it is difficult to undo, except by crashing the database and doing a roll-forward.</p>
<p>Created 10/16/1994 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a81829f0bccb1547a55fd6461c1b8473e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81829f0bccb1547a55fd6461c1b8473e">&#9670;&nbsp;</a></span>BTR_BLOB_HDR_NEXT_PAGE_NO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_BLOB_HDR_NEXT_PAGE_NO&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>next BLOB part page no, FIL_NULL if none </p>

</div>
</div>
<a id="ad2fa20fa4bf99570a15c9dcc0bbd0eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fa20fa4bf99570a15c9dcc0bbd0eb9">&#9670;&nbsp;</a></span>BTR_BLOB_HDR_PART_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_BLOB_HDR_PART_LEN&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The structure of a BLOB part header BLOB part len on this page </p>

</div>
</div>
<a id="aea5f81ea5d3109de24a617dcecfe90b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5f81ea5d3109de24a617dcecfe90b4">&#9670;&nbsp;</a></span>BTR_BLOB_HDR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_BLOB_HDR_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of a BLOB part header, in bytes </p>

</div>
</div>
<a id="a4676319e3e8cde7d9790089fe965df40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4676319e3e8cde7d9790089fe965df40">&#9670;&nbsp;</a></span>BTR_CUR_PAGE_REORGANIZE_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_CUR_PAGE_REORGANIZE_LIMIT&#160;&#160;&#160;(UNIV_PAGE_SIZE / 32)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the optimistic insert, if the insert does not fit, but this much space can be released by page reorganize, then it is reorganized </p>

</div>
</div>
<a id="a6a8d18327a6158583ba43c082f1e96a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8d18327a6158583ba43c082f1e96a2">&#9670;&nbsp;</a></span>btr_rec_get_field_ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_rec_get_field_ref</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>) + <a class="el" href="btr0cur_8cc.html#adf9151a0d4ebaee472d93bfd55f835f2">btr_rec_get_field_ref_offs</a>(<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a pointer to the externally stored part of a field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>record </td></tr>
    <tr><td class="paramname">offsets</td><td>rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">n</td><td>index of the externally stored field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the externally stored part </dd></dl>

</div>
</div>
<a id="a76518092843bb988e2222a5712cc0a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76518092843bb988e2222a5712cc0a9f">&#9670;&nbsp;</a></span>BTR_TABLE_STATS_FROM_SAMPLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_TABLE_STATS_FROM_SAMPLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sample, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ext_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">not_empty&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((value) * (ib_int64_t) <a class="code" href="btr0btr_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>-&gt;stat_n_leaf_pages               \</div><div class="line">          + (sample) - 1 + (ext_size) + (not_empty)) / ((sample) + (ext_size)))</div><div class="ttc" id="btr0btr_8cc_html_a4ddeaa41a4dab23a7eaa06ee52e4522b"><div class="ttname"><a href="btr0btr_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a></div><div class="ttdeci">static ulint buf_block_t dict_index_t * index</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:1984</div></div>
</div><!-- fragment --><p>Estimated table level stats from sampled value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>sampled stats </td></tr>
    <tr><td class="paramname">index</td><td>index being sampled </td></tr>
    <tr><td class="paramname">sample</td><td>number of sampled rows </td></tr>
    <tr><td class="paramname">ext_size</td><td>external stored data size </td></tr>
    <tr><td class="paramname">not_empty</td><td>table not empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>estimated table wide stats from sampled value </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e1e7dcb5ea919124b9d6e8e868bbc8">&#9670;&nbsp;</a></span>btr_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="btr0cur_8cc.html#ac8e1e7dcb5ea919124b9d6e8e868bbc8">btr_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffered B-tree operation types, introduced as part of delete buffering. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8a84f603208288c0b21ebee05430ca4229"></a>BTR_NO_OP&#160;</td><td class="fielddoc"><p>Not buffered </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8af727af06be5922ef5e53314387951e52"></a>BTR_INSERT_OP&#160;</td><td class="fielddoc"><p>Insert, do not ignore UNIQUE </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8a791b52e53c17e5174c4a38d4b93d5fdb"></a>BTR_INSERT_IGNORE_UNIQUE_OP&#160;</td><td class="fielddoc"><p>Insert, ignoring UNIQUE </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8a4d7f260f169e344aa04a3df1a3100c63"></a>BTR_DELETE_OP&#160;</td><td class="fielddoc"><p>Purge a delete-marked record </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8e1e7dcb5ea919124b9d6e8e868bbc8ac67a876f7a3a5ebc554eb5170a6604e4"></a>BTR_DELMARK_OP&#160;</td><td class="fielddoc"><p>Mark a record for deletion </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a84ce4257c4707454c73e179f9006f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ce4257c4707454c73e179f9006f5fe">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull, warn_unused_result)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a record if there is enough space, or if enough space can be freed by reorganizing. Differs from btr_cur_optimistic_insert because no heuristics is applied to whether it pays to use CPU time for reorganizing the page or not.</p>
<p>IMPORTANT: The caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking <a class="el" href="ibuf0ibuf_8cc.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits()</a> before <a class="el" href="mtr0mtr_8h.html#a25a00697e0e499f9ff7848618c744112">mtr_commit()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to inserted record if succeed, else NULL </dd></dl>

</div>
</div>
<a id="ad17c7aca3c9b98ea596c57c77e42ec55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17c7aca3c9b98ea596c57c77e42ec55">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(warn_unused_result, nonnull(2, 3, 5, 6))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For an insert, checks the locks and does the undo logging if desired. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_WAIT_LOCK, DB_FAIL, or error number </dd></dl>

</div>
</div>
<a id="a71f30c7cc54155670a51d7a9d57e7d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f30c7cc54155670a51d7a9d57e7d3a">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(warn_unused_result, nonnull(2, 3, 6, 7))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For an update, checks the locks and does the undo logging. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_WAIT_LOCK, or error number </dd></dl>

</div>
</div>
<a id="ab8dded3d38f75234ce09545eb49296ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dded3d38f75234ce09545eb49296ec">&#9670;&nbsp;</a></span>btr_blob_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_blob_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocate a buffer block that was reserved for a BLOB part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block </td></tr>
    <tr><td class="paramname">all</td><td>in: TRUE=remove also the compressed page if there is one </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction to commit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee97b5a93315df85a25c58103157fe94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee97b5a93315df85a25c58103157fe94">&#9670;&nbsp;</a></span>btr_blob_get_next_page_no()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint btr_blob_get_next_page_no </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>blob_header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the page number where the next BLOB part is stored. </p><dl class="section return"><dt>Returns</dt><dd>page number or FIL_NULL if no more pages </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob_header</td><td>in: blob header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8d80569014cbe63fe700117569637d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d80569014cbe63fe700117569637d4">&#9670;&nbsp;</a></span>btr_blob_get_part_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint btr_blob_get_part_len </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>blob_header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the length of a BLOB part stored on the header page. </p><dl class="section return"><dt>Returns</dt><dd>part length </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob_header</td><td>in: blob header </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13c2ced4a02d7e7240c8a703f06c69c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c2ced4a02d7e7240c8a703f06c69c7">&#9670;&nbsp;</a></span>btr_check_blob_fil_page_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_check_blob_fil_page_type </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> the FIL_PAGE_TYPE on an uncompressed BLOB page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
    <tr><td class="paramname">page</td><td>in: page </td></tr>
    <tr><td class="paramname">read</td><td>in: TRUE=read, FALSE=purge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b65c349282e853286b7a51e0197a202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b65c349282e853286b7a51e0197a202">&#9670;&nbsp;</a></span>btr_check_blob_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_check_blob_limit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *&#160;</td>
          <td class="paramname"><em>big_rec_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if the total length of the modified blob for the row is within 10% of the total redo log size. This constraint on the blob length is to avoid overwriting the redo logs beyond the last checkpoint lsn. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_TOO_BIG_FOR_REDO. </dd></dl>

</div>
</div>
<a id="a1c8302445adebd0988fac5577c4b66a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8302445adebd0988fac5577c4b66a6">&#9670;&nbsp;</a></span>btr_copy_blob_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint btr_copy_blob_prefix </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the prefix of an uncompressed BLOB. The clustered index record that points to this BLOB must be protected by a lock or a page latch. </p><dl class="section return"><dt>Returns</dt><dd>number of bytes written to buf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: the externally stored part of the field, or a prefix of it </td></tr>
    <tr><td class="paramname">len</td><td>in: length of buf, in bytes </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id of the BLOB pages </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number of the first BLOB page </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset on the first BLOB page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3c5f0fcaabcc7487018ae03937c2412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c5f0fcaabcc7487018ae03937c2412">&#9670;&nbsp;</a></span>btr_copy_externally_stored_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_copy_externally_stored_field </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>local_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies an externally stored field of a record to mem heap. The clustered index record must be protected by a lock or a page latch. </p><dl class="section return"><dt>Returns</dt><dd>the whole field copied to heap </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>out: length of the whole field </td></tr>
    <tr><td class="paramname">data</td><td>in: 'internally' stored part of the field containing also the reference to the external part; must be protected by a lock or a page latch </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">local_len</td><td>in: length of data </td></tr>
    <tr><td class="paramname">heap</td><td>in: mem heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24703540cfa917a52abe379751f5004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24703540cfa917a52abe379751f5004">&#9670;&nbsp;</a></span>btr_copy_externally_stored_field_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_copy_externally_stored_field_prefix </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>local_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the prefix of an externally stored field of a record. The clustered index record must be protected by a lock or a page latch. </p><dl class="section return"><dt>Returns</dt><dd>the length of the copied field, or 0 if the column was being or has been deleted </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: the field, or a prefix of it </td></tr>
    <tr><td class="paramname">len</td><td>in: length of buf, in bytes </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">data</td><td>in: 'internally' stored part of the field containing also the reference to the external part; must be protected by a lock or a page latch </td></tr>
    <tr><td class="paramname">local_len</td><td>in: length of data, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cfa1155d520e5dbba0d0b1c43e4238c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfa1155d520e5dbba0d0b1c43e4238c">&#9670;&nbsp;</a></span>btr_copy_externally_stored_field_prefix_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint btr_copy_externally_stored_field_prefix_low </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the prefix of an externally stored field of a record. The clustered index record that points to this BLOB must be protected by a lock or a page latch. </p><dl class="section return"><dt>Returns</dt><dd>number of bytes written to buf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: the externally stored part of the field, or a prefix of it </td></tr>
    <tr><td class="paramname">len</td><td>in: length of buf, in bytes </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id of the first BLOB page </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number of the first BLOB page </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset on the first BLOB page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f7e668ecf8471882cba76f726b76b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7e668ecf8471882cba76f726b76b56">&#9670;&nbsp;</a></span>btr_copy_zblob_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint btr_copy_zblob_prefix </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the prefix of a compressed BLOB. The clustered index record that points to this BLOB must be protected by a lock or a page latch. </p><dl class="section return"><dt>Returns</dt><dd>number of bytes written to buf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: the externally stored part of the field, or a prefix of it </td></tr>
    <tr><td class="paramname">len</td><td>in: length of buf, in bytes </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed BLOB page size </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id of the BLOB pages </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number of the first BLOB page </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset on the first BLOB page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d25b1d3defc3c7b44c623f71c32dfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d25b1d3defc3c7b44c623f71c32dfce">&#9670;&nbsp;</a></span>btr_cur_add_path_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_cur_add_path_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>root_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds path information to the cursor for the current page, for which the binary search has been performed. in: root node height in tree</p>
<p>Adds path information to the cursor for the current page, for which the binary search has been performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor positioned on a page </td></tr>
    <tr><td class="paramname">height</td><td>in: height of the page in tree; 0 means leaf node </td></tr>
    <tr><td class="paramname">root_height</td><td>in: root node height in tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b81af0e0706d0294ef4f78a24e129cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b81af0e0706d0294ef4f78a24e129cd">&#9670;&nbsp;</a></span>btr_cur_compress_if_useful()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_cur_compress_if_useful </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>adjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to compress a page of the tree if it seems useful. It is assumed that mtr holds an x-latch on the tree and on the cursor page. To avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. NOTE: it is assumed that the caller has reserved enough free extents so that the compression will always succeed if done! </p><dl class="section return"><dt>Returns</dt><dd>TRUE if compression occurred </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the page to compress; cursor does not stay valid if !adjust and compression occurs </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE if should adjust the cursor position even if compression occurs </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab141b416d488f70486cfc04e65887a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab141b416d488f70486cfc04e65887a7b">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_del_mark_set_clust_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a clustered index record deleted. Writes an undo log record to undo log on this delete marking. Writes in the trx id field the id of the deleting transaction, and in the roll ptr field pointer to the undo log record created. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: buffer block of the record </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index of the record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a770e0a5b2cd615f9d598bb931b0474be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770e0a5b2cd615f9d598bb931b0474be">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_clust_rec_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_cur_del_mark_set_clust_rec_log </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the redo log record for delete marking or unmarking of an index record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the record </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr to the undo log record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c48710d5682281f4fd0f7fcffeac6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c48710d5682281f4fd0f7fcffeac6d">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_sec_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_del_mark_set_sec_rec </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a secondary index record delete mark to TRUE or FALSE. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: locking flag </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78b5e425b158cb805c7a59d8d52ffc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b5e425b158cb805c7a59d8d52ffc10">&#9670;&nbsp;</a></span>btr_cur_del_mark_set_sec_rec_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_cur_del_mark_set_sec_rec_log </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the redo log record for a delete mark setting of a secondary index record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f5caa33f4651b2e26649e1659003497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5caa33f4651b2e26649e1659003497">&#9670;&nbsp;</a></span>btr_cur_disown_inherited_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_disown_inherited_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks non-updated off-page fields as disowned by this record. The ownership must be transferred to the updated record which is inserted elsewhere in the index tree. In purge only the owner of externally stored field is allowed to free the field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record in a clustered index </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the page </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75d02a22ead9dd703eecfda611ac1e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d02a22ead9dd703eecfda611ac1e8f">&#9670;&nbsp;</a></span>btr_cur_latch_leaves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_cur_latch_leaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Latches the leaf page or pages requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: leaf page where the search converged </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number of the leaf </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ... </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a629bd7d543ce4b486a11ac6054d033a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629bd7d543ce4b486a11ac6054d033a2">&#9670;&nbsp;</a></span>btr_cur_open_at_index_side_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_open_at_index_side_func </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a cursor at either end of an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_left</td><td>in: true if open to the low end, false if to the high end </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: latch mode </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: cursor </td></tr>
    <tr><td class="paramname">level</td><td>in: level to search for (0=leaf). </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b17c00c932d341c9b0cbe9e0b23642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b17c00c932d341c9b0cbe9e0b23642">&#9670;&nbsp;</a></span>btr_cur_open_at_rnd_pos_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_open_at_rnd_pos_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Positions a cursor at a randomly chosen position within a B-tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ... </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: B-tree cursor </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4e09b340d9572904cd88353ed791715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e09b340d9572904cd88353ed791715">&#9670;&nbsp;</a></span>btr_cur_optimistic_delete_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_cur_optimistic_delete_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the record on which the tree cursor is positioned on a leaf page. It is assumed that the mtr has an x-latch on the page where the cursor is positioned, but no latch on the whole tree. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success, i.e., the page did not become too empty </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on leaf page, on the record to delete; cursor stays valid: if deletion succeeds, on function exit it points to the successor of the deleted record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr; if this function returns TRUE on a leaf page of a secondary index, the mtr must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedcc2ada2a58da05de9b82cb8aeac9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcc2ada2a58da05de9b82cb8aeac9a7">&#9670;&nbsp;</a></span>btr_cur_optimistic_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_optimistic_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to perform an insert to a page in an index tree, next to cursor. It is assumed that mtr holds an x-latch on the page. The operation does not succeed if there is too little space on the page. If there is just one record on the page, the insert will always succeed; this is to prevent trying to split a page with just one record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_WAIT_LOCK, DB_FAIL, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags: if not zero, the parameters index and thr should be specified </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on page after which to insert; cursor stays valid </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>out: pointer to inserted record if succeed </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this function returns DB_SUCCESS on a leaf page of a secondary index in a compressed tablespace, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28009a77b6c56d6fe8fe6cfe9b1a1672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28009a77b6c56d6fe8fe6cfe9b1a1672">&#9670;&nbsp;</a></span>btr_cur_optimistic_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_optimistic_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to update a record on a page in an index tree. It is assumed that mtr holds an x-latch on the page. The operation does not succeed if there is too little space on the page or if the update would result in too empty a page, so that tree compression is recommended. We assume here that the ordering fields of the record do not change. </p><dl class="section return"><dt>Returns</dt><dd>error code, including </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_OVERFLOW</td><td>if the updated record does not fit </td></tr>
    <tr><td class="paramname">DB_UNDERFLOW</td><td>if the page would become too empty </td></tr>
    <tr><td class="paramname">DB_ZIP_OVERFLOW</td><td>if there is not enough space left on the compressed page (IBUF_BITMAP_FREE was reset outside mtr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to update; cursor stays valid and positioned on the same record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to NULL or memory heap </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector; this must also contain trx id and roll ptr fields </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this is a secondary index, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67626b88e4c9b6e4bd41bc71d432e095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67626b88e4c9b6e4bd41bc71d432e095">&#9670;&nbsp;</a></span>btr_cur_parse_del_mark_set_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_cur_parse_del_mark_set_clust_rec </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the redo log record for delete marking or unmarking of a clustered index record. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index corresponding to page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d8d168c724c8ac87371442df85fc233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8d168c724c8ac87371442df85fc233">&#9670;&nbsp;</a></span>btr_cur_parse_del_mark_set_sec_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_cur_parse_del_mark_set_sec_rec </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the redo log record for delete marking or unmarking of a secondary index record. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad06c6cbe14c2af25f2240b5e54aa1d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06c6cbe14c2af25f2240b5e54aa1d5a">&#9670;&nbsp;</a></span>btr_cur_parse_update_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_cur_parse_update_in_place </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a redo log record of updating a record in-place. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: index corresponding to page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8a8df6cc43f61d2a90dceb886983ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a8df6cc43f61d2a90dceb886983ef9">&#9670;&nbsp;</a></span>btr_cur_pess_upd_restore_supremum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_cur_pess_upd_restore_supremum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If, in a split, a new supremum record was created as the predecessor of the updated record, the supremum record must inherit exactly the locks on the updated record. In the split it may have inherited locks from the successor of the updated record, which is not correct. This function restores the right locks for the new supremum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: updated record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb318f5dd90a5b76b03dfa7b52349048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb318f5dd90a5b76b03dfa7b52349048">&#9670;&nbsp;</a></span>btr_cur_pessimistic_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool btr_cur_pessimistic_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>has_reserved_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a>&#160;</td>
          <td class="paramname"><em>rb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the record on which the tree cursor is positioned. Tries to compress the page if its fillfactor drops below a threshold or if it is the only page on the level. It is assumed that mtr holds an x-latch on the tree and on the cursor page. To avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if compression occurred </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>out: DB_SUCCESS or DB_OUT_OF_FILE_SPACE; the latter may occur because we may have to update node pointers on upper levels, and in the case of variable length keys these may actually grow in size </td></tr>
    <tr><td class="paramname">has_reserved_extents</td><td>in: TRUE if the caller has already reserved enough free extents so that he knows that the operation will succeed </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to delete; if compression does not occur, the cursor stays valid: it points to successor of deleted record on function exit </td></tr>
    <tr><td class="paramname">flags</td><td>in: BTR_CREATE_FLAG or 0 </td></tr>
    <tr><td class="paramname">rb_ctx</td><td>in: rollback context </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34fdcfe6aa08e8d6f9ce4af72d05ddb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fdcfe6aa08e8d6f9ce4af72d05ddb0">&#9670;&nbsp;</a></span>btr_cur_pessimistic_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_pessimistic_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an insert on a page of an index tree. It is assumed that mtr holds an x-latch on the tree and on the cursor page. If the insert is made on the leaf level, to avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags: if not zero, the parameter thr should be specified; if no undo logging is specified, then the caller must have reserved enough free extents in the file space so that the insertion will certainly succeed </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor after which to insert; cursor stays valid </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>out: pointer to inserted record if succeed </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b74099a04e706fcd43989aa373e9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b74099a04e706fcd43989aa373e9bd">&#9670;&nbsp;</a></span>btr_cur_pessimistic_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_pessimistic_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offsets_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>entry_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an update of a record on a page of a tree. It is assumed that mtr holds an x-latch on the tree and on the cursor page. If the update is made on the leaf level, to avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. We assume here that the ordering fields of the record do not change. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging, locking, and rollback flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the record to update; cursor may become invalid if *big_rec == NULL || !(flags &amp; BTR_KEEP_POS_FLAG) </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">offsets_heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">entry_heap</td><td>in/out: memory heap for allocating big_rec and the index tuple </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector; this is allowed also contain trx id and roll ptr fields, but the values in update vector have no effect </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82a13fbc0aaa77d0f1164914785757c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a13fbc0aaa77d0f1164914785757c0">&#9670;&nbsp;</a></span>btr_cur_search_to_nth_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_search_to_nth_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>has_search_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches an index tree and positions a tree cursor on a given level. NOTE: n_fields_cmp in tuple must be set so that it cannot be compared to node pointer page number fields on the upper levels of the tree! Note that if mode is PAGE_CUR_LE, which is used in inserts, then cursor-&gt;up_match and cursor-&gt;low_match both will have sensible values. If mode is PAGE_CUR_GE, then up_match will a have a sensible value.</p>
<p>If mode is PAGE_CUR_LE , cursor is left at the place where an insert of the search tuple should be performed in the B-tree. InnoDB does an insert immediately after the cursor. Thus, the cursor may end up on a user record, or on a page infimum record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: the tree level of search </td></tr>
    <tr><td class="paramname">tuple</td><td>in: data tuple; NOTE: n_fields_cmp in tuple must be set so that it cannot get compared to the node ptr page number field! </td></tr>
    <tr><td class="paramname">mode</td><td>in: PAGE_CUR_L, ...; Inserts should always be made using PAGE_CUR_LE to search the position! </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ..., ORed with at most one of BTR_INSERT, BTR_DELETE_MARK, BTR_DELETE, or BTR_ESTIMATE; cursor-&gt;left_block is used to store a pointer to the left neighbor page, in the cases BTR_SEARCH_PREV and BTR_MODIFY_PREV; NOTE that if has_search_latch is != 0, we maybe do not have a latch set on the cursor page, we assume the caller uses his search latch to protect the record! </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: tree cursor; the cursor page is s- or x-latched, but see also above! </td></tr>
    <tr><td class="paramname">has_search_latch</td><td>in: info on the latch mode the caller currently has on btr_search_latch: RW_S_LATCH, or 0 </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c43a7dff2e949e99467e0323bcc24f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c43a7dff2e949e99467e0323bcc24f9">&#9670;&nbsp;</a></span>btr_cur_set_deleted_flag_for_ibuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_set_deleted_flag_for_ibuf </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a secondary index record's delete mark to the given value. This function is only used by the insert buffer merge mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page corresponding to rec, or NULL when the tablespace is uncompressed </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb798c62adc181798999bc16a85a21fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb798c62adc181798999bc16a85a21fe">&#9670;&nbsp;</a></span>btr_cur_set_ownership_of_extern_field()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_cur_set_ownership_of_extern_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the ownership bit of an externally stored field in a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: clustered index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the page </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">i</td><td>in: field number </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr, or NULL if not logged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1097d8a403bf691a8345e5e581aeae84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1097d8a403bf691a8345e5e581aeae84">&#9670;&nbsp;</a></span>btr_cur_unmark_extern_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_cur_unmark_extern_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Marks all extern fields in a record as owned by the record. This function should be called if the delete mark of a record is removed: a not delete marked record always owns all its extern fields. in: mtr, or NULL if not logged</p>
<p>Marks all extern fields in a record as owned by the record. This function should be called if the delete mark of a record is removed: a not delete marked record always owns all its extern fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record in a clustered index </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the page </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr, or NULL if not logged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e73fe14abad54b535be2ef8914cc9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e73fe14abad54b535be2ef8914cc9af">&#9670;&nbsp;</a></span>btr_cur_update_alloc_zip_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool btr_cur_update_alloc_zip_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See if there is enough place in the page modification log to log an update-in-place.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if out of space; IBUF_BITMAP_FREE will be reset outside mtr if the page was recompressed </td></tr>
    <tr><td class="paramname">true</td><td>if enough place;</td></tr>
  </table>
  </dd>
</dl>
<p>IMPORTANT: The caller will have to update IBUF_BITMAP_FREE if this is a secondary index leaf page. This has to be done either within the same mini-transaction, or by invoking <a class="el" href="ibuf0ibuf_8cc.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits()</a> before mtr_commit(mtr). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: B-tree page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index corresponding to cursor </td></tr>
    <tr><td class="paramname">length</td><td>in: size needed </td></tr>
    <tr><td class="paramname">create</td><td>in: true=delete-and-insert, false=update-in-place </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c229db0c9e7a45d3e5deba525eee172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c229db0c9e7a45d3e5deba525eee172">&#9670;&nbsp;</a></span>btr_cur_update_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_update_in_place </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates a record when the update causes no size changes in its fields. We assume here that the ordering fields of the record do not change. </p><dl class="section return"><dt>Returns</dt><dd>locking or undo log related error code, or </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_ZIP_OVERFLOW</td><td>if there is not enough space left on the compressed page (IBUF_BITMAP_FREE was reset outside mtr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to update; cursor stays valid and positioned on the same record </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this is a secondary index, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee589ffc2bbe2baeef4aa270d839eaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee589ffc2bbe2baeef4aa270d839eaa0">&#9670;&nbsp;</a></span>btr_cur_update_in_place_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_update_in_place_log </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a redo log record of updating a record in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: flags </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the record </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac56a487d045ea12d204c0cbe34ff4c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56a487d045ea12d204c0cbe34ff4c95">&#9670;&nbsp;</a></span>btr_estimate_n_rows_in_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ib_int64_t btr_estimate_n_rows_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimates the number of rows in a given index range. </p><dl class="section return"><dt>Returns</dt><dd>estimated number of rows </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">tuple1</td><td>in: range start, may also be empty tuple </td></tr>
    <tr><td class="paramname">mode1</td><td>in: search mode for range start </td></tr>
    <tr><td class="paramname">tuple2</td><td>in: range end, may also be empty tuple </td></tr>
    <tr><td class="paramname">mode2</td><td>in: search mode for range end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d6e9e587cdf5dad1145ea99915b6280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6e9e587cdf5dad1145ea99915b6280">&#9670;&nbsp;</a></span>btr_estimate_n_rows_in_range_on_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ib_int64_t btr_estimate_n_rows_in_range_on_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__path__t.html">btr_path_t</a> *&#160;</td>
          <td class="paramname"><em>slot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__path__t.html">btr_path_t</a> *&#160;</td>
          <td class="paramname"><em>slot2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_int64_t&#160;</td>
          <td class="paramname"><em>n_rows_on_prev_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>is_n_rows_exact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimate the number of rows between slot1 and slot2 for any level on a B-tree. This function starts from slot1-&gt;page and reads a few pages to the right, counting their records. If we reach slot2-&gt;page quickly then we know exactly how many records there are between slot1 and slot2 and we set is_n_rows_exact to TRUE. If we cannot reach slot2-&gt;page quickly then we calculate the average number of records in the pages scanned so far and assume that all pages that we did not scan up to slot2-&gt;page contain the same number of records, then we multiply that average to the number of pages between slot1-&gt;page and slot2-&gt;page (which is n_rows_on_prev_level). In this case we set is_n_rows_exact to FALSE. </p><dl class="section return"><dt>Returns</dt><dd>number of rows (exact or estimated) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">slot1</td><td>in: left border </td></tr>
    <tr><td class="paramname">slot2</td><td>in: right border </td></tr>
    <tr><td class="paramname">n_rows_on_prev_level</td><td>in: number of rows on the previous level for the same descend paths; used to determine the numbe of pages on this level </td></tr>
    <tr><td class="paramname">is_n_rows_exact</td><td>out: TRUE if the returned value is exact i.e. not an estimation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50de491c34525f93cbe27307044ea89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50de491c34525f93cbe27307044ea89">&#9670;&nbsp;</a></span>btr_estimate_number_of_different_key_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_estimate_number_of_different_key_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimates the number of different key values in a given index, for each n-column prefix of the index where 1 &lt;= n &lt;= dict_index_get_n_unique(index). The estimates are stored in the array index-&gt;stat_n_diff_key_vals[] (indexed 0..n_uniq-1) and the number of pages that were sampled is saved in index-&gt;stat_n_sample_sizes[]. If innodb_stats_method is nulls_ignored, we also record the number of non-null values for each prefix and stored the estimates in array index-&gt;stat_n_non_null_key_vals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a2d07c971548819ccb53196d89f83a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2d07c971548819ccb53196d89f83a6">&#9670;&nbsp;</a></span>btr_free_externally_stored_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_free_externally_stored_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>field_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a>&#160;</td>
          <td class="paramname"><em>rb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *local_mtr &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the space in an externally stored field to the file space management if the field in data is owned by the externally stored field, in a rollback we may have the additional condition that the field must not be inherited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of the data, the index tree MUST be X-latched; if the tree height is 1, then also the root page must be X-latched! (this is relevant in the case this function is called from purge where 'data' is located on an undo log page, not an index page) </td></tr>
    <tr><td class="paramname">field_ref</td><td>in/out: field reference </td></tr>
    <tr><td class="paramname">rec</td><td>in: record containing field_ref, for <a class="el" href="page0zip_8h.html#a9fb82f7de3a6622169bd966a7c97949f">page_zip_write_blob_ptr()</a>, or NULL </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index), or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in: compressed page corresponding to rec, or NULL if rec == NULL </td></tr>
    <tr><td class="paramname">i</td><td>in: field number of field_ref; ignored if rec == NULL </td></tr>
    <tr><td class="paramname">rb_ctx</td><td>in: rollback context </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in: mtr containing the latch to data an an X-latch to the index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe8370879960597a006379bb68d82b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8370879960597a006379bb68d82b52">&#9670;&nbsp;</a></span>btr_push_update_extern_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_push_update_extern_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags the data tuple fields that are marked as extern storage in the update vector. We use this function to remember which fields we must mark as extern storage in a record inserted for an update. </p><dl class="section return"><dt>Returns</dt><dd>number of flagged external columns </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in/out: data tuple </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c383bd105f982d216a7a430935f5706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c383bd105f982d216a7a430935f5706">&#9670;&nbsp;</a></span>btr_rec_copy_externally_stored_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_rec_copy_externally_stored_field </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies an externally stored field of a record to mem heap. </p><dl class="section return"><dt>Returns</dt><dd>the field copied to heap, or NULL if the field is incomplete </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record in a clustered index; must be protected by a lock or a page latch </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">no</td><td>in: field number </td></tr>
    <tr><td class="paramname">len</td><td>out: length of the field </td></tr>
    <tr><td class="paramname">heap</td><td>in: mem heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a599b288d0f486987f54d85ce1c533d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599b288d0f486987f54d85ce1c533d0e">&#9670;&nbsp;</a></span>btr_rec_free_externally_stored_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_rec_free_externally_stored_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a>&#160;</td>
          <td class="paramname"><em>rb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees the externally stored fields for a record. in: mini-transaction handle which contains an X-latch to record page and to the index tree</p>
<p>Frees the externally stored fields for a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of the data, the index tree MUST be X-latched </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">page_zip</td><td>in: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">rb_ctx</td><td>in: rollback context </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle which contains an X-latch to record page and to the index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28e8222dc60b8dec80cac33498a15a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e8222dc60b8dec80cac33498a15a2a">&#9670;&nbsp;</a></span>btr_rec_free_updated_extern_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_rec_free_updated_extern_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a>&#160;</td>
          <td class="paramname"><em>rb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees the externally stored fields for a record, if the field is mentioned in the update vector. in: mini-transaction handle which contains an X-latch to record page and to the tree</p>
<p>Frees the externally stored fields for a record, if the field is mentioned in the update vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of rec; the index tree MUST be X-latched </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">rb_ctx</td><td>in: rollback context </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle which contains an X-latch to record page and to the tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58003b4ea2270cb2170f97974b5f36fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58003b4ea2270cb2170f97974b5f36fa">&#9670;&nbsp;</a></span>btr_rec_get_externally_stored_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_rec_get_externally_stored_len </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the externally stored size of a record, in units of a database page. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>array returned by rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>externally stored part, in units of a database page </dd></dl>

</div>
</div>
<a id="adf9151a0d4ebaee472d93bfd55f835f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9151a0d4ebaee472d93bfd55f835f2">&#9670;&nbsp;</a></span>btr_rec_get_field_ref_offs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint btr_rec_get_field_ref_offs </td>
          <td>(</td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the offset of the pointer to the externally stored part of a field. </p><dl class="section return"><dt>Returns</dt><dd>offset of the pointer to the externally stored part </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">n</td><td>in: index of the external field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a649dfaf6f1de1688d814e6e95ac1caf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649dfaf6f1de1688d814e6e95ac1caf5">&#9670;&nbsp;</a></span>btr_rec_set_deleted_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_rec_set_deleted_flag </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The following function is used to set the deleted bit of a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: physical record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page (or NULL) </td></tr>
    <tr><td class="paramname">flag</td><td>in: nonzero if delete marked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3504db9f888c4d4994bf1b8a894b8b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3504db9f888c4d4994bf1b8a894b8b90">&#9670;&nbsp;</a></span>btr_record_not_null_field_in_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void btr_record_not_null_field_in_rec </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t *&#160;</td>
          <td class="paramname"><em>n_not_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Record the number of non_null key values in a given index for each n-column prefix of the index where 1 &lt;= n &lt;= dict_index_get_n_unique(index). The estimates are eventually stored in the array: index-&gt;stat_n_non_null_key_vals[], which is indexed from 0 to n-1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_unique</td><td>in: dict_index_get_n_unique(index), number of columns uniquely determine an index entry </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index), its size could be for all fields or that of "n_unique" </td></tr>
    <tr><td class="paramname">n_not_null</td><td>in/out: array to record number of not null rows for n-column prefix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdf9b005e1233e0700fc247dd383d475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf9b005e1233e0700fc247dd383d475">&#9670;&nbsp;</a></span>btr_store_big_rec_extern_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_store_big_rec_extern_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>rec_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *&#160;</td>
          <td class="paramname"><em>big_rec_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>btr_mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the fields in big_rec_vec to the tablespace and puts pointers to them in rec. The extern flags in rec will have to be set beforehand. The fields are stored on pages allocated from leaf node file segment of the index tree. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_OUT_OF_FILE_SPACE or DB_TOO_BIG_FOR_REDO</dd></dl>
<p>in: operation code </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of rec; the index tree MUST be X-latched </td></tr>
    <tr><td class="paramname">rec_block</td><td>in/out: block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index); the "external storage" flags in offsets will not correspond to rec when this function returns </td></tr>
    <tr><td class="paramname">big_rec_vec</td><td>in: vector containing fields to be stored externally </td></tr>
    <tr><td class="paramname">btr_mtr</td><td>in: mtr containing the latches to the clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a28f1a6f7902bd8a0cb58c2d0cac08c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f1a6f7902bd8a0cb58c2d0cac08c84">&#9670;&nbsp;</a></span>btr_cur_n_non_sea</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_cur_n_non_sea = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of searches down the B-tree in <a class="el" href="btr0cur_8cc.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level()</a>. </p>

</div>
</div>
<a id="a7643cc79559dd1b9461b11f88b554cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7643cc79559dd1b9461b11f88b554cd7">&#9670;&nbsp;</a></span>btr_cur_n_non_sea_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_cur_n_non_sea_old = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Old value of btr_cur_n_non_sea. Copied by <a class="el" href="srv0srv_8cc.html#aa7037cea22c187eff94afb8389fe04f2">srv_refresh_innodb_monitor_stats()</a>. Referenced by <a class="el" href="srv0srv_8h.html#ad9cbe424aaafd2138998d34630066322">srv_printf_innodb_monitor()</a>. </p>

</div>
</div>
<a id="a86620ab2987088f030f547ea4efcb9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86620ab2987088f030f547ea4efcb9c0">&#9670;&nbsp;</a></span>btr_cur_n_sea</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_cur_n_sea = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of successful adaptive hash index lookups in <a class="el" href="btr0cur_8cc.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level()</a>. </p>

</div>
</div>
<a id="a999c419864f12f8c08bdb760a2932f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999c419864f12f8c08bdb760a2932f76">&#9670;&nbsp;</a></span>btr_cur_n_sea_old</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_cur_n_sea_old = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Old value of btr_cur_n_sea. Copied by <a class="el" href="srv0srv_8cc.html#aa7037cea22c187eff94afb8389fe04f2">srv_refresh_innodb_monitor_stats()</a>. Referenced by <a class="el" href="srv0srv_8h.html#ad9cbe424aaafd2138998d34630066322">srv_printf_innodb_monitor()</a>. </p>

</div>
</div>
<a id="ab7e363c98b33d8339e7170309cd05207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e363c98b33d8339e7170309cd05207">&#9670;&nbsp;</a></span>cmpl_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0crea_8cc.html#a031463c80760e1002350e552afd98dd9">node</a> cmpl_info = cmpl_info</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: compiler info on secondary index updates </p>

</div>
</div>
<a id="ae6be834938be56633c510e0de2248709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6be834938be56633c510e0de2248709">&#9670;&nbsp;</a></span>cursor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> * cursor</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: undo logging and locking flags: if not zero, the parameters index and thr should be specified in: cursor on page after which to insert</p>
<p>&lt; in: undo logging and locking flags in: cursor on record to update</p>
<p>in: B-tree cursor</p>
<p>in: cursor on insert position</p>
<p>&lt; in: undo logging and locking flags in: B-tree cursor </p>

</div>
</div>
<a id="a522293ca1fb49d5a00042fade0fbb892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522293ca1fb49d5a00042fade0fbb892">&#9670;&nbsp;</a></span>entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> <a class="el" href="structdtuple__t.html">dtuple_t</a>* <a class="el" href="struct__entry.html">entry</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in/out: entry to insert </p>

</div>
</div>
<a id="aa2089f0f61b443ddde99d203fc1603fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2089f0f61b443ddde99d203fc1603fc">&#9670;&nbsp;</a></span>err</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> err</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="lock0lock_8h.html#a1351ab9296a8042326ebda0ec84c8a50">lock_rec_insert_check_and_lock</a>(<a class="code" href="ha__innodb_8cc.html#a7753a95f14c692e8da042e17c4d2df93">flags</a>, rec,</div><div class="line">                                             btr_cur_get_block(<a class="code" href="btr0cur_8cc.html#ae6be834938be56633c510e0de2248709">cursor</a>),</div><div class="line">                                             index, <a class="code" href="btr0cur_8cc.html#a09e213f7a1ae08e6d7a9c1c9218639a8">thr</a>, <a class="code" href="btr0cur_8cc.html#a4cd47c263be1b31cfc0b2ca0d0ba2f32">mtr</a>, <a class="code" href="btr0cur_8cc.html#aee6abb32bf6a300010a2c88fe98cc831">inherit</a>)</div><div class="ttc" id="btr0cur_8cc_html_a4cd47c263be1b31cfc0b2ca0d0ba2f32"><div class="ttname"><a href="btr0cur_8cc.html#a4cd47c263be1b31cfc0b2ca0d0ba2f32">mtr</a></div><div class="ttdeci">static const dtuple_t ulint mem_heap_t ulint mtr_t * mtr</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1102</div></div>
<div class="ttc" id="btr0cur_8cc_html_ae6be834938be56633c510e0de2248709"><div class="ttname"><a href="btr0cur_8cc.html#ae6be834938be56633c510e0de2248709">cursor</a></div><div class="ttdeci">UNIV_INLINE btr_cur_t * cursor</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1140</div></div>
<div class="ttc" id="btr0cur_8cc_html_aee6abb32bf6a300010a2c88fe98cc831"><div class="ttname"><a href="btr0cur_8cc.html#aee6abb32bf6a300010a2c88fe98cc831">inherit</a></div><div class="ttdeci">UNIV_INLINE btr_cur_t dtuple_t que_thr_t mtr_t ibool * inherit</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1147</div></div>
<div class="ttc" id="btr0cur_8cc_html_a09e213f7a1ae08e6d7a9c1c9218639a8"><div class="ttname"><a href="btr0cur_8cc.html#a09e213f7a1ae08e6d7a9c1c9218639a8">thr</a></div><div class="ttdeci">UNIV_INLINE btr_cur_t dtuple_t que_thr_t * thr</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1140</div></div>
<div class="ttc" id="ha__innodb_8cc_html_a7753a95f14c692e8da042e17c4d2df93"><div class="ttname"><a href="ha__innodb_8cc.html#a7753a95f14c692e8da042e17c4d2df93">flags</a></div><div class="ttdeci">static const TABLE const char const char const char ulint flags</div><div class="ttdef"><b>Definition:</b> ha_innodb.cc:8471</div></div>
<div class="ttc" id="lock0lock_8h_html_a1351ab9296a8042326ebda0ec84c8a50"><div class="ttname"><a href="lock0lock_8h.html#a1351ab9296a8042326ebda0ec84c8a50">lock_rec_insert_check_and_lock</a></div><div class="ttdeci">UNIV_INTERN dberr_t lock_rec_insert_check_and_lock(ulint flags, const rec_t *rec, buf_block_t *block, dict_index_t *index, que_thr_t *thr, mtr_t *mtr, ibool *inherit) __attribute__((nonnull</div></div>
</div><!-- fragment --><p>&lt; in: error code </p>

</div>
</div>
<a id="acf93462cc7a2ace0e2399e07e85210fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf93462cc7a2ace0e2399e07e85210fd">&#9670;&nbsp;</a></span>field_ref_zero</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const byte field_ref_zero[<a class="el" href="btr0types_8h.html#a0ce016535d5de52a1e27362330676df0">BTR_EXTERN_FIELD_REF_SIZE</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">        0, 0, 0, 0, 0,</div><div class="line">}</div></div><!-- fragment --><p>A BLOB field reference full of zero, for use in assertions and tests. Initially, BLOB field references are set to zero, in <a class="el" href="data0data_8cc.html#a2990a34a7c805c23d96819212eac1fa1">dtuple_convert_big_rec()</a>. </p>

</div>
</div>
<a id="adae46c2b2b2983e27a2c07a934885b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae46c2b2b2983e27a2c07a934885b46">&#9670;&nbsp;</a></span>heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint <a class="el" href="structmem__block__info__t.html">mem_heap_t</a>** heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in/out: pointer to memory heap, or NULL </p>

</div>
</div>
<a id="aee6abb32bf6a300010a2c88fe98cc831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6abb32bf6a300010a2c88fe98cc831">&#9670;&nbsp;</a></span>inherit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> <a class="el" href="structdtuple__t.html">dtuple_t</a> <a class="el" href="structque__thr__t.html">que_thr_t</a> <a class="el" href="structmtr__t.html">mtr_t</a> ibool* inherit</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <a class="code" href="structdict__index__t.html">dict_index_t</a>*   <a class="code" href="btr0btr_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a></div><div class="ttc" id="btr0btr_8cc_html_a4ddeaa41a4dab23a7eaa06ee52e4522b"><div class="ttname"><a href="btr0btr_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a></div><div class="ttdeci">static ulint buf_block_t dict_index_t * index</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:1984</div></div>
<div class="ttc" id="structdict__index__t_html"><div class="ttname"><a href="structdict__index__t.html">dict_index_t</a></div><div class="ttdef"><b>Definition:</b> dict0mem.h:566</div></div>
</div><!-- fragment --><p>&lt; out: TRUE if the inserted new record maybe should inherit LOCK_GAP type locks from the successor record </p>

</div>
</div>
<a id="a4cd47c263be1b31cfc0b2ca0d0ba2f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd47c263be1b31cfc0b2ca0d0ba2f32">&#9670;&nbsp;</a></span>mtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> const ulint const <a class="el" href="structupd__t.html">upd_t</a> ulint <a class="el" href="structque__thr__t.html">que_thr_t</a> <a class="el" href="structmtr__t.html">mtr_t</a>* mtr</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <a class="code" href="structpage__cur__t.html">page_cur_t</a>*     page_cursor</div><div class="ttc" id="structpage__cur__t_html"><div class="ttname"><a href="structpage__cur__t.html">page_cur_t</a></div><div class="ttdef"><b>Definition:</b> page0cur.h:378</div></div>
</div><!-- fragment --><p>&lt; in/out: mini-transaction</p>
<p>in/out: mini-transaction </p>

</div>
</div>
<a id="ab14e90cca5a13bd23c0993003c060e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14e90cca5a13bd23c0993003c060e03">&#9670;&nbsp;</a></span>n_ext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdtuple__t.html">dtuple_t</a> ulint <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> ulint n_ext</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: number of externally stored columns </p>

</div>
</div>
<a id="aeb186d52353116440b6e52fe66ed7ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb186d52353116440b6e52fe66ed7ea2">&#9670;&nbsp;</a></span>offsets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> const ulint* offsets</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>out: offsets on *rec</p>
<p>in: rec_get_offsets() on cursor </p>

</div>
</div>
<a id="a7c8cb9c29630901b8b5da4cdd7401d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8cb9c29630901b8b5da4cdd7401d36">&#9670;&nbsp;</a></span>rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rec</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="page0cur_8h.html#ae7a16e3c79f07fe42479802c0cb6ea23">page_cur_tuple_insert</a>(page_cursor, <a class="code" href="btr0cur_8cc.html#a77dc77108c9afbd5a202202d6e239fca">tuple</a>, <a class="code" href="btr0cur_8cc.html#ae6be834938be56633c510e0de2248709">cursor</a>-&gt;<a class="code" href="structbtr__cur__t.html#a1d268419dab170f2cb96f2548ad99833">index</a>,</div><div class="line">                                    <a class="code" href="btr0cur_8cc.html#aeb186d52353116440b6e52fe66ed7ea2">offsets</a>, <a class="code" href="btr0cur_8cc.html#adae46c2b2b2983e27a2c07a934885b46">heap</a>, <a class="code" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>, <a class="code" href="btr0cur_8cc.html#a4cd47c263be1b31cfc0b2ca0d0ba2f32">mtr</a>)</div><div class="ttc" id="btr0cur_8cc_html_a4cd47c263be1b31cfc0b2ca0d0ba2f32"><div class="ttname"><a href="btr0cur_8cc.html#a4cd47c263be1b31cfc0b2ca0d0ba2f32">mtr</a></div><div class="ttdeci">static const dtuple_t ulint mem_heap_t ulint mtr_t * mtr</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1102</div></div>
<div class="ttc" id="btr0cur_8cc_html_ab14e90cca5a13bd23c0993003c060e03"><div class="ttname"><a href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a></div><div class="ttdeci">static const dtuple_t ulint mem_heap_t ulint n_ext</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1097</div></div>
<div class="ttc" id="btr0cur_8cc_html_adae46c2b2b2983e27a2c07a934885b46"><div class="ttname"><a href="btr0cur_8cc.html#adae46c2b2b2983e27a2c07a934885b46">heap</a></div><div class="ttdeci">static const dtuple_t ulint mem_heap_t ** heap</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1097</div></div>
<div class="ttc" id="btr0cur_8cc_html_ae6be834938be56633c510e0de2248709"><div class="ttname"><a href="btr0cur_8cc.html#ae6be834938be56633c510e0de2248709">cursor</a></div><div class="ttdeci">UNIV_INLINE btr_cur_t * cursor</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1140</div></div>
<div class="ttc" id="structbtr__cur__t_html_a1d268419dab170f2cb96f2548ad99833"><div class="ttname"><a href="structbtr__cur__t.html#a1d268419dab170f2cb96f2548ad99833">btr_cur_t::index</a></div><div class="ttdeci">dict_index_t * index</div><div class="ttdef"><b>Definition:</b> btr0cur.h:807</div></div>
<div class="ttc" id="btr0cur_8cc_html_aeb186d52353116440b6e52fe66ed7ea2"><div class="ttname"><a href="btr0cur_8cc.html#aeb186d52353116440b6e52fe66ed7ea2">offsets</a></div><div class="ttdeci">static const dtuple_t ulint ** offsets</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1097</div></div>
<div class="ttc" id="page0cur_8h_html_ae7a16e3c79f07fe42479802c0cb6ea23"><div class="ttname"><a href="page0cur_8h.html#ae7a16e3c79f07fe42479802c0cb6ea23">page_cur_tuple_insert</a></div><div class="ttdeci">UNIV_INLINE rec_t * page_cur_tuple_insert(page_cur_t *cursor, const dtuple_t *tuple, dict_index_t *index, ulint **offsets, mem_heap_t **heap, ulint n_ext, mtr_t *mtr) __attribute__((nonnull(1</div></div>
<div class="ttc" id="btr0cur_8cc_html_a77dc77108c9afbd5a202202d6e239fca"><div class="ttname"><a href="btr0cur_8cc.html#a77dc77108c9afbd5a202202d6e239fca">tuple</a></div><div class="ttdeci">static const dtuple_t * tuple</div><div class="ttdef"><b>Definition:</b> btr0cur.cc:1097</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad1c4f16d584f1fabcea984746cf904a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c4f16d584f1fabcea984746cf904a1">&#9670;&nbsp;</a></span>roll_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> const ulint const <a class="el" href="structupd__t.html">upd_t</a> ulint <a class="el" href="structque__thr__t.html">que_thr_t</a> <a class="el" href="structmtr__t.html">mtr_t</a> <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> * roll_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <a class="code" href="structdict__index__t.html">dict_index_t</a>*   <a class="code" href="btr0btr_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a></div><div class="ttc" id="btr0btr_8cc_html_a4ddeaa41a4dab23a7eaa06ee52e4522b"><div class="ttname"><a href="btr0btr_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a></div><div class="ttdeci">static ulint buf_block_t dict_index_t * index</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:1984</div></div>
<div class="ttc" id="structdict__index__t_html"><div class="ttname"><a href="structdict__index__t.html">dict_index_t</a></div><div class="ttdef"><b>Definition:</b> dict0mem.h:566</div></div>
</div><!-- fragment --><p>&lt; out: roll pointer </p>

</div>
</div>
<a id="a09e213f7a1ae08e6d7a9c1c9218639a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e213f7a1ae08e6d7a9c1c9218639a8">&#9670;&nbsp;</a></span>thr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structque__thr__t.html">que_thr_t</a> * thr</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        <a class="code" href="structdict__foreign__t.html">dict_foreign_t</a>* <a class="code" href="dict0crea_8cc.html#a1362873f2d7bb1bfd79ca409ddbb674a">foreign</a></div><div class="ttc" id="structdict__foreign__t_html"><div class="ttname"><a href="structdict__foreign__t.html">dict_foreign_t</a></div><div class="ttdef"><b>Definition:</b> dict0mem.h:697</div></div>
<div class="ttc" id="dict0crea_8cc_html_a1362873f2d7bb1bfd79ca409ddbb674a"><div class="ttname"><a href="dict0crea_8cc.html#a1362873f2d7bb1bfd79ca409ddbb674a">foreign</a></div><div class="ttdeci">static const char const dict_foreign_t * foreign</div><div class="ttdef"><b>Definition:</b> dict0crea.cc:1538</div></div>
</div><!-- fragment --><p>in: query thread or NULL</p>
<p>in: query thread (can be NULL if BTR_NO_LOCKING_FLAG)</p>
<p>in: query thread</p>
<p>&lt; in: query thread</p>
<p>&lt; in: row insert node</p>
<p>&lt; in: query thread</p>
<p>&lt; in: select node</p>
<p>&lt; in: query thread</p>
<p>&lt; in: row undo node in: query thread</p>
<p>&lt; in: row undo node</p>
<p>&lt; in: query thread</p>
<p>&lt; in: search mode: BTR_MODIFY_LEAF or BTR_MODIFY_TREE in: query thread</p>
<p>&lt; in: row update node</p>
<p>&lt; in: query thread </p>

</div>
</div>
<a id="a77dc77108c9afbd5a202202d6e239fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dc77108c9afbd5a202202d6e239fca">&#9670;&nbsp;</a></span>tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdtuple__t.html">dtuple_t</a>* tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: cursor on page after which to insert; cursor stays valid in: tuple to insert; the size info need not have been stored to tuple </p>

</div>
</div>
<a id="a322291216e779ab29b06492cf9e41dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322291216e779ab29b06492cf9e41dce">&#9670;&nbsp;</a></span>update</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__t.html">upd_t</a> * update</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: update vector </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

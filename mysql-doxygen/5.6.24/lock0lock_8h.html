<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/lock0lock.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lock0lock.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0types_8h_source.html">mtr0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0types_8h_source.html">rem0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0types_8h_source.html">que0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0types_8h_source.html">lock0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="read0types_8h_source.html">read0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0vec_8h_source.html">ut0vec.h</a>&quot;</code><br />
<code>#include &quot;lock0lock.ic&quot;</code><br />
</div>
<p><a href="lock0lock_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__op__t.html">lock_op_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__sys__t.html">lock_sys_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab55bf242eefa1adae272425906fb4fad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab55bf242eefa1adae272425906fb4fad">lock_mutex_enter_nowait</a>()&#160;&#160;&#160;mutex_enter_nowait(&amp;<a class="el" href="lock0lock_8cc.html#a1743fff1d65daa7cd28852fcc17e5b87">lock_sys</a>-&gt;mutex)</td></tr>
<tr class="separator:ab55bf242eefa1adae272425906fb4fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2627320b3fe16bdedeed909919de3e58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a2627320b3fe16bdedeed909919de3e58">lock_mutex_own</a>()&#160;&#160;&#160;mutex_own(&amp;<a class="el" href="lock0lock_8cc.html#a1743fff1d65daa7cd28852fcc17e5b87">lock_sys</a>-&gt;mutex)</td></tr>
<tr class="separator:a2627320b3fe16bdedeed909919de3e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bfbe3afb8e847cdafb2bb6457b6721"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aa0bfbe3afb8e847cdafb2bb6457b6721">lock_mutex_enter</a>()</td></tr>
<tr class="separator:aa0bfbe3afb8e847cdafb2bb6457b6721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3974c25207bb78672d5c167125cc80ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3974c25207bb78672d5c167125cc80ff">lock_mutex_exit</a>()</td></tr>
<tr class="separator:a3974c25207bb78672d5c167125cc80ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf586f74bea52a9f41cb48d219e03cda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aaf586f74bea52a9f41cb48d219e03cda">lock_wait_mutex_own</a>()&#160;&#160;&#160;mutex_own(&amp;<a class="el" href="lock0lock_8cc.html#a1743fff1d65daa7cd28852fcc17e5b87">lock_sys</a>-&gt;wait_mutex)</td></tr>
<tr class="separator:aaf586f74bea52a9f41cb48d219e03cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af316b7272e81c47c1548d22025f542e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af316b7272e81c47c1548d22025f542e3">lock_wait_mutex_enter</a>()</td></tr>
<tr class="separator:af316b7272e81c47c1548d22025f542e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac7466a6379499864e831e92c950956"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#acac7466a6379499864e831e92c950956">lock_wait_mutex_exit</a>()</td></tr>
<tr class="separator:acac7466a6379499864e831e92c950956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aea25ac33bd6692ef77c95c6a7da765a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aea25ac33bd6692ef77c95c6a7da765a8">LOCK_MODE_MASK</a>&#160;&#160;&#160;0xFUL</td></tr>
<tr class="separator:aea25ac33bd6692ef77c95c6a7da765a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5d26fd94580daba78f376b8ca887dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3f5d26fd94580daba78f376b8ca887dd">LOCK_TABLE</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a3f5d26fd94580daba78f376b8ca887dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145ae646d1def688ee264b9d98c2e981"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a145ae646d1def688ee264b9d98c2e981">LOCK_REC</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a145ae646d1def688ee264b9d98c2e981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51876da8368dde6b362ce3c465dcc9eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a51876da8368dde6b362ce3c465dcc9eb">LOCK_TYPE_MASK</a>&#160;&#160;&#160;0xF0UL</td></tr>
<tr class="separator:a51876da8368dde6b362ce3c465dcc9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ad796dd0adc2da08468a220376fe76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a92ad796dd0adc2da08468a220376fe76">LOCK_WAIT</a>&#160;&#160;&#160;256</td></tr>
<tr class="separator:a92ad796dd0adc2da08468a220376fe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f8dd3d016d01aaa314160f0db74e75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a95f8dd3d016d01aaa314160f0db74e75">LOCK_ORDINARY</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a95f8dd3d016d01aaa314160f0db74e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8631af3f85d4c19484f6de819b2b2a37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a8631af3f85d4c19484f6de819b2b2a37">LOCK_GAP</a>&#160;&#160;&#160;512</td></tr>
<tr class="separator:a8631af3f85d4c19484f6de819b2b2a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec9b0cce21ee17de083d3bb96b1bec6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5ec9b0cce21ee17de083d3bb96b1bec6">LOCK_REC_NOT_GAP</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a5ec9b0cce21ee17de083d3bb96b1bec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a448126f7465de2aa940d1751dd8b7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7a448126f7465de2aa940d1751dd8b7e">LOCK_INSERT_INTENTION</a>&#160;&#160;&#160;2048</td></tr>
<tr class="separator:a7a448126f7465de2aa940d1751dd8b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afd6d281988732c472d3e0f7eac4d6e4e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#afd6d281988732c472d3e0f7eac4d6e4e">lock_get_size</a> (void)</td></tr>
<tr class="separator:afd6d281988732c472d3e0f7eac4d6e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ad348feb00e96aec397b06dbec7c64"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a40ad348feb00e96aec397b06dbec7c64">lock_sys_create</a> (ulint n_cells)</td></tr>
<tr class="separator:a40ad348feb00e96aec397b06dbec7c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2350ce483b08686c48c19407f63da9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9c2350ce483b08686c48c19407f63da9">lock_sys_close</a> (void)</td></tr>
<tr class="separator:a9c2350ce483b08686c48c19407f63da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d299943e5932310b8db82f441b885f5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9d299943e5932310b8db82f441b885f5">lock_get_min_heap_no</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a9d299943e5932310b8db82f441b885f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7273b2c3c75e90408bdc5a711effc73a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7273b2c3c75e90408bdc5a711effc73a">lock_move_reorganize_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *oblock)</td></tr>
<tr class="separator:a7273b2c3c75e90408bdc5a711effc73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb43b7be638bd32fa36b7c025d636bb6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#adb43b7be638bd32fa36b7c025d636bb6">lock_move_rec_list_end</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:adb43b7be638bd32fa36b7c025d636bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e7197a446aee79574d335d277aaa84"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a23e7197a446aee79574d335d277aaa84">lock_move_rec_list_start</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const rec_t *old_end)</td></tr>
<tr class="separator:a23e7197a446aee79574d335d277aaa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd5be77aa944f96aa6ff0aeebc6eb98"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9cd5be77aa944f96aa6ff0aeebc6eb98">lock_update_split_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="separator:a9cd5be77aa944f96aa6ff0aeebc6eb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2bdadfd1e57ddbedfc05740e884eb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9ec2bdadfd1e57ddbedfc05740e884eb">lock_update_merge_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const rec_t *orig_succ, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="separator:a9ec2bdadfd1e57ddbedfc05740e884eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e3b8ed16aaab0770730fb554e23af2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a82e3b8ed16aaab0770730fb554e23af2">lock_update_root_raise</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *root)</td></tr>
<tr class="separator:a82e3b8ed16aaab0770730fb554e23af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc8f00508ee648886c7d51046af30d1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a6cc8f00508ee648886c7d51046af30d1">lock_update_copy_and_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="btr0btr_8cc.html#a027a5099548314f2e2405f7d6270725f">new_block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a6cc8f00508ee648886c7d51046af30d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5beb29b82077fbb4080d16b8214c1d57"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5beb29b82077fbb4080d16b8214c1d57">lock_update_split_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="separator:a5beb29b82077fbb4080d16b8214c1d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742d185fcf374672c516427602f386eb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a742d185fcf374672c516427602f386eb">lock_update_merge_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block, const rec_t *orig_pred, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block)</td></tr>
<tr class="separator:a742d185fcf374672c516427602f386eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a1ced4eeb3daa98b39ee2365df8b1a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af1a1ced4eeb3daa98b39ee2365df8b1a">lock_rec_reset_and_inherit_gap_locks</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, ulint heir_heap_no, ulint heap_no)</td></tr>
<tr class="separator:af1a1ced4eeb3daa98b39ee2365df8b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d322cfc717fe99e4c5c88f7b93512e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a47d322cfc717fe99e4c5c88f7b93512e">lock_update_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, ulint heir_heap_no, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a47d322cfc717fe99e4c5c88f7b93512e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b800d596ae20af9b8b28f7a879658b4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7b800d596ae20af9b8b28f7a879658b4">lock_update_insert</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:a7b800d596ae20af9b8b28f7a879658b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd33b69b0b70f3e6643e70275550a0a7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#acd33b69b0b70f3e6643e70275550a0a7">lock_update_delete</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:acd33b69b0b70f3e6643e70275550a0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32bb2ec136f61df97fea7e90c94a7cf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ad32bb2ec136f61df97fea7e90c94a7cf">lock_rec_store_on_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>)</td></tr>
<tr class="separator:ad32bb2ec136f61df97fea7e90c94a7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04f9ddc87db84d8621e853f1a3434db"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ad04f9ddc87db84d8621e853f1a3434db">lock_rec_restore_from_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *donator)</td></tr>
<tr class="separator:ad04f9ddc87db84d8621e853f1a3434db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c287ddf568445e841142a590b6d9b3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab8c287ddf568445e841142a590b6d9b3">lock_rec_expl_exist_on_page</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result))</td></tr>
<tr class="separator:ab8c287ddf568445e841142a590b6d9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1351ab9296a8042326ebda0ec84c8a50"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a1351ab9296a8042326ebda0ec84c8a50">lock_rec_insert_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, ibool *<a class="el" href="btr0cur_8cc.html#aee6abb32bf6a300010a2c88fe98cc831">inherit</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a1351ab9296a8042326ebda0ec84c8a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62a996fe1bd175c8407401036801759"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac62a996fe1bd175c8407401036801759">lock_clust_rec_modify_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result</td></tr>
<tr class="separator:ac62a996fe1bd175c8407401036801759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b391867035415fabb8d5989e419b598"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a2b391867035415fabb8d5989e419b598">lock_sec_rec_modify_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result</td></tr>
<tr class="separator:a2b391867035415fabb8d5989e419b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5451bb0a1ff92516e34e1243cce87d01"><td class="memItemLeft" align="right" valign="top"><a id="a5451bb0a1ff92516e34e1243cce87d01"></a>
UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nonnull</b> (2, 3, 4, 6)))</td></tr>
<tr class="separator:a5451bb0a1ff92516e34e1243cce87d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d5f3bc41223f625ac09672a1ca19bf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab1d5f3bc41223f625ac09672a1ca19bf">lock_sec_rec_read_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:ab1d5f3bc41223f625ac09672a1ca19bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa600625a4fffa2b7f0a68cdd64b1ad3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:afa600625a4fffa2b7f0a68cdd64b1ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39da625c9be699c01ebd3cd0449639b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aa39da625c9be699c01ebd3cd0449639b">lock_clust_rec_read_check_and_lock_alt</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:aa39da625c9be699c01ebd3cd0449639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac202bf2346684b96cfecca70ad64b002"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac202bf2346684b96cfecca70ad64b002">lock_clust_rec_cons_read_sees</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="structread__view__t.html">read_view_t</a> *view)</td></tr>
<tr class="separator:ac202bf2346684b96cfecca70ad64b002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd747ddccebb0da116d544b97ce93ffe"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#afd747ddccebb0da116d544b97ce93ffe">lock_sec_rec_cons_read_sees</a> (const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, const <a class="el" href="structread__view__t.html">read_view_t</a> *view) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:afd747ddccebb0da116d544b97ce93ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250be234223f746d5068a155f771ca77"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a250be234223f746d5068a155f771ca77">lock_table</a> (ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, enum lock_mode <a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a250be234223f746d5068a155f771ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056fa163c142cf71d21e6e3d046f060"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a1056fa163c142cf71d21e6e3d046f060">lock_table_ix_resurrect</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a1056fa163c142cf71d21e6e3d046f060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409999adb50ece16b81d59486af7af45"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a409999adb50ece16b81d59486af7af45">lock_rec_unlock</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, enum lock_mode lock_mode)</td></tr>
<tr class="separator:a409999adb50ece16b81d59486af7af45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af056c93107ab266face88ec37bae94c7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af056c93107ab266face88ec37bae94c7">lock_trx_release_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:af056c93107ab266face88ec37bae94c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430d15f2674ea7fb0d8cf61636192011"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a430d15f2674ea7fb0d8cf61636192011">lock_remove_all_on_table</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, ibool remove_also_table_sx_locks)</td></tr>
<tr class="separator:a430d15f2674ea7fb0d8cf61636192011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06042fa19a19db9a11511aeb0399e6da"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a06042fa19a19db9a11511aeb0399e6da">lock_rec_fold</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((const))</td></tr>
<tr class="separator:a06042fa19a19db9a11511aeb0399e6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2ec292dd7525aff0dee8910ca3a99d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5f2ec292dd7525aff0dee8910ca3a99d">lock_rec_hash</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:a5f2ec292dd7525aff0dee8910ca3a99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac31e933724030fe1aca76ebbd1b524"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aeac31e933724030fe1aca76ebbd1b524">lock_rec_find_set_bit</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:aeac31e933724030fe1aca76ebbd1b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663621ff9b0550c0f2caa5fe6facc3e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab663621ff9b0550c0f2caa5fe6facc3e">lock_get_src_table</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *dest, enum lock_mode *<a class="el" href="row0umod_8cc.html#a72b8a027308addc643f9adf5e4d41f9a">mode</a>)</td></tr>
<tr class="separator:ab663621ff9b0550c0f2caa5fe6facc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c383616365a77c9eb155fa41ef99809"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a2c383616365a77c9eb155fa41ef99809">lock_is_table_exclusive</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>, const <a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a2c383616365a77c9eb155fa41ef99809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa82401a7f43bcd7ee507b462151b50"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a4fa82401a7f43bcd7ee507b462151b50">lock_has_to_wait</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock1, const <a class="el" href="structlock__t.html">lock_t</a> *lock2)</td></tr>
<tr class="separator:a4fa82401a7f43bcd7ee507b462151b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d388e6198f7c7312d0de9cb804b378"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a67d388e6198f7c7312d0de9cb804b378">lock_report_trx_id_insanity</a> (<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> <a class="el" href="trx0undo_8cc.html#a31dc85e5157cc0055a93f38465fdef6b">trx_id</a>, const rec_t *<a class="el" href="row0sel_8cc.html#a885b1a2aa48633ec89f311f7ec2c9aaa">rec</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="row0upd_8cc.html#a4ddeaa41a4dab23a7eaa06ee52e4522b">index</a>, const ulint *<a class="el" href="row0upd_8cc.html#aba3805bd573676d9962792683b40ac6b">offsets</a>, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> max_trx_id) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a67d388e6198f7c7312d0de9cb804b378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf98b08ed2e93284570fc964e5b24c16"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#adf98b08ed2e93284570fc964e5b24c16">lock_table_print</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:adf98b08ed2e93284570fc964e5b24c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed491db1a4f9e54c46b5618fda1a72dd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aed491db1a4f9e54c46b5618fda1a72dd">lock_rec_print</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:aed491db1a4f9e54c46b5618fda1a72dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b323a3ed0083cd3856c35c551a388b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aa1b323a3ed0083cd3856c35c551a388b">lock_print_info_summary</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>, ibool nowait) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:aa1b323a3ed0083cd3856c35c551a388b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d8a6d0b9f2926b63ea83ec8b9633c7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a96d8a6d0b9f2926b63ea83ec8b9633c7">lock_print_info_all_transactions</a> (FILE *<a class="el" href="row0quiesce_8cc.html#a702945180aa732857b380a007a7e2a21">file</a>)</td></tr>
<tr class="separator:a96d8a6d0b9f2926b63ea83ec8b9633c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c816baaa2b3982f4bcf8c7519510cd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a74c816baaa2b3982f4bcf8c7519510cd">lock_number_of_rows_locked</a> (const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *trx_lock) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull</td></tr>
<tr class="separator:a74c816baaa2b3982f4bcf8c7519510cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c17bbd1a704e818f0a9e93dcf7b0541"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3c17bbd1a704e818f0a9e93dcf7b0541">lock_get_type</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a3c17bbd1a704e818f0a9e93dcf7b0541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c9a06b5b21a1e4c04b5cafc68b6ccd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab9c9a06b5b21a1e4c04b5cafc68b6ccd">lock_get_trx_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ab9c9a06b5b21a1e4c04b5cafc68b6ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2809d68943d3e72cbfd11885126356"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ade2809d68943d3e72cbfd11885126356">lock_get_mode_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ade2809d68943d3e72cbfd11885126356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdf57695b21f5d522b265090787f5d4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5bdf57695b21f5d522b265090787f5d4">lock_get_type_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a5bdf57695b21f5d522b265090787f5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec13113aefe2d0c30da8e0b70d8529d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN table_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5ec13113aefe2d0c30da8e0b70d8529d">lock_get_table_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a5ec13113aefe2d0c30da8e0b70d8529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec43fb602ff6a6cb8964d5c4c1c0d4f7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aec43fb602ff6a6cb8964d5c4c1c0d4f7">lock_get_table_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:aec43fb602ff6a6cb8964d5c4c1c0d4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad153d0b712ae422378a58151c8628efd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ad153d0b712ae422378a58151c8628efd">lock_rec_get_index</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ad153d0b712ae422378a58151c8628efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0200bf5b9ee51f495a2ddf704c63ad"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3b0200bf5b9ee51f495a2ddf704c63ad">lock_rec_get_index_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a3b0200bf5b9ee51f495a2ddf704c63ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90793ee45348397c09e6eb0938fa3e4a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a90793ee45348397c09e6eb0938fa3e4a">lock_rec_get_space_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:a90793ee45348397c09e6eb0938fa3e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cdf332f59754136d761b9fe0d88564"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ae5cdf332f59754136d761b9fe0d88564">lock_rec_get_page_no</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="separator:ae5cdf332f59754136d761b9fe0d88564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a934d7768a7c68d802e733fcf86f1c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a97a934d7768a7c68d802e733fcf86f1c">lock_table_has_locks</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>)</td></tr>
<tr class="separator:a97a934d7768a7c68d802e733fcf86f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3fb581b71eeb0fa35520a1fe944abb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7d3fb581b71eeb0fa35520a1fe944abb">lock_wait_timeout_thread</a> (void *arg)</td></tr>
<tr class="separator:a7d3fb581b71eeb0fa35520a1fe944abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05119c03d5d3b065c5da4ae75d8aa1ff"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a05119c03d5d3b065c5da4ae75d8aa1ff">lock_wait_release_thread_if_suspended</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:a05119c03d5d3b065c5da4ae75d8aa1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfdc852efca69d23054639668aa17b6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#addfdc852efca69d23054639668aa17b6">lock_wait_suspend_thread</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *<a class="el" href="row0upd_8cc.html#a6a975f02e8f3909627020f06146ee9dd">thr</a>)</td></tr>
<tr class="separator:addfdc852efca69d23054639668aa17b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838b492f61b92e3678c7b7be18a2f1be"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a838b492f61b92e3678c7b7be18a2f1be">lock_unlock_table_autoinc</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>)</td></tr>
<tr class="separator:a838b492f61b92e3678c7b7be18a2f1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bc2bfbf01660ced593b50590ae0cf0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a88bc2bfbf01660ced593b50590ae0cf0">lock_trx_handle_wait</a> (<a class="el" href="structtrx__t.html">trx_t</a> *<a class="el" href="trx0trx_8cc.html#a33c6bd3ec7adfebaac8ed4906004b2ab">trx</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a88bc2bfbf01660ced593b50590ae0cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a0117979ee1b97fa239bbac6a6e087"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a04a0117979ee1b97fa239bbac6a6e087">lock_table_get_n_locks</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *<a class="el" href="row0upd_8cc.html#ab172ed3d3d31ff02fc5f798fe7e1bfb8">table</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a04a0117979ee1b97fa239bbac6a6e087"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af7a69bef6f3b62fe12e88640d633b782"><td class="memItemLeft" align="right" valign="top"><a id="af7a69bef6f3b62fe12e88640d633b782"></a>
UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>warn_unused_result</b></td></tr>
<tr class="separator:af7a69bef6f3b62fe12e88640d633b782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e52cc2e3285acc40bf3590695c8f2b"><td class="memItemLeft" align="right" valign="top"><a id="a40e52cc2e3285acc40bf3590695c8f2b"></a>
UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nonnull</b></td></tr>
<tr class="separator:a40e52cc2e3285acc40bf3590695c8f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5399aad1a992cb27e897fc806570ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlock__sys__t.html">lock_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a></td></tr>
<tr class="separator:ac5399aad1a992cb27e897fc806570ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The transaction lock system</p>
<p>Created 5/7/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8631af3f85d4c19484f6de819b2b2a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8631af3f85d4c19484f6de819b2b2a37">&#9670;&nbsp;</a></span>LOCK_GAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_GAP&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when this bit is set, it means that the lock holds only on the gap before the record; for instance, an x-lock on the gap does not give permission to modify the record on which the bit is set; locks of this type are created when records are removed from the index chain of records </p>

</div>
</div>
<a id="a7a448126f7465de2aa940d1751dd8b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a448126f7465de2aa940d1751dd8b7e">&#9670;&nbsp;</a></span>LOCK_INSERT_INTENTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_INSERT_INTENTION&#160;&#160;&#160;2048</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this bit is set when we place a waiting gap type record lock request in order to let an insert of an index record to wait until there are no conflicting locks by other transactions on the gap; note that this flag remains set when the waiting lock is granted, or if the lock is inherited to a neighboring record </p>

</div>
</div>
<a id="aea25ac33bd6692ef77c95c6a7da765a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea25ac33bd6692ef77c95c6a7da765a8">&#9670;&nbsp;</a></span>LOCK_MODE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_MODE_MASK&#160;&#160;&#160;0xFUL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock modes and types mask used to extract mode from the type_mode field in a lock </p>

</div>
</div>
<a id="aa0bfbe3afb8e847cdafb2bb6457b6721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bfbe3afb8e847cdafb2bb6457b6721">&#9670;&nbsp;</a></span>lock_mutex_enter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_mutex_enter</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div><div class="line">        mutex_enter(&amp;<a class="code" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;<a class="code" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">mutex</a>);          \</div><div class="line">} <span class="keywordflow">while</span> (0)</div><div class="ttc" id="lock0lock_8h_html_ac5399aad1a992cb27e897fc806570ba0"><div class="ttname"><a href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a></div><div class="ttdeci">lock_sys_t * lock_sys</div><div class="ttdef"><b>Definition:</b> lock0lock.cc:416</div></div>
<div class="ttc" id="structlock__sys__t_html_a5cac6a7c287b4a2831854e39ccf7cb70"><div class="ttname"><a href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">lock_sys_t::mutex</a></div><div class="ttdeci">ib_mutex_t mutex</div><div class="ttdef"><b>Definition:</b> lock0lock.h:939</div></div>
</div><!-- fragment --><p>Acquire the lock_sys-&gt;mutex. </p>

</div>
</div>
<a id="ab55bf242eefa1adae272425906fb4fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55bf242eefa1adae272425906fb4fad">&#9670;&nbsp;</a></span>lock_mutex_enter_nowait</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_mutex_enter_nowait</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;mutex_enter_nowait(&amp;<a class="el" href="lock0lock_8cc.html#a1743fff1d65daa7cd28852fcc17e5b87">lock_sys</a>-&gt;mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if lock_sys-&gt;mutex can be acquired without waiting. </p>

</div>
</div>
<a id="a3974c25207bb78672d5c167125cc80ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3974c25207bb78672d5c167125cc80ff">&#9670;&nbsp;</a></span>lock_mutex_exit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_mutex_exit</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div><div class="line">        mutex_exit(&amp;<a class="code" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;<a class="code" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">mutex</a>);           \</div><div class="line">} <span class="keywordflow">while</span> (0)</div><div class="ttc" id="lock0lock_8h_html_ac5399aad1a992cb27e897fc806570ba0"><div class="ttname"><a href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a></div><div class="ttdeci">lock_sys_t * lock_sys</div><div class="ttdef"><b>Definition:</b> lock0lock.cc:416</div></div>
<div class="ttc" id="structlock__sys__t_html_a5cac6a7c287b4a2831854e39ccf7cb70"><div class="ttname"><a href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">lock_sys_t::mutex</a></div><div class="ttdeci">ib_mutex_t mutex</div><div class="ttdef"><b>Definition:</b> lock0lock.h:939</div></div>
</div><!-- fragment --><p>Release the lock_sys-&gt;mutex. </p>

</div>
</div>
<a id="a2627320b3fe16bdedeed909919de3e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2627320b3fe16bdedeed909919de3e58">&#9670;&nbsp;</a></span>lock_mutex_own</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_mutex_own</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;mutex_own(&amp;<a class="el" href="lock0lock_8cc.html#a1743fff1d65daa7cd28852fcc17e5b87">lock_sys</a>-&gt;mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if lock_sys-&gt;mutex is owned. </p>

</div>
</div>
<a id="a95f8dd3d016d01aaa314160f0db74e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f8dd3d016d01aaa314160f0db74e75">&#9670;&nbsp;</a></span>LOCK_ORDINARY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_ORDINARY&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this flag denotes an ordinary next-key lock in contrast to LOCK_GAP or LOCK_REC_NOT_GAP </p>

</div>
</div>
<a id="a145ae646d1def688ee264b9d98c2e981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145ae646d1def688ee264b9d98c2e981">&#9670;&nbsp;</a></span>LOCK_REC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_REC&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>record lock </p>

</div>
</div>
<a id="a5ec9b0cce21ee17de083d3bb96b1bec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec9b0cce21ee17de083d3bb96b1bec6">&#9670;&nbsp;</a></span>LOCK_REC_NOT_GAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_REC_NOT_GAP&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this bit means that the lock is only on the index record and does NOT block inserts to the gap before the index record; this is used in the case when we retrieve a record with a unique key, and is also used in locking plain SELECTs (not part of UPDATE or DELETE) when the user has set the READ COMMITTED isolation level </p>

</div>
</div>
<a id="a3f5d26fd94580daba78f376b8ca887dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5d26fd94580daba78f376b8ca887dd">&#9670;&nbsp;</a></span>LOCK_TABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_TABLE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock types table lock </p>

</div>
</div>
<a id="a51876da8368dde6b362ce3c465dcc9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51876da8368dde6b362ce3c465dcc9eb">&#9670;&nbsp;</a></span>LOCK_TYPE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_TYPE_MASK&#160;&#160;&#160;0xF0UL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mask used to extract lock type from the type_mode field in a lock </p>

</div>
</div>
<a id="a92ad796dd0adc2da08468a220376fe76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ad796dd0adc2da08468a220376fe76">&#9670;&nbsp;</a></span>LOCK_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_WAIT&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waiting lock flag; when set, it means that the lock has not yet been granted, it is just waiting for its turn in the wait queue </p>

</div>
</div>
<a id="af316b7272e81c47c1548d22025f542e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af316b7272e81c47c1548d22025f542e3">&#9670;&nbsp;</a></span>lock_wait_mutex_enter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_wait_mutex_enter</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {            \</div><div class="line">        mutex_enter(&amp;<a class="code" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;<a class="code" href="structlock__sys__t.html#a9fc1affce7ce17500f48fa8100067864">wait_mutex</a>);     \</div><div class="line">} <span class="keywordflow">while</span> (0)</div><div class="ttc" id="structlock__sys__t_html_a9fc1affce7ce17500f48fa8100067864"><div class="ttname"><a href="structlock__sys__t.html#a9fc1affce7ce17500f48fa8100067864">lock_sys_t::wait_mutex</a></div><div class="ttdeci">ib_mutex_t wait_mutex</div><div class="ttdef"><b>Definition:</b> lock0lock.h:943</div></div>
<div class="ttc" id="lock0lock_8h_html_ac5399aad1a992cb27e897fc806570ba0"><div class="ttname"><a href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a></div><div class="ttdeci">lock_sys_t * lock_sys</div><div class="ttdef"><b>Definition:</b> lock0lock.cc:416</div></div>
</div><!-- fragment --><p>Acquire the lock_sys-&gt;wait_mutex. </p>

</div>
</div>
<a id="acac7466a6379499864e831e92c950956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac7466a6379499864e831e92c950956">&#9670;&nbsp;</a></span>lock_wait_mutex_exit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_wait_mutex_exit</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {            \</div><div class="line">        mutex_exit(&amp;<a class="code" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;<a class="code" href="structlock__sys__t.html#a9fc1affce7ce17500f48fa8100067864">wait_mutex</a>);      \</div><div class="line">} <span class="keywordflow">while</span> (0)</div><div class="ttc" id="structlock__sys__t_html_a9fc1affce7ce17500f48fa8100067864"><div class="ttname"><a href="structlock__sys__t.html#a9fc1affce7ce17500f48fa8100067864">lock_sys_t::wait_mutex</a></div><div class="ttdeci">ib_mutex_t wait_mutex</div><div class="ttdef"><b>Definition:</b> lock0lock.h:943</div></div>
<div class="ttc" id="lock0lock_8h_html_ac5399aad1a992cb27e897fc806570ba0"><div class="ttname"><a href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a></div><div class="ttdeci">lock_sys_t * lock_sys</div><div class="ttdef"><b>Definition:</b> lock0lock.cc:416</div></div>
</div><!-- fragment --><p>Release the lock_sys-&gt;wait_mutex. </p>

</div>
</div>
<a id="aaf586f74bea52a9f41cb48d219e03cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf586f74bea52a9f41cb48d219e03cda">&#9670;&nbsp;</a></span>lock_wait_mutex_own</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_wait_mutex_own</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;mutex_own(&amp;<a class="el" href="lock0lock_8cc.html#a1743fff1d65daa7cd28852fcc17e5b87">lock_sys</a>-&gt;wait_mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if lock_sys-&gt;wait_mutex is owned. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac202bf2346684b96cfecca70ad64b002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac202bf2346684b96cfecca70ad64b002">&#9670;&nbsp;</a></span>lock_clust_rec_cons_read_sees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool lock_clust_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structread__view__t.html">read_view_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that a record is seen in a consistent read. </p><dl class="section return"><dt>Returns</dt><dd>true if sees, or false if an earlier version of the record should be retrieved in: consistent read view</dd></dl>
<p>Checks that a record is seen in a consistent read. </p><dl class="section return"><dt>Returns</dt><dd>true if sees, or false if an earlier version of the record should be retrieved </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">view</td><td>in: consistent read view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac62a996fe1bd175c8407401036801759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62a996fe1bd175c8407401036801759">&#9670;&nbsp;</a></span>lock_clust_rec_modify_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate modify (update, delete mark, or delete unmark) of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record x-lock to the lock queue. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa600625a4fffa2b7f0a68cdd64b1ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa600625a4fffa2b7f0a68cdd64b1ad3">&#9670;&nbsp;</a></span>lock_clust_rec_read_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED in: query thread</dd></dl>
<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa39da625c9be699c01ebd3cd0449639b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39da625c9be699c01ebd3cd0449639b">&#9670;&nbsp;</a></span>lock_clust_rec_read_check_and_lock_alt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock_alt </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. This is an alternative version of <a class="el" href="lock0lock_8h.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock()</a> that does not require the parameter "offsets". </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d299943e5932310b8db82f441b885f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d299943e5932310b8db82f441b885f5">&#9670;&nbsp;</a></span>lock_get_min_heap_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_get_min_heap_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the heap_no of the smallest user record on a page. </p><dl class="section return"><dt>Returns</dt><dd>heap_no of smallest user record, or PAGE_HEAP_NO_SUPREMUM in: buffer block </dd></dl>

</div>
</div>
<a id="ade2809d68943d3e72cbfd11885126356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2809d68943d3e72cbfd11885126356">&#9670;&nbsp;</a></span>lock_get_mode_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_get_mode_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the mode of a lock in a human readable string. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock mode in: lock</dd></dl>
<p>Gets the mode of a lock in a human readable string. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock mode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd6d281988732c472d3e0f7eac4d6e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6d281988732c472d3e0f7eac4d6e4e">&#9670;&nbsp;</a></span>lock_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_get_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of a lock struct. </p><dl class="section return"><dt>Returns</dt><dd>size in bytes </dd></dl>

</div>
</div>
<a id="ab663621ff9b0550c0f2caa5fe6facc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab663621ff9b0550c0f2caa5fe6facc3e">&#9670;&nbsp;</a></span>lock_get_src_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a>* lock_get_src_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the source table of an ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> transaction. The table must be covered by an IX or IS table lock. </p><dl class="section return"><dt>Returns</dt><dd>the source table of transaction, if it is covered by an IX or IS table lock; dest if there is no source table, and NULL if the transaction is locking more than two tables or an inconsistency is found out: lock mode of the source table</dd></dl>
<p>Gets the source table of an ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> transaction. The table must be covered by an IX or IS table lock. </p><dl class="section return"><dt>Returns</dt><dd>the source table of transaction, if it is covered by an IX or IS table lock; dest if there is no source table, and NULL if the transaction is locking more than two tables or an inconsistency is found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">dest</td><td>in: destination of ALTER <a class="el" href="struct_t_a_b_l_e.html">TABLE</a> </td></tr>
    <tr><td class="paramname">mode</td><td>out: lock mode of the source table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec13113aefe2d0c30da8e0b70d8529d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec13113aefe2d0c30da8e0b70d8529d">&#9670;&nbsp;</a></span>lock_get_table_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN table_id_t lock_get_table_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the id of the table on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>id of the table in: lock</dd></dl>
<p>Gets the id of the table on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>id of the table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec43fb602ff6a6cb8964d5c4c1c0d4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec43fb602ff6a6cb8964d5c4c1c0d4f7">&#9670;&nbsp;</a></span>lock_get_table_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_get_table_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the name of the table on which the lock is. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>name of the table in: lock</dd></dl>
<p>Gets the name of the table on which the lock is. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>name of the table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9c9a06b5b21a1e4c04b5cafc68b6ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c9a06b5b21a1e4c04b5cafc68b6ccd">&#9670;&nbsp;</a></span>lock_get_trx_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> lock_get_trx_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the id of the transaction owning a lock. </p><dl class="section return"><dt>Returns</dt><dd>transaction id in: lock</dd></dl>
<p>Gets the id of the transaction owning a lock. </p><dl class="section return"><dt>Returns</dt><dd>transaction id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c17bbd1a704e818f0a9e93dcf7b0541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c17bbd1a704e818f0a9e93dcf7b0541">&#9670;&nbsp;</a></span>lock_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_get_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the type of a lock. Non-inline version for using outside of the lock module. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_TABLE or LOCK_REC in: lock</dd></dl>
<p>Gets the type of a lock. Non-inline version for using outside of the lock module. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_TABLE or LOCK_REC </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bdf57695b21f5d522b265090787f5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdf57695b21f5d522b265090787f5d4">&#9670;&nbsp;</a></span>lock_get_type_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_get_type_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the type of a lock in a human readable string. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock type in: lock</dd></dl>
<p>Gets the type of a lock in a human readable string. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fa82401a7f43bcd7ee507b462151b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa82401a7f43bcd7ee507b462151b50">&#9670;&nbsp;</a></span>lock_has_to_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool lock_has_to_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a lock request lock1 has to wait for request lock2. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if lock1 has to wait for lock2 to be removed in: another lock; NOTE that it is assumed that this has a lock bit set on the same record as in lock1 if the locks are record locks</dd></dl>
<p>Checks if a lock request lock1 has to wait for request lock2. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if lock1 has to wait for lock2 to be removed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock1</td><td>in: waiting lock </td></tr>
    <tr><td class="paramname">lock2</td><td>in: another lock; NOTE that it is assumed that this has a lock bit set on the same record as in lock1 if the locks are record locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c383616365a77c9eb155fa41ef99809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c383616365a77c9eb155fa41ef99809">&#9670;&nbsp;</a></span>lock_is_table_exclusive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool lock_is_table_exclusive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if the given table is exclusively "owned" by the given transaction, i.e., transaction holds LOCK_IX and possibly LOCK_AUTO_INC on the table. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if table is only locked by trx, with LOCK_IX, and possibly LOCK_AUTO_INC </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb43b7be638bd32fa36b7c025d636bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb43b7be638bd32fa36b7c025d636bb6">&#9670;&nbsp;</a></span>lock_move_rec_list_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_move_rec_list_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the explicit locks on user records to another page if a record list end is moved to another page. in: record on page: this is the first record moved</p>
<p>Moves the explicit locks on user records to another page if a record list end is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: index page to move to </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">rec</td><td>in: record on page: this is the first record moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23e7197a446aee79574d335d277aaa84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e7197a446aee79574d335d277aaa84">&#9670;&nbsp;</a></span>lock_move_rec_list_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_move_rec_list_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>old_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the explicit locks on user records to another page if a record list start is moved to another page. in: old previous-to-last record on new_page before the records were copied</p>
<p>Moves the explicit locks on user records to another page if a record list start is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: index page to move to </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">rec</td><td>in: record on page: this is the first record NOT copied </td></tr>
    <tr><td class="paramname">old_end</td><td>in: old previous-to-last record on new_page before the records were copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7273b2c3c75e90408bdc5a711effc73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7273b2c3c75e90408bdc5a711effc73a">&#9670;&nbsp;</a></span>lock_move_reorganize_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_move_reorganize_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>oblock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when we have reorganized a page. NOTE: we copy also the locks set on the infimum of the page; the infimum may carry locks if an update of a record is occurring on the page, and its locks were temporarily stored on the infimum. in: copy of the old, not reorganized page</p>
<p>Updates the lock table when we have reorganized a page. NOTE: we copy also the locks set on the infimum of the page; the infimum may carry locks if an update of a record is occurring on the page, and its locks were temporarily stored on the infimum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: old index page, now reorganized </td></tr>
    <tr><td class="paramname">oblock</td><td>in: copy of the old, not reorganized page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74c816baaa2b3982f4bcf8c7519510cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c816baaa2b3982f4bcf8c7519510cd">&#9670;&nbsp;</a></span>lock_number_of_rows_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_number_of_rows_locked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *&#160;</td>
          <td class="paramname"><em>trx_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return approximate number or record locks (bits set in the bitmap) for this transaction. Since delete-marked records may be removed, the record count will not be precise. The caller must be holding lock_sys-&gt;mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_lock</td><td>in: transaction locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96d8a6d0b9f2926b63ea83ec8b9633c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d8a6d0b9f2926b63ea83ec8b9633c7">&#9670;&nbsp;</a></span>lock_print_info_all_transactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_print_info_all_transactions </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of locks for each transaction. This function assumes that the caller holds the lock mutex and more importantly it will release the lock mutex on behalf of the caller. (This should be fixed in the future). in: file where to print</p>
<p>Prints info of locks for each transaction. This function assumes that the caller holds the lock mutex and more importantly it will release the lock mutex on behalf of the caller. (This should be fixed in the future). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1b323a3ed0083cd3856c35c551a388b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b323a3ed0083cd3856c35c551a388b">&#9670;&nbsp;</a></span>lock_print_info_summary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool lock_print_info_summary </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>nowait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of locks for all transactions. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if not able to obtain lock mutex and exits without printing info </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">nowait</td><td>in: whether to wait for the lock mutex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8c287ddf568445e841142a590b6d9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c287ddf568445e841142a590b6d9b3">&#9670;&nbsp;</a></span>lock_rec_expl_exist_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_expl_exist_on_page </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if there are explicit record locks on a page. </p><dl class="section return"><dt>Returns</dt><dd>an explicit record lock on the page, or NULL if there are none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeac31e933724030fe1aca76ebbd1b524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac31e933724030fe1aca76ebbd1b524">&#9670;&nbsp;</a></span>lock_rec_find_set_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_rec_find_set_bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a set bit in a record lock bitmap. Returns ULINT_UNDEFINED, if none found. </p><dl class="section return"><dt>Returns</dt><dd>bit index == heap number of the record, or ULINT_UNDEFINED if none found in: record lock with at least one bit set</dd></dl>
<p>Looks for a set bit in a record lock bitmap. Returns ULINT_UNDEFINED, if none found. </p><dl class="section return"><dt>Returns</dt><dd>bit index == heap number of the record, or ULINT_UNDEFINED if none found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock with at least one bit set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06042fa19a19db9a11511aeb0399e6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06042fa19a19db9a11511aeb0399e6da">&#9670;&nbsp;</a></span>lock_rec_fold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_fold </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the fold value of a page file address: used in inserting or searching for a lock in the hash table. </p><dl class="section return"><dt>Returns</dt><dd>folded value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad153d0b712ae422378a58151c8628efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad153d0b712ae422378a58151c8628efd">&#9670;&nbsp;</a></span>lock_rec_get_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structdict__index__t.html">dict_index_t</a>* lock_rec_get_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the index on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>index in: lock</dd></dl>
<p>For a record lock, gets the index on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b0200bf5b9ee51f495a2ddf704c63ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0200bf5b9ee51f495a2ddf704c63ad">&#9670;&nbsp;</a></span>lock_rec_get_index_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_rec_get_index_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the name of the index on which the lock is. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>name of the index in: lock</dd></dl>
<p>For a record lock, gets the name of the index on which the lock is. The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>name of the index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5cdf332f59754136d761b9fe0d88564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cdf332f59754136d761b9fe0d88564">&#9670;&nbsp;</a></span>lock_rec_get_page_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_rec_get_page_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the page number on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>page number in: lock</dd></dl>
<p>For a record lock, gets the page number on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90793ee45348397c09e6eb0938fa3e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90793ee45348397c09e6eb0938fa3e4a">&#9670;&nbsp;</a></span>lock_rec_get_space_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_rec_get_space_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the tablespace number on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>tablespace number in: lock</dd></dl>
<p>For a record lock, gets the tablespace number on which the lock is. </p><dl class="section return"><dt>Returns</dt><dd>tablespace number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f2ec292dd7525aff0dee8910ca3a99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f2ec292dd7525aff0dee8910ca3a99d">&#9670;&nbsp;</a></span>lock_rec_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_hash </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the hash value of a page file address: used in inserting or searching for a lock in the hash table. </p><dl class="section return"><dt>Returns</dt><dd>hashed value in: page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1351ab9296a8042326ebda0ec84c8a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1351ab9296a8042326ebda0ec84c8a50">&#9670;&nbsp;</a></span>lock_rec_insert_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_insert_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate insert of a record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a gap x-lock to the lock queue. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">rec</td><td>in: record after which to insert </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">inherit</td><td>out: set to TRUE if the new inserted record maybe should inherit LOCK_GAP type locks from the successor record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed491db1a4f9e54c46b5618fda1a72dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed491db1a4f9e54c46b5618fda1a72dd">&#9670;&nbsp;</a></span>lock_rec_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of a record lock. in: record type lock</p>
<p>Prints info of a record lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">lock</td><td>in: record type lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1a1ced4eeb3daa98b39ee2365df8b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a1ced4eeb3daa98b39ee2365df8b1a">&#9670;&nbsp;</a></span>lock_rec_reset_and_inherit_gap_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_reset_and_inherit_gap_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the original locks on heir and replaces them with gap type locks inherited from rec. in: heap_no of the donating record</p>
<p>Resets the original locks on heir and replaces them with gap type locks inherited from rec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heir_block</td><td>in: block containing the record which inherits </td></tr>
    <tr><td class="paramname">block</td><td>in: block containing the record from which inherited; does NOT reset the locks on this record </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of the inheriting record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap_no of the donating record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad04f9ddc87db84d8621e853f1a3434db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04f9ddc87db84d8621e853f1a3434db">&#9670;&nbsp;</a></span>lock_rec_restore_from_page_infimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_restore_from_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>donator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores the state of explicit lock requests on a single record, where the state was stored on the infimum of the page. in: page (rec is not necessarily on this page) whose infimum stored the lock state; lock bits are reset on the infimum</p>
<p>Restores the state of explicit lock requests on a single record, where the state was stored on the infimum of the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record whose lock state is restored </td></tr>
    <tr><td class="paramname">donator</td><td>in: page (rec is not necessarily on this page) whose infimum stored the lock state; lock bits are reset on the infimum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad32bb2ec136f61df97fea7e90c94a7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32bb2ec136f61df97fea7e90c94a7cf">&#9670;&nbsp;</a></span>lock_rec_store_on_page_infimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_store_on_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores on the page infimum record the explicit locks of another record. This function is used to store the lock state of a record when it is updated and the size of the record changes in the update. The record is in such an update moved, perhaps to another page. The infimum record acts as a dummy carrier record, taking care of lock releases while the actual record is being moved. in: record whose lock state is stored on the infimum record of the same page; lock bits are reset on the record</p>
<p>Stores on the page infimum record the explicit locks of another record. This function is used to store the lock state of a record when it is updated and the size of the record changes in the update. The record is moved in such an update, perhaps to another page. The infimum record acts as a dummy carrier record, taking care of lock releases while the actual record is being moved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record whose lock state is stored on the infimum record of the same page; lock bits are reset on the record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409999adb50ece16b81d59486af7af45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409999adb50ece16b81d59486af7af45">&#9670;&nbsp;</a></span>lock_rec_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode lock_mode&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a granted record lock of a transaction from the queue and grants locks to other transactions waiting in the queue if they now are entitled to a lock. in: LOCK_S or LOCK_X</p>
<p>Removes a granted record lock of a transaction from the queue and grants locks to other transactions waiting in the queue if they now are entitled to a lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction that has set a record lock </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a430d15f2674ea7fb0d8cf61636192011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430d15f2674ea7fb0d8cf61636192011">&#9670;&nbsp;</a></span>lock_remove_all_on_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_remove_all_on_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>remove_also_table_sx_locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes locks on a table to be dropped or truncated. If remove_also_table_sx_locks is TRUE then table-level S and X locks are also removed in addition to other table-level and record-level locks. No lock, that is going to be removed, is allowed to be a wait lock. in: also removes table S and X locks</p>
<p>Removes locks on a table to be dropped or truncated. If remove_also_table_sx_locks is TRUE then table-level S and X locks are also removed in addition to other table-level and record-level locks. No lock, that is going to be removed, is allowed to be a wait lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to be dropped or truncated </td></tr>
    <tr><td class="paramname">remove_also_table_sx_locks</td><td>in: also removes table S and X locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67d388e6198f7c7312d0de9cb804b378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d388e6198f7c7312d0de9cb804b378">&#9670;&nbsp;</a></span>lock_report_trx_id_insanity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_report_trx_id_insanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>max_trx_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reports that a transaction id is insensible, i.e., in the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_id</td><td>in: trx id </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">max_trx_id</td><td>in: <a class="el" href="trx0sys_8h.html#aaf92577bb351b5b6e51fac1f36a0abd3">trx_sys_get_max_trx_id()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd747ddccebb0da116d544b97ce93ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd747ddccebb0da116d544b97ce93ffe">&#9670;&nbsp;</a></span>lock_sec_rec_cons_read_sees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool lock_sec_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structread__view__t.html">read_view_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that a non-clustered index record is seen in a consistent read.</p>
<p>NOTE that a non-clustered index page contains so little information on its modifications that also in the case false, the present version of rec may be the right, but we must check this from the clustered index record.</p>
<dl class="section return"><dt>Returns</dt><dd>true if certainly sees, or false if an earlier version of the clustered index record might be needed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">view</td><td>in: consistent read view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b391867035415fabb8d5989e419b598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b391867035415fabb8d5989e419b598">&#9670;&nbsp;</a></span>lock_sec_rec_modify_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate modify (delete mark or delete unmark) of a secondary index record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified; NOTE: as this is a secondary index, we always have to modify the clustered index record first: see the comment below </td></tr>
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread (can be NULL if BTR_NO_LOCKING_FLAG) </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1d5f3bc41223f625ac09672a1ca19bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d5f3bc41223f625ac09672a1ca19bf">&#9670;&nbsp;</a></span>lock_sec_rec_read_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="lock0lock_8cc.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock()</a>, but reads a secondary index record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED in: query thread</dd></dl>
<p>Like <a class="el" href="lock0lock_8cc.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock()</a>, but reads a secondary index record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c2350ce483b08686c48c19407f63da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2350ce483b08686c48c19407f63da9">&#9670;&nbsp;</a></span>lock_sys_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_sys_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the lock system at database shutdown. </p>

</div>
</div>
<a id="a40ad348feb00e96aec397b06dbec7c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ad348feb00e96aec397b06dbec7c64">&#9670;&nbsp;</a></span>lock_sys_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_sys_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the lock system at database start. in: number of slots in lock hash table</p>
<p>Creates the lock system at database start. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_cells</td><td>in: number of slots in lock hash table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a250be234223f746d5068a155f771ca77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250be234223f746d5068a155f771ca77">&#9670;&nbsp;</a></span>lock_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_table </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the specified database table in the mode given. If the lock cannot be granted immediately, the query thread is put to wait. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">table</td><td>in/out: database table in dictionary cache </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04a0117979ee1b97fa239bbac6a6e087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a0117979ee1b97fa239bbac6a6e087">&#9670;&nbsp;</a></span>lock_table_get_n_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_table_get_n_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of locks on a table. </p><dl class="section return"><dt>Returns</dt><dd>number of locks </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97a934d7768a7c68d802e733fcf86f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a934d7768a7c68d802e733fcf86f1c">&#9670;&nbsp;</a></span>lock_table_has_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool lock_table_has_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> if there are any locks (table or rec) against table. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if locks exist in: check if there are any locks held on records in this table or on the table itself</dd></dl>
<p><a class="el" href="struct_check.html">Check</a> if there are any locks (table or rec) against table. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if table has either table or record locks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: check if there are any locks held on records in this table or on the table itself </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1056fa163c142cf71d21e6e3d046f060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1056fa163c142cf71d21e6e3d046f060">&#9670;&nbsp;</a></span>lock_table_ix_resurrect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_table_ix_resurrect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a table IX lock object for a resurrected transaction. in/out: transaction</p>
<p>Creates a table IX lock object for a resurrected transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf98b08ed2e93284570fc964e5b24c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf98b08ed2e93284570fc964e5b24c16">&#9670;&nbsp;</a></span>lock_table_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_table_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of a table lock. in: table type lock</p>
<p>Prints info of a table lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">lock</td><td>in: table type lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88bc2bfbf01660ced593b50590ae0cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bc2bfbf01660ced593b50590ae0cf0">&#9670;&nbsp;</a></span>lock_trx_handle_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_trx_handle_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> whether the transaction has already been rolled back because it was selected as a deadlock victim, or if it has to wait then cancel the wait lock. </p><dl class="section return"><dt>Returns</dt><dd>DB_DEADLOCK, DB_LOCK_WAIT or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: trx lock state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af056c93107ab266face88ec37bae94c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af056c93107ab266face88ec37bae94c7">&#9670;&nbsp;</a></span>lock_trx_release_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_trx_release_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a transaction's locks, and releases possible other transactions waiting because of these locks. Change the state of the transaction to TRX_STATE_COMMITTED_IN_MEMORY. in/out: transaction</p>
<p>Releases a transaction's locks, and releases possible other transactions waiting because of these locks. Change the state of the transaction to TRX_STATE_COMMITTED_IN_MEMORY. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838b492f61b92e3678c7b7be18a2f1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838b492f61b92e3678c7b7be18a2f1be">&#9670;&nbsp;</a></span>lock_unlock_table_autoinc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_unlock_table_autoinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks AUTO_INC type locks that were possibly reserved by a trx. This function should be called at the the end of an SQL statement, by the connection thread that owns the transaction (trx-&gt;mysql_thd). in/out: transaction</p>
<p>Unlocks AUTO_INC type locks that were possibly reserved by a trx. This function should be called at the the end of an SQL statement, by the connection thread that owns the transaction (trx-&gt;mysql_thd). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cc8f00508ee648886c7d51046af30d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc8f00508ee648886c7d51046af30d1">&#9670;&nbsp;</a></span>lock_update_copy_and_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_copy_and_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is copied to another and the original page is removed from the chain of leaf pages, except if page is the root! in: index page; NOT the root!</p>
<p>Updates the lock table when a page is copied to another and the original page is removed from the chain of leaf pages, except if page is the root! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: index page to which copied </td></tr>
    <tr><td class="paramname">block</td><td>in: index page; NOT the root! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd33b69b0b70f3e6643e70275550a0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd33b69b0b70f3e6643e70275550a0a7">&#9670;&nbsp;</a></span>lock_update_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a record is removed. in: the record to be removed</p>
<p>Updates the lock table when a record is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: the record to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d322cfc717fe99e4c5c88f7b93512e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d322cfc717fe99e4c5c88f7b93512e">&#9670;&nbsp;</a></span>lock_update_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is discarded. in: index page which will be discarded</p>
<p>Updates the lock table when a page is discarded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heir_block</td><td>in: index page which will inherit the locks </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of the record which will inherit the locks </td></tr>
    <tr><td class="paramname">block</td><td>in: index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b800d596ae20af9b8b28f7a879658b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b800d596ae20af9b8b28f7a879658b4">&#9670;&nbsp;</a></span>lock_update_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a new user record is inserted. in: the inserted record</p>
<p>Updates the lock table when a new user record is inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: the inserted record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a742d185fcf374672c516427602f386eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742d185fcf374672c516427602f386eb">&#9670;&nbsp;</a></span>lock_update_merge_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_merge_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>orig_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is merged to the left. in: merged index page which will be discarded</p>
<p>Updates the lock table when a page is merged to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_block</td><td>in: left page to which merged </td></tr>
    <tr><td class="paramname">orig_pred</td><td>in: original predecessor of supremum on the left page before merge </td></tr>
    <tr><td class="paramname">right_block</td><td>in: merged index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ec2bdadfd1e57ddbedfc05740e884eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec2bdadfd1e57ddbedfc05740e884eb">&#9670;&nbsp;</a></span>lock_update_merge_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_merge_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>orig_succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is merged to the right. in: merged index page which will be discarded</p>
<p>Updates the lock table when a page is merged to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right_block</td><td>in: right page to which merged </td></tr>
    <tr><td class="paramname">orig_succ</td><td>in: original successor of infimum on the right page before merge </td></tr>
    <tr><td class="paramname">left_block</td><td>in: merged index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82e3b8ed16aaab0770730fb554e23af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e3b8ed16aaab0770730fb554e23af2">&#9670;&nbsp;</a></span>lock_update_root_raise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_root_raise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when the root page is copied to another in btr_root_raise_and_insert. Note that we leave lock structs on the root page, even though they do not make sense on other than leaf pages: the reason is that in a pessimistic update the infimum record of the root page will act as a dummy carrier of the locks of the record to be updated. in: root page</p>
<p>Updates the lock table when the root page is copied to another in btr_root_raise_and_insert. Note that we leave lock structs on the root page, even though they do not make sense on other than leaf pages: the reason is that in a pessimistic update the infimum record of the root page will act as a dummy carrier of the locks of the record to be updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page to which copied </td></tr>
    <tr><td class="paramname">root</td><td>in: root page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5beb29b82077fbb4080d16b8214c1d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5beb29b82077fbb4080d16b8214c1d57">&#9670;&nbsp;</a></span>lock_update_split_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_split_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is split to the left. in: left page</p>
<p>Updates the lock table when a page is split to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right_block</td><td>in: right page </td></tr>
    <tr><td class="paramname">left_block</td><td>in: left page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cd5be77aa944f96aa6ff0aeebc6eb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd5be77aa944f96aa6ff0aeebc6eb98">&#9670;&nbsp;</a></span>lock_update_split_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_split_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is split to the right. in: left page</p>
<p>Updates the lock table when a page is split to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right_block</td><td>in: right page </td></tr>
    <tr><td class="paramname">left_block</td><td>in: left page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05119c03d5d3b065c5da4ae75d8aa1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05119c03d5d3b065c5da4ae75d8aa1ff">&#9670;&nbsp;</a></span>lock_wait_release_thread_if_suspended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_wait_release_thread_if_suspended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a user OS thread waiting for a lock to be released, if the thread is already suspended. in: query thread associated with the user OS thread</p>
<p>Releases a user OS thread waiting for a lock to be released, if the thread is already suspended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread associated with the user OS thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addfdc852efca69d23054639668aa17b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfdc852efca69d23054639668aa17b6">&#9670;&nbsp;</a></span>lock_wait_suspend_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_wait_suspend_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts a user OS thread to wait for a lock to be released. If an error occurs during the wait trx-&gt;error_state associated with thr is != DB_SUCCESS when we return. DB_LOCK_WAIT_TIMEOUT and DB_DEADLOCK are possible errors. DB_DEADLOCK is returned if selective deadlock resolution chose this transaction as a victim. in: query thread associated with the user OS thread</p>
<p>Puts a user OS thread to wait for a lock to be released. If an error occurs during the wait trx-&gt;error_state associated with thr is != DB_SUCCESS when we return. DB_LOCK_WAIT_TIMEOUT and DB_DEADLOCK are possible errors. DB_DEADLOCK is returned if selective deadlock resolution chose this transaction as a victim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread associated with the user OS thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d3fb581b71eeb0fa35520a1fe944abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3fb581b71eeb0fa35520a1fe944abb">&#9670;&nbsp;</a></span>lock_wait_timeout_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>() lock_wait_timeout_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A thread which wakes up threads whose lock wait may have lasted too long. </p><dl class="section return"><dt>Returns</dt><dd>a dummy parameter in: a dummy parameter required by os_thread_create </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac5399aad1a992cb27e897fc806570ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5399aad1a992cb27e897fc806570ba0">&#9670;&nbsp;</a></span>lock_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlock__sys__t.html">lock_sys_t</a>* lock_sys</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The lock system </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

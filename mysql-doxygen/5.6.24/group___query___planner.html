<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: Query Planner</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query Planner</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_loose__scan__opt.html">Loose_scan_opt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga42f852eb43f8bc7a538dad8571f9b36f"><td class="memItemLeft" align="right" valign="top"><a id="ga42f852eb43f8bc7a538dad8571f9b36f"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>prev_record_reads</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, uint idx, table_map found_ref)</td></tr>
<tr class="separator:ga42f852eb43f8bc7a538dad8571f9b36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287945c7b5b4a7419bb032390c634fe5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#ga287945c7b5b4a7419bb032390c634fe5">trace_plan_prefix</a> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, uint idx, table_map excluded_tables)</td></tr>
<tr class="separator:ga287945c7b5b4a7419bb032390c634fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f81044d8b2b8a2af2a3325bf58f6f69"><td class="memItemLeft" align="right" valign="top"><a id="ga2f81044d8b2b8a2af2a3325bf58f6f69"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_part_bit</b> (key_part_map bits)</td></tr>
<tr class="separator:ga2f81044d8b2b8a2af2a3325bf58f6f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527fc42447a50830258e011b46b18307"><td class="memItemLeft" align="right" valign="top"><a id="ga527fc42447a50830258e011b46b18307"></a>
static uint&#160;</td><td class="memItemRight" valign="bottom"><b>cache_record_length</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, uint idx)</td></tr>
<tr class="separator:ga527fc42447a50830258e011b46b18307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51edd4249ea43d69718f9754c9422fd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#gaf51edd4249ea43d69718f9754c9422fd">semijoin_order_allows_materialization</a> (const <a class="el" href="class_j_o_i_n.html">JOIN</a> *join, table_map remaining_tables, const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, uint idx)</td></tr>
<tr class="separator:gaf51edd4249ea43d69718f9754c9422fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86cd1753e0358916f08ed5ddcd210dae"><td class="memItemLeft" align="right" valign="top"><a id="ga86cd1753e0358916f08ed5ddcd210dae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_partial_join_cost</b> (<a class="el" href="class_j_o_i_n.html">JOIN</a> *join, uint n_tables, double *read_time_arg, double *record_count_arg)</td></tr>
<tr class="separator:ga86cd1753e0358916f08ed5ddcd210dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1f71cbda48f95308f73129c76e12cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#gaae1f71cbda48f95308f73129c76e12cc">Optimize_table_order::best_access_path</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *<a class="el" href="dict0mem_8cc.html#a9ebb0c5278a47b6001b42fdff65f648f">s</a>, table_map remaining_tables, uint idx, bool disable_jbuf, double record_count, <a class="el" href="structst__position.html">POSITION</a> *pos, <a class="el" href="structst__position.html">POSITION</a> *loose_scan_pos)</td></tr>
<tr class="separator:gaae1f71cbda48f95308f73129c76e12cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf585184987b0097465505d600394b8f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#gaf585184987b0097465505d600394b8f3">Optimize_table_order::choose_table_order</a> ()</td></tr>
<tr class="separator:gaf585184987b0097465505d600394b8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1345da559c5841bf89d657bf2348e230"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#ga1345da559c5841bf89d657bf2348e230">Optimize_table_order::determine_search_depth</a> (uint search_depth, uint table_count)</td></tr>
<tr class="separator:ga1345da559c5841bf89d657bf2348e230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4eb4a2a802676363d5079335af9106d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#gae4eb4a2a802676363d5079335af9106d">Optimize_table_order::optimize_straight_join</a> (table_map join_tables)</td></tr>
<tr class="separator:gae4eb4a2a802676363d5079335af9106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0e0e4bba8f362f8b3c60cfb2736559"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#ga1d0e0e4bba8f362f8b3c60cfb2736559">Optimize_table_order::greedy_search</a> (table_map remaining_tables)</td></tr>
<tr class="separator:ga1d0e0e4bba8f362f8b3c60cfb2736559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0c0a4f6809dffbb4f82b5b563f946d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#ga5f0c0a4f6809dffbb4f82b5b563f946d">Optimize_table_order::consider_plan</a> (uint idx, double record_count, double read_time, <a class="el" href="class_opt__trace__object.html">Opt_trace_object</a> *trace_obj)</td></tr>
<tr class="separator:ga5f0c0a4f6809dffbb4f82b5b563f946d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bcfc4f0e53c23266674782781c7a42c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#ga7bcfc4f0e53c23266674782781c7a42c">Optimize_table_order::best_extension_by_limited_search</a> (table_map remaining_tables, uint idx, double record_count, double read_time, uint current_search_depth)</td></tr>
<tr class="separator:ga7bcfc4f0e53c23266674782781c7a42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0027ccbdc2fcae194c506c735481d2e"><td class="memItemLeft" align="right" valign="top">table_map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#gae0027ccbdc2fcae194c506c735481d2e">Optimize_table_order::eq_ref_extension_by_limited_search</a> (table_map remaining_tables, uint idx, double record_count, double read_time, uint current_search_depth)</td></tr>
<tr class="separator:gae0027ccbdc2fcae194c506c735481d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba76f383cbe1dccc7c7a6facaf1fe6b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#gaba76f383cbe1dccc7c7a6facaf1fe6b8">Optimize_table_order::fix_semijoin_strategies</a> ()</td></tr>
<tr class="memdesc:gaba76f383cbe1dccc7c7a6facaf1fe6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix semi-join strategies for the picked join order.  <a href="#gaba76f383cbe1dccc7c7a6facaf1fe6b8">More...</a><br /></td></tr>
<tr class="separator:gaba76f383cbe1dccc7c7a6facaf1fe6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40175e89a592caf0dce0b81876c820f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#ga40175e89a592caf0dce0b81876c820f1">Optimize_table_order::check_interleaving_with_nj</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *next_tab)</td></tr>
<tr class="separator:ga40175e89a592caf0dce0b81876c820f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8452432379e04249b9b647ec608b3b6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#ga8452432379e04249b9b647ec608b3b6b">Optimize_table_order::semijoin_firstmatch_loosescan_access_paths</a> (uint first_tab, uint last_tab, table_map remaining_tables, bool loosescan, bool final, double *newcount, double *newcost)</td></tr>
<tr class="separator:ga8452432379e04249b9b647ec608b3b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81420e7965b6e4a2f13d67ac15d05ec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#ga81420e7965b6e4a2f13d67ac15d05ec9">Optimize_table_order::semijoin_mat_scan_access_paths</a> (uint last_inner_tab, uint last_outer_tab, table_map remaining_tables, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *sjm_nest, bool final, double *newcount, double *newcost)</td></tr>
<tr class="separator:ga81420e7965b6e4a2f13d67ac15d05ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0e9baa19f09976372ae2ed2c19d5a7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#gac0e9baa19f09976372ae2ed2c19d5a7d">Optimize_table_order::semijoin_mat_lookup_access_paths</a> (uint last_inner, <a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *sjm_nest, double *newcount, double *newcost)</td></tr>
<tr class="separator:gac0e9baa19f09976372ae2ed2c19d5a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8bc9bccf882a55db6cb971dbfbc8d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#gabf8bc9bccf882a55db6cb971dbfbc8d9">Optimize_table_order::semijoin_dupsweedout_access_paths</a> (uint first_tab, uint last_tab, table_map remaining_tables, double *newcount, double *newcost)</td></tr>
<tr class="separator:gabf8bc9bccf882a55db6cb971dbfbc8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a7e995505577ffbc683024366808b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#ga89a7e995505577ffbc683024366808b0">Optimize_table_order::advance_sj_state</a> (table_map remaining_tables, const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, uint idx, double *current_rowcount, double *current_cost, <a class="el" href="structst__position.html">POSITION</a> *loose_scan_pos)</td></tr>
<tr class="separator:ga89a7e995505577ffbc683024366808b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa149d4e4ac91df26688a77c6f2a2c55d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___query___planner.html#gaa149d4e4ac91df26688a77c6f2a2c55d">Optimize_table_order::backout_nj_state</a> (const table_map remaining_tables, const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:gaa149d4e4ac91df26688a77c6f2a2c55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga89a7e995505577ffbc683024366808b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a7e995505577ffbc683024366808b0">&#9670;&nbsp;</a></span>advance_sj_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::advance_sj_state </td>
          <td>(</td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>new_join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>current_rowcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>current_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__position.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>loose_scan_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do semi-join optimization step after we've added a new tab to join prefix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td>Tables not in the join prefix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">new_join_tab</td><td>Join tab that we are adding to the join prefix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx</td><td>Index of this join tab (i.e. number of tables in the prefix) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">current_rowcount</td><td>Estimate of #rows in join prefix's output </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">current_cost</td><td>Cost to execute the join prefix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">loose_scan_pos</td><td>A POSITION with LooseScan plan to access table new_join_tab (produced by last best_access_path call)</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment">Update semi-join optimization state after we've added another tab (table 
and access method) to the join prefix.

The state is maintained in join-&gt;positions[#prefix_size]. Each of the
available strategies has its own state variables.

for each semi-join strategy
{
  update strategy's state variables;

  if (join prefix has all the tables that are needed to consider
      using this strategy for the semi-join(s))
  {
    calculate cost of using the strategy
    if ((this is the first strategy to handle the semi-join nest(s)  ||
        the cost is less than other strategies))
    {
</pre><p> Pick this strategy pos-&gt;sj_strategy= .. .. } }</p>
<p>Most of the new state is saved in join-&gt;positions[idx] (and hence no undo is necessary).</p>
<p>See <a class="el" href="group___query___optimizer.html#gadd6d91b682441f4991964f9b3ef828c9">setup_semijoin_dups_elimination()</a> for a description of what kinds of join prefixes each strategy can handle.</p>
<p>A note on access path, rowcount and cost estimates:</p><ul>
<li><a class="el" href="group___query___planner.html#ga7bcfc4f0e53c23266674782781c7a42c">best_extension_by_limited_search()</a> performs <em>initial calculations</em> of access paths, rowcount and cost based on the operation being an inner join or an outer join operation. These estimates are saved in join-&gt;positions.</li>
<li><a class="el" href="group___query___planner.html#ga89a7e995505577ffbc683024366808b0">advance_sj_state()</a> performs <em>intermediate calculations</em> based on the same table information, but for the supported semi-join strategies. The access path part of these calculations are not saved anywhere, but the rowcount and cost of the best semi-join strategy are saved in join-&gt;positions.</li>
<li>Because the semi-join access path information was not saved previously, <a class="el" href="group___query___planner.html#gaba76f383cbe1dccc7c7a6facaf1fe6b8" title="Fix semi-join strategies for the picked join order. ">fix_semijoin_strategies()</a> must perform <em>final calculations</em> of access paths, rowcount and cost when saving the selected table order in join-&gt;best_positions. The results of the final calculations will be the same as the results of the "best" intermediate calculations. </li>
</ul>

</div>
</div>
<a id="gaa149d4e4ac91df26688a77c6f2a2c55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa149d4e4ac91df26688a77c6f2a2c55d">&#9670;&nbsp;</a></span>backout_nj_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::backout_nj_state </td>
          <td>(</td>
          <td class="paramtype">const table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Nested joins perspective: Remove the last table from the join order.</p>
<p>Remove the last table from the partial join order and update the nested joins counters and cur_embedding_map. It is ok to call this function for the first table in join order (for which check_interleaving_with_nj has not been called)</p>
<p>This function rolls back changes done by:</p><ul>
<li><a class="el" href="group___query___planner.html#ga40175e89a592caf0dce0b81876c820f1">check_interleaving_with_nj()</a>: removes the last table from the partial join order and update the nested joins counters and cur_embedding_map. It is ok to call this for the first table in join order (for which <a class="el" href="group___query___planner.html#ga40175e89a592caf0dce0b81876c820f1">check_interleaving_with_nj()</a> has not been called).</li>
</ul>
<p>The algorithm is the reciprocal of <a class="el" href="group___query___planner.html#ga40175e89a592caf0dce0b81876c820f1">check_interleaving_with_nj()</a>, hence parent join nest nodes are updated only when the last table in its child node is removed. The ASCII graphic below will clarify.</p>
<p>A table nesting such as <code> t1 x [ ( t2 x t3 ) x ( t4 x t5 ) ] </code>is represented by the below join nest tree.</p>
<pre class="fragment">                   NJ1
                _/ /  \
              _/  /    NJ2
            _/   /     / \ 
           /    /     /   \
 t1 x [ (t2 x t3) x (t4 x t5) ]
</pre><p>At the point in time when <a class="el" href="group___query___planner.html#ga40175e89a592caf0dce0b81876c820f1">check_interleaving_with_nj()</a> adds the table t5 to the query execution plan, QEP, it also directs the node named NJ2 to mark the table as covered. NJ2 does so by incrementing its <code>counter</code> member. Since all of NJ2's tables are now covered by the QEP, the algorithm proceeds up the tree to NJ1, incrementing its counter as well. All join nests are now completely covered by the QEP.</p>
<p><a class="el" href="group___query___planner.html#gaa149d4e4ac91df26688a77c6f2a2c55d">backout_nj_state()</a> does the above in reverse. As seen above, the node NJ1 contains the nodes t2, t3, and NJ2. Its counter being equal to 3 means that the plan covers t2, t3, and NJ2, <em>and</em> that the sub-plan (t4 x t5) completely covers NJ2. The removal of t5 from the partial plan will first decrement NJ2's counter to 1. It will then detect that NJ2 went from being completely to partially covered, and hence the algorithm must continue upwards to NJ1 and decrement its counter to 2. A subsequent removal of t4 will however not influence NJ1 since it did not un-cover the last table in NJ2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remaining_tables</td><td>remaining tables to optimize, must contain 'tab' </td></tr>
    <tr><td class="paramname">tab</td><td>join table to remove, assumed to be the last in current partial join order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae1f71cbda48f95308f73129c76e12cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae1f71cbda48f95308f73129c76e12cc">&#9670;&nbsp;</a></span>best_access_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::best_access_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disable_jbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>record_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__position.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__position.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>loose_scan_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the best access path for an extension of a partial execution plan and add this path to the plan.</p>
<p>The function finds the best access path to table 's' from the passed partial plan where an access path is the general term for any means to access the data in 's'. An access path may use either an index or a scan, whichever is cheaper. The input partial plan is passed via the array 'join-&gt;positions' of length 'idx'. The chosen access method for 's' and its cost are stored in 'join-&gt;positions[idx]'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">s</td><td>the table to be joined by the function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread for the connection that submitted the query </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td>set of tables not included in the partial plan yet. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx</td><td>the length of the partial plan </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">disable_jbuf</td><td>TRUE&lt;=&gt; Don't use join buffering </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">record_count</td><td>estimate for the number of records returned by the partial plan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Table access plan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">loose_scan_pos</td><td>Table plan that uses loosescan, or set cost to DBL_MAX if not possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7bcfc4f0e53c23266674782781c7a42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bcfc4f0e53c23266674782781c7a42c">&#9670;&nbsp;</a></span>best_extension_by_limited_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Optimize_table_order::best_extension_by_limited_search </td>
          <td>(</td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>record_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>read_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>current_search_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a good, possibly optimal, query execution plan (QEP) by a possibly exhaustive search.</p>
<p>The procedure searches for the optimal ordering of the query tables in set 'remaining_tables' of size N, and the corresponding optimal access paths to each table. The choice of a table order and an access path for each table constitutes a query execution plan (QEP) that fully specifies how to execute the query.</p>
<p>The maximal size of the found plan is controlled by the parameter 'search_depth'. When search_depth == N, the resulting plan is complete and can be used directly as a QEP. If search_depth &lt; N, the found plan consists of only some of the query tables. Such "partial" optimal plans are useful only as input to query optimization procedures, and cannot be used directly to execute a query.</p>
<p>The algorithm begins with an empty partial plan stored in 'join-&gt;positions' and a set of N tables - 'remaining_tables'. Each step of the algorithm evaluates the cost of the partial plan extended by all access plans for each of the relations in 'remaining_tables', expands the current partial plan with the access plan that results in lowest cost of the expanded partial plan, and removes the corresponding relation from 'remaining_tables'. The algorithm continues until it either constructs a complete optimal plan, or constructs an optimal plartial plan with size = search_depth.</p>
<p>The final optimal plan is stored in 'join-&gt;best_positions'. The corresponding cost of the optimal plan is in 'join-&gt;best_read'.</p>
<dl class="section note"><dt>Note</dt><dd>The procedure uses a recursive depth-first search where the depth of the recursion (and thus the exhaustiveness of the search) is controlled by the parameter 'search_depth'.</dd>
<dd>
The pseudocode below describes the algorithm of 'best_extension_by_limited_search'. The worst-case complexity of this algorithm is O(N*N^search_depth/search_depth). When serch_depth &gt;= N, then the complexity of greedy_search is O(N!).</dd>
<dd>
::best_extension_by_limited_search() &amp; ::eq_ref_extension_by_limited_search() are closely related to each other and intentially implemented using the same pattern wherever possible. If a change/bug fix is done to either of these also consider if it is relevant for the other.</dd></dl>
<div class="fragment"><div class="line">procedure <a class="code" href="group___query___planner.html#ga7bcfc4f0e53c23266674782781c7a42c">best_extension_by_limited_search</a>(</div><div class="line">  pplan in,             <span class="comment">// in, partial plan of tables-joined-so-far</span></div><div class="line">  pplan_cost,           <span class="comment">// in, cost of pplan</span></div><div class="line">  remaining_tables,     <span class="comment">// in, set of tables not referenced in pplan</span></div><div class="line">  best_plan_so_far,     <span class="comment">// in/out, best plan found so far</span></div><div class="line">  best_plan_so_far_cost,<span class="comment">// in/out, cost of best_plan_so_far</span></div><div class="line">  search_depth)         <span class="comment">// in, maximum size of the plans being considered</span></div><div class="line">{</div><div class="line">  <span class="keywordflow">for each</span> <a class="code" href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a> T <a class="code" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a> remaining_tables</div><div class="line">  {</div><div class="line">    <span class="comment">// Calculate the cost of using table T as above</span></div><div class="line">    cost = complex-series-<a class="code" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a>-calculations;</div><div class="line"></div><div class="line">    <span class="comment">// Add the cost to the cost so far.</span></div><div class="line">    pplan_cost+= cost;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (pplan_cost &gt;= best_plan_so_far_cost)</div><div class="line">      <span class="comment">// pplan_cost already too great, stop search</span></div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    pplan= expand pplan by best_access_method;</div><div class="line">    remaining_tables= remaining_tables - <a class="code" href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a> T;</div><div class="line">    <span class="keywordflow">if</span> (remaining_tables is not an empty <span class="keyword">set</span></div><div class="line">        and</div><div class="line">        search_depth &gt; 1)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a> T is EQ_REF-joined)</div><div class="line">        eq_ref_eq_ref_extension_by_limited_search(</div><div class="line">                                         pplan, pplan_cost,</div><div class="line">                                         remaining_tables,</div><div class="line">                                         best_plan_so_far,</div><div class="line">                                         best_plan_so_far_cost,</div><div class="line">                                         search_depth - 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group___query___planner.html#ga7bcfc4f0e53c23266674782781c7a42c">best_extension_by_limited_search</a>(pplan, pplan_cost,</div><div class="line">                                         remaining_tables,</div><div class="line">                                         best_plan_so_far,</div><div class="line">                                         best_plan_so_far_cost,</div><div class="line">                                         search_depth - 1);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      best_plan_so_far_cost= pplan_cost;</div><div class="line">      best_plan_so_far= pplan;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>When 'best_extension_by_limited_search' is called for the first time, 'join-&gt;best_read' must be set to the largest possible value (e.g. DBL_MAX). The actual implementation provides a way to optionally use pruning heuristic (controlled by the parameter 'prune_level') to reduce the search space by skipping some partial plans.</dd>
<dd>
The parameter 'search_depth' provides control over the recursion depth, and thus the size of the resulting optimal plan.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remaining_tables</td><td>set of tables not included into the partial plan yet </td></tr>
    <tr><td class="paramname">idx</td><td>length of the partial QEP in 'join-&gt;positions'; since a depth-first search is used, also corresponds to the current depth of the search tree; also an index in the array 'join-&gt;best_ref'; </td></tr>
    <tr><td class="paramname">record_count</td><td>estimate for the number of records returned by the best partial plan </td></tr>
    <tr><td class="paramname">read_time</td><td>the cost of the best partial plan </td></tr>
    <tr><td class="paramname">current_search_depth</td><td>maximum depth of recursion and thus size of the found optimal plan (0 &lt; current_search_depth &lt;= join-&gt;tables+1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>

</div>
</div>
<a id="ga40175e89a592caf0dce0b81876c820f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40175e89a592caf0dce0b81876c820f1">&#9670;&nbsp;</a></span>check_interleaving_with_nj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Optimize_table_order::check_interleaving_with_nj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> interleaving with an inner tables of an outer join for extension table.</p>
<p><a class="el" href="struct_check.html">Check</a> if table tab can be added to current partial join order, and if yes, record that it has been added. This recording can be rolled back with <a class="el" href="group___query___planner.html#gaa149d4e4ac91df26688a77c6f2a2c55d">backout_nj_state()</a>.</p>
<p>The function assumes that both current partial join order and its extension with tab are valid wrt table dependencies.</p>
<pre class="fragment">   IMPLEMENTATION 
     LIMITATIONS ON JOIN ORDER
       The nested [outer] joins executioner algorithm imposes these limitations
       on join order:
       1. "Outer tables first" -  any "outer" table must be before any 
           corresponding "inner" table.
       2. "No interleaving" - tables inside a nested join must form a continuous
          sequence in join order (i.e. the sequence must not be interrupted by 
          tables that are outside of this nested join).

       #1 is checked elsewhere, this function checks #2 provided that #1 has
       been already checked.

     WHY NEED NON-INTERLEAVING
       Consider an example: 

         select * from t0 join t1 left join (t2 join t3) on cond1

       The join order "t1 t2 t0 t3" is invalid:

       table t0 is outside of the nested join, so WHERE condition for t0 is
       attached directly to t0 (without triggers, and it may be used to access
       t0). Applying WHERE(t0) to (t2,t0,t3) record is invalid as we may miss
       combinations of (t1, t2, t3) that satisfy condition cond1, and produce a
       null-complemented (t1, t2.NULLs, t3.NULLs) row, which should not have
       been produced.

       If table t0 is not between t2 and t3, the problem doesn't exist:
        If t0 is located after (t2,t3), WHERE(t0) is applied after nested join
         processing has finished.
        If t0 is located before (t2,t3), predicates like WHERE_cond(t0, t2) are
         wrapped into condition triggers, which takes care of correct nested
         join processing.

     HOW IT IS IMPLEMENTED
       The limitations on join order can be rephrased as follows: for valid
       join order one must be able to:
         1. write down the used tables in the join order on one line.
         2. for each nested join, put one '(' and one ')' on the said line        
         3. write "LEFT JOIN" and "ON (...)" where appropriate
         4. get a query equivalent to the query we're trying to execute.

       Calls to check_interleaving_with_nj() are equivalent to writing the
       above described line from left to right. 
       A single check_interleaving_with_nj(A,B) call is equivalent to writing 
       table B and appropriate brackets on condition that table A and
       appropriate brackets is the last what was written. Graphically the
       transition is as follows:

                            +---- current position
                            |
           ... last_tab ))) | ( tab )  )..) | ...
                              X     Y   Z   |
                                            +- need to move to this
                                               position.

       Notes about the position:
         The caller guarantees that there is no more then one X-bracket by 
         checking "!(remaining_tables &amp; s-&gt;dependent)" before calling this 
         function. X-bracket may have a pair in Y-bracket.

       When "writing" we store/update this auxilary info about the current
       position:
        1. cur_embedding_map - bitmap of pairs of brackets (aka nested
           joins) we've opened but didn't close.
        2. {each NESTED_JOIN structure not simplified away}-&gt;counter - number
           of this nested join's children that have already been added to to
           the partial join order.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Table we're going to extend the current partial join with</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Join order extended, nested joins info about current join order (see NOTE section) updated. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Requested join order extension not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf585184987b0097465505d600394b8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf585184987b0097465505d600394b8f3">&#9670;&nbsp;</a></span>choose_table_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Optimize_table_order::choose_table_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Entry point to table join order optimization. For further description, see class header and private function headers.</p>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error</dd></dl>
<p>Selects and invokes a search strategy for an optimal query join order.</p>
<p>The function checks user-configurable parameters that control the search strategy for an optimal plan, selects the search method and then invokes it. Each specific optimization procedure stores the final optimal plan in the array 'join-&gt;best_positions', and the cost of the plan in 'join-&gt;best_read'. The function can be invoked to produce a plan for all tables in the query (in this case, the const tables are usually filtered out), or it can be invoked to produce a plan for a materialization of a semijoin nest. Set a non-NULL emb_sjm_nest pointer when producing a plan for a semijoin nest to be materialized and a NULL pointer when producing a full query plan.</p>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>
<p>&lt; The tables involved in order selection </p>

</div>
</div>
<a id="ga5f0c0a4f6809dffbb4f82b5b563f946d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0c0a4f6809dffbb4f82b5b563f946d">&#9670;&nbsp;</a></span>consider_plan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::consider_plan </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>record_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>read_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_opt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>trace_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cost calculation of another (partial-)QEP has been completed.</p>
<p>If this is our 'best' plan explored so far, we record this query plan and its cost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>length of the partial QEP in 'join-&gt;positions'; also corresponds to the current depth of the search tree; also an index in the array 'join-&gt;best_ref'; </td></tr>
    <tr><td class="paramname">record_count</td><td>estimate for the number of records returned by the best partial plan </td></tr>
    <tr><td class="paramname">read_time</td><td>the cost of the best partial plan </td></tr>
    <tr><td class="paramname">trace_obj</td><td>trace object where information is to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1345da559c5841bf89d657bf2348e230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1345da559c5841bf89d657bf2348e230">&#9670;&nbsp;</a></span>determine_search_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint Optimize_table_order::determine_search_depth </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>search_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Heuristic procedure to automatically guess a reasonable degree of exhaustiveness for the greedy search procedure.</p>
<p>The procedure estimates the optimization time and selects a search depth big enough to result in a near-optimal QEP, that doesn't take too long to find. If the number of tables in the query exceeds some constant, then search_depth is set to this constant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_depth</td><td>Search depth value specified. If zero, calculate a default value. </td></tr>
    <tr><td class="paramname">table_count</td><td>Number of tables to be optimized (excludes const tables)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is an extremely simplistic implementation that serves as a stub for a more advanced analysis of the join. Ideally the search depth should be determined by learning from previous query optimizations, because it will depend on the CPU power (and other factors).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000101">Todo:</a></b></dt><dd>this value should be determined dynamically, based on statistics: uint max_tables_for_exhaustive_opt= 7;</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000102">Todo:</a></b></dt><dd>this value could be determined by some mapping of the form: depth : table_count -&gt; [max_tables_for_exhaustive_opt..MAX_EXHAUSTIVE]</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer that specifies the search depth (and thus the exhaustiveness) of the depth-first search algorithm used by 'greedy_search'. </dd></dl>

</div>
</div>
<a id="gae0027ccbdc2fcae194c506c735481d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0027ccbdc2fcae194c506c735481d2e">&#9670;&nbsp;</a></span>eq_ref_extension_by_limited_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">table_map Optimize_table_order::eq_ref_extension_by_limited_search </td>
          <td>(</td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>record_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>read_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>current_search_depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Heuristic utility used by <a class="el" href="group___query___planner.html#ga7bcfc4f0e53c23266674782781c7a42c">best_extension_by_limited_search()</a>. Adds EQ_REF-joined tables to the partial plan without extensive 'greedy' cost calculation.</p>
<p>When a table is joined by an unique key there is a 1::1 relation between the rows being joined. Assuming we have multiple such 1::1 (star-)joined relations in a sequence, without other join types inbetween. Then all of these 'eq_ref-joins' will be estimated to return the excact same #rows and having identical 'cost' (or 'read_time').</p>
<p>This leads to that we can append such a contigous sequence of eq_ref-joins to a partial plan in any order without affecting the total cost of the query plan. Exploring the different permutations of these eq_refs in the 'greedy' optimizations will simply be a waste of precious CPU cycles.</p>
<p>Once we have appended a single eq_ref-join to a partial plan, we may use <a class="el" href="group___query___planner.html#gae0027ccbdc2fcae194c506c735481d2e">eq_ref_extension_by_limited_search()</a> to search 'remaining_tables' for more eq_refs which will form a contigous set of eq_refs in the QEP.</p>
<p>Effectively, this chain of eq_refs will be handled as a single entity wrt. the full 'greedy' exploration of the possible join plans. This will reduce the 'N' in the O(N!) complexity of the full greedy search.</p>
<p>The algorithm start by already having a eq_ref joined table in position[idx-1] when called. It then search for more eq_ref-joinable 'remaining_tables' which are added directly to the partial QEP without further cost analysis. The algorithm continues until it either has constructed a complete plan, constructed a partial plan with size = search_depth, or could not find more eq_refs to append.</p>
<p>In the later case the algorithm continues into 'best_extension_by_limited_search' which does a 'greedy' search for the next table to add - Possibly with later eq_ref_extensions.</p>
<p>The final optimal plan is stored in 'join-&gt;best_positions'. The corresponding cost of the optimal plan is in 'join-&gt;best_read'.</p>
<dl class="section note"><dt>Note</dt><dd>::best_extension_by_limited_search() &amp; ::eq_ref_extension_by_limited_search() are closely related to each other and intentially implemented using the same pattern wherever possible. If a change/bug fix is done to either of these also consider if it is relevant for the other.</dd></dl>
<div class="fragment"><div class="line">procedure <a class="code" href="group___query___planner.html#gae0027ccbdc2fcae194c506c735481d2e">eq_ref_extension_by_limited_search</a>(</div><div class="line">  pplan in,             <span class="comment">// in, partial plan of tables-joined-so-far</span></div><div class="line">  pplan_cost,           <span class="comment">// in, cost of pplan</span></div><div class="line">  remaining_tables,     <span class="comment">// in, set of tables not referenced in pplan</span></div><div class="line">  best_plan_so_far,     <span class="comment">// in/out, best plan found so far</span></div><div class="line">  best_plan_so_far_cost,<span class="comment">// in/out, cost of best_plan_so_far</span></div><div class="line">  search_depth)         <span class="comment">// in, maximum size of the plans being considered</span></div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> find <span class="stringliteral">&#39;eq_ref&#39;</span> <a class="code" href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a> T <a class="code" href="ha__innodb_8cc.html#af9f143e62cdad4afb8a53a21b8b8fcfd">from</a> remaining_tables</div><div class="line">  {</div><div class="line">    <span class="comment">// Calculate the cost of using table T as above</span></div><div class="line">    cost = complex-series-<a class="code" href="row0merge_8cc.html#ac9307a61f1cda9f3a298e7c2eebc4347">of</a>-calculations;</div><div class="line"></div><div class="line">    <span class="comment">// Add the cost to the cost so far.</span></div><div class="line">    pplan_cost+= cost;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (pplan_cost &gt;= best_plan_so_far_cost)</div><div class="line">      <span class="comment">// pplan_cost already too great, stop search</span></div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    pplan= expand pplan by best_access_method;</div><div class="line">    remaining_tables= remaining_tables - <a class="code" href="dict0crea_8cc.html#a97b9c482d2e3a71e14565e116943095a">table</a> T;</div><div class="line">    <a class="code" href="group___query___planner.html#gae0027ccbdc2fcae194c506c735481d2e">eq_ref_extension_by_limited_search</a>(pplan, pplan_cost,</div><div class="line">                                       remaining_tables,</div><div class="line">                                       best_plan_so_far,</div><div class="line">                                       best_plan_so_far_cost,</div><div class="line">                                       search_depth - 1);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <a class="code" href="group___query___planner.html#ga7bcfc4f0e53c23266674782781c7a42c">best_extension_by_limited_search</a>(pplan, pplan_cost,</div><div class="line">                                     remaining_tables,</div><div class="line">                                     best_plan_so_far,</div><div class="line">                                     best_plan_so_far_cost,</div><div class="line">                                     search_depth - 1);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The parameter 'search_depth' provides control over the recursion depth, and thus the size of the resulting optimal plan.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remaining_tables</td><td>set of tables not included into the partial plan yet </td></tr>
    <tr><td class="paramname">idx</td><td>length of the partial QEP in 'join-&gt;positions'; since a depth-first search is used, also corresponds to the current depth of the search tree; also an index in the array 'join-&gt;best_ref'; </td></tr>
    <tr><td class="paramname">record_count</td><td>estimate for the number of records returned by the best partial plan </td></tr>
    <tr><td class="paramname">read_time</td><td>the cost of the best partial plan </td></tr>
    <tr><td class="paramname">current_search_depth</td><td>maximum depth of recursion and thus size of the found optimal plan (0 &lt; current_search_depth &lt;= join-&gt;tables+1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">'table_map'</td><td>Map of those tables appended to the EQ_REF-joined sequence </td></tr>
    <tr><td class="paramname">~(table_map)0</td><td>Fatal error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba76f383cbe1dccc7c7a6facaf1fe6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba76f383cbe1dccc7c7a6facaf1fe6b8">&#9670;&nbsp;</a></span>fix_semijoin_strategies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Optimize_table_order::fix_semijoin_strategies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix semi-join strategies for the picked join order. </p>
<dl class="section return"><dt>Returns</dt><dd>FALSE if success, TRUE if error</dd></dl>
<p>Fix semi-join strategies for the picked join order. This is a step that needs to be done right after we have fixed the join order. What we do here is switch join's semi-join strategy description from backward-based to forwards based.</p>
<p>When join optimization is in progress, we re-consider semi-join strategies after we've added another table. Here's an illustration. Suppose the join optimization is underway:</p>
<p>1) ot1 it1 it2 sjX &ndash; looking at (ot1, it1, it2) join prefix, we decide to use semi-join strategy sjX.</p>
<p>2) ot1 it1 it2 ot2 sjX sjY &ndash; Having added table ot2, we now may consider another semi-join strategy and decide to use a different strategy sjY. Note that the record of sjX has remained under it2. That is necessary because we need to be able to get back to (ot1, it1, it2) join prefix. what makes things even worse is that there are cases where the choice of sjY changes the way we should access it2.</p>
<p>3) [ot1 it1 it2 ot2 ot3] sjX sjY &ndash; This means that after join optimization is finished, semi-join info should be read right-to-left (while nearly all plan refinement functions, EXPLAIN, etc proceed from left to right)</p>
<p>This function does the needed reversal, making it possible to read the join and semi-join order from left to right. </p>

</div>
</div>
<a id="ga1d0e0e4bba8f362f8b3c60cfb2736559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d0e0e4bba8f362f8b3c60cfb2736559">&#9670;&nbsp;</a></span>greedy_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Optimize_table_order::greedy_search </td>
          <td>(</td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a good, possibly optimal, query execution plan (QEP) by a greedy search.</p>
<p>The search procedure uses a hybrid greedy/exhaustive search with controlled exhaustiveness. The search is performed in N = card(remaining_tables) steps. Each step evaluates how promising is each of the unoptimized tables, selects the most promising table, and extends the current partial QEP with that table. Currenly the most 'promising' table is the one with least expensive extension.\</p>
<p>There are two extreme cases:</p><ol type="1">
<li>When (card(remaining_tables) &lt; search_depth), the estimate finds the best complete continuation of the partial QEP. This continuation can be used directly as a result of the search.</li>
<li>When (search_depth == 1) the 'best_extension_by_limited_search' consideres the extension of the current QEP with each of the remaining unoptimized tables.</li>
</ol>
<p>All other cases are in-between these two extremes. Thus the parameter 'search_depth' controlls the exhaustiveness of the search. The higher the value, the longer the optimizaton time and possibly the better the resulting plan. The lower the value, the fewer alternative plans are estimated, but the more likely to get a bad QEP.</p>
<p>All intermediate and final results of the procedure are stored in 'join':</p><ul>
<li>join-&gt;positions : modified for every partial QEP that is explored</li>
<li>join-&gt;best_positions: modified for the current best complete QEP</li>
<li>join-&gt;best_read : modified for the current best complete QEP</li>
<li>join-&gt;best_ref : might be partially reordered</li>
</ul>
<p>The final optimal plan is stored in 'join-&gt;best_positions', and its corresponding cost in 'join-&gt;best_read'.</p>
<dl class="section note"><dt>Note</dt><dd>The following pseudocode describes the algorithm of 'greedy_search':</dd></dl>
<div class="fragment"><div class="line">procedure <a class="code" href="group___query___planner.html#ga1d0e0e4bba8f362f8b3c60cfb2736559">greedy_search</a></div><div class="line">input: remaining_tables</div><div class="line">output: pplan;</div><div class="line">{</div><div class="line">  pplan = &lt;&gt;;</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">    (t, <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>) = best_extension(pplan, remaining_tables);</div><div class="line">    pplan = concat(pplan, (t, <a class="code" href="row0merge_8cc.html#aaba8987b345486af51614561bddd051b">a</a>));</div><div class="line">    remaining_tables = remaining_tables - t;</div><div class="line">  } <span class="keywordflow">while</span> (remaining_tables != {})</div><div class="line">  <span class="keywordflow">return</span> pplan;</div><div class="line">}</div></div><!-- fragment --><p> where 'best_extension' is a placeholder for a procedure that selects the most "promising" of all tables in 'remaining_tables'. Currently this estimate is performed by calling 'best_extension_by_limited_search' to evaluate all extensions of the current QEP of size 'search_depth', thus the complexity of 'greedy_search' mainly depends on that of 'best_extension_by_limited_search'.</p>
<dl class="section user"><dt></dt><dd>If 'best_extension()' == '<a class="el" href="group___query___planner.html#ga7bcfc4f0e53c23266674782781c7a42c">best_extension_by_limited_search()</a>', then the worst-case complexity of this algorithm is &lt;= O(N*N^search_depth/search_depth). When serch_depth &gt;= N, then the complexity of greedy_search is O(N!). 'N' is the number of 'non eq_ref' tables + 'eq_ref groups' which normally are considerable less than total numbers of tables in the query.</dd></dl>
<dl class="section user"><dt></dt><dd>In the future, 'greedy_search' might be extended to support other implementations of 'best_extension'.</dd></dl>
<dl class="section user"><dt></dt><dd><code>search_depth</code> from <a class="el" href="class_optimize__table__order.html">Optimize_table_order</a> controls the exhaustiveness of the search, and <code>prune_level</code> controls the pruning heuristics that should be applied during search.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remaining_tables</td><td>set of tables not included into the partial plan yet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error </dd></dl>

</div>
</div>
<a id="gae4eb4a2a802676363d5079335af9106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4eb4a2a802676363d5079335af9106d">&#9670;&nbsp;</a></span>optimize_straight_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::optimize_straight_join </td>
          <td>(</td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>join_tables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Select the best ways to access the tables in a query without reordering them.</p>
<p>Find the best access paths for each query table and compute their costs according to their order in the array 'join-&gt;best_ref' (thus without reordering the join tables). The function calls sequentially 'best_access_path' for each table in the query to select the best table access method. The final optimal plan is stored in the array 'join-&gt;best_positions', and the corresponding cost in 'join-&gt;best_read'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_tables</td><td>set of the tables in the query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can be applied to:<ul>
<li>queries with STRAIGHT_JOIN</li>
<li>internally to compute the cost of an arbitrary QEP </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Thus 'optimize_straight_join' can be used at any stage of the query optimization process to finalize a QEP as it is. </dd></dl>
<p>If many plans have identical cost, which one will be used depends on how compiler optimizes floating-point calculations. this fix adds repeatability to the optimizer. (Similar code in best_extension_by_li...)</p>

</div>
</div>
<a id="gabf8bc9bccf882a55db6cb971dbfbc8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf8bc9bccf882a55db6cb971dbfbc8d9">&#9670;&nbsp;</a></span>semijoin_dupsweedout_access_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::semijoin_dupsweedout_access_paths </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>first_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>last_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find best access paths for semi-join DuplicateWeedout strategy and calculate rowcount and cost based on these.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">first_tab</td><td>The first tab to calculate access paths for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">last_tab</td><td>The last tab to calculate access paths for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td><a class="el" href="class_bitmap.html">Bitmap</a> of tables that are not in the [0...last_tab] join prefix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcount</td><td>New output row count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcost</td><td>New join prefix cost</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if strategy selection successful, false otherwise.</dd></dl>
<p>Notice that new best access paths need not be calculated. The proper access path information is already in join-&gt;positions, because DuplicateWeedout can handle any join buffering strategy. The only action performed by this function is to calculate output rowcount, and an updated cost estimate.</p>
<p>The cost estimate is based on performing a join over the involved tables, but we must also add the cost of creating and populating the temporary table used for duplicate removal, and the cost of doing lookups against this table. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000103">Todo:</a></b></dt><dd>: Some times, some outer fanout is "absorbed" into the inner fanout. In this case, we should make a better estimate for outer_fanout that is used to calculate the output rowcount. Trial code: if (inner_fanout &gt; 1.0) { We have inner table(s) before an outer table. If there are dependencies between these tables, the fanout for the outer table is not a good estimate for the final number of rows from the weedout execution, therefore we convert some of the inner fanout into an outer fanout, limited to the number of possible rows in the outer table. double fanout= min(inner_fanout*p-&gt;records_read, p-&gt;table-&gt;table-&gt;quick_condition_rows); inner_fanout*= p-&gt;records_read / fanout; outer_fanout*= fanout; } else outer_fanout*= p-&gt;records_read; </dd></dl>

</div>
</div>
<a id="ga8452432379e04249b9b647ec608b3b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8452432379e04249b9b647ec608b3b6b">&#9670;&nbsp;</a></span>semijoin_firstmatch_loosescan_access_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Optimize_table_order::semijoin_firstmatch_loosescan_access_paths </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>first_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>last_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loosescan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>final</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find best access paths for semi-join FirstMatch or LooseScan strategy and calculate rowcount and cost based on these.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">first_tab</td><td>The first tab to calculate access paths for, this is always a semi-join inner table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">last_tab</td><td>The last tab to calculate access paths for, always a semi-join inner table for FirstMatch, may be inner or outer for LooseScan. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td><a class="el" href="class_bitmap.html">Bitmap</a> of tables that are not in the [0...last_tab] join prefix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">loosescan</td><td>If true, use LooseScan strategy, otherwise FirstMatch </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">final</td><td>If true, use and update access path data in join-&gt;best_positions, otherwise use join-&gt;positions and update a local buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rowcount</td><td>New output row count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcost</td><td>New join prefix cost</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if strategy selection successful, false otherwise.</dd></dl>
<p>Calculate best access paths for the tables of a semi-join FirstMatch or LooseScan strategy, given the order of tables provided in join-&gt;positions (or join-&gt;best_positions when calculating the cost of a final plan). Calculate estimated cost and rowcount for this plan. Given a join prefix [0; ... first_tab-1], change the access to the tables in the range [first_tab; last_tab] according to the constraints set by the relevant semi-join strategy. Those constraints are:</p>
<ul>
<li>For the LooseScan strategy, join buffering can be used for the outer tables following the last inner table.</li>
<li>For the FirstMatch strategy, join buffering can be used if there is a single inner table in the semi-join nest.</li>
</ul>
<p>For FirstMatch, the handled range of tables may be a mix of inner tables and non-dependent outer tables. The first and last table in the handled range are always inner tables. For LooseScan, the handled range can be a mix of inner tables and dependent and non-dependent outer tables. The first table is always an inner table. </p>

</div>
</div>
<a id="gac0e9baa19f09976372ae2ed2c19d5a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0e9baa19f09976372ae2ed2c19d5a7d">&#9670;&nbsp;</a></span>semijoin_mat_lookup_access_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::semijoin_mat_lookup_access_paths </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>last_inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>sjm_nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find best access paths for semi-join MaterializeLookup strategy. and calculate rowcount and cost based on these.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">last_inner</td><td>Index of the last inner table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sjm_nest</td><td>Pointer to semi-join nest for inner tables </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rowcount</td><td>New output row count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcost</td><td>New join prefix cost</td></tr>
  </table>
  </dd>
</dl>
<p>All outer tables may use join buffering, so there is no need to recalculate access paths nor costs for these. Add cost of materialization and scanning the materialized table to the costs of accessing the outer tables. </p>

</div>
</div>
<a id="ga81420e7965b6e4a2f13d67ac15d05ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81420e7965b6e4a2f13d67ac15d05ec9">&#9670;&nbsp;</a></span>semijoin_mat_scan_access_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Optimize_table_order::semijoin_mat_scan_access_paths </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>last_inner_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>last_outer_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_a_b_l_e___l_i_s_t.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>sjm_nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>final</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>newcost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find best access paths for semi-join MaterializeScan strategy and calculate rowcount and cost based on these.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">last_inner_tab</td><td>The last tab in the set of inner tables </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">last_outer_tab</td><td>The last tab in the set of outer tables </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remaining_tables</td><td><a class="el" href="class_bitmap.html">Bitmap</a> of tables that are not in the join prefix including the inner and outer tables processed here. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sjm_nest</td><td>Pointer to semi-join nest for inner tables </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">final</td><td>If true, use and update access path data in join-&gt;best_positions, otherwise use join-&gt;positions and update a local buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rowcount</td><td>New output row count </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newcost</td><td>New join prefix cost</td></tr>
  </table>
  </dd>
</dl>
<p>Calculate best access paths for the outer tables of the MaterializeScan semi-join strategy. All outer tables may use join buffering. The prefix row count is adjusted with the estimated number of rows in the materialized tables, before taking into consideration the rows contributed by the outer tables. </p>

</div>
</div>
<a id="gaf51edd4249ea43d69718f9754c9422fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf51edd4249ea43d69718f9754c9422fd">&#9670;&nbsp;</a></span>semijoin_order_allows_materialization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int semijoin_order_allows_materialization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>remaining_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="struct_check.html">Check</a> whether a semijoin materialization strategy is allowed for the current (semi)join table order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join object </td></tr>
    <tr><td class="paramname">remaining_tables</td><td>Tables that have not yet been added to the join plan </td></tr>
    <tr><td class="paramname">tab</td><td>Join tab of the table being considered </td></tr>
    <tr><td class="paramname">idx</td><td>Index of table with join tab "tab"</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SJ_OPT_NONE</td><td>- Materialization not applicable </td></tr>
    <tr><td class="paramname">SJ_OPT_MATERIALIZE_LOOKUP</td><td>- Materialization with lookup applicable </td></tr>
    <tr><td class="paramname">SJ_OPT_MATERIALIZE_SCAN</td><td>- Materialization with scan applicable</td></tr>
  </table>
  </dd>
</dl>
<p>The function checks applicability of both MaterializeLookup and MaterializeScan strategies. No checking is made until "tab" is pointing to the last inner table of a semijoin nest that can be executed using materialization - for all other cases SJ_OPT_NONE is returned.</p>
<p>MaterializeLookup and MaterializeScan are both applicable in the following two cases:</p>
<ol type="1">
<li>There are no correlated outer tables, or</li>
<li>There are correlated outer tables within the prefix only.</li>
</ol>
<p>In this case, MaterializeLookup is returned based on a heuristic decision. </p>

</div>
</div>
<a id="ga287945c7b5b4a7419bb032390c634fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga287945c7b5b4a7419bb032390c634fe5">&#9670;&nbsp;</a></span>trace_plan_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trace_plan_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_j_o_i_n.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>excluded_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to write the current plan's prefix to the optimizer trace. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

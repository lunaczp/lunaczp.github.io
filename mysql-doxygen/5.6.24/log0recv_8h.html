<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/include/log0recv.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">log0recv.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &lt;list&gt;</code><br />
<code>#include &quot;log0recv.ic&quot;</code><br />
</div>
<p><a href="log0recv_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrecv__data__t.html">recv_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrecv__t.html">recv_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrecv__addr__t.html">recv_addr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrecv__dblwr__t.html">recv_dblwr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrecv__sys__t.html">recv_sys_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acfba28514ab74f04842e7c79174a5754"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#acfba28514ab74f04842e7c79174a5754">recv_recover_page</a>(jri,  <a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)&#160;&#160;&#160;<a class="el" href="log0recv_8cc.html#a6bab7e1e70f3c89ccba51bb66a7b5cb8">recv_recover_page_func</a>(jri, <a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:acfba28514ab74f04842e7c79174a5754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5c2f5c1d19e49e67766247c62dfd53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#aaf5c2f5c1d19e49e67766247c62dfd53">recv_recovery_from_checkpoint_start</a>(<a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>,  lim,  min,  max)&#160;&#160;&#160;<a class="el" href="log0recv_8cc.html#ad58d651ba2056c889b8296ad43d5d9c3">recv_recovery_from_checkpoint_start_func</a>(min,max)</td></tr>
<tr class="separator:aaf5c2f5c1d19e49e67766247c62dfd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd85278988f4344ef4d339eb491ec18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a3bd85278988f4344ef4d339eb491ec18">RECV_PARSING_BUF_SIZE</a>&#160;&#160;&#160;(2 * 1024 * 1024)</td></tr>
<tr class="separator:a3bd85278988f4344ef4d339eb491ec18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e229060b2dd637a566107fc7806c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#ab45e229060b2dd637a566107fc7806c7">RECV_SCAN_SIZE</a>&#160;&#160;&#160;(4 * UNIV_PAGE_SIZE)</td></tr>
<tr class="separator:ab45e229060b2dd637a566107fc7806c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3f5aa2ca6270b43214c955cb53517e23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a3f5aa2ca6270b43214c955cb53517e23">recv_addr_state</a> { <a class="el" href="log0recv_8h.html#a3f5aa2ca6270b43214c955cb53517e23a8a687e630d4e57fc748070019093dec8">RECV_NOT_PROCESSED</a>, 
<a class="el" href="log0recv_8h.html#a3f5aa2ca6270b43214c955cb53517e23a0a458a804a1684b65ea4b3e8e22dbd5c">RECV_BEING_READ</a>, 
<a class="el" href="log0recv_8h.html#a3f5aa2ca6270b43214c955cb53517e23a7c0771bb68a174a932be6f9a89f1cafe">RECV_BEING_PROCESSED</a>, 
<a class="el" href="log0recv_8h.html#a3f5aa2ca6270b43214c955cb53517e23acb50921c1c4973d7607e5f3b623d5213">RECV_PROCESSED</a>
 }</td></tr>
<tr class="separator:a3f5aa2ca6270b43214c955cb53517e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af9c07e71ae94f02e7ced76531d20e09d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#af9c07e71ae94f02e7ced76531d20e09d">recv_recovery_is_on</a> (void)</td></tr>
<tr class="separator:af9c07e71ae94f02e7ced76531d20e09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bab7e1e70f3c89ccba51bb66a7b5cb8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a6bab7e1e70f3c89ccba51bb66a7b5cb8">recv_recover_page_func</a> (ibool just_read_in, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a6bab7e1e70f3c89ccba51bb66a7b5cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58d651ba2056c889b8296ad43d5d9c3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#ad58d651ba2056c889b8296ad43d5d9c3">recv_recovery_from_checkpoint_start_func</a> (lsn_t <a class="el" href="srv0start_8cc.html#a1d546c3fcf2f25749006e0d32da645f4">min_flushed_lsn</a>, lsn_t <a class="el" href="srv0start_8cc.html#a451b129f36127c7dc27ad05fe897b792">max_flushed_lsn</a>)</td></tr>
<tr class="separator:ad58d651ba2056c889b8296ad43d5d9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe97c7ed59b6670bd29aabde13ff61b4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#abe97c7ed59b6670bd29aabde13ff61b4">recv_recovery_from_checkpoint_finish</a> (void)</td></tr>
<tr class="separator:abe97c7ed59b6670bd29aabde13ff61b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ed9e29164666b1d7831257c1a04793"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a06ed9e29164666b1d7831257c1a04793">recv_recovery_rollback_active</a> (void)</td></tr>
<tr class="separator:a06ed9e29164666b1d7831257c1a04793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f768c3dac723e2444428bb6f1388c3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a44f768c3dac723e2444428bb6f1388c3">recv_scan_log_recs</a> (ulint available_memory, ibool store_to_hash, const byte *<a class="el" href="row0merge_8cc.html#ac7f6dbf32ec9428223e605e1b7f87bde">buf</a>, ulint <a class="el" href="row0sel_8cc.html#abc67df9cd0bfdc52888bacc2e5097fdd">len</a>, lsn_t start_lsn, lsn_t *contiguous_lsn, lsn_t *group_scanned_lsn)</td></tr>
<tr class="separator:a44f768c3dac723e2444428bb6f1388c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae039612836bd7c4b644a8eea84fa89aa"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#ae039612836bd7c4b644a8eea84fa89aa">recv_reset_logs</a> (lsn_t <a class="el" href="trx0trx_8cc.html#ac590ff49613347cd747ceb94a0bb8b51">lsn</a>)</td></tr>
<tr class="separator:ae039612836bd7c4b644a8eea84fa89aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6a2e802976bbca76d67d8788c711d8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#aaa6a2e802976bbca76d67d8788c711d8">recv_sys_create</a> (void)</td></tr>
<tr class="separator:aaa6a2e802976bbca76d67d8788c711d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b14557f39abeba9b80bd66fbc96aeb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a65b14557f39abeba9b80bd66fbc96aeb">recv_sys_close</a> (void)</td></tr>
<tr class="separator:a65b14557f39abeba9b80bd66fbc96aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41975a23eb880acab4a47274910cd338"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a41975a23eb880acab4a47274910cd338">recv_sys_mem_free</a> (void)</td></tr>
<tr class="separator:a41975a23eb880acab4a47274910cd338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78f6b379d555b6609120b94a88e48c8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#af78f6b379d555b6609120b94a88e48c8">recv_sys_init</a> (ulint available_memory)</td></tr>
<tr class="separator:af78f6b379d555b6609120b94a88e48c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa292eaf15cfd7536fefda28f01a19a7e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#aa292eaf15cfd7536fefda28f01a19a7e">recv_sys_var_init</a> (void)</td></tr>
<tr class="separator:aa292eaf15cfd7536fefda28f01a19a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d4a25490a9a0a3723b1c99f22706a3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a66d4a25490a9a0a3723b1c99f22706a3">recv_apply_hashed_log_recs</a> (ibool allow_ibuf)</td></tr>
<tr class="separator:a66d4a25490a9a0a3723b1c99f22706a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a933290104831a9ad6f97c2952b420963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrecv__sys__t.html">recv_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a933290104831a9ad6f97c2952b420963">recv_sys</a></td></tr>
<tr class="separator:a933290104831a9ad6f97c2952b420963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec84e1e44861d8fb34d235980f109689"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#aec84e1e44861d8fb34d235980f109689">recv_recovery_on</a></td></tr>
<tr class="separator:aec84e1e44861d8fb34d235980f109689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33c348e52c3b6bec2a8ec3795516d32"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#ab33c348e52c3b6bec2a8ec3795516d32">recv_no_ibuf_operations</a></td></tr>
<tr class="separator:ab33c348e52c3b6bec2a8ec3795516d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c4025a44b76e120aab4653eaead111"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#a28c4025a44b76e120aab4653eaead111">recv_needed_recovery</a></td></tr>
<tr class="separator:a28c4025a44b76e120aab4653eaead111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61ce1f3b2b1e21c3117030573852920"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#ab61ce1f3b2b1e21c3117030573852920">recv_lsn_checks_on</a></td></tr>
<tr class="separator:ab61ce1f3b2b1e21c3117030573852920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0307a102944157c341e394aee959769"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#aa0307a102944157c341e394aee959769">recv_max_parsed_page_no</a></td></tr>
<tr class="separator:aa0307a102944157c341e394aee959769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67bbbbc46b800ca54edf37d35f2cc60"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="log0recv_8h.html#ab67bbbbc46b800ca54edf37d35f2cc60">recv_n_pool_free_frames</a></td></tr>
<tr class="separator:ab67bbbbc46b800ca54edf37d35f2cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Recovery</p>
<p>Created 9/20/1997 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3bd85278988f4344ef4d339eb491ec18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd85278988f4344ef4d339eb491ec18">&#9670;&nbsp;</a></span>RECV_PARSING_BUF_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RECV_PARSING_BUF_SIZE&#160;&#160;&#160;(2 * 1024 * 1024)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the parsing buffer; it must accommodate RECV_SCAN_SIZE many times! </p>

</div>
</div>
<a id="acfba28514ab74f04842e7c79174a5754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfba28514ab74f04842e7c79174a5754">&#9670;&nbsp;</a></span>recv_recover_page</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define recv_recover_page</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">jri, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="log0recv_8cc.html#a6bab7e1e70f3c89ccba51bb66a7b5cb8">recv_recover_page_func</a>(jri, <a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for <a class="el" href="log0recv_8h.html#a6bab7e1e70f3c89ccba51bb66a7b5cb8">recv_recover_page_func()</a>. Applies the hashed log records to the page, if the page lsn is less than the lsn of a log record. This can be called when a buffer page has just been read in, or also for a page already in the buffer pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jri</td><td>in: TRUE if just read in (the i/o handler calls this for a freshly read page) </td></tr>
    <tr><td class="paramname">block</td><td>in/out: the buffer block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf5c2f5c1d19e49e67766247c62dfd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5c2f5c1d19e49e67766247c62dfd53">&#9670;&nbsp;</a></span>recv_recovery_from_checkpoint_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define recv_recovery_from_checkpoint_start</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="trx0undo_8cc.html#a6093ca66dd564a9c407d64ce43838c28">type</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lim, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">min, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="log0recv_8cc.html#ad58d651ba2056c889b8296ad43d5d9c3">recv_recovery_from_checkpoint_start_func</a>(min,max)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for <a class="el" href="log0recv_8h.html#ad58d651ba2056c889b8296ad43d5d9c3">recv_recovery_from_checkpoint_start_func()</a>. Recovers from a checkpoint. When this function returns, the database is able to start processing of new user transactions, but the function recv_recovery_from_checkpoint_finish should be called later to complete the recovery and free the resources used in it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>ignored: LOG_CHECKPOINT or LOG_ARCHIVE </td></tr>
    <tr><td class="paramname">lim</td><td>ignored: recover up to this log sequence number if possible </td></tr>
    <tr><td class="paramname">min</td><td>in: minimum flushed log sequence number from data files </td></tr>
    <tr><td class="paramname">max</td><td>in: maximum flushed log sequence number from data files </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS </dd></dl>

</div>
</div>
<a id="ab45e229060b2dd637a566107fc7806c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e229060b2dd637a566107fc7806c7">&#9670;&nbsp;</a></span>RECV_SCAN_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RECV_SCAN_SIZE&#160;&#160;&#160;(4 * UNIV_PAGE_SIZE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of block reads when the log groups are scanned forward to do a roll-forward </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a3f5aa2ca6270b43214c955cb53517e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5aa2ca6270b43214c955cb53517e23">&#9670;&nbsp;</a></span>recv_addr_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="log0recv_8h.html#a3f5aa2ca6270b43214c955cb53517e23">recv_addr_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>States of <a class="el" href="structrecv__addr__t.html">recv_addr_t</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3f5aa2ca6270b43214c955cb53517e23a8a687e630d4e57fc748070019093dec8"></a>RECV_NOT_PROCESSED&#160;</td><td class="fielddoc"><p>not yet processed </p>
</td></tr>
<tr><td class="fieldname"><a id="a3f5aa2ca6270b43214c955cb53517e23a0a458a804a1684b65ea4b3e8e22dbd5c"></a>RECV_BEING_READ&#160;</td><td class="fielddoc"><p>page is being read </p>
</td></tr>
<tr><td class="fieldname"><a id="a3f5aa2ca6270b43214c955cb53517e23a7c0771bb68a174a932be6f9a89f1cafe"></a>RECV_BEING_PROCESSED&#160;</td><td class="fielddoc"><p>log records are being applied on the page </p>
</td></tr>
<tr><td class="fieldname"><a id="a3f5aa2ca6270b43214c955cb53517e23acb50921c1c4973d7607e5f3b623d5213"></a>RECV_PROCESSED&#160;</td><td class="fielddoc"><p>log records have been applied on the page, or they have been discarded because the tablespace does not exist </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a66d4a25490a9a0a3723b1c99f22706a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d4a25490a9a0a3723b1c99f22706a3">&#9670;&nbsp;</a></span>recv_apply_hashed_log_recs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_apply_hashed_log_recs </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>allow_ibuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empties the hash table of stored log records, applying them to appropriate pages. in: if TRUE, also ibuf operations are allowed during the application; if FALSE, no ibuf operations are allowed, and after the application all file pages are flushed to disk and invalidated in buffer pool: this alternative means that no new log records can be generated during the application</p>
<p>Empties the hash table of stored log records, applying them to appropriate pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allow_ibuf</td><td>in: if TRUE, also ibuf operations are allowed during the application; if FALSE, no ibuf operations are allowed, and after the application all file pages are flushed to disk and invalidated in buffer pool: this alternative means that no new log records can be generated during the application; the caller must in this case own the log mutex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bab7e1e70f3c89ccba51bb66a7b5cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bab7e1e70f3c89ccba51bb66a7b5cb8">&#9670;&nbsp;</a></span>recv_recover_page_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_recover_page_func </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>just_read_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies the hashed log records to the page, if the page lsn is less than the lsn of a log record. This can be called when a buffer page has just been read in, or also for a page already in the buffer pool. in/out: buffer block</p>
<p>Applies the hashed log records to the page, if the page lsn is less than the lsn of a log record. This can be called when a buffer page has just been read in, or also for a page already in the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">just_read_in</td><td>in: TRUE if the i/o handler calls this for a freshly read page </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe97c7ed59b6670bd29aabde13ff61b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe97c7ed59b6670bd29aabde13ff61b4">&#9670;&nbsp;</a></span>recv_recovery_from_checkpoint_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_recovery_from_checkpoint_finish </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes recovery from a checkpoint. </p>

</div>
</div>
<a id="ad58d651ba2056c889b8296ad43d5d9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58d651ba2056c889b8296ad43d5d9c3">&#9670;&nbsp;</a></span>recv_recovery_from_checkpoint_start_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> recv_recovery_from_checkpoint_start_func </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>min_flushed_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>max_flushed_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recovers from a checkpoint. When this function returns, the database is able to start processing of new user transactions, but the function recv_recovery_from_checkpoint_finish should be called later to complete the recovery and free the resources used in it. </p><dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS in: max flushed lsn from data files</dd></dl>
<p>Recovers from a checkpoint. When this function returns, the database is able to start processing of new user transactions, but the function recv_recovery_from_checkpoint_finish should be called later to complete the recovery and free the resources used in it. </p><dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS </dd></dl>
<p>TRUE when recovering from a checkpoint</p>
<p>Recover up to this log sequence number </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_flushed_lsn</td><td>in: min flushed lsn from data files </td></tr>
    <tr><td class="paramname">max_flushed_lsn</td><td>in: max flushed lsn from data files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9c07e71ae94f02e7ced76531d20e09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c07e71ae94f02e7ced76531d20e09d">&#9670;&nbsp;</a></span>recv_recovery_is_on()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool recv_recovery_is_on </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if recovery is currently running. </p><dl class="section return"><dt>Returns</dt><dd>recv_recovery_on </dd></dl>

</div>
</div>
<a id="a06ed9e29164666b1d7831257c1a04793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ed9e29164666b1d7831257c1a04793">&#9670;&nbsp;</a></span>recv_recovery_rollback_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_recovery_rollback_active </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates the rollback of active transactions. </p>

</div>
</div>
<a id="ae039612836bd7c4b644a8eea84fa89aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae039612836bd7c4b644a8eea84fa89aa">&#9670;&nbsp;</a></span>recv_reset_logs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_reset_logs </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the logs. The contents of log files will be lost! in: reset to this lsn rounded up to be divisible by OS_FILE_LOG_BLOCK_SIZE, after which we add LOG_BLOCK_HDR_SIZE</p>
<p>Resets the logs. The contents of log files will be lost! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lsn</td><td>in: reset to this lsn rounded up to be divisible by OS_FILE_LOG_BLOCK_SIZE, after which we add LOG_BLOCK_HDR_SIZE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44f768c3dac723e2444428bb6f1388c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f768c3dac723e2444428bb6f1388c3">&#9670;&nbsp;</a></span>recv_scan_log_recs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool recv_scan_log_recs </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>available_memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>store_to_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t *&#160;</td>
          <td class="paramname"><em>contiguous_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t *&#160;</td>
          <td class="paramname"><em>group_scanned_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans log from a buffer and stores new log data to the parsing buffer. Parses and hashes the log records if new data found. Unless UNIV_HOTBACKUP is defined, this function will apply log records automatically when the hash table becomes full. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if limit_lsn has been reached, or not able to scan any more in this log group out: scanning succeeded up to this lsn</dd></dl>
<p>Scans log from a buffer and stores new log data to the parsing buffer. Parses and hashes the log records if new data found. Unless UNIV_HOTBACKUP is defined, this function will apply log records automatically when the hash table becomes full. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if limit_lsn has been reached, or not able to scan any more in this log group </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">available_memory</td><td>in: we let the hash table of recs to grow to this size, at the maximum </td></tr>
    <tr><td class="paramname">store_to_hash</td><td>in: TRUE if the records should be stored to the hash table; this is set to FALSE if just debug checking is needed </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer containing a log segment or garbage </td></tr>
    <tr><td class="paramname">len</td><td>in: buffer length </td></tr>
    <tr><td class="paramname">start_lsn</td><td>in: buffer start lsn </td></tr>
    <tr><td class="paramname">contiguous_lsn</td><td>in/out: it is known that all log groups contain contiguous log data up to this lsn </td></tr>
    <tr><td class="paramname">group_scanned_lsn</td><td>out: scanning succeeded up to this lsn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65b14557f39abeba9b80bd66fbc96aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b14557f39abeba9b80bd66fbc96aeb">&#9670;&nbsp;</a></span>recv_sys_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release recovery system mutexes. </p>

</div>
</div>
<a id="aaa6a2e802976bbca76d67d8788c711d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6a2e802976bbca76d67d8788c711d8">&#9670;&nbsp;</a></span>recv_sys_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the recovery system. </p>

</div>
</div>
<a id="af78f6b379d555b6609120b94a88e48c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78f6b379d555b6609120b94a88e48c8">&#9670;&nbsp;</a></span>recv_sys_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>available_memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inits the recovery system for a recovery operation. in: available memory in bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">available_memory</td><td>in: available memory in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41975a23eb880acab4a47274910cd338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41975a23eb880acab4a47274910cd338">&#9670;&nbsp;</a></span>recv_sys_mem_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_mem_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the recovery system memory. </p>

</div>
</div>
<a id="aa292eaf15cfd7536fefda28f01a19a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa292eaf15cfd7536fefda28f01a19a7e">&#9670;&nbsp;</a></span>recv_sys_var_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void recv_sys_var_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the state of the recovery system variables. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab61ce1f3b2b1e21c3117030573852920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61ce1f3b2b1e21c3117030573852920">&#9670;&nbsp;</a></span>recv_lsn_checks_on</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool recv_lsn_checks_on</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if <a class="el" href="buf0buf_8cc.html#a97d1cedcc7115ef5e7518d26cc24ccbc">buf_page_is_corrupted()</a> should check if the log sequence number (FIL_PAGE_LSN) is in the future. Initially FALSE, and set by <a class="el" href="log0recv_8h.html#ad58d651ba2056c889b8296ad43d5d9c3">recv_recovery_from_checkpoint_start_func()</a>. </p>

</div>
</div>
<a id="aa0307a102944157c341e394aee959769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0307a102944157c341e394aee959769">&#9670;&nbsp;</a></span>recv_max_parsed_page_no</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint recv_max_parsed_page_no</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum page number encountered in the redo log </p>

</div>
</div>
<a id="ab67bbbbc46b800ca54edf37d35f2cc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67bbbbc46b800ca54edf37d35f2cc60">&#9670;&nbsp;</a></span>recv_n_pool_free_frames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint recv_n_pool_free_frames</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This many frames must be left free in the buffer pool when we scan the log and store the scanned log records in the buffer pool: we will use these free frames to read in pages when we start applying the log records to the database.</p>
<p>This many frames must be left free in the buffer pool when we scan the log and store the scanned log records in the buffer pool: we will use these free frames to read in pages when we start applying the log records to the database. This is the default value. If the actual size of the buffer pool is larger than 10 MB we'll set this value to 512. </p>

</div>
</div>
<a id="a28c4025a44b76e120aab4653eaead111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c4025a44b76e120aab4653eaead111">&#9670;&nbsp;</a></span>recv_needed_recovery</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool recv_needed_recovery</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE when <a class="el" href="log0recv_8cc.html#ae28110ea7dec38ca47b81da1b6947687">recv_init_crash_recovery()</a> has been called. </p>

</div>
</div>
<a id="ab33c348e52c3b6bec2a8ec3795516d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33c348e52c3b6bec2a8ec3795516d32">&#9670;&nbsp;</a></span>recv_no_ibuf_operations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool recv_no_ibuf_operations</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the following is TRUE, the buffer pool file pages must be invalidated after recovery and no ibuf operations are allowed; this becomes TRUE if the log record hash table becomes too full, and log records must be merged to file pages already before the recovery is finished: in this case no ibuf operations are allowed, as they could modify the pages read in the buffer pool before the pages have been recovered to the up-to-date state.</p>
<p>TRUE means that recovery is running and no operations on the log files are allowed yet: the variable name is misleading. </p>

</div>
</div>
<a id="aec84e1e44861d8fb34d235980f109689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec84e1e44861d8fb34d235980f109689">&#9670;&nbsp;</a></span>recv_recovery_on</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool recv_recovery_on</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE when applying redo log records during crash recovery; FALSE otherwise. Note that this is FALSE while a background thread is rolling back incomplete transactions. </p>

</div>
</div>
<a id="a933290104831a9ad6f97c2952b420963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933290104831a9ad6f97c2952b420963">&#9670;&nbsp;</a></span>recv_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrecv__sys__t.html">recv_sys_t</a>* recv_sys</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The recovery system </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

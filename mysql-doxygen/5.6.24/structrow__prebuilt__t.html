<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: row_prebuilt_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structrow__prebuilt__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">row_prebuilt_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad936db2921893119b95f7e33727f2d2a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad936db2921893119b95f7e33727f2d2a">magic_n</a></td></tr>
<tr class="separator:ad936db2921893119b95f7e33727f2d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c2a8205446e84d2e64f80088a7846c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a19c2a8205446e84d2e64f80088a7846c">table</a></td></tr>
<tr class="separator:a19c2a8205446e84d2e64f80088a7846c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb88835f509e12ea05929f410f4df0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#afeb88835f509e12ea05929f410f4df0a">index</a></td></tr>
<tr class="separator:afeb88835f509e12ea05929f410f4df0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa177d7d5264d91df66db86414dfa7da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa177d7d5264d91df66db86414dfa7da8">trx</a></td></tr>
<tr class="separator:aa177d7d5264d91df66db86414dfa7da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1004d8c54485ba370f756c48f26d93a7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1004d8c54485ba370f756c48f26d93a7">sql_stat_start</a>:1</td></tr>
<tr class="separator:a1004d8c54485ba370f756c48f26d93a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abfde48ea9d8abc5c235403e2f3b022"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6abfde48ea9d8abc5c235403e2f3b022">mysql_has_locked</a>:1</td></tr>
<tr class="separator:a6abfde48ea9d8abc5c235403e2f3b022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd76361eda548fa2e2f8d80d66d08612"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#abd76361eda548fa2e2f8d80d66d08612">clust_index_was_generated</a>:1</td></tr>
<tr class="separator:abd76361eda548fa2e2f8d80d66d08612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59950f1aed60deccf5ba6a917afc357"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ac59950f1aed60deccf5ba6a917afc357">index_usable</a>:1</td></tr>
<tr class="separator:ac59950f1aed60deccf5ba6a917afc357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2406d22fe6361a563ec8b4e9b010287"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa2406d22fe6361a563ec8b4e9b010287">read_just_key</a>:1</td></tr>
<tr class="separator:aa2406d22fe6361a563ec8b4e9b010287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0568bf55e0cd59e39cbf5264e0107a04"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0568bf55e0cd59e39cbf5264e0107a04">used_in_HANDLER</a>:1</td></tr>
<tr class="separator:a0568bf55e0cd59e39cbf5264e0107a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6cf19178262078ea73dd92941a88ca"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#afa6cf19178262078ea73dd92941a88ca">template_type</a>:2</td></tr>
<tr class="separator:afa6cf19178262078ea73dd92941a88ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551a6896bb6da7d979e6fb20decf18ba"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a551a6896bb6da7d979e6fb20decf18ba">n_template</a>:10</td></tr>
<tr class="separator:a551a6896bb6da7d979e6fb20decf18ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4218e8b9331e26a43e2507663d59bdc1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4218e8b9331e26a43e2507663d59bdc1">null_bitmap_len</a>:10</td></tr>
<tr class="separator:a4218e8b9331e26a43e2507663d59bdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94506e9f10462650bfa377f9414cf7db"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a94506e9f10462650bfa377f9414cf7db">need_to_access_clustered</a>:1</td></tr>
<tr class="separator:a94506e9f10462650bfa377f9414cf7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666323e0b2127c47e743adf5ba2bef94"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a666323e0b2127c47e743adf5ba2bef94">templ_contains_blob</a>:1</td></tr>
<tr class="separator:a666323e0b2127c47e743adf5ba2bef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c5641e4244b609f7e89f11069239e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a25c5641e4244b609f7e89f11069239e5">mysql_template</a></td></tr>
<tr class="separator:a25c5641e4244b609f7e89f11069239e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1114f766781ead5174ff03d9bfcaac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#afa1114f766781ead5174ff03d9bfcaac">heap</a></td></tr>
<tr class="separator:afa1114f766781ead5174ff03d9bfcaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c9cc595e33ade9ceeb4a1f14a9d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4d7c9cc595e33ade9ceeb4a1f14a9d76">ins_node</a></td></tr>
<tr class="separator:a4d7c9cc595e33ade9ceeb4a1f14a9d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1085ad273bb47a95631ac73a16a9a22"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa1085ad273bb47a95631ac73a16a9a22">ins_upd_rec_buff</a></td></tr>
<tr class="separator:aa1085ad273bb47a95631ac73a16a9a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b397e188f2d0d2ebc9af03578617d35"><td class="memItemLeft" align="right" valign="top">const byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1b397e188f2d0d2ebc9af03578617d35">default_rec</a></td></tr>
<tr class="separator:a1b397e188f2d0d2ebc9af03578617d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23328500b0f9834d0baddce5d3bbbc48"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a23328500b0f9834d0baddce5d3bbbc48">hint_need_to_fetch_extra_cols</a></td></tr>
<tr class="separator:a23328500b0f9834d0baddce5d3bbbc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f54b68eb4f1a5349eef999f88a9967f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0f54b68eb4f1a5349eef999f88a9967f">upd_node</a></td></tr>
<tr class="separator:a0f54b68eb4f1a5349eef999f88a9967f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0079ca440c8a887b00c656ca73c767c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0079ca440c8a887b00c656ca73c767c6">trx_id</a></td></tr>
<tr class="separator:a0079ca440c8a887b00c656ca73c767c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46537393407eb4071c703343586d22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ae46537393407eb4071c703343586d22a">ins_graph</a></td></tr>
<tr class="separator:ae46537393407eb4071c703343586d22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3aca3ac08088406e83cd47adb824a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9a3aca3ac08088406e83cd47adb824a4">upd_graph</a></td></tr>
<tr class="separator:a9a3aca3ac08088406e83cd47adb824a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999d8694c7f57409124f50c937caedf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a999d8694c7f57409124f50c937caedf9">pcur</a></td></tr>
<tr class="separator:a999d8694c7f57409124f50c937caedf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3738d2771017637a67cbdbdee9871be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a3738d2771017637a67cbdbdee9871be7">clust_pcur</a></td></tr>
<tr class="separator:a3738d2771017637a67cbdbdee9871be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3504add5a29b9352f5f7a70da89e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#affb3504add5a29b9352f5f7a70da89e9">sel_graph</a></td></tr>
<tr class="separator:affb3504add5a29b9352f5f7a70da89e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2110e245f510fe5703437190bdf7c9e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a2110e245f510fe5703437190bdf7c9e1">search_tuple</a></td></tr>
<tr class="separator:a2110e245f510fe5703437190bdf7c9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac44d559d12885d25cceeebba46c7e6c"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aac44d559d12885d25cceeebba46c7e6c">row_id</a> [DATA_ROW_ID_LEN]</td></tr>
<tr class="separator:aac44d559d12885d25cceeebba46c7e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1fb978fc37f85f0f278ec6c09180d"><td class="memItemLeft" align="right" valign="top"><a id="a2ab1fb978fc37f85f0f278ec6c09180d"></a>
<a class="el" href="fts0fts_8h.html#a380910af8d69503a3e3dcbf6d809a3b6">doc_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fts_doc_id</b></td></tr>
<tr class="separator:a2ab1fb978fc37f85f0f278ec6c09180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad849b52ec988d5c989838523993998aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad849b52ec988d5c989838523993998aa">clust_ref</a></td></tr>
<tr class="separator:ad849b52ec988d5c989838523993998aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ba7f40688b0b0acd0e46ce459eb134"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a33ba7f40688b0b0acd0e46ce459eb134">select_lock_type</a></td></tr>
<tr class="separator:a33ba7f40688b0b0acd0e46ce459eb134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8d86728884036618a531bc50546deb"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1a8d86728884036618a531bc50546deb">stored_select_lock_type</a></td></tr>
<tr class="separator:a1a8d86728884036618a531bc50546deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b853f8cb36486a637e6f58ad95b458c"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6b853f8cb36486a637e6f58ad95b458c">row_read_type</a></td></tr>
<tr class="separator:a6b853f8cb36486a637e6f58ad95b458c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a9ba86fe41e70b9a84837054fc0088"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ac3a9ba86fe41e70b9a84837054fc0088">new_rec_locks</a></td></tr>
<tr class="separator:ac3a9ba86fe41e70b9a84837054fc0088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2656fbd8b2cf6d356622f37bace7444a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a2656fbd8b2cf6d356622f37bace7444a">mysql_prefix_len</a></td></tr>
<tr class="separator:a2656fbd8b2cf6d356622f37bace7444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930a910f8de38274b71e4dcc79888496"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a930a910f8de38274b71e4dcc79888496">mysql_row_len</a></td></tr>
<tr class="separator:a930a910f8de38274b71e4dcc79888496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9219653973849987e00efd71c57cd9b5"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9219653973849987e00efd71c57cd9b5">n_rows_fetched</a></td></tr>
<tr class="separator:a9219653973849987e00efd71c57cd9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8befaa7c077a4d5a0c3e673b09c4c361"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a8befaa7c077a4d5a0c3e673b09c4c361">fetch_direction</a></td></tr>
<tr class="separator:a8befaa7c077a4d5a0c3e673b09c4c361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1ab35f63cdb3d2b64bb81a0a12cf84"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9f1ab35f63cdb3d2b64bb81a0a12cf84">fetch_cache</a> [MYSQL_FETCH_CACHE_SIZE]</td></tr>
<tr class="separator:a9f1ab35f63cdb3d2b64bb81a0a12cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b52068ec945cf852151523434a786a"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ab6b52068ec945cf852151523434a786a">keep_other_fields_on_keyread</a></td></tr>
<tr class="separator:ab6b52068ec945cf852151523434a786a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a497bcd529e69f9b9ca11de686cc72"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad1a497bcd529e69f9b9ca11de686cc72">fetch_cache_first</a></td></tr>
<tr class="separator:ad1a497bcd529e69f9b9ca11de686cc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633f4db03c18e781fe73864afb32fd4a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a633f4db03c18e781fe73864afb32fd4a">n_fetch_cached</a></td></tr>
<tr class="separator:a633f4db03c18e781fe73864afb32fd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2bf20a06ef44d9114b5a7667f028c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4b2bf20a06ef44d9114b5a7667f028c2">blob_heap</a></td></tr>
<tr class="separator:a4b2bf20a06ef44d9114b5a7667f028c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f020430b4ec6fdd33b90bc1a811f6f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a7f020430b4ec6fdd33b90bc1a811f6f3">old_vers_heap</a></td></tr>
<tr class="separator:a7f020430b4ec6fdd33b90bc1a811f6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0dfee13cc2dd7f8603d873d0155d41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a7d0dfee13cc2dd7f8603d873d0155d41">in_fts_query</a></td></tr>
<tr class="separator:a7d0dfee13cc2dd7f8603d873d0155d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec305f742e5262b09eeaad0e64066d0c"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aec305f742e5262b09eeaad0e64066d0c">autoinc_last_value</a></td></tr>
<tr class="separator:aec305f742e5262b09eeaad0e64066d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6646ec8dded9b73f2ed89f14177fbbcd"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6646ec8dded9b73f2ed89f14177fbbcd">autoinc_increment</a></td></tr>
<tr class="separator:a6646ec8dded9b73f2ed89f14177fbbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c818b53352ba1e88d517b9e2d74c44"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a38c818b53352ba1e88d517b9e2d74c44">autoinc_offset</a></td></tr>
<tr class="separator:a38c818b53352ba1e88d517b9e2d74c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9ef76992b0b772c92df797bb0b1f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9f9ef76992b0b772c92df797bb0b1f01">autoinc_error</a></td></tr>
<tr class="separator:a9f9ef76992b0b772c92df797bb0b1f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cde88cb2f601a3e3c5a04697b3e7fe"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a54cde88cb2f601a3e3c5a04697b3e7fe">idx_cond</a></td></tr>
<tr class="separator:a54cde88cb2f601a3e3c5a04697b3e7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a85744d402aac8d6bd38de0d637ef4d"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6a85744d402aac8d6bd38de0d637ef4d">idx_cond_n_cols</a></td></tr>
<tr class="separator:a6a85744d402aac8d6bd38de0d637ef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc0a986a1cfa9c1af8d0c881d326f4b"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#affc0a986a1cfa9c1af8d0c881d326f4b">magic_n2</a></td></tr>
<tr class="separator:affc0a986a1cfa9c1af8d0c881d326f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb2c828efad5ccf81c3165c79269f80"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a3cb2c828efad5ccf81c3165c79269f80">innodb_api</a>:1</td></tr>
<tr class="separator:a3cb2c828efad5ccf81c3165c79269f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace90681d96b49e946dcade7a36f935a"><td class="memItemLeft" align="right" valign="top">const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aace90681d96b49e946dcade7a36f935a">innodb_api_rec</a></td></tr>
<tr class="separator:aace90681d96b49e946dcade7a36f935a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93437253882fa8d53a3b576a4633fc94"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a93437253882fa8d53a3b576a4633fc94">srch_key_val1</a></td></tr>
<tr class="separator:a93437253882fa8d53a3b576a4633fc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fe59b7101e2d8df0b534618b591511"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a05fe59b7101e2d8df0b534618b591511">srch_key_val2</a></td></tr>
<tr class="separator:a05fe59b7101e2d8df0b534618b591511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd747a430fb3aa32a2db04cebf345b6"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aefd747a430fb3aa32a2db04cebf345b6">srch_key_val_len</a></td></tr>
<tr class="separator:aefd747a430fb3aa32a2db04cebf345b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A struct for (sometimes lazily) prebuilt structures in an Innobase table handle used within MySQL; these are used to save CPU time. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a9f9ef76992b0b772c92df797bb0b1f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9ef76992b0b772c92df797bb0b1f01">&#9670;&nbsp;</a></span>autoinc_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_prebuilt_t::autoinc_error</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The actual error code encountered while trying to init or read the autoinc value from the table. We store it here so that we can return it to MySQL </p>

</div>
</div>
<a id="a6646ec8dded9b73f2ed89f14177fbbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6646ec8dded9b73f2ed89f14177fbbcd">&#9670;&nbsp;</a></span>autoinc_increment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong row_prebuilt_t::autoinc_increment</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The increment step of the auto increment column. Value must be greater than or equal to 1. Required to calculate the next value </p>

</div>
</div>
<a id="aec305f742e5262b09eeaad0e64066d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec305f742e5262b09eeaad0e64066d0c">&#9670;&nbsp;</a></span>autoinc_last_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong row_prebuilt_t::autoinc_last_value</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>last value of AUTO-INC interval </p>

</div>
</div>
<a id="a38c818b53352ba1e88d517b9e2d74c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c818b53352ba1e88d517b9e2d74c44">&#9670;&nbsp;</a></span>autoinc_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong row_prebuilt_t::autoinc_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The offset passed to get_auto_increment() by MySQL. Required to calculate the next value </p>

</div>
</div>
<a id="a4b2bf20a06ef44d9114b5a7667f028c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2bf20a06ef44d9114b5a7667f028c2">&#9670;&nbsp;</a></span>blob_heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* row_prebuilt_t::blob_heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in SELECTS BLOB fields are copied to this heap </p>

</div>
</div>
<a id="abd76361eda548fa2e2f8d80d66d08612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd76361eda548fa2e2f8d80d66d08612">&#9670;&nbsp;</a></span>clust_index_was_generated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::clust_index_was_generated</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if the user did not define a primary key in MySQL, then Innobase automatically generated a clustered index where the ordering column is the row id: in this case this flag is set to TRUE </p>

</div>
</div>
<a id="a3738d2771017637a67cbdbdee9871be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3738d2771017637a67cbdbdee9871be7">&#9670;&nbsp;</a></span>clust_pcur</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> row_prebuilt_t::clust_pcur</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>persistent cursor used in some selects and updates </p>

</div>
</div>
<a id="ad849b52ec988d5c989838523993998aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad849b52ec988d5c989838523993998aa">&#9670;&nbsp;</a></span>clust_ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a>* row_prebuilt_t::clust_ref</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prebuilt dtuple used in sel/upd/del </p>

</div>
</div>
<a id="a1b397e188f2d0d2ebc9af03578617d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b397e188f2d0d2ebc9af03578617d35">&#9670;&nbsp;</a></span>default_rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const byte* row_prebuilt_t::default_rec</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the default values of all columns (a "default row") in MySQL format </p>

</div>
</div>
<a id="a9f1ab35f63cdb3d2b64bb81a0a12cf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1ab35f63cdb3d2b64bb81a0a12cf84">&#9670;&nbsp;</a></span>fetch_cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* row_prebuilt_t::fetch_cache[MYSQL_FETCH_CACHE_SIZE]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>a cache for fetched rows if we fetch many rows from the same cursor: it saves CPU time to fetch them in a batch; we reserve mysql_row_len bytes for each such row; these pointers point 4 bytes past the allocated mem buf start, because there is a 4 byte magic number at the start and at the end </p>

</div>
</div>
<a id="ad1a497bcd529e69f9b9ca11de686cc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a497bcd529e69f9b9ca11de686cc72">&#9670;&nbsp;</a></span>fetch_cache_first</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::fetch_cache_first</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>position of the first not yet fetched row in fetch_cache </p>

</div>
</div>
<a id="a8befaa7c077a4d5a0c3e673b09c4c361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8befaa7c077a4d5a0c3e673b09c4c361">&#9670;&nbsp;</a></span>fetch_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::fetch_direction</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ROW_SEL_NEXT or ROW_SEL_PREV </p>

</div>
</div>
<a id="afa1114f766781ead5174ff03d9bfcaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1114f766781ead5174ff03d9bfcaac">&#9670;&nbsp;</a></span>heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* row_prebuilt_t::heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>memory heap from which these auxiliary structures are allocated when needed </p>

</div>
</div>
<a id="a23328500b0f9834d0baddce5d3bbbc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23328500b0f9834d0baddce5d3bbbc48">&#9670;&nbsp;</a></span>hint_need_to_fetch_extra_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::hint_need_to_fetch_extra_cols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>normally this is set to 0; if this is set to ROW_RETRIEVE_PRIMARY_KEY, then we should at least retrieve all columns in the primary key; if this is set to ROW_RETRIEVE_ALL_COLS, then we must retrieve all columns in the key (if read_just_key == 1), or all columns in the table </p>

</div>
</div>
<a id="a54cde88cb2f601a3e3c5a04697b3e7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cde88cb2f601a3e3c5a04697b3e7fe">&#9670;&nbsp;</a></span>idx_cond</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* row_prebuilt_t::idx_cond</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In ICP, pointer to a <a class="el" href="classha__innobase.html">ha_innobase</a>, passed to <a class="el" href="ha__innodb_8cc.html#a2c638f4977f830887a45c161f2597b84">innobase_index_cond()</a>. NULL if index condition pushdown is not used. </p>

</div>
</div>
<a id="a6a85744d402aac8d6bd38de0d637ef4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a85744d402aac8d6bd38de0d637ef4d">&#9670;&nbsp;</a></span>idx_cond_n_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::idx_cond_n_cols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of fields in idx_cond_cols. 0 if and only if idx_cond == NULL. </p>

</div>
</div>
<a id="a7d0dfee13cc2dd7f8603d873d0155d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0dfee13cc2dd7f8603d873d0155d41">&#9670;&nbsp;</a></span>in_fts_query</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool row_prebuilt_t::in_fts_query</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether we are in a FTS query </p>

</div>
</div>
<a id="afeb88835f509e12ea05929f410f4df0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb88835f509e12ea05929f410f4df0a">&#9670;&nbsp;</a></span>index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* row_prebuilt_t::index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>current index for a search, if any </p>

</div>
</div>
<a id="ac59950f1aed60deccf5ba6a917afc357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59950f1aed60deccf5ba6a917afc357">&#9670;&nbsp;</a></span>index_usable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::index_usable</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>caches the value of row_merge_is_index_usable(trx,index) </p>

</div>
</div>
<a id="a3cb2c828efad5ccf81c3165c79269f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb2c828efad5ccf81c3165c79269f80">&#9670;&nbsp;</a></span>innodb_api</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::innodb_api</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>whether this is a InnoDB API query </p>

</div>
</div>
<a id="aace90681d96b49e946dcade7a36f935a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace90681d96b49e946dcade7a36f935a">&#9670;&nbsp;</a></span>innodb_api_rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t* row_prebuilt_t::innodb_api_rec</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>InnoDB API search result </p>

</div>
</div>
<a id="ae46537393407eb4071c703343586d22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46537393407eb4071c703343586d22a">&#9670;&nbsp;</a></span>ins_graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__fork__t.html">que_fork_t</a>* row_prebuilt_t::ins_graph</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase SQL query graph used in inserts. Will be rebuilt on trx_id or n_indexes mismatch. </p>

</div>
</div>
<a id="a4d7c9cc595e33ade9ceeb4a1f14a9d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7c9cc595e33ade9ceeb4a1f14a9d76">&#9670;&nbsp;</a></span>ins_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structins__node__t.html">ins_node_t</a>* row_prebuilt_t::ins_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase SQL insert node used to perform inserts to the table </p>

</div>
</div>
<a id="aa1085ad273bb47a95631ac73a16a9a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1085ad273bb47a95631ac73a16a9a22">&#9670;&nbsp;</a></span>ins_upd_rec_buff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* row_prebuilt_t::ins_upd_rec_buff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>buffer for storing data converted to the Innobase format from the MySQL format </p>

</div>
</div>
<a id="ab6b52068ec945cf852151523434a786a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b52068ec945cf852151523434a786a">&#9670;&nbsp;</a></span>keep_other_fields_on_keyread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool row_prebuilt_t::keep_other_fields_on_keyread</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when using fetch cache with HA_EXTRA_KEYREAD, don't overwrite other fields in mysql row row buffer. </p>

</div>
</div>
<a id="ad936db2921893119b95f7e33727f2d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad936db2921893119b95f7e33727f2d2a">&#9670;&nbsp;</a></span>magic_n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::magic_n</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this magic number is set to ROW_PREBUILT_ALLOCATED when created, or ROW_PREBUILT_FREED when the struct has been freed </p>

</div>
</div>
<a id="affc0a986a1cfa9c1af8d0c881d326f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc0a986a1cfa9c1af8d0c881d326f4b">&#9670;&nbsp;</a></span>magic_n2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::magic_n2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this should be the same as magic_n </p>

</div>
</div>
<a id="a6abfde48ea9d8abc5c235403e2f3b022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abfde48ea9d8abc5c235403e2f3b022">&#9670;&nbsp;</a></span>mysql_has_locked</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::mysql_has_locked</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this is set TRUE when MySQL calls external_lock on this handle with a lock flag, and set FALSE when with the F_UNLOCK flag </p>

</div>
</div>
<a id="a2656fbd8b2cf6d356622f37bace7444a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2656fbd8b2cf6d356622f37bace7444a">&#9670;&nbsp;</a></span>mysql_prefix_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::mysql_prefix_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>byte offset of the end of the last requested column </p>

</div>
</div>
<a id="a930a910f8de38274b71e4dcc79888496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930a910f8de38274b71e4dcc79888496">&#9670;&nbsp;</a></span>mysql_row_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::mysql_row_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>length in bytes of a row in the MySQL format </p>

</div>
</div>
<a id="a25c5641e4244b609f7e89f11069239e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c5641e4244b609f7e89f11069239e5">&#9670;&nbsp;</a></span>mysql_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a>* row_prebuilt_t::mysql_template</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>template used to transform rows fast between MySQL and Innobase formats; memory for this template is not allocated from 'heap' </p>

</div>
</div>
<a id="a633f4db03c18e781fe73864afb32fd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633f4db03c18e781fe73864afb32fd4a">&#9670;&nbsp;</a></span>n_fetch_cached</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::n_fetch_cached</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of not yet fetched rows in fetch_cache </p>

</div>
</div>
<a id="a9219653973849987e00efd71c57cd9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9219653973849987e00efd71c57cd9b5">&#9670;&nbsp;</a></span>n_rows_fetched</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::n_rows_fetched</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of rows fetched after positioning the current cursor </p>

</div>
</div>
<a id="a551a6896bb6da7d979e6fb20decf18ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551a6896bb6da7d979e6fb20decf18ba">&#9670;&nbsp;</a></span>n_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::n_template</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of elements in the template </p>

</div>
</div>
<a id="a94506e9f10462650bfa377f9414cf7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94506e9f10462650bfa377f9414cf7db">&#9670;&nbsp;</a></span>need_to_access_clustered</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::need_to_access_clustered</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if we are fetching columns through a secondary index and at least one column is not in the secondary index, then this is set to TRUE </p>

</div>
</div>
<a id="ac3a9ba86fe41e70b9a84837054fc0088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a9ba86fe41e70b9a84837054fc0088">&#9670;&nbsp;</a></span>new_rec_locks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::new_rec_locks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>normally 0; if srv_locks_unsafe_for_binlog is TRUE or session is using READ COMMITTED or READ UNCOMMITTED isolation level, set in <a class="el" href="row0sel_8h.html#aeba7e459b3bf39375f826472c316259a">row_search_for_mysql()</a> if we set a new record lock on the secondary or clustered index; this is used in <a class="el" href="row0mysql_8h.html#acb760c818831cd0ca90522711533b4c7">row_unlock_for_mysql()</a> when releasing the lock under the cursor if we determine after retrieving the row that it does not need to be locked ('mini-rollback') </p>

</div>
</div>
<a id="a4218e8b9331e26a43e2507663d59bdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4218e8b9331e26a43e2507663d59bdc1">&#9670;&nbsp;</a></span>null_bitmap_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::null_bitmap_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of bytes in the SQL NULL bitmap at the start of a row in the MySQL format </p>

</div>
</div>
<a id="a7f020430b4ec6fdd33b90bc1a811f6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f020430b4ec6fdd33b90bc1a811f6f3">&#9670;&nbsp;</a></span>old_vers_heap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* row_prebuilt_t::old_vers_heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>memory heap where a previous version is built in consistent read </p>

</div>
</div>
<a id="a999d8694c7f57409124f50c937caedf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999d8694c7f57409124f50c937caedf9">&#9670;&nbsp;</a></span>pcur</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> row_prebuilt_t::pcur</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>persistent cursor used in selects and updates </p>

</div>
</div>
<a id="aa2406d22fe6361a563ec8b4e9b010287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2406d22fe6361a563ec8b4e9b010287">&#9670;&nbsp;</a></span>read_just_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::read_just_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set to 1 when MySQL calls <a class="el" href="classha__innobase.html#a48a8e8c82b63bb51e96caac9e65e7ba3">ha_innobase::extra</a> with the argument HA_EXTRA_KEYREAD; it is enough to read just columns defined in the index (i.e., no read of the clustered index record necessary) </p>

</div>
</div>
<a id="aac44d559d12885d25cceeebba46c7e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac44d559d12885d25cceeebba46c7e6c">&#9670;&nbsp;</a></span>row_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte row_prebuilt_t::row_id[DATA_ROW_ID_LEN]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if the clustered index was generated, the row id of the last row fetched is stored here </p>

</div>
</div>
<a id="a6b853f8cb36486a637e6f58ad95b458c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b853f8cb36486a637e6f58ad95b458c">&#9670;&nbsp;</a></span>row_read_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::row_read_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ROW_READ_WITH_LOCKS if row locks should be the obtained for records under an UPDATE or DELETE cursor. If innodb_locks_unsafe_for_binlog is TRUE, this can be set to ROW_READ_TRY_SEMI_CONSISTENT, so that if the row under an UPDATE or DELETE cursor was locked by another transaction, InnoDB will resort to reading the last committed value ('semi-consistent read'). Then, this field will be set to ROW_READ_DID_SEMI_CONSISTENT to indicate that. If the row does not match the WHERE condition, MySQL will invoke handler::unlock_row() to clear the flag back to ROW_READ_TRY_SEMI_CONSISTENT and to simply skip the row. If the row matches, the next call to <a class="el" href="row0sel_8h.html#aeba7e459b3bf39375f826472c316259a">row_search_for_mysql()</a> will lock the row. This eliminates lock waits in some cases; note that this breaks serializability. </p>

</div>
</div>
<a id="a2110e245f510fe5703437190bdf7c9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2110e245f510fe5703437190bdf7c9e1">&#9670;&nbsp;</a></span>search_tuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a>* row_prebuilt_t::search_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prebuilt dtuple used in selects </p>

</div>
</div>
<a id="affb3504add5a29b9352f5f7a70da89e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb3504add5a29b9352f5f7a70da89e9">&#9670;&nbsp;</a></span>sel_graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__fork__t.html">que_fork_t</a>* row_prebuilt_t::sel_graph</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dummy query graph used in selects </p>

</div>
</div>
<a id="a33ba7f40688b0b0acd0e46ce459eb134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ba7f40688b0b0acd0e46ce459eb134">&#9670;&nbsp;</a></span>select_lock_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::select_lock_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LOCK_NONE, LOCK_S, or LOCK_X </p>

</div>
</div>
<a id="a1004d8c54485ba370f756c48f26d93a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1004d8c54485ba370f756c48f26d93a7">&#9670;&nbsp;</a></span>sql_stat_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::sql_stat_start</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE when we start processing of an SQL statement: we may have to set an intention lock on the table, create a consistent read view etc. </p>

</div>
</div>
<a id="a93437253882fa8d53a3b576a4633fc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93437253882fa8d53a3b576a4633fc94">&#9670;&nbsp;</a></span>srch_key_val1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* row_prebuilt_t::srch_key_val1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>buffer used in converting search key values from MySQL format to InnoDB format. </p>

</div>
</div>
<a id="a05fe59b7101e2d8df0b534618b591511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fe59b7101e2d8df0b534618b591511">&#9670;&nbsp;</a></span>srch_key_val2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* row_prebuilt_t::srch_key_val2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>buffer used in converting search key values from MySQL format to InnoDB format. </p>

</div>
</div>
<a id="aefd747a430fb3aa32a2db04cebf345b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd747a430fb3aa32a2db04cebf345b6">&#9670;&nbsp;</a></span>srch_key_val_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint row_prebuilt_t::srch_key_val_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of search key </p>

</div>
</div>
<a id="a1a8d86728884036618a531bc50546deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8d86728884036618a531bc50546deb">&#9670;&nbsp;</a></span>stored_select_lock_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::stored_select_lock_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this field is used to remember the original select_lock_type that was decided in <a class="el" href="ha__innodb_8cc.html">ha_innodb.cc</a>, ::store_lock(), ::external_lock(), etc. </p>

</div>
</div>
<a id="a19c2a8205446e84d2e64f80088a7846c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c2a8205446e84d2e64f80088a7846c">&#9670;&nbsp;</a></span>table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__table__t.html">dict_table_t</a>* row_prebuilt_t::table</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase table handle </p>

</div>
</div>
<a id="a666323e0b2127c47e743adf5ba2bef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666323e0b2127c47e743adf5ba2bef94">&#9670;&nbsp;</a></span>templ_contains_blob</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::templ_contains_blob</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if the template contains a column with DATA_BLOB == <a class="el" href="ha__innodb_8cc.html#a48f54f30467fa2c61c12a388e7654012">get_innobase_type_from_mysql_type()</a>; not to be confused with InnoDB externally stored columns (VARCHAR can be off-page too) </p>

</div>
</div>
<a id="afa6cf19178262078ea73dd92941a88ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6cf19178262078ea73dd92941a88ca">&#9670;&nbsp;</a></span>template_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::template_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ROW_MYSQL_WHOLE_ROW, ROW_MYSQL_REC_FIELDS, ROW_MYSQL_DUMMY_TEMPLATE, or ROW_MYSQL_NO_TEMPLATE </p>

</div>
</div>
<a id="aa177d7d5264d91df66db86414dfa7da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa177d7d5264d91df66db86414dfa7da8">&#9670;&nbsp;</a></span>trx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtrx__t.html">trx_t</a>* row_prebuilt_t::trx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>current transaction handle </p>

</div>
</div>
<a id="a0079ca440c8a887b00c656ca73c767c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0079ca440c8a887b00c656ca73c767c6">&#9670;&nbsp;</a></span>trx_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> row_prebuilt_t::trx_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The table-&gt;def_trx_id when ins_graph was built </p>

</div>
</div>
<a id="a9a3aca3ac08088406e83cd47adb824a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3aca3ac08088406e83cd47adb824a4">&#9670;&nbsp;</a></span>upd_graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__fork__t.html">que_fork_t</a>* row_prebuilt_t::upd_graph</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase SQL query graph used in updates or deletes </p>

</div>
</div>
<a id="a0f54b68eb4f1a5349eef999f88a9967f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f54b68eb4f1a5349eef999f88a9967f">&#9670;&nbsp;</a></span>upd_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__node__t.html">upd_node_t</a>* row_prebuilt_t::upd_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase SQL update node used to perform updates and deletes </p>

</div>
</div>
<a id="a0568bf55e0cd59e39cbf5264e0107a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0568bf55e0cd59e39cbf5264e0107a04">&#9670;&nbsp;</a></span>used_in_HANDLER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::used_in_HANDLER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if we have been using this handle in a MySQL HANDLER low level index cursor command: then we must store the pcur position even in a unique search from a clustered index, because HANDLER allows NEXT and PREV in such a situation </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>storage/innobase/include/<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

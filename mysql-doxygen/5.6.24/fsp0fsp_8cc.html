<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PERFORMANCE SCHEMA: storage/innobase/fsp/fsp0fsp.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PERFORMANCE SCHEMA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_f72db50d7a2b1bec60c096157bfea18c.html">fsp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fsp0fsp.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="fsp0fsp_8h_source.html">fsp0fsp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mtr0log_8h_source.html">mtr0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0page_8h_source.html">page0page.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="page0zip_8h_source.html">page0zip.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fut0fut_8h_source.html">fut0fut.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2271298646733b7e7318938d9cc2d565"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a2271298646733b7e7318938d9cc2d565">fsp_free_extent</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a2271298646733b7e7318938d9cc2d565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8cdd94af3946bfc8743e809f96a31a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a7e8cdd94af3946bfc8743e809f96a31a">fseg_free_extent</a> (fseg_inode_t *seg_inode, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a7e8cdd94af3946bfc8743e809f96a31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098fbfcb36bdb7da8b642a2f4990c693"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a098fbfcb36bdb7da8b642a2f4990c693">fseg_n_reserved_pages_low</a> (fseg_inode_t *<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, ulint *used, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a098fbfcb36bdb7da8b642a2f4990c693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accee9488458f6ad9ba22500f7a1e44f2"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#accee9488458f6ad9ba22500f7a1e44f2">__attribute__</a> ((nonnull)) void fseg_mark_page_used(fseg_inode_t *seg_inode</td></tr>
<tr class="separator:accee9488458f6ad9ba22500f7a1e44f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd01778a92cfde041dbcec7a7b6c0ff"><td class="memItemLeft" align="right" valign="top">static xdes_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a3dd01778a92cfde041dbcec7a7b6c0ff">fseg_get_first_extent</a> (fseg_inode_t *inode, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a3dd01778a92cfde041dbcec7a7b6c0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494a503611daee8298c414bd5b4bff0e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a494a503611daee8298c414bd5b4bff0e">fsp_fill_free_list</a> (ibool init_space, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, fsp_header_t *<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>) UNIV_COLD <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((nonnull))</td></tr>
<tr class="separator:a494a503611daee8298c414bd5b4bff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae472093c5c51efa0a1f030362ada18be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ae472093c5c51efa0a1f030362ada18be">fseg_alloc_free_page_low</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, fseg_inode_t *seg_inode, ulint <a class="el" href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a>, byte <a class="el" href="btr0btr_8cc.html#a942da44c6711d230377078633665e89b">direction</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="fsp0fsp_8cc.html#affc0fcb1d10ea38c48239ca6a9772e0b">init_mtr</a>) <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((warn_unused_result</td></tr>
<tr class="separator:ae472093c5c51efa0a1f030362ada18be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f27ecde86147c06fbf9c07cd3a5d29e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a2f27ecde86147c06fbf9c07cd3a5d29e">fsp_get_size_low</a> (<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:a2f27ecde86147c06fbf9c07cd3a5d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1fc77af0aeddec49525e752079f8a0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE fsp_header_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#acd1fc77af0aeddec49525e752079f8a0">fsp_get_space_header</a> (ulint <a class="el" href="trx0undo_8cc.html#a42c94db63b554b8c7fa2a814f1f3dc8f">id</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:acd1fc77af0aeddec49525e752079f8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74ac9cf95883ec1d5d06d2841c312e7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ac74ac9cf95883ec1d5d06d2841c312e7">xdes_mtr_get_bit</a> (const xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a60c1506135317302131bd515c87116bf">bit</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac74ac9cf95883ec1d5d06d2841c312e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ad7c8974c00d5f7e30842a82dd7039"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ae9ad7c8974c00d5f7e30842a82dd7039">xdes_set_bit</a> (xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a60c1506135317302131bd515c87116bf">bit</a>, ulint <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, ibool val, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ae9ad7c8974c00d5f7e30842a82dd7039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b7f2822e3e23466374ae486ad6dedd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a16b7f2822e3e23466374ae486ad6dedd">xdes_find_bit</a> (xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a60c1506135317302131bd515c87116bf">bit</a>, ibool val, ulint <a class="el" href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a16b7f2822e3e23466374ae486ad6dedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f29d492039ab6bd9fa3408b9a20056"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a64f29d492039ab6bd9fa3408b9a20056">xdes_get_n_used</a> (const xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a64f29d492039ab6bd9fa3408b9a20056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a40c104599a3b433dacf02c8442a90"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a09a40c104599a3b433dacf02c8442a90">xdes_is_free</a> (const xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a09a40c104599a3b433dacf02c8442a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b1c61387c588e9feb7c812efb47a1c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a45b1c61387c588e9feb7c812efb47a1c">xdes_is_full</a> (const xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a45b1c61387c588e9feb7c812efb47a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af785ee4585efa65188a829af006ebade"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#af785ee4585efa65188a829af006ebade">xdes_set_state</a> (xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, ulint state, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:af785ee4585efa65188a829af006ebade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3112b68a6aecde76e8f42405152ee673"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a3112b68a6aecde76e8f42405152ee673">xdes_get_state</a> (const xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a3112b68a6aecde76e8f42405152ee673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a25848103da9d0354b7558bb48a6aa4"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a9a25848103da9d0354b7558bb48a6aa4">xdes_init</a> (xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a9a25848103da9d0354b7558bb48a6aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbef06646d57bf26765b0710c0b1302"><td class="memItemLeft" align="right" valign="top"><a id="a9dbef06646d57bf26765b0710c0b1302"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (mtr_memo_contains(<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="fil0fil_8h.html#a5a5f586c95f7cca4e59613bcdb09555c">fil_space_get_latch</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, NULL), MTR_MEMO_X_LOCK))</td></tr>
<tr class="separator:a9dbef06646d57bf26765b0710c0b1302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e84abcd81e66e703d35fe7dd4de592f"><td class="memItemLeft" align="right" valign="top"><a id="a9e84abcd81e66e703d35fe7dd4de592f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (mtr_memo_contains_page(<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, sp_header, MTR_MEMO_PAGE_X_FIX))</td></tr>
<tr class="separator:a9e84abcd81e66e703d35fe7dd4de592f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc840eb4666377c1c5649bee2819ff"><td class="memItemLeft" align="right" valign="top"><a id="a97fc840eb4666377c1c5649bee2819ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="page0page_8h.html#a6862a8e0be7713fc39e7ad656791bb4e">page_offset</a>(sp_header)==<a class="el" href="fsp0fsp_8h.html#ac07d76ccd967dec4a5ecb06f7fd865f8">FSP_HEADER_OFFSET</a>)</td></tr>
<tr class="separator:a97fc840eb4666377c1c5649bee2819ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5378b84992af3af1727a1c1913612bf0"><td class="memItemLeft" align="right" valign="top"><a id="a5378b84992af3af1727a1c1913612bf0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> ((<a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a> &gt;=<a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)||(<a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a> &gt;=<a class="el" href="ibuf0ibuf_8cc.html#a2dfd6b5310e6dd7028210bb6a8d13549">limit</a>))</td></tr>
<tr class="separator:a5378b84992af3af1727a1c1913612bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c682fba60d30ab10ade82ab6a0ad81"><td class="memItemLeft" align="right" valign="top"><a id="a39c682fba60d30ab10ade82ab6a0ad81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (descr_page_no==0)</td></tr>
<tr class="separator:a39c682fba60d30ab10ade82ab6a0ad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04efd5ef702cb99e0e01c8e3cfc2365b"><td class="memItemLeft" align="right" valign="top"><a id="a04efd5ef702cb99e0e01c8e3cfc2365b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_dbg_add_level</b> (<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, SYNC_FSP_PAGE)</td></tr>
<tr class="separator:a04efd5ef702cb99e0e01c8e3cfc2365b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa673421c2e1e704919e90e28b65a0e6a"><td class="memItemLeft" align="right" valign="top"><a id="aa673421c2e1e704919e90e28b65a0e6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (descr_page+<a class="el" href="fsp0fsp_8h.html#af3890d54c69f7ed67e31621280d0e0f9">XDES_ARR_OFFSET</a>+<a class="el" href="fsp0fsp_8h.html#a4990ee7a5bb67557472304b9acef6564">XDES_SIZE</a> *<a class="el" href="fsp0fsp_8h.html#a93b1d32d3a54b9468dd41327417250f5">xdes_calc_descriptor_index</a>(<a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>))</td></tr>
<tr class="separator:aa673421c2e1e704919e90e28b65a0e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3569ce42c739c8a07530bcb97a040fe1"><td class="memItemLeft" align="right" valign="top"><a id="a3569ce42c739c8a07530bcb97a040fe1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (xdes_get_descriptor_with_space_hdr(sp_header, <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>))</td></tr>
<tr class="separator:a3569ce42c739c8a07530bcb97a040fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2aa6c65a4cee4302c5c5dca0a8920a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE xdes_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a0a2aa6c65a4cee4302c5c5dca0a8920a">xdes_lst_get_descriptor</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structfil__addr__t.html">fil_addr_t</a> lst_node, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a0a2aa6c65a4cee4302c5c5dca0a8920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3c246e8f86d3d784f92538c711916c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#aab3c246e8f86d3d784f92538c711916c">xdes_get_offset</a> (const xdes_t *<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>)</td></tr>
<tr class="separator:aab3c246e8f86d3d784f92538c711916c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6657d8c4337720f91d520e64c5cbfc29"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a6657d8c4337720f91d520e64c5cbfc29">fsp_init_file_page_low</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a6657d8c4337720f91d520e64c5cbfc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9467d8d0b011da9c0a1076ea18affe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#aff9467d8d0b011da9c0a1076ea18affe">fsp_init_file_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:aff9467d8d0b011da9c0a1076ea18affe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635914f58fc8c6e25a5e2cf6fe1fe093"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a635914f58fc8c6e25a5e2cf6fe1fe093">fsp_parse_init_file_page</a> (byte *ptr, byte *end_ptr <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)), <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a635914f58fc8c6e25a5e2cf6fe1fe093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3b9629cf78fbf3686c68b4fe33442c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a2c3b9629cf78fbf3686c68b4fe33442c">fsp_init</a> (void)</td></tr>
<tr class="separator:a2c3b9629cf78fbf3686c68b4fe33442c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84329d0871d5a4955e04d1c5e89ab984"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a84329d0871d5a4955e04d1c5e89ab984">fsp_header_init_fields</a> (<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint space_id, ulint <a class="el" href="handler0alter_8cc.html#a4069e5feb5d17fbac4d832518d169cdd">flags</a>)</td></tr>
<tr class="separator:a84329d0871d5a4955e04d1c5e89ab984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186d7849e005217308d59eecfee9d525"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a186d7849e005217308d59eecfee9d525">fsp_header_init</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a186d7849e005217308d59eecfee9d525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508fbc25a0013563f5e9abdc3cbc70eb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a508fbc25a0013563f5e9abdc3cbc70eb">fsp_header_get_space_id</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:a508fbc25a0013563f5e9abdc3cbc70eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5d3bc7cb303541974af62f10aa55e4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a3c5d3bc7cb303541974af62f10aa55e4">fsp_header_get_flags</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:a3c5d3bc7cb303541974af62f10aa55e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac499b7f3fa89086f68b19f426c5d51"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a9ac499b7f3fa89086f68b19f426c5d51">fsp_header_get_zip_size</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:a9ac499b7f3fa89086f68b19f426c5d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b3c3e2d1cc874ae6ec5310cda752e4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ae7b3c3e2d1cc874ae6ec5310cda752e4">fsp_header_inc_size</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint size_inc, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ae7b3c3e2d1cc874ae6ec5310cda752e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9640882a719f0d8b1e4a0a49dec34f2c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a9640882a719f0d8b1e4a0a49dec34f2c">fsp_header_get_tablespace_size</a> (void)</td></tr>
<tr class="separator:a9640882a719f0d8b1e4a0a49dec34f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3020bc333ad84e30e8fe02149d4cee5e"><td class="memItemLeft" align="right" valign="top"><a id="a3020bc333ad84e30e8fe02149d4cee5e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_a</b> (<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a> !=0)</td></tr>
<tr class="separator:a3020bc333ad84e30e8fe02149d4cee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbc597f5bbda6fc654938dc4e5366a6"><td class="memItemLeft" align="right" valign="top"><a id="affbc597f5bbda6fc654938dc4e5366a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_a</b> (<a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a> &gt;=<a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>)</td></tr>
<tr class="separator:affbc597f5bbda6fc654938dc4e5366a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202cf4cda9880671c419a83e84347d1c"><td class="memItemLeft" align="right" valign="top"><a id="a202cf4cda9880671c419a83e84347d1c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mlog_write_ulint</b> (<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>+FSP_SIZE, actual_size, <a class="el" href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a202cf4cda9880671c419a83e84347d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54338e9dd1a82d56d88c40696031e6b"><td class="memItemLeft" align="right" valign="top"><a id="ad54338e9dd1a82d56d88c40696031e6b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (success)</td></tr>
<tr class="separator:ad54338e9dd1a82d56d88c40696031e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15251d3aec1f24f94ec7438d6aa126ef"><td class="memItemLeft" align="right" valign="top"><a id="a15251d3aec1f24f94ec7438d6aa126ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>==0 &amp;&amp;!srv_auto_extend_last_data_file)</td></tr>
<tr class="separator:a15251d3aec1f24f94ec7438d6aa126ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde949452e7b7e540a889225f2308168"><td class="memItemLeft" align="right" valign="top"><a id="acde949452e7b7e540a889225f2308168"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (!<a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>)</td></tr>
<tr class="separator:acde949452e7b7e540a889225f2308168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb306aeb0a459c784cbdfd8d20d5143"><td class="memItemLeft" align="right" valign="top"><a id="aaeb306aeb0a459c784cbdfd8d20d5143"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>&lt; extent_size)</td></tr>
<tr class="separator:aaeb306aeb0a459c784cbdfd8d20d5143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8882f03ec489a9249e63eba5e8db44"><td class="memItemLeft" align="right" valign="top"><a id="a0b8882f03ec489a9249e63eba5e8db44"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (size_increase==0)</td></tr>
<tr class="separator:a0b8882f03ec489a9249e63eba5e8db44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3799dc820aa3e1bb9df9e7e9c0739d"><td class="memItemLeft" align="right" valign="top"><a id="a9e3799dc820aa3e1bb9df9e7e9c0739d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mlog_write_ulint</b> (<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>+FSP_SIZE, new_size, <a class="el" href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a9e3799dc820aa3e1bb9df9e7e9c0739d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc794263f34d1e80b2344450756ed72b"><td class="memItemLeft" align="right" valign="top"><a id="afc794263f34d1e80b2344450756ed72b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (TRUE)</td></tr>
<tr class="separator:afc794263f34d1e80b2344450756ed72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac835771657a63bc17ec8d035327fc372"><td class="memItemLeft" align="right" valign="top">static xdes_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ac835771657a63bc17ec8d035327fc372">fsp_alloc_free_extent</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac835771657a63bc17ec8d035327fc372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151eba0db5afae22ac543cd14e9ae88f"><td class="memItemLeft" align="right" valign="top"><a id="a151eba0db5afae22ac543cd14e9ae88f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="fsp0fsp_8cc.html#a3112b68a6aecde76e8f42405152ee673">xdes_get_state</a>(<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)==XDES_FREE_FRAG)</td></tr>
<tr class="separator:a151eba0db5afae22ac543cd14e9ae88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096c9c5f35a56ec1925b1f746623fce1"><td class="memItemLeft" align="right" valign="top"><a id="a096c9c5f35a56ec1925b1f746623fce1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_a</b> (<a class="el" href="fsp0fsp_8cc.html#ac74ac9cf95883ec1d5d06d2841c312e7">xdes_mtr_get_bit</a>(<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, XDES_FREE_BIT, <a class="el" href="fsp0fsp_8cc.html#a60c1506135317302131bd515c87116bf">bit</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>))</td></tr>
<tr class="separator:a096c9c5f35a56ec1925b1f746623fce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3c63556e935ad15b7aea1cd49e4a7e"><td class="memItemLeft" align="right" valign="top"><a id="a6c3c63556e935ad15b7aea1cd49e4a7e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>xdes_set_bit</b> (<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, XDES_FREE_BIT, <a class="el" href="fsp0fsp_8cc.html#a60c1506135317302131bd515c87116bf">bit</a>, FALSE, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a6c3c63556e935ad15b7aea1cd49e4a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde6c9e07736bde923d7fc7236ebe56d"><td class="memItemLeft" align="right" valign="top"><a id="acde6c9e07736bde923d7fc7236ebe56d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mlog_write_ulint</b> (<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>+FSP_FRAG_N_USED, frag_n_used, <a class="el" href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:acde6c9e07736bde923d7fc7236ebe56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3592b31f14d2f0868c0db8bc5fd3ca"><td class="memItemLeft" align="right" valign="top"><a id="a6d3592b31f14d2f0868c0db8bc5fd3ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="fsp0fsp_8cc.html#a45b1c61387c588e9feb7c812efb47a1c">xdes_is_full</a>(<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>))</td></tr>
<tr class="separator:a6d3592b31f14d2f0868c0db8bc5fd3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d78c4de454a9ad80ec8cc2b5f694b3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a6d78c4de454a9ad80ec8cc2b5f694b3c">fsp_page_create</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="fsp0fsp_8cc.html#affc0fcb1d10ea38c48239ca6a9772e0b">init_mtr</a>)</td></tr>
<tr class="separator:a6d78c4de454a9ad80ec8cc2b5f694b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6add5e9479e73dfbf5dfba689e303cc4"><td class="memItemLeft" align="right" valign="top"><a id="a6add5e9479e73dfbf5dfba689e303cc4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a6add5e9479e73dfbf5dfba689e303cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab074e0ca9326e8e895eb0eb0960b3a96"><td class="memItemLeft" align="right" valign="top"><a id="ab074e0ca9326e8e895eb0eb0960b3a96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="fsp0fsp_8cc.html#affc0fcb1d10ea38c48239ca6a9772e0b">init_mtr</a>)</td></tr>
<tr class="separator:ab074e0ca9326e8e895eb0eb0960b3a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d076ca7ab98b938add1be5c58b5d1"><td class="memItemLeft" align="right" valign="top"><a id="ac23d076ca7ab98b938add1be5c58b5d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a> &amp;&amp;(<a class="el" href="fsp0fsp_8cc.html#a3112b68a6aecde76e8f42405152ee673">xdes_get_state</a>(<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)==XDES_FREE_FRAG))</td></tr>
<tr class="separator:ac23d076ca7ab98b938add1be5c58b5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ad60986d234af433a54f69213bca0a"><td class="memItemLeft" align="right" valign="top"><a id="a80ad60986d234af433a54f69213bca0a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="fil0fil_8h.html#a4802ee32fc62991424922156482dc039">fil_addr_is_null</a>(first))</td></tr>
<tr class="separator:a80ad60986d234af433a54f69213bca0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e7bc467056e0df820b74efb3d39f54"><td class="memItemLeft" align="right" valign="top"><a id="a86e7bc467056e0df820b74efb3d39f54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (free==ULINT_UNDEFINED)</td></tr>
<tr class="separator:a86e7bc467056e0df820b74efb3d39f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb09598e21460b5db41ee0b661c466"><td class="memItemLeft" align="right" valign="top"><a id="ac6bb09598e21460b5db41ee0b661c466"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (space_size&lt;=<a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>)</td></tr>
<tr class="separator:ac6bb09598e21460b5db41ee0b661c466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797d6b74663b599ed9a86b5d1473df12"><td class="memItemLeft" align="right" valign="top"><a id="a797d6b74663b599ed9a86b5d1473df12"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>fsp_alloc_from_free_frag</b> (<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, <a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, free, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a797d6b74663b599ed9a86b5d1473df12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c4ba05f3984d3b0d2b3a921faf4dae"><td class="memItemLeft" align="right" valign="top"><a id="a03c4ba05f3984d3b0d2b3a921faf4dae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (<a class="el" href="fsp0fsp_8cc.html#a6d78c4de454a9ad80ec8cc2b5f694b3c">fsp_page_create</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="fsp0fsp_8cc.html#affc0fcb1d10ea38c48239ca6a9772e0b">init_mtr</a>))</td></tr>
<tr class="separator:a03c4ba05f3984d3b0d2b3a921faf4dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb7aefbebc9fda79375273e5f7ac3c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a3cb7aefbebc9fda79375273e5f7ac3c5">fsp_free_page</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a3cb7aefbebc9fda79375273e5f7ac3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54cba6faba1812a0c015db0f4e7ba25"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE fseg_inode_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ab54cba6faba1812a0c015db0f4e7ba25">fsp_seg_inode_page_get_nth_inode</a> (<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a> <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)), <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a> <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:ab54cba6faba1812a0c015db0f4e7ba25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfd3ccdee0d5d4b4f19fb3b7020693c"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a7cfd3ccdee0d5d4b4f19fb3b7020693c">fsp_seg_inode_page_find_used</a> (<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a7cfd3ccdee0d5d4b4f19fb3b7020693c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e675397bb4af20e1e02fff063f60e65"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a9e675397bb4af20e1e02fff063f60e65">fsp_seg_inode_page_find_free</a> (<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint <a class="el" href="dict0mem_8cc.html#ac23062089f3a5a2693cbb4ce7a75f1e5">i</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a9e675397bb4af20e1e02fff063f60e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae908b612e64b189d8c71c07264bbd811"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ae908b612e64b189d8c71c07264bbd811">fsp_alloc_seg_inode_page</a> (fsp_header_t *space_header, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ae908b612e64b189d8c71c07264bbd811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad46c0aeca619515748903ed217d64d"><td class="memItemLeft" align="right" valign="top">static fseg_inode_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a1ad46c0aeca619515748903ed217d64d">fsp_alloc_seg_inode</a> (fsp_header_t *space_header, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a1ad46c0aeca619515748903ed217d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2273b840c26ca599e0166e6135363573"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a2273b840c26ca599e0166e6135363573">fsp_free_seg_inode</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, fseg_inode_t *inode, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a2273b840c26ca599e0166e6135363573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3786a85f30ca0e1cafcb771ed12c0097"><td class="memItemLeft" align="right" valign="top">static fseg_inode_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a3786a85f30ca0e1cafcb771ed12c0097">fseg_inode_try_get</a> (fseg_header_t *<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a3786a85f30ca0e1cafcb771ed12c0097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6b4c0fe89c0ae6da60c468e2f5993d"><td class="memItemLeft" align="right" valign="top">static fseg_inode_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a9d6b4c0fe89c0ae6da60c468e2f5993d">fseg_inode_get</a> (fseg_header_t *<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a9d6b4c0fe89c0ae6da60c468e2f5993d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac168f7f7f148eb8c000116c55cf15e36"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ac168f7f7f148eb8c000116c55cf15e36">fseg_get_nth_frag_page_no</a> (fseg_inode_t *inode, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a> <a class="el" href="trx0undo_8cc.html#aa965850120c0683c58e8c762cdc0fb17">__attribute__</a>((unused)))</td></tr>
<tr class="separator:ac168f7f7f148eb8c000116c55cf15e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49951969d2fc811417f1391f6091057c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a49951969d2fc811417f1391f6091057c">fseg_set_nth_frag_page_no</a> (fseg_inode_t *inode, ulint <a class="el" href="srv0start_8cc.html#a2600c8257a9de5721a19ec363ee4c09e">n</a>, ulint <a class="el" href="ibuf0ibuf_8cc.html#a4856a6e725a44f73f3d7a0201373c5b7">page_no</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a49951969d2fc811417f1391f6091057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed23297177001bf275ba7a9f421203a5"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#aed23297177001bf275ba7a9f421203a5">fseg_find_free_frag_page_slot</a> (fseg_inode_t *inode, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:aed23297177001bf275ba7a9f421203a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9e00496fdb082ed6d794b36ea1658a"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a6f9e00496fdb082ed6d794b36ea1658a">fseg_find_last_used_frag_page_slot</a> (fseg_inode_t *inode, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a6f9e00496fdb082ed6d794b36ea1658a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a330e3e4327bf76d67935aa08ff68"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a722a330e3e4327bf76d67935aa08ff68">fseg_get_n_frag_pages</a> (fseg_inode_t *inode, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a722a330e3e4327bf76d67935aa08ff68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae124cb538384c65a08e6c70b01652f29"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ae124cb538384c65a08e6c70b01652f29">fseg_create_general</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint byte_offset, ibool has_done_reservation, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ae124cb538384c65a08e6c70b01652f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357368d30f0a154db923fb4f816af437"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a357368d30f0a154db923fb4f816af437">fseg_create</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, ulint byte_offset, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a357368d30f0a154db923fb4f816af437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2038bfb8aacb910b0ebc9f54227d3015"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a2038bfb8aacb910b0ebc9f54227d3015">fseg_n_reserved_pages</a> (fseg_header_t *<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, ulint *used, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a2038bfb8aacb910b0ebc9f54227d3015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf852dd97ce8074b743bf8478aed26a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#addf852dd97ce8074b743bf8478aed26a">fseg_fill_free_list</a> (fseg_inode_t *inode, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:addf852dd97ce8074b743bf8478aed26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a77c0bb7a872b0c27e9a0d108e8708c"><td class="memItemLeft" align="right" valign="top">static xdes_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a2a77c0bb7a872b0c27e9a0d108e8708c">fseg_alloc_free_extent</a> (fseg_inode_t *inode, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a2a77c0bb7a872b0c27e9a0d108e8708c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06eb7a2ac32654627af1c9a5fa2c6c60"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a06eb7a2ac32654627af1c9a5fa2c6c60">fseg_alloc_free_page_general</a> (fseg_header_t *seg_header, ulint <a class="el" href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a>, byte <a class="el" href="btr0btr_8cc.html#a942da44c6711d230377078633665e89b">direction</a>, ibool has_done_reservation, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="fsp0fsp_8cc.html#affc0fcb1d10ea38c48239ca6a9772e0b">init_mtr</a>)</td></tr>
<tr class="separator:a06eb7a2ac32654627af1c9a5fa2c6c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae420d97d130e40d89dee06f60cef8d0c"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ae420d97d130e40d89dee06f60cef8d0c">fsp_reserve_free_pages</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, fsp_header_t *space_header, ulint <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ae420d97d130e40d89dee06f60cef8d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa63afa1be039f1f5eccd2f2f1a7648c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#afa63afa1be039f1f5eccd2f2f1a7648c">fsp_reserve_free_extents</a> (ulint *n_reserved, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="btr0cur_8cc.html#ab14e90cca5a13bd23c0993003c060e03">n_ext</a>, ulint alloc_type, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:afa63afa1be039f1f5eccd2f2f1a7648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82b7efd6737bc577ef6edb60ea7b467"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ullint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ae82b7efd6737bc577ef6edb60ea7b467">fsp_get_available_space_in_free_extents</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>)</td></tr>
<tr class="separator:ae82b7efd6737bc577ef6edb60ea7b467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5197da43e37002abf6baeec47c0d46a"><td class="memItemLeft" align="right" valign="top"><a id="ab5197da43e37002abf6baeec47c0d46a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (!((<a class="el" href="page0page_8h.html#a6862a8e0be7713fc39e7ad656791bb4e">page_offset</a>(seg_inode) - FSEG_ARR_OFFSET) % FSEG_INODE_SIZE))</td></tr>
<tr class="separator:ab5197da43e37002abf6baeec47c0d46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cf9c246943ed98c6c7138af80b54c6"><td class="memItemLeft" align="right" valign="top"><a id="a18cf9c246943ed98c6c7138af80b54c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="mach0data_8h.html#acede0a33738a2a4fffc468cb6b41df78">mach_read_from_4</a>(seg_inode+FSEG_MAGIC_N)==FSEG_MAGIC_N_VALUE)</td></tr>
<tr class="separator:a18cf9c246943ed98c6c7138af80b54c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2220e0acf25a47caf3a87b61783608b7"><td class="memItemLeft" align="right" valign="top"><a id="a2220e0acf25a47caf3a87b61783608b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="mtr0mtr_8cc.html#a80db4736e06a546b600d07aae586f809">mtr_read_ulint</a>(seg_inode+FSEG_ID, <a class="el" href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)==<a class="el" href="mtr0mtr_8cc.html#a80db4736e06a546b600d07aae586f809">mtr_read_ulint</a>(<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>+XDES_ID, <a class="el" href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>))</td></tr>
<tr class="separator:a2220e0acf25a47caf3a87b61783608b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7791415362101f60eed918de1b37082e"><td class="memItemLeft" align="right" valign="top"><a id="a7791415362101f60eed918de1b37082e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (<a class="el" href="fsp0fsp_8cc.html#a09a40c104599a3b433dacf02c8442a90">xdes_is_free</a>(<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>))</td></tr>
<tr class="separator:a7791415362101f60eed918de1b37082e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d30fc895f42fff471614663c0cd658f"><td class="memItemLeft" align="right" valign="top"><a id="a9d30fc895f42fff471614663c0cd658f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ut_ad</b> (<a class="el" href="fsp0fsp_8cc.html#ac74ac9cf95883ec1d5d06d2841c312e7">xdes_mtr_get_bit</a>(<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, XDES_FREE_BIT, <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a> % FSP_EXTENT_SIZE, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>))</td></tr>
<tr class="separator:a9d30fc895f42fff471614663c0cd658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0493812cd5df35ce27fc240bf066840d"><td class="memItemLeft" align="right" valign="top"><a id="a0493812cd5df35ce27fc240bf066840d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>xdes_set_bit</b> (<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, XDES_FREE_BIT, <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a> % FSP_EXTENT_SIZE, FALSE, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a0493812cd5df35ce27fc240bf066840d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eed9a3e43429f27b2c45e044400b34d"><td class="memItemLeft" align="right" valign="top"><a id="a6eed9a3e43429f27b2c45e044400b34d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mlog_write_ulint</b> (seg_inode+FSEG_NOT_FULL_N_USED, not_full_n_used, <a class="el" href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a6eed9a3e43429f27b2c45e044400b34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f03bc3e900151e1898bf926b7efd86"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ac7f03bc3e900151e1898bf926b7efd86">fseg_free_page_low</a> (fseg_inode_t *seg_inode, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ac7f03bc3e900151e1898bf926b7efd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e8f0816d2ba1f91f95957f728bc7c8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ad9e8f0816d2ba1f91f95957f728bc7c8">fseg_free_page</a> (fseg_header_t *seg_header, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ad9e8f0816d2ba1f91f95957f728bc7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af029aae13897cf4d5ffe805bfcc1dcd0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#af029aae13897cf4d5ffe805bfcc1dcd0">fseg_page_is_free</a> (fseg_header_t *seg_header, ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, ulint <a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a>)</td></tr>
<tr class="separator:af029aae13897cf4d5ffe805bfcc1dcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368030d2c197d4f01187f0796db1e264"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a368030d2c197d4f01187f0796db1e264">fseg_free_step</a> (fseg_header_t *<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a368030d2c197d4f01187f0796db1e264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a63f82b0ba09a66706eb5f755bab769"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a3a63f82b0ba09a66706eb5f755bab769">fseg_free_step_not_header</a> (fseg_header_t *<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a3a63f82b0ba09a66706eb5f755bab769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dfbd7362f7e9fa5259caeb254e36d7"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a16dfbd7362f7e9fa5259caeb254e36d7">fseg_validate_low</a> (fseg_inode_t *inode, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr2)</td></tr>
<tr class="separator:a16dfbd7362f7e9fa5259caeb254e36d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7920054c59e838b70447f0da7c0eae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a0a7920054c59e838b70447f0da7c0eae">fseg_print_low</a> (fseg_inode_t *inode, <a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:a0a7920054c59e838b70447f0da7c0eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae245be113c8528ada2afb42d828eafe4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ae245be113c8528ada2afb42d828eafe4">fsp_validate</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>)</td></tr>
<tr class="separator:ae245be113c8528ada2afb42d828eafe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a96e33dab9d5a52d56521b2834cd183"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a5a96e33dab9d5a52d56521b2834cd183">fsp_print</a> (ulint <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>)</td></tr>
<tr class="separator:a5a96e33dab9d5a52d56521b2834cd183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Format of the IBUF_REC_FIELD_METADATA of an insert buffer record</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The fourth column in the MySQL 5.5 format contains an operation type, counter, and some flags. </p>
</div></td></tr>
<tr class="memitem:a25ccd7dca1c1a6f437f5041ea0855a96"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a25ccd7dca1c1a6f437f5041ea0855a96">__attribute__</a> ((nonnull, warn_unused_result)) xdes_t *xdes_get_descriptor_with_space_hdr(fsp_header_t *sp_header</td></tr>
<tr class="separator:a25ccd7dca1c1a6f437f5041ea0855a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad128bc7d258f5ba0f88a4391cc4b052b"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ad128bc7d258f5ba0f88a4391cc4b052b">fsp_tbs_full_error_printed</a> = FALSE</td></tr>
<tr class="separator:ad128bc7d258f5ba0f88a4391cc4b052b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e3109c6b8c8d21dfc851e276de8389"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a69e3109c6b8c8d21dfc851e276de8389">page</a></td></tr>
<tr class="separator:a69e3109c6b8c8d21dfc851e276de8389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fe4cbf409943b0a9ad7be772abc938"><td class="memItemLeft" align="right" valign="top">static ulint xdes_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a> = xdes_get_descriptor_with_space_hdr(<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ab1fe4cbf409943b0a9ad7be772abc938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af844392d3072f7f29433c4c4c7b932c5"><td class="memItemLeft" align="right" valign="top">static ulint xdes_t <a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#af844392d3072f7f29433c4c4c7b932c5">mtr</a></td></tr>
<tr class="separator:af844392d3072f7f29433c4c4c7b932c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d674a5233ffaf93241241525855907a"><td class="memItemLeft" align="right" valign="top"><a id="a0d674a5233ffaf93241241525855907a"></a>
static <a class="el" href="structbuf__block__t.html">buf_block_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nonnull</b></td></tr>
<tr class="separator:a0d674a5233ffaf93241241525855907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417adcfdc3449d6de97bbb1965d67d04"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a417adcfdc3449d6de97bbb1965d67d04">space</a></td></tr>
<tr class="separator:a417adcfdc3449d6de97bbb1965d67d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394fcd8654772552f8178df5d2ed1048"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a394fcd8654772552f8178df5d2ed1048">offset</a></td></tr>
<tr class="separator:a394fcd8654772552f8178df5d2ed1048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ba5a514c395b398630a3d7791561bc"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a> = <a class="el" href="mach0data_8h.html#acede0a33738a2a4fffc468cb6b41df78">mach_read_from_4</a>(sp_header + FSP_SIZE)</td></tr>
<tr class="separator:aa2ba5a514c395b398630a3d7791561bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab272a29ed146ac233db12e8b72443195"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ab272a29ed146ac233db12e8b72443195">zip_size</a></td></tr>
<tr class="separator:ab272a29ed146ac233db12e8b72443195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddaf06e1dd596e2b6973128f6a4b148"><td class="memItemLeft" align="right" valign="top"><a id="a2ddaf06e1dd596e2b6973128f6a4b148"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>descr_page_no</b> = <a class="el" href="fsp0fsp_8h.html#a2d6ac50b9eb3713adb7982e1e9cbbab7">xdes_calc_descriptor_page</a>(<a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="os0file_8cc.html#a7b6b91e619d6e5e1a8a9f7da64bc0cdb">offset</a>)</td></tr>
<tr class="separator:a2ddaf06e1dd596e2b6973128f6a4b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75894eeec5ffeb864166a15ac4276c62"><td class="memItemLeft" align="right" valign="top"><a id="a75894eeec5ffeb864166a15ac4276c62"></a>
<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>descr_page</b> = buf_block_get_frame(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a75894eeec5ffeb864166a15ac4276c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e21280adfab4d1a5b4275b3aea590"><td class="memItemLeft" align="right" valign="top"><a id="a6e8e21280adfab4d1a5b4275b3aea590"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>limit</b> = <a class="el" href="mach0data_8h.html#acede0a33738a2a4fffc468cb6b41df78">mach_read_from_4</a>(sp_header + FSP_FREE_LIMIT)</td></tr>
<tr class="separator:a6e8e21280adfab4d1a5b4275b3aea590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544c3fe466e421738dae463968b70ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a0544c3fe466e421738dae463968b70ba">else</a></td></tr>
<tr class="separator:a0544c3fe466e421738dae463968b70ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17afa58b2bc574dedcd1cc02e1fdf165"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>block</b></td></tr>
<tr class="separator:a17afa58b2bc574dedcd1cc02e1fdf165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b25e49f85a5839b373678fb1833a000"><td class="memItemLeft" align="right" valign="top"><a id="a3b25e49f85a5839b373678fb1833a000"></a>
fsp_header_t *&#160;</td><td class="memItemRight" valign="bottom"><b>sp_header</b> = <a class="el" href="fsp0fsp_8h.html#ac07d76ccd967dec4a5ecb06f7fd865f8">FSP_HEADER_OFFSET</a> + buf_block_get_frame(<a class="el" href="row0merge_8cc.html#a93c46cf7240dc5a16f8137e7d34a5049">block</a>)</td></tr>
<tr class="separator:a3b25e49f85a5839b373678fb1833a000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14e86873f8d034759194bb1c17e1a8d"><td class="memItemLeft" align="right" valign="top">static UNIV_COLD ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#ab14e86873f8d034759194bb1c17e1a8d">page_no</a> = <a class="el" href="fsp0fsp_8cc.html#aab3c246e8f86d3d784f92538c711916c">xdes_get_offset</a>(<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>) + free</td></tr>
<tr class="separator:ab14e86873f8d034759194bb1c17e1a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17e72298b614d3ef0c0f311e7418e42"><td class="memItemLeft" align="right" valign="top">static UNIV_COLD ulint fsp_header_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a> = <a class="el" href="fsp0fsp_8cc.html#acd1fc77af0aeddec49525e752079f8a0">fsp_get_space_header</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:af17e72298b614d3ef0c0f311e7418e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ddcdccbf66c037e9bdd3460b03006a"><td class="memItemLeft" align="right" valign="top"><a id="a61ddcdccbf66c037e9bdd3460b03006a"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>actual_size</b></td></tr>
<tr class="separator:a61ddcdccbf66c037e9bdd3460b03006a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7960f9c558f9ee2c3d4a8fdea096fb56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>success</b></td></tr>
<tr class="separator:a7960f9c558f9ee2c3d4a8fdea096fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb33c11fb2d6f285963a9af1f9e3229"><td class="memItemLeft" align="right" valign="top"><a id="a8bb33c11fb2d6f285963a9af1f9e3229"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>new_size</b></td></tr>
<tr class="separator:a8bb33c11fb2d6f285963a9af1f9e3229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbff5207770a269a3b5a3e13a876280c"><td class="memItemLeft" align="right" valign="top"><a id="abbff5207770a269a3b5a3e13a876280c"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>old_size</b> = <a class="el" href="srv0start_8cc.html#aa2ba5a514c395b398630a3d7791561bc">size</a></td></tr>
<tr class="separator:abbff5207770a269a3b5a3e13a876280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff4637523bcc5dddde81c004734fba6"><td class="memItemLeft" align="right" valign="top"><a id="a8ff4637523bcc5dddde81c004734fba6"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>size_increase</b></td></tr>
<tr class="separator:a8ff4637523bcc5dddde81c004734fba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778a17d63d44bba6998c87f95f17bc5b"><td class="memItemLeft" align="right" valign="top"><a id="a778a17d63d44bba6998c87f95f17bc5b"></a>
*&#160;</td><td class="memItemRight" valign="bottom"><b>actual_increase</b> = 0</td></tr>
<tr class="separator:a778a17d63d44bba6998c87f95f17bc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c1506135317302131bd515c87116bf"><td class="memItemLeft" align="right" valign="top">static xdes_t ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#a60c1506135317302131bd515c87116bf">bit</a></td></tr>
<tr class="separator:a60c1506135317302131bd515c87116bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c7edc3216207f5d2b854b9d4139786"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>frag_n_used</b></td></tr>
<tr class="separator:ad8c7edc3216207f5d2b854b9d4139786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed44f205c7d95ae205b0f69d2b723b55"><td class="memItemLeft" align="right" valign="top">static ulint ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a> = 0</td></tr>
<tr class="separator:aed44f205c7d95ae205b0f69d2b723b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc0fcb1d10ea38c48239ca6a9772e0b"><td class="memItemLeft" align="right" valign="top">static ulint ulint <a class="el" href="structmtr__t.html">mtr_t</a> <a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsp0fsp_8cc.html#affc0fcb1d10ea38c48239ca6a9772e0b">init_mtr</a></td></tr>
<tr class="separator:affc0fcb1d10ea38c48239ca6a9772e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2982791a8a84e9433606a34819e6e093"><td class="memItemLeft" align="right" valign="top"><a id="a2982791a8a84e9433606a34819e6e093"></a>
<a class="el" href="structfil__addr__t.html">fil_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>first</b></td></tr>
<tr class="separator:a2982791a8a84e9433606a34819e6e093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ea2c9c6c1ba23efaf7efaeb118a065"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><b>free</b></td></tr>
<tr class="separator:a21ea2c9c6c1ba23efaf7efaeb118a065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade481073a0ca23ec18c4eb43f686d008"><td class="memItemLeft" align="right" valign="top"><a id="ade481073a0ca23ec18c4eb43f686d008"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>space_size</b> = <a class="el" href="mtr0mtr_8cc.html#a80db4736e06a546b600d07aae586f809">mtr_read_ulint</a>(<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a> + FSP_SIZE, <a class="el" href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td></tr>
<tr class="separator:ade481073a0ca23ec18c4eb43f686d008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b07c11c0bc8b7e49fead5aa8c45d33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>not_full_n_used</b></td></tr>
<tr class="separator:ad5b07c11c0bc8b7e49fead5aa8c45d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>File space management</p>
<p>Created 11/29/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="accee9488458f6ad9ba22500f7a1e44f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accee9488458f6ad9ba22500f7a1e44f2">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Marks a page used. The page must reside within the extents of the given segment.</p>
<p>Tries to extend the last data file of a tablespace if it is auto-extending. </p><dl class="section return"><dt>Returns</dt><dd>FALSE if not auto-extending</dd></dl>
<p>Allocates a single free page from a space. </p>

</div>
</div>
<a id="a25ccd7dca1c1a6f437f5041ea0855a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ccd7dca1c1a6f437f5041ea0855a96">&#9670;&nbsp;</a></span>__attribute__() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull, warn_unused_result)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">new</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets pointer to a the extent descriptor of a page. The page where the extent descriptor resides is x-locked. This function no longer extends the data file. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the extent descriptor, NULL if the page does not exist in the space or if the offset is &gt;= the free limit</dd></dl>
<p>Gets pointer to a the extent descriptor of a page. The page where the extent descriptor resides is x-locked. If the page offset is equal to the free limit of the space, adds new extents from above the free limit to the space free list, if not free limit == space size. This adding is necessary to make the descriptor defined, as they are uninitialized above the free limit. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the extent descriptor, NULL if the page does not exist in the space or if the offset exceeds the free limit</dd></dl>
<p>Tries to extend a single-table tablespace so that a page would fit in the data file. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if success</dd></dl>
<p>Allocates a single free page from a space. The page is marked as used. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr) </td></tr>
    <tr><td class="paramname">block</td><td>(not allocated or initialized) otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Rename a single auxiliary table due to database name change. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Drops the common ancillary tables needed for supporting an FTS index on the given table. row_mysql_lock_data_dictionary must have been called before this. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Drops FTS ancillary tables needed for supporting an FTS index on the given table. row_mysql_lock_data_dictionary must have been called before this. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Do commit-phase steps necessary for the insertion of a new row. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Do commit-phase steps necessary for the deletion of a row. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Do commit-phase steps necessary for the modification of a row. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>The given transaction is about to be committed; do whatever is necessary from the FTS system's POV. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>&lt; in: FTS table to commit</p>
<p>Add rows to the DELETED_CACHE table. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all went well else error code</dd></dl>
<p>Write the words and ilist to disk. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all went well else error code</dd></dl>
<p>Run SYNC on the table, i.e., write out data from the index specific cache to the FTS aux INDEX table and FTS aux doc id stats table. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>Commit the SYNC, change state of processed doc ids etc. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>&lt; in: sync state</p>
<p>Rename an aux table to HEX format. It's called when "%016llu" is used to format an object id in table name, which only happens in Windows.</p>
<p>Rename all aux tables of a parent table to HEX format. Also set aux tables' flags2 and parent table's flags2 with DICT_TF2_FTS_AUX_HEX_NAME. It's called when "%016llu" is used to format an object id in table name, which only happens in Windows. Note the ids in tables are correct but the names are old ambiguous ones.</p>
<p>This function should make sure that either all the parent table and aux tables are set DICT_TF2_FTS_AUX_HEX_NAME with flags2 or none of them are set</p>
<p>Determine the starting pos within the deleted doc id vector for a word. </p><dl class="section return"><dt>Returns</dt><dd>delete position</dd></dl>
<p>Update the FTS index table. This is a delete followed by an insert. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Optimize the word ilist and rewrite data to the FTS index. </p><dl class="section return"><dt>Returns</dt><dd>status one of RESTART, EXIT, ERROR</dd></dl>
<p>Optimize is complete. Set the completion time, and reset the optimize start string for this FTS index to "". </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>Read the list of words from the FTS auxiliary index that will be optimized in this pass. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>Run OPTIMIZE on the given FTS index. Note: this can take a very long time (hours). </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>Delete the document ids in the delete, and delete cache tables. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>&lt; in: optimize instance</p>
<p>Delete the document ids in the pending delete, and delete tables. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>&lt; in: optimize instance</p>
<p>Copy the deleted doc ids that will be purged during this optimize run to the being deleted FTS auxiliary tables. The transaction is committed upon successfull copy and rolled back on DB_DUPLICATE_KEY error. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>&lt; in: optimize instance</p>
<p>Read in the document ids that are to be purged during optimize. The transaction is committed upon successfully read. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>&lt; in: optimize instance</p>
<p>Optimze all the FTS indexes, skipping those that have already been optimized, since the FTS auxiliary indexes are not guaranteed to be of the same cardinality. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>&lt; in: optimize instance</p>
<p>Cleanup the snapshot tables and the master deleted table. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>&lt; in: optimize instance</p>
<p>Reset the start time to 0 so that a new optimize can be started. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>&lt; in: optimize instance</p>
<p>Intersect the token doc ids with the current set. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all go well</dd></dl>
<p>Set union. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all go well</dd></dl>
<p>Retrieve the document and match the phrase tokens. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>This function fetches the original documents and count the words in between matching words to see that is in specified distance </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>Iterate over the matched document ids and search the for the actual phrase in the text. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK</dd></dl>
<p>Text/Phrase search. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Find the word and evaluate. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all go well</dd></dl>
<p>This function implements a simple "blind" query expansion search: words in documents found in the first search pass will be used as search arguments to search the document again, thus "expand" the search result set. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if success, otherwise the error code</dd></dl>
<p>Renames an InnoDB table. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Reads page numbers for a space id from an ibuf tree. </p><dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined volume of records which will be merged</dd></dl>
<p>Contracts insert buffer trees by reading pages to the buffer pool. </p><dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined size in bytes of entries which will be merged from ibuf trees to the pages read, 0 if ibuf is empty</dd></dl>
<p>Buffer an operation in the insert/delete buffer, instead of doing it directly to the disk page, if this is possible. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_STRONG_FAIL or other error</dd></dl>
<p>Does a synchronous write operation in Posix. </p><dl class="section return"><dt>Returns</dt><dd>number of bytes written, -1 if error</dd></dl>
<p>Report error during tablespace import.</p>
<p>Adjust the root page index node and leaf node segment headers, update with the new space id. For all the table's secondary indexes. </p><dl class="section return"><dt>Returns</dt><dd>error code</dd></dl>
<p>Ensure that dict_sys-&gt;row_id exceeds SELECT MAX(DB_ROW_ID). </p><dl class="section return"><dt>Returns</dt><dd>error code</dd></dl>
<p>Write the meta data (index user fields) config file. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code.</dd></dl>
<p>Read the index names and root page numbers of the indexes and set the values. Row format [root_page_no, len of str, str ... ] </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code.</dd></dl>
<p>Read the meta data (table columns) config file. Deserialise the contents of <a class="el" href="structdict__col__t.html">dict_col_t</a> structure, along with the column name.</p>
<p>Read the contents of the &lt;tablespace&gt;.cfg file. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code.</dd></dl>
<p>Read the contents of the &lt;tablename&gt;.cfg file. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code.</dd></dl>
<p>Does an insert operation by delete unmarking and updating a delete marked existing record in the index. This situation can occur if the delete marked record is kept in the index for consistent reads. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_FAIL, or error code</dd></dl>
<p>Returns the number of ancestor UPDATE or DELETE nodes of a cascaded update/delete node. </p><dl class="section return"><dt>Returns</dt><dd>number of ancestors</dd></dl>
<p>&lt; in: node in a query graph</p>
<p>Calculates the update vector node-&gt;cascade-&gt;update for a child table in a cascaded update. </p><dl class="section return"><dt>Returns</dt><dd>number of fields in the calculated update vector; the value can also be 0 if no foreign key fields changed; the returned value is ULINT_UNDEFINED if the column type in the child table is too short to fit the new value in the parent table: that means the update fails</dd></dl>
<p>Perform referential actions or checks when a parent row is deleted or updated and the constraint had an ON DELETE or ON UPDATE condition which was not RESTRICT. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error code</dd></dl>
<p>Checks if foreign key constraints fail for an index entry. If index is not mentioned in any constraint, this function does nothing, Otherwise does searches to the indexes of referenced tables and sets shared locks which lock either the success or the failure of a constraint. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Scans a unique non-clustered index at a given index entry to determine whether a uniqueness violation has occurred for the key value of the entry. Set shared locks on possible duplicate records. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_DUPLICATE_KEY, or DB_LOCK_WAIT</dd></dl>
<p>Checks for a duplicate when the table is being rebuilt online. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>when no duplicate is detected </td></tr>
    <tr><td class="paramname">DB_SUCCESS_LOCKED_REC</td><td>when rec is an exact match of entry or a newer version of entry (the entry should not be inserted) </td></tr>
    <tr><td class="paramname">DB_DUPLICATE_KEY</td><td>when entry is a duplicate of rec</td></tr>
  </table>
  </dd>
</dl>
<p>Checks if a unique key violation error would occur at an index entry insert. Sets shared locks on possible duplicate records. Works only for a clustered index! </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>if no error </td></tr>
    <tr><td class="paramname">DB_DUPLICATE_KEY</td><td>if error, </td></tr>
    <tr><td class="paramname">DB_LOCK_WAIT</td><td>if we have to wait for a lock on a possible duplicate record </td></tr>
    <tr><td class="paramname">DB_SUCCESS_LOCKED_REC</td><td>if an exact match of the record was found in online table rebuild (flags &amp; (BTR_KEEP_SYS_FLAG | BTR_NO_LOCKING_FLAG))</td></tr>
  </table>
  </dd>
</dl>
<p>Starts a mini-transaction and checks if the index will be dropped. </p><dl class="section return"><dt>Returns</dt><dd>true if the index is to be dropped</dd></dl>
<p>Inserts a single index entry to the table. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT</dd></dl>
<p>Inserts a row to a table. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT</dd></dl>
<p>Converts a log record to a table row. </p><dl class="section return"><dt>Returns</dt><dd>converted row, or NULL if the conversion fails</dd></dl>
<p>Replays an insert operation on a table that was rebuilt. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Replays an update operation on a table that was rebuilt. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Applies an operation to a table that was rebuilt. </p><dl class="section return"><dt>Returns</dt><dd>NULL on failure (mrec corruption) or when out of data; pointer to next record on success</dd></dl>
<p>Applies operations to a table was rebuilt. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, or error code on failure</dd></dl>
<p>Applies an operation to a secondary index that was being created. </p><dl class="section return"><dt>Returns</dt><dd>NULL on failure (mrec corruption) or when out of data; pointer to next record on success</dd></dl>
<p>Copy a block of index entries. </p><dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure</dd></dl>
<p>Read sorted file containing index data tuples and insert these data tuples to the index </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error number</dd></dl>
<p>Create and execute a query graph for creating an index. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Delete a single constraint. </p><dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS</dd></dl>
<p>Removes a clustered index record if it has not been modified after the delete marking. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the row was not found, or it was successfully removed </td></tr>
    <tr><td class="paramname">false</td><td>the purge needs to be suspended because of running out of file space.</td></tr>
  </table>
  </dd>
</dl>
<p>&lt; in/out: row purge node</p>
<p>Purges a delete marking of a record. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the row was not found, or it was successfully removed </td></tr>
    <tr><td class="paramname">false</td><td>the purge needs to be suspended because of running out of file space</td></tr>
  </table>
  </dd>
</dl>
<p>&lt; in/out: row purge node</p>
<p>Purges the parsed record. </p><dl class="section return"><dt>Returns</dt><dd>true if purged, false if skipped</dd></dl>
<p>Write the meta data config file index information. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code.</dd></dl>
<p>Write the meta data (table columns) config file. Serialise the contents of <a class="el" href="structdict__col__t.html">dict_col_t</a> structure, along with the column name. All fields are serialized as ib_uint32_t. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code.</dd></dl>
<p>Write the meta data config file header. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code.</dd></dl>
<p>Write the table meta data after quiesce. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Retrieves the clustered index record corresponding to a record in a non-clustered index. Does the necessary locking. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Performs a select step. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Builds a previous version of a clustered index record for a consistent read </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Retrieves the clustered index record corresponding to a record in a non-clustered index. Does the necessary locking. Used in the MySQL interface. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, or error code</dd></dl>
<p>Removes a secondary index entry if found. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_FAIL, or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>Removes a secondary index entry from the index if found. Tries first optimistic, then pessimistic descent down the tree. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>Removes secondary index records. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>&lt; in/out: row undo node</p>
<p>Purges a clustered index record after undo if possible. This is attempted when the record was inserted by updating a delete-marked record and there no longer exist transactions that would see the delete-marked record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_FAIL, or error code: we may run out of file space</dd></dl>
<p>Undoes a modify in a clustered index record. Sets also the node state for the next round of undo. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code: we may run out of file space</dd></dl>
<p>Delete marks or removes a secondary index entry if found. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_FAIL, or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>Delete marks or removes a secondary index entry if found. NOTE that if we updated the fields of a delete-marked secondary index record so that alphabetically they stayed the same, e.g., 'abc' -&gt; 'aBc', we cannot return to the original values because we do not know them. But this should not cause problems because in <a class="el" href="row0sel_8cc.html">row0sel.cc</a>, in queries we always retrieve the clustered index record or an earlier version of it, if the secondary index record through which we do the search is delete-marked. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>Delete unmarks a secondary index entry which must be found. It might not be delete-marked at the moment, but it does not harm to unmark it anyway. We also need to update the fields of the secondary index record if we updated its fields but alphabetically they stayed the same, e.g., 'abc' -&gt; 'aBc'. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_FAIL</td><td>if BTR_MODIFY_TREE should be tried </td></tr>
    <tr><td class="paramname">DB_OUT_OF_FILE_SPACE</td><td>when running out of tablespace </td></tr>
    <tr><td class="paramname">DB_DUPLICATE_KEY</td><td>if the value was missing and an insert would lead to a duplicate exists</td></tr>
  </table>
  </dd>
</dl>
<p>Undoes a modify in secondary indexes when undo record type is UPD_DEL. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>Undoes a modify in secondary indexes when undo record type is DEL_MARK. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>Undoes a modify in secondary indexes when undo record type is UPD_EXIST. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>Updates a secondary index entry of a row. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT</dd></dl>
<p>Updates the secondary index record if it is changed in the row update or deletes it if this is a delete. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT</dd></dl>
<p>Marks the clustered index record deleted and inserts the updated version of the record to the index. This function should be used when the ordering fields of the clustered index record change. This should be quite rare in database applications. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT</dd></dl>
<p>Updates a clustered index record of a row when the ordering fields do not change. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT</dd></dl>
<p>Delete marks a clustered index record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code</dd></dl>
<p>Updates the clustered index record. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, DB_LOCK_WAIT in case of a lock wait, else error code</dd></dl>
<p>Updates the affected index records of a row. When the control is transferred to this node, we assume that we have a persistent cursor which was on a record, and the position of the cursor is stored in the cursor. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if operation successfully completed, else error code or DB_LOCK_WAIT</dd></dl>
<p>Opens a log file. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Creates or opens database data files and closes them. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code</dd></dl>
<p>Creates a new undo log. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if successful in creating the new undo lob object, possible error codes are: DB_TOO_MANY_CONCURRENT_TRXS DB_OUT_OF_FILE_SPACE DB_OUT_OF_MEMORY </dd></dl>

</div>
</div>
<a id="a2a77c0bb7a872b0c27e9a0d108e8708c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a77c0bb7a872b0c27e9a0d108e8708c">&#9670;&nbsp;</a></span>fseg_alloc_free_extent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static xdes_t* fseg_alloc_free_extent </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a free extent for the segment: looks first in the free list of the segment, then tries to allocate from the space free list. NOTE that the extent returned still resides in the segment free list, it is not yet taken off it! </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr) </td></tr>
    <tr><td class="paramname">block</td><td>(not allocated or initialized) otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06eb7a2ac32654627af1c9a5fa2c6c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06eb7a2ac32654627af1c9a5fa2c6c60">&#9670;&nbsp;</a></span>fseg_alloc_free_page_general()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* fseg_alloc_free_page_general </td>
          <td>(</td>
          <td class="paramtype">fseg_header_t *&#160;</td>
          <td class="paramname"><em>seg_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>has_done_reservation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>init_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a single free page from a segment. This function implements the intelligent allocation strategy which tries to minimize file space fragmentation. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr) </td></tr>
    <tr><td class="paramname">block</td><td>(not allocated or initialized) otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_header</td><td>in/out: segment header </td></tr>
    <tr><td class="paramname">hint</td><td>in: hint of which page would be desirable </td></tr>
    <tr><td class="paramname">direction</td><td>in: if the new page is needed because of an index page split, and records are inserted there in order, into which direction they go alphabetically: FSP_DOWN, FSP_UP, FSP_NO_DIR </td></tr>
    <tr><td class="paramname">has_done_reservation</td><td>in: TRUE if the caller has already done the reservation for the page with fsp_reserve_free_extents, then there is no need to do the check for this individual page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">init_mtr</td><td>in/out: mtr or another mini-transaction in which the page should be initialized. If init_mtr!=mtr, but the page is already latched in mtr, do not initialize the page. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae472093c5c51efa0a1f030362ada18be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae472093c5c51efa0a1f030362ada18be">&#9670;&nbsp;</a></span>fseg_alloc_free_page_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a> * fseg_alloc_free_page_low </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>seg_inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>init_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a single free page from a segment. This function implements the intelligent allocation strategy which tries to minimize file space fragmentation. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr) </td></tr>
    <tr><td class="paramname">block</td><td>(not allocated or initialized) otherwise </td></tr>
  </table>
  </dd>
</dl>
<p>&lt; extent of the hinted page</p>
<p>&lt; the allocated page offset, FIL_NULL if could not be allocated</p>
<p>&lt; the extent of the allocated page </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">seg_inode</td><td>in/out: segment inode </td></tr>
    <tr><td class="paramname">hint</td><td>in: hint of which page would be desirable </td></tr>
    <tr><td class="paramname">direction</td><td>in: if the new page is needed because of an index page split, and records are inserted there in order, into which direction they go alphabetically: FSP_DOWN, FSP_UP, FSP_NO_DIR </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">init_mtr</td><td>in/out: mtr or another mini-transaction in which the page should be initialized. If init_mtr!=mtr, but the page is already latched in mtr, do not initialize the page. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a357368d30f0a154db923fb4f816af437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357368d30f0a154db923fb4f816af437">&#9670;&nbsp;</a></span>fseg_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* fseg_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new segment. </p><dl class="section return"><dt>Returns</dt><dd>the block where the segment header is placed, x-latched, NULL if could not create segment because of lack of space </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page</td><td>in: page where the segment header is placed: if this is != 0, the page must belong to another segment, if this is 0, a new page will be allocated and it will belong to the created segment </td></tr>
    <tr><td class="paramname">byte_offset</td><td>in: byte offset of the created segment header on the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae124cb538384c65a08e6c70b01652f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae124cb538384c65a08e6c70b01652f29">&#9670;&nbsp;</a></span>fseg_create_general()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* fseg_create_general </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>has_done_reservation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new segment. </p><dl class="section return"><dt>Returns</dt><dd>the block where the segment header is placed, x-latched, NULL if could not create segment because of lack of space </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page</td><td>in: page where the segment header is placed: if this is != 0, the page must belong to another segment, if this is 0, a new page will be allocated and it will belong to the created segment </td></tr>
    <tr><td class="paramname">byte_offset</td><td>in: byte offset of the created segment header on the page </td></tr>
    <tr><td class="paramname">has_done_reservation</td><td>in: TRUE if the caller has already done the reservation for the pages with fsp_reserve_free_extents (at least 2 extents: one for the inode and the other for the segment) then there is no need to do the check for this individual operation </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addf852dd97ce8074b743bf8478aed26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf852dd97ce8074b743bf8478aed26a">&#9670;&nbsp;</a></span>fseg_fill_free_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fseg_fill_free_list </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to fill the free list of a segment with consecutive free extents. This happens if the segment is big enough to allow extents in the free list, the free list is empty, and the extents can be allocated consecutively from the hint onward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">hint</td><td>in: hint which extent would be good as the first extent </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed23297177001bf275ba7a9f421203a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed23297177001bf275ba7a9f421203a5">&#9670;&nbsp;</a></span>fseg_find_free_frag_page_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint fseg_find_free_frag_page_slot </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds a fragment page slot which is free. </p><dl class="section return"><dt>Returns</dt><dd>slot index; ULINT_UNDEFINED if none found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f9e00496fdb082ed6d794b36ea1658a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9e00496fdb082ed6d794b36ea1658a">&#9670;&nbsp;</a></span>fseg_find_last_used_frag_page_slot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint fseg_find_last_used_frag_page_slot </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds a fragment page slot which is used and last in the array. </p><dl class="section return"><dt>Returns</dt><dd>slot index; ULINT_UNDEFINED if none found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e8cdd94af3946bfc8743e809f96a31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8cdd94af3946bfc8743e809f96a31a">&#9670;&nbsp;</a></span>fseg_free_extent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fseg_free_extent </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>seg_inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees an extent of a segment to the space free list. in/out: mini-transaction</p>
<p>Frees an extent of a segment to the space free list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page</td><td>in: page offset in the extent </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9e8f0816d2ba1f91f95957f728bc7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e8f0816d2ba1f91f95957f728bc7c8">&#9670;&nbsp;</a></span>fseg_free_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fseg_free_page </td>
          <td>(</td>
          <td class="paramtype">fseg_header_t *&#160;</td>
          <td class="paramname"><em>seg_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a single page of a segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_header</td><td>in: segment header </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page</td><td>in: page offset </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7f03bc3e900151e1898bf926b7efd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f03bc3e900151e1898bf926b7efd86">&#9670;&nbsp;</a></span>fseg_free_page_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fseg_free_page_low </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>seg_inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a single page of a segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page</td><td>in: page offset </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a368030d2c197d4f01187f0796db1e264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368030d2c197d4f01187f0796db1e264">&#9670;&nbsp;</a></span>fseg_free_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fseg_free_step </td>
          <td>(</td>
          <td class="paramtype">fseg_header_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees part of a segment. This function can be used to free a segment by repeatedly calling this function in different mini-transactions. Doing the freeing in a single mini-transaction might result in too big a mini-transaction. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if freeing completed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>in, own: segment header; NOTE: if the header resides on the first page of the frag list of the segment, this pointer becomes obsolete after the last freeing step </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a63f82b0ba09a66706eb5f755bab769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a63f82b0ba09a66706eb5f755bab769">&#9670;&nbsp;</a></span>fseg_free_step_not_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fseg_free_step_not_header </td>
          <td>(</td>
          <td class="paramtype">fseg_header_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees part of a segment. Differs from fseg_free_step because this function leaves the header page unfreed. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if freeing completed, except the header page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>in: segment header which must reside on the first fragment page of the segment </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dd01778a92cfde041dbcec7a7b6c0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd01778a92cfde041dbcec7a7b6c0ff">&#9670;&nbsp;</a></span>fseg_get_first_extent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static xdes_t * fseg_get_first_extent </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the first extent descriptor for a segment. We think of the extent lists of the segment catenated in the order FSEG_FULL -&gt; FSEG_NOT_FULL -&gt; FSEG_FREE. </p><dl class="section return"><dt>Returns</dt><dd>the first extent descriptor, or NULL if none in/out: mini-transaction</dd></dl>
<p>Returns the first extent descriptor for a segment. We think of the extent lists of the segment catenated in the order FSEG_FULL -&gt; FSEG_NOT_FULL -&gt; FSEG_FREE. </p><dl class="section return"><dt>Returns</dt><dd>the first extent descriptor, or NULL if none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a722a330e3e4327bf76d67935aa08ff68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722a330e3e4327bf76d67935aa08ff68">&#9670;&nbsp;</a></span>fseg_get_n_frag_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint fseg_get_n_frag_pages </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates reserved fragment page slots. </p><dl class="section return"><dt>Returns</dt><dd>number of fragment pages </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac168f7f7f148eb8c000116c55cf15e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac168f7f7f148eb8c000116c55cf15e36">&#9670;&nbsp;</a></span>fseg_get_nth_frag_page_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint fseg_get_nth_frag_page_no </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a> &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the page number from the nth fragment page slot. </p><dl class="section return"><dt>Returns</dt><dd>page number, FIL_NULL if not in use </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">n</td><td>in: slot index </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d6b4c0fe89c0ae6da60c468e2f5993d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6b4c0fe89c0ae6da60c468e2f5993d">&#9670;&nbsp;</a></span>fseg_inode_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static fseg_inode_t* fseg_inode_get </td>
          <td>(</td>
          <td class="paramtype">fseg_header_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the file segment inode, page x-latched. </p><dl class="section return"><dt>Returns</dt><dd>segment inode, page x-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>in: segment header </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3786a85f30ca0e1cafcb771ed12c0097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3786a85f30ca0e1cafcb771ed12c0097">&#9670;&nbsp;</a></span>fseg_inode_try_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static fseg_inode_t* fseg_inode_try_get </td>
          <td>(</td>
          <td class="paramtype">fseg_header_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the file segment inode, page x-latched. </p><dl class="section return"><dt>Returns</dt><dd>segment inode, page x-latched; NULL if the inode is free </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>in: segment header </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2038bfb8aacb910b0ebc9f54227d3015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2038bfb8aacb910b0ebc9f54227d3015">&#9670;&nbsp;</a></span>fseg_n_reserved_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fseg_n_reserved_pages </td>
          <td>(</td>
          <td class="paramtype">fseg_header_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of pages reserved by a segment, and how many pages are currently used. </p><dl class="section return"><dt>Returns</dt><dd>number of reserved pages </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>in: segment header </td></tr>
    <tr><td class="paramname">used</td><td>out: number of pages used (&lt;= reserved) </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a098fbfcb36bdb7da8b642a2f4990c693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098fbfcb36bdb7da8b642a2f4990c693">&#9670;&nbsp;</a></span>fseg_n_reserved_pages_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint fseg_n_reserved_pages_low </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>used</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the number of pages reserved by a segment, and how many pages are currently used. </p><dl class="section return"><dt>Returns</dt><dd>number of reserved pages in/out: mini-transaction</dd></dl>
<p>Calculates the number of pages reserved by a segment, and how many pages are currently used. </p><dl class="section return"><dt>Returns</dt><dd>number of reserved pages </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">used</td><td>out: number of pages used (not more than reserved) </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af029aae13897cf4d5ffe805bfcc1dcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af029aae13897cf4d5ffe805bfcc1dcd0">&#9670;&nbsp;</a></span>fseg_page_is_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool fseg_page_is_free </td>
          <td>(</td>
          <td class="paramtype">fseg_header_t *&#160;</td>
          <td class="paramname"><em>seg_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a single page of a segment is free. </p><dl class="section return"><dt>Returns</dt><dd>true if free </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg_header</td><td>in: segment header </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page</td><td>in: page offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a7920054c59e838b70447f0da7c0eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7920054c59e838b70447f0da7c0eae">&#9670;&nbsp;</a></span>fseg_print_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fseg_print_low </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes info of a segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49951969d2fc811417f1391f6091057c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49951969d2fc811417f1391f6091057c">&#9670;&nbsp;</a></span>fseg_set_nth_frag_page_no()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void fseg_set_nth_frag_page_no </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the page number in the nth fragment page slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">n</td><td>in: slot index </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number to set </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16dfbd7362f7e9fa5259caeb254e36d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dfbd7362f7e9fa5259caeb254e36d7">&#9670;&nbsp;</a></span>fseg_validate_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fseg_validate_low </td>
          <td>(</td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validates a segment. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">mtr2</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac835771657a63bc17ec8d035327fc372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac835771657a63bc17ec8d035327fc372">&#9670;&nbsp;</a></span>fsp_alloc_free_extent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static xdes_t* fsp_alloc_free_extent </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new free extent. </p><dl class="section return"><dt>Returns</dt><dd>extent descriptor, NULL if cannot be allocated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">hint</td><td>in: hint of which extent would be desirable: any page offset in the extent goes; the hint must not be &gt; FSP_FREE_LIMIT </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ad46c0aeca619515748903ed217d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad46c0aeca619515748903ed217d64d">&#9670;&nbsp;</a></span>fsp_alloc_seg_inode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static fseg_inode_t* fsp_alloc_seg_inode </td>
          <td>(</td>
          <td class="paramtype">fsp_header_t *&#160;</td>
          <td class="paramname"><em>space_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new file segment inode. </p><dl class="section return"><dt>Returns</dt><dd>segment inode, or NULL if not enough space </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_header</td><td>in: space header </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae908b612e64b189d8c71c07264bbd811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae908b612e64b189d8c71c07264bbd811">&#9670;&nbsp;</a></span>fsp_alloc_seg_inode_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fsp_alloc_seg_inode_page </td>
          <td>(</td>
          <td class="paramtype">fsp_header_t *&#160;</td>
          <td class="paramname"><em>space_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new file segment inode page. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if could be allocated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_header</td><td>in: space header </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a494a503611daee8298c414bd5b4bff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494a503611daee8298c414bd5b4bff0e">&#9670;&nbsp;</a></span>fsp_fill_free_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fsp_fill_free_list </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>init_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fsp_header_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts new extents to the free list if there are free extents above the free limit. If an extent happens to contain an extent descriptor page, the extent is put to the FSP_FREE_FRAG list with the page marked as used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_space</td><td>in: TRUE if this is a single-table tablespace and we are only initing the tablespace's first extent descriptor page and ibuf bitmap page; then we do not allocate more extents </td></tr>
    <tr><td class="paramname">space</td><td>in: space </td></tr>
    <tr><td class="paramname">header</td><td>in/out: space header </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2271298646733b7e7318938d9cc2d565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2271298646733b7e7318938d9cc2d565">&#9670;&nbsp;</a></span>fsp_free_extent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fsp_free_extent </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an extent to the free list of a space. in/out: mini-transaction</p>
<p>Returns an extent to the free list of a space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page</td><td>in: page offset in the extent </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cb7aefbebc9fda79375273e5f7ac3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb7aefbebc9fda79375273e5f7ac3c5">&#9670;&nbsp;</a></span>fsp_free_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fsp_free_page </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a single page of a space. The page is marked as free and clean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page</td><td>in: page offset </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2273b840c26ca599e0166e6135363573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2273b840c26ca599e0166e6135363573">&#9670;&nbsp;</a></span>fsp_free_seg_inode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fsp_free_seg_inode </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fseg_inode_t *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a file segment inode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">inode</td><td>in: segment inode </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae82b7efd6737bc577ef6edb60ea7b467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82b7efd6737bc577ef6edb60ea7b467">&#9670;&nbsp;</a></span>fsp_get_available_space_in_free_extents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ullint fsp_get_available_space_in_free_extents </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be used to get information on how much we still will be able to insert new data to the database without running out the tablespace. Only free extents are taken into account and we also subtract the safety margin required by the above function fsp_reserve_free_extents. </p><dl class="section return"><dt>Returns</dt><dd>available space in kB </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f27ecde86147c06fbf9c07cd3a5d29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f27ecde86147c06fbf9c07cd3a5d29e">&#9670;&nbsp;</a></span>fsp_get_size_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fsp_get_size_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the file space size stored in the header page. </p><dl class="section return"><dt>Returns</dt><dd>tablespace size stored in the space header </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: header page (page 0 in the tablespace) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd1fc77af0aeddec49525e752079f8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1fc77af0aeddec49525e752079f8a0">&#9670;&nbsp;</a></span>fsp_get_space_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE fsp_header_t* fsp_get_space_header </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a pointer to the space header and x-locks its page. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the space header, page x-locked </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c5d3bc7cb303541974af62f10aa55e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5d3bc7cb303541974af62f10aa55e4">&#9670;&nbsp;</a></span>fsp_header_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fsp_header_get_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the space flags from the first page of a tablespace. </p><dl class="section return"><dt>Returns</dt><dd>flags </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: first page of a tablespace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a508fbc25a0013563f5e9abdc3cbc70eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508fbc25a0013563f5e9abdc3cbc70eb">&#9670;&nbsp;</a></span>fsp_header_get_space_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fsp_header_get_space_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the space id from the first page of a tablespace. </p><dl class="section return"><dt>Returns</dt><dd>space id, ULINT UNDEFINED if error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: first page of a tablespace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9640882a719f0d8b1e4a0a49dec34f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9640882a719f0d8b1e4a0a49dec34f2c">&#9670;&nbsp;</a></span>fsp_header_get_tablespace_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fsp_header_get_tablespace_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of the system tablespace from the tablespace header. If we do not have an auto-extending data file, this should be equal to the size of the data files. If there is an auto-extending data file, this can be smaller. </p><dl class="section return"><dt>Returns</dt><dd>size in pages </dd></dl>

</div>
</div>
<a id="a9ac499b7f3fa89086f68b19f426c5d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac499b7f3fa89086f68b19f426c5d51">&#9670;&nbsp;</a></span>fsp_header_get_zip_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint fsp_header_get_zip_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the compressed page size from the first page of a tablespace. </p><dl class="section return"><dt>Returns</dt><dd>compressed page size in bytes, or 0 if uncompressed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: first page of a tablespace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7b3c3e2d1cc874ae6ec5310cda752e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b3c3e2d1cc874ae6ec5310cda752e4">&#9670;&nbsp;</a></span>fsp_header_inc_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fsp_header_inc_size </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size_inc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increases the space size field of a space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">size_inc</td><td>in: size increment in pages </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a186d7849e005217308d59eecfee9d525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186d7849e005217308d59eecfee9d525">&#9670;&nbsp;</a></span>fsp_header_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fsp_header_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the space header of a new created space and creates also the insert buffer tree root if space == 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">size</td><td>in: current size in blocks </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84329d0871d5a4955e04d1c5e89ab984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84329d0871d5a4955e04d1c5e89ab984">&#9670;&nbsp;</a></span>fsp_header_init_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fsp_header_init_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the space id and flags to a tablespace header. The flags contain row type, physical/compressed page size, and logical/uncompressed page size of the tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in/out: first page in the space </td></tr>
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
    <tr><td class="paramname">flags</td><td>in: tablespace flags (FSP_SPACE_FLAGS) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3b9629cf78fbf3686c68b4fe33442c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3b9629cf78fbf3686c68b4fe33442c">&#9670;&nbsp;</a></span>fsp_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fsp_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the fsp system. </p>

</div>
</div>
<a id="aff9467d8d0b011da9c0a1076ea18affe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9467d8d0b011da9c0a1076ea18affe">&#9670;&nbsp;</a></span>fsp_init_file_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fsp_init_file_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inits a file page whose prior contents should be ignored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to a page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6657d8c4337720f91d520e64c5cbfc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6657d8c4337720f91d520e64c5cbfc29">&#9670;&nbsp;</a></span>fsp_init_file_page_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fsp_init_file_page_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inits a file page whose prior contents should be ignored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to a page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d78c4de454a9ad80ec8cc2b5f694b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d78c4de454a9ad80ec8cc2b5f694b3c">&#9670;&nbsp;</a></span>fsp_page_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbuf__block__t.html">buf_block_t</a>* fsp_page_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>init_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a buffer block for an allocated page.</p>
<p>NOTE: If init_mtr != mtr, the block will only be initialized if it was not previously x-latched. It is assumed that the block has been x-latched only by mtr, and freed in mtr in that case.</p>
<dl class="section return"><dt>Returns</dt><dd>block, initialized if init_mtr==mtr or rw_lock_x_lock_count(&amp;block-&gt;lock) == 1 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id of the allocated page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number of the allocated page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction of the allocation </td></tr>
    <tr><td class="paramname">init_mtr</td><td>in: mini-transaction for initializing the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a635914f58fc8c6e25a5e2cf6fe1fe093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635914f58fc8c6e25a5e2cf6fe1fe093">&#9670;&nbsp;</a></span>fsp_parse_init_file_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* fsp_parse_init_file_page </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *end_ptr &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a redo log record of a file page init. </p><dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">block</td><td>in: block or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a96e33dab9d5a52d56521b2834cd183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a96e33dab9d5a52d56521b2834cd183">&#9670;&nbsp;</a></span>fsp_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void fsp_print </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of a file space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa63afa1be039f1f5eccd2f2f1a7648c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa63afa1be039f1f5eccd2f2f1a7648c">&#9670;&nbsp;</a></span>fsp_reserve_free_extents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fsp_reserve_free_extents </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_reserved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>alloc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves free pages from a tablespace. All mini-transactions which may use several pages from the tablespace should call this function beforehand and reserve enough free extents so that they certainly will be able to do their operation, like a B-tree page split, fully. Reservations must be released with function fil_space_release_free_extents!</p>
<p>The alloc_type below has the following meaning: FSP_NORMAL means an operation which will probably result in more space usage, like an insert in a B-tree; FSP_UNDO means allocation to undo logs: if we are deleting rows, then this allocation will in the long run result in less space usage (after a purge); FSP_CLEANING means allocation done in a physical record delete (like in a purge) or other cleaning operation which will result in less space usage in the long run. We prefer the latter two types of allocation: when space is scarce, FSP_NORMAL allocations will not succeed, but the latter two allocations will succeed, if possible. The purpose is to avoid dead end where the database is full but the user cannot free any space because these freeing operations temporarily reserve some space.</p>
<p>Single-table tablespaces whose size is &lt; 32 pages are a special case. In this function we would liberally reserve several 64 page extents for every page split or merge in a B-tree. But we do not want to waste disk space if the table only occupies &lt; 32 pages. That is why we apply different rules in that special case, just ensuring that there are 3 free pages available. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if we were able to make the reservation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_reserved</td><td>out: number of extents actually reserved; if we return TRUE and the tablespace size is &lt; 64 pages, then this can be 0, otherwise it is n_ext </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of extents to reserve </td></tr>
    <tr><td class="paramname">alloc_type</td><td>in: FSP_NORMAL, FSP_UNDO, or FSP_CLEANING </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae420d97d130e40d89dee06f60cef8d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae420d97d130e40d89dee06f60cef8d0c">&#9670;&nbsp;</a></span>fsp_reserve_free_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool fsp_reserve_free_pages </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fsp_header_t *&#160;</td>
          <td class="paramname"><em>space_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks that we have at least 2 frag pages free in the first extent of a single-table tablespace, and they are also physically initialized to the data file. That is we have already extended the data file so that those pages are inside the data file. If not, this function extends the tablespace with pages. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if there were &gt;= 3 free pages, or we were able to extend </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id, must be != 0 </td></tr>
    <tr><td class="paramname">space_header</td><td>in: header of that space, x-latched </td></tr>
    <tr><td class="paramname">size</td><td>in: size of the tablespace in pages, must be &lt; FSP_EXTENT_SIZE/2 </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e675397bb4af20e1e02fff063f60e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e675397bb4af20e1e02fff063f60e65">&#9670;&nbsp;</a></span>fsp_seg_inode_page_find_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint fsp_seg_inode_page_find_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for an unused segment inode on a segment inode page. </p><dl class="section return"><dt>Returns</dt><dd>segment inode index, or ULINT_UNDEFINED if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: segment inode page </td></tr>
    <tr><td class="paramname">i</td><td>in: search forward starting from this index </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size, or 0 </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cfd3ccdee0d5d4b4f19fb3b7020693c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfd3ccdee0d5d4b4f19fb3b7020693c">&#9670;&nbsp;</a></span>fsp_seg_inode_page_find_used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint fsp_seg_inode_page_find_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for a used segment inode on a segment inode page. </p><dl class="section return"><dt>Returns</dt><dd>segment inode index, or ULINT_UNDEFINED if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: segment inode page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size, or 0 </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab54cba6faba1812a0c015db0f4e7ba25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54cba6faba1812a0c015db0f4e7ba25">&#9670;&nbsp;</a></span>fsp_seg_inode_page_get_nth_inode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE fseg_inode_t* fsp_seg_inode_page_get_nth_inode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a> &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *<a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a> &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the nth inode slot on an inode page. </p><dl class="section return"><dt>Returns</dt><dd>segment inode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: segment inode page </td></tr>
    <tr><td class="paramname">i</td><td>in: inode index on page </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in: compressed page size, or 0 </td></tr>
    <tr><td class="paramname">__attribute__</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae245be113c8528ada2afb42d828eafe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae245be113c8528ada2afb42d828eafe4">&#9670;&nbsp;</a></span>fsp_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ibool fsp_validate </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validates the file space system and its segments. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16b7f2822e3e23466374ae486ad6dedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b7f2822e3e23466374ae486ad6dedd">&#9670;&nbsp;</a></span>xdes_find_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint xdes_find_bit </td>
          <td>(</td>
          <td class="paramtype">xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a descriptor bit having the desired value. Starts from hint and scans upward; at the end of the extent the search is wrapped to the start of the extent. </p><dl class="section return"><dt>Returns</dt><dd>bit index of the bit, ULINT_UNDEFINED if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in: descriptor </td></tr>
    <tr><td class="paramname">bit</td><td>in: XDES_FREE_BIT or XDES_CLEAN_BIT </td></tr>
    <tr><td class="paramname">val</td><td>in: desired bit value </td></tr>
    <tr><td class="paramname">hint</td><td>in: hint of which bit position would be desirable </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64f29d492039ab6bd9fa3408b9a20056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f29d492039ab6bd9fa3408b9a20056">&#9670;&nbsp;</a></span>xdes_get_n_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint xdes_get_n_used </td>
          <td>(</td>
          <td class="paramtype">const xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of used pages in a descriptor. </p><dl class="section return"><dt>Returns</dt><dd>number of pages used </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in: descriptor </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3c246e8f86d3d784f92538c711916c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3c246e8f86d3d784f92538c711916c">&#9670;&nbsp;</a></span>xdes_get_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint xdes_get_offset </td>
          <td>(</td>
          <td class="paramtype">const xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns page offset of the first page in extent described by a descriptor. </p><dl class="section return"><dt>Returns</dt><dd>offset of the first page in extent </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in: extent descriptor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3112b68a6aecde76e8f42405152ee673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3112b68a6aecde76e8f42405152ee673">&#9670;&nbsp;</a></span>xdes_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint xdes_get_state </td>
          <td>(</td>
          <td class="paramtype">const xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the state of an xdes. </p><dl class="section return"><dt>Returns</dt><dd>state </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in: descriptor </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a25848103da9d0354b7558bb48a6aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a25848103da9d0354b7558bb48a6aa4">&#9670;&nbsp;</a></span>xdes_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void xdes_init </td>
          <td>(</td>
          <td class="paramtype">xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inits an extent descriptor to the free and clean state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in: descriptor </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09a40c104599a3b433dacf02c8442a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a40c104599a3b433dacf02c8442a90">&#9670;&nbsp;</a></span>xdes_is_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool xdes_is_free </td>
          <td>(</td>
          <td class="paramtype">const xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if extent contains no used pages. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if totally free </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in: descriptor </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45b1c61387c588e9feb7c812efb47a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b1c61387c588e9feb7c812efb47a1c">&#9670;&nbsp;</a></span>xdes_is_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool xdes_is_full </td>
          <td>(</td>
          <td class="paramtype">const xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if extent contains no free pages. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if full </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in: descriptor </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a2aa6c65a4cee4302c5c5dca0a8920a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2aa6c65a4cee4302c5c5dca0a8920a">&#9670;&nbsp;</a></span>xdes_lst_get_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE xdes_t* xdes_lst_get_descriptor </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__addr__t.html">fil_addr_t</a>&#160;</td>
          <td class="paramname"><em>lst_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets pointer to a the extent descriptor if the file address of the descriptor list node is known. The page where the extent descriptor resides is x-locked. </p><dl class="section return"><dt>Returns</dt><dd>pointer to the extent descriptor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">lst_node</td><td>in: file address of the list node contained in the descriptor </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac74ac9cf95883ec1d5d06d2841c312e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74ac9cf95883ec1d5d06d2841c312e7">&#9670;&nbsp;</a></span>xdes_mtr_get_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool xdes_mtr_get_bit </td>
          <td>(</td>
          <td class="paramtype">const xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a descriptor bit of a page. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if free </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in: descriptor </td></tr>
    <tr><td class="paramname">bit</td><td>in: XDES_FREE_BIT or XDES_CLEAN_BIT </td></tr>
    <tr><td class="paramname">offset</td><td>in: page offset within extent: 0 ... FSP_EXTENT_SIZE - 1 </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9ad7c8974c00d5f7e30842a82dd7039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ad7c8974c00d5f7e30842a82dd7039">&#9670;&nbsp;</a></span>xdes_set_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void xdes_set_bit </td>
          <td>(</td>
          <td class="paramtype">xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a descriptor bit of a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in: descriptor </td></tr>
    <tr><td class="paramname">bit</td><td>in: XDES_FREE_BIT or XDES_CLEAN_BIT </td></tr>
    <tr><td class="paramname">offset</td><td>in: page offset within extent: 0 ... FSP_EXTENT_SIZE - 1 </td></tr>
    <tr><td class="paramname">val</td><td>in: bit value </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af785ee4585efa65188a829af006ebade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af785ee4585efa65188a829af006ebade">&#9670;&nbsp;</a></span>xdes_set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void xdes_set_state </td>
          <td>(</td>
          <td class="paramtype">xdes_t *&#160;</td>
          <td class="paramname"><em>descr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the state of an xdes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descr</td><td>in/out: descriptor </td></tr>
    <tr><td class="paramname">state</td><td>in: state to set </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a60c1506135317302131bd515c87116bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c1506135317302131bd515c87116bf">&#9670;&nbsp;</a></span>bit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xdes_t ulint bit</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: slot to allocate in the extent </p>

</div>
</div>
<a id="a17afa58b2bc574dedcd1cc02e1fdf165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17afa58b2bc574dedcd1cc02e1fdf165">&#9670;&nbsp;</a></span>block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">block</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="buf0buf_8h.html#af42256ee94cebb3086096244fcbb872d">buf_page_get</a>(<a class="code" href="fsp0fsp_8cc.html#a417adcfdc3449d6de97bbb1965d67d04">space</a>, <a class="code" href="fsp0fsp_8cc.html#ab272a29ed146ac233db12e8b72443195">zip_size</a>, descr_page_no,</div><div class="line">                                     RW_X_LATCH, <a class="code" href="fsp0fsp_8cc.html#af844392d3072f7f29433c4c4c7b932c5">mtr</a>)</div><div class="ttc" id="fsp0fsp_8cc_html_a417adcfdc3449d6de97bbb1965d67d04"><div class="ttname"><a href="fsp0fsp_8cc.html#a417adcfdc3449d6de97bbb1965d67d04">space</a></div><div class="ttdeci">UNIV_INLINE ulint space</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:434</div></div>
<div class="ttc" id="fsp0fsp_8cc_html_af844392d3072f7f29433c4c4c7b932c5"><div class="ttname"><a href="fsp0fsp_8cc.html#af844392d3072f7f29433c4c4c7b932c5">mtr</a></div><div class="ttdeci">static ulint xdes_t mtr_t * mtr</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:101</div></div>
<div class="ttc" id="fsp0fsp_8cc_html_ab272a29ed146ac233db12e8b72443195"><div class="ttname"><a href="fsp0fsp_8cc.html#ab272a29ed146ac233db12e8b72443195">zip_size</a></div><div class="ttdeci">ulint zip_size</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:443</div></div>
<div class="ttc" id="buf0buf_8h_html_af42256ee94cebb3086096244fcbb872d"><div class="ttname"><a href="buf0buf_8h.html#af42256ee94cebb3086096244fcbb872d">buf_page_get</a></div><div class="ttdeci">#define buf_page_get(SP, ZS, OF, LA, MTR)</div><div class="ttdef"><b>Definition:</b> buf0buf.h:347</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab1fe4cbf409943b0a9ad7be772abc938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1fe4cbf409943b0a9ad7be772abc938">&#9670;&nbsp;</a></span>descr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static ulint xdes_t * descr = xdes_get_descriptor_with_space_hdr(<a class="el" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a>, <a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: extent descriptor</p>
<p>&lt; in/out: tablespace header in/out: extent descriptor </p>

</div>
</div>
<a id="a0544c3fe466e421738dae463968b70ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0544c3fe466e421738dae463968b70ba">&#9670;&nbsp;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">                <a class="code" href="structbuf__block__t.html">buf_block_t</a>*    <a class="code" href="btr0btr_8cc.html#a14a0ea71b9884198035c8b95d64f539a">block</a></div><div class="ttc" id="structbuf__block__t_html"><div class="ttname"><a href="structbuf__block__t.html">buf_block_t</a></div><div class="ttdef"><b>Definition:</b> buf0buf.h:1634</div></div>
<div class="ttc" id="btr0btr_8cc_html_a14a0ea71b9884198035c8b95d64f539a"><div class="ttname"><a href="btr0btr_8cc.html#a14a0ea71b9884198035c8b95d64f539a">block</a></div><div class="ttdeci">static ulint buf_block_t * block</div><div class="ttdef"><b>Definition:</b> btr0btr.cc:1984</div></div>
</div><!-- fragment --><p>one megabyte, in pages </p>

</div>
</div>
<a id="ad8c7edc3216207f5d2b854b9d4139786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c7edc3216207f5d2b854b9d4139786">&#9670;&nbsp;</a></span>frag_n_used</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">frag_n_used</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="mtr0mtr_8h.html#a0985c839f25999097177e009cee432a5">mtr_read_ulint</a>(<a class="code" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a> + FSP_FRAG_N_USED, <a class="code" href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a>,</div><div class="line">                                     <a class="code" href="fsp0fsp_8cc.html#af844392d3072f7f29433c4c4c7b932c5">mtr</a>)</div><div class="ttc" id="fsp0fsp_8cc_html_af17e72298b614d3ef0c0f311e7418e42"><div class="ttname"><a href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a></div><div class="ttdeci">static UNIV_COLD ulint fsp_header_t * header</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:858</div></div>
<div class="ttc" id="fsp0fsp_8cc_html_af844392d3072f7f29433c4c4c7b932c5"><div class="ttname"><a href="fsp0fsp_8cc.html#af844392d3072f7f29433c4c4c7b932c5">mtr</a></div><div class="ttdeci">static ulint xdes_t mtr_t * mtr</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:101</div></div>
<div class="ttc" id="mtr0mtr_8h_html_a0985c839f25999097177e009cee432a5"><div class="ttname"><a href="mtr0mtr_8h.html#a0985c839f25999097177e009cee432a5">mtr_read_ulint</a></div><div class="ttdeci">UNIV_INTERN ulint mtr_read_ulint(const byte *ptr, ulint type, mtr_t *mtr)</div></div>
<div class="ttc" id="mtr0mtr_8h_html_ac17be725c0610e41a38b9cbaf7b37314"><div class="ttname"><a href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a></div><div class="ttdeci">#define MLOG_4BYTES</div><div class="ttdef"><b>Definition:</b> mtr0mtr.h:78</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a21ea2c9c6c1ba23efaf7efaeb118a065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ea2c9c6c1ba23efaf7efaeb118a065">&#9670;&nbsp;</a></span>free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">free</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="fsp0fsp_8cc.html#a16b7f2822e3e23466374ae486ad6dedd">xdes_find_bit</a>(<a class="code" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>, XDES_FREE_BIT, TRUE,</div><div class="line">                             <a class="code" href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a> % FSP_EXTENT_SIZE, <a class="code" href="fsp0fsp_8cc.html#af844392d3072f7f29433c4c4c7b932c5">mtr</a>)</div><div class="ttc" id="fsp0fsp_8cc_html_aed44f205c7d95ae205b0f69d2b723b55"><div class="ttname"><a href="fsp0fsp_8cc.html#aed44f205c7d95ae205b0f69d2b723b55">hint</a></div><div class="ttdeci">static ulint ulint hint</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:1318</div></div>
<div class="ttc" id="fsp0fsp_8cc_html_a16b7f2822e3e23466374ae486ad6dedd"><div class="ttname"><a href="fsp0fsp_8cc.html#a16b7f2822e3e23466374ae486ad6dedd">xdes_find_bit</a></div><div class="ttdeci">UNIV_INLINE ulint xdes_find_bit(xdes_t *descr, ulint bit, ibool val, ulint hint, mtr_t *mtr)</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:271</div></div>
<div class="ttc" id="fsp0fsp_8cc_html_af844392d3072f7f29433c4c4c7b932c5"><div class="ttname"><a href="fsp0fsp_8cc.html#af844392d3072f7f29433c4c4c7b932c5">mtr</a></div><div class="ttdeci">static ulint xdes_t mtr_t * mtr</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:101</div></div>
<div class="ttc" id="fsp0fsp_8cc_html_ab1fe4cbf409943b0a9ad7be772abc938"><div class="ttname"><a href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a></div><div class="ttdeci">static ulint xdes_t * descr</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:101</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad128bc7d258f5ba0f88a4391cc4b052b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad128bc7d258f5ba0f88a4391cc4b052b">&#9670;&nbsp;</a></span>fsp_tbs_full_error_printed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ibool fsp_tbs_full_error_printed = FALSE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag to indicate if we have printed the tablespace full error. </p>

</div>
</div>
<a id="af17e72298b614d3ef0c0f311e7418e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17e72298b614d3ef0c0f311e7418e42">&#9670;&nbsp;</a></span>header</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static UNIV_COLD ulint fsp_header_t * header = <a class="el" href="fsp0fsp_8cc.html#acd1fc77af0aeddec49525e752079f8a0">fsp_get_space_header</a>(<a class="el" href="ibuf0ibuf_8cc.html#aae9e36bded84b28f880abb9a711c7d1e">space</a>, <a class="el" href="row0merge_8cc.html#acbd6f0665ead771e112f93b23cf27faf">zip_size</a>, <a class="el" href="trx0undo_8cc.html#a9013d42949ecc21fdd8de523420df8ba">mtr</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in/out: space header </p>

</div>
</div>
<a id="aed44f205c7d95ae205b0f69d2b723b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed44f205c7d95ae205b0f69d2b723b55">&#9670;&nbsp;</a></span>hint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hint = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: hint of which page would be desirable </p>

</div>
</div>
<a id="affc0fcb1d10ea38c48239ca6a9772e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc0fcb1d10ea38c48239ca6a9772e0b">&#9670;&nbsp;</a></span>init_mtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint ulint <a class="el" href="structmtr__t.html">mtr_t</a> <a class="el" href="structmtr__t.html">mtr_t</a>* init_mtr</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        fsp_header_t*   <a class="code" href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a></div><div class="ttc" id="fsp0fsp_8cc_html_af17e72298b614d3ef0c0f311e7418e42"><div class="ttname"><a href="fsp0fsp_8cc.html#af17e72298b614d3ef0c0f311e7418e42">header</a></div><div class="ttdeci">static UNIV_COLD ulint fsp_header_t * header</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:858</div></div>
</div><!-- fragment --><p>&lt; in/out: mini-transaction in which the page should be initialized (may be the same as mtr) </p>

</div>
</div>
<a id="af844392d3072f7f29433c4c4c7b932c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af844392d3072f7f29433c4c4c7b932c5">&#9670;&nbsp;</a></span>mtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint xdes_t <a class="el" href="structmtr__t.html">mtr_t</a>* mtr</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">        ulint   <a class="code" href="ibuf0ibuf_8cc.html#a2dfd6b5310e6dd7028210bb6a8d13549">limit</a></div><div class="ttc" id="ibuf0ibuf_8cc_html_a2dfd6b5310e6dd7028210bb6a8d13549"><div class="ttname"><a href="ibuf0ibuf_8cc.html#a2dfd6b5310e6dd7028210bb6a8d13549">limit</a></div><div class="ttdeci">static ulint ulint limit</div><div class="ttdef"><b>Definition:</b> ibuf0ibuf.cc:2536</div></div>
</div><!-- fragment --><p>in/out: mini-transaction</p>
<p>&lt; in/out: mini-transaction </p>

</div>
</div>
<a id="ad5b07c11c0bc8b7e49fead5aa8c45d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b07c11c0bc8b7e49fead5aa8c45d33">&#9670;&nbsp;</a></span>not_full_n_used</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">not_full_n_used</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="mtr0mtr_8h.html#a0985c839f25999097177e009cee432a5">mtr_read_ulint</a>(seg_inode + FSEG_NOT_FULL_N_USED,</div><div class="line">                                         <a class="code" href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a>, <a class="code" href="fsp0fsp_8cc.html#af844392d3072f7f29433c4c4c7b932c5">mtr</a>)</div><div class="ttc" id="fsp0fsp_8cc_html_af844392d3072f7f29433c4c4c7b932c5"><div class="ttname"><a href="fsp0fsp_8cc.html#af844392d3072f7f29433c4c4c7b932c5">mtr</a></div><div class="ttdeci">static ulint xdes_t mtr_t * mtr</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:101</div></div>
<div class="ttc" id="mtr0mtr_8h_html_a0985c839f25999097177e009cee432a5"><div class="ttname"><a href="mtr0mtr_8h.html#a0985c839f25999097177e009cee432a5">mtr_read_ulint</a></div><div class="ttdeci">UNIV_INTERN ulint mtr_read_ulint(const byte *ptr, ulint type, mtr_t *mtr)</div></div>
<div class="ttc" id="mtr0mtr_8h_html_ac17be725c0610e41a38b9cbaf7b37314"><div class="ttname"><a href="mtr0mtr_8h.html#ac17be725c0610e41a38b9cbaf7b37314">MLOG_4BYTES</a></div><div class="ttdeci">#define MLOG_4BYTES</div><div class="ttdef"><b>Definition:</b> mtr0mtr.h:78</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a394fcd8654772552f8178df5d2ed1048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394fcd8654772552f8178df5d2ed1048">&#9670;&nbsp;</a></span>offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint ulint offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: page offset; if equal to the free limit, we try to add new extents to the space free list </p>

</div>
</div>
<a id="a69e3109c6b8c8d21dfc851e276de8389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e3109c6b8c8d21dfc851e276de8389">&#9670;&nbsp;</a></span>page</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint page</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: segment inode in: page offset </p>

</div>
</div>
<a id="ab14e86873f8d034759194bb1c17e1a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14e86873f8d034759194bb1c17e1a8d">&#9670;&nbsp;</a></span>page_no</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">page_no = <a class="el" href="fsp0fsp_8cc.html#aab3c246e8f86d3d784f92538c711916c">xdes_get_offset</a>(<a class="el" href="fsp0fsp_8cc.html#ab1fe4cbf409943b0a9ad7be772abc938">descr</a>) + free</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: space in: page number </p>

</div>
</div>
<a id="aa2ba5a514c395b398630a3d7791561bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ba5a514c395b398630a3d7791561bc">&#9670;&nbsp;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0file_8h.html#a56e6594160a317a93fa099a4ba9ba59d">os_offset_t</a> size = <a class="el" href="mach0data_8h.html#acede0a33738a2a4fffc468cb6b41df78">mach_read_from_4</a>(sp_header + FSP_SIZE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in/out: online rebuild log in: size of log record </p>

</div>
</div>
<a id="a417adcfdc3449d6de97bbb1965d67d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417adcfdc3449d6de97bbb1965d67d04">&#9670;&nbsp;</a></span>space</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_COLD ulint space</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in/out: space header, x-latched in mtr in: space id</p>
<p>&lt; out: actual increase in pages, where we measure the tablespace size from what the header field says; it may be the actual file size rounded down to megabyte in: space </p>

</div>
</div>
<a id="a7960f9c558f9ee2c3d4a8fdea096fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7960f9c558f9ee2c3d4a8fdea096fb56">&#9670;&nbsp;</a></span>success</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool success</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="fil0fil_8cc.html#a77f5de18476e82ce28875ce0a00dfca6">fil_extend_space_to_desired_size</a>(&amp;actual_size, <a class="code" href="fsp0fsp_8cc.html#a417adcfdc3449d6de97bbb1965d67d04">space</a>,</div><div class="line">                                                   <a class="code" href="fsp0fsp_8cc.html#ab14e86873f8d034759194bb1c17e1a8d">page_no</a> + 1)</div><div class="ttc" id="fsp0fsp_8cc_html_a417adcfdc3449d6de97bbb1965d67d04"><div class="ttname"><a href="fsp0fsp_8cc.html#a417adcfdc3449d6de97bbb1965d67d04">space</a></div><div class="ttdeci">UNIV_INLINE ulint space</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:434</div></div>
<div class="ttc" id="fil0fil_8cc_html_a77f5de18476e82ce28875ce0a00dfca6"><div class="ttname"><a href="fil0fil_8cc.html#a77f5de18476e82ce28875ce0a00dfca6">fil_extend_space_to_desired_size</a></div><div class="ttdeci">UNIV_INTERN ibool fil_extend_space_to_desired_size(ulint *actual_size, ulint space_id, ulint size_after_extend)</div><div class="ttdef"><b>Definition:</b> fil0fil.cc:5032</div></div>
<div class="ttc" id="fsp0fsp_8cc_html_ab14e86873f8d034759194bb1c17e1a8d"><div class="ttname"><a href="fsp0fsp_8cc.html#ab14e86873f8d034759194bb1c17e1a8d">page_no</a></div><div class="ttdeci">static UNIV_COLD ulint page_no</div><div class="ttdef"><b>Definition:</b> fsp0fsp.cc:858</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab272a29ed146ac233db12e8b72443195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab272a29ed146ac233db12e8b72443195">&#9670;&nbsp;</a></span>zip_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint zip_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="fsp0fsp_8h.html#a756b6cf349bd7bd19bc781fd208f8403">fsp_flags_get_zip_size</a>(</div><div class="line">                <a class="code" href="mach0data_8h.html#acede0a33738a2a4fffc468cb6b41df78">mach_read_from_4</a>(sp_header + FSP_SPACE_FLAGS))</div><div class="ttc" id="fsp0fsp_8h_html_a756b6cf349bd7bd19bc781fd208f8403"><div class="ttname"><a href="fsp0fsp_8h.html#a756b6cf349bd7bd19bc781fd208f8403">fsp_flags_get_zip_size</a></div><div class="ttdeci">UNIV_INLINE ulint fsp_flags_get_zip_size(ulint flags)</div></div>
<div class="ttc" id="mach0data_8h_html_acede0a33738a2a4fffc468cb6b41df78"><div class="ttname"><a href="mach0data_8h.html#acede0a33738a2a4fffc468cb6b41df78">mach_read_from_4</a></div><div class="ttdeci">UNIV_INLINE ulint mach_read_from_4(const byte *b) __attribute__((nonnull</div></div>
</div><!-- fragment --><p>&lt; in: space id in: compressed page size in bytes or 0 for uncompressed pages </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
